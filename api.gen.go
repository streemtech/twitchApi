// Package twitchApi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.

//Generated with imports.tmpl

package twitchApi

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	json "github.com/go-json-experiment/json"
	"github.com/oapi-codegen/runtime"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
)

const (
	Twitch_authScopes = "twitch_auth.Scopes"
)

// Defines values for BroadcasterSubscriptionTier.
const (
	BroadcasterSubscriptionTierN1000 BroadcasterSubscriptionTier = "1000"
	BroadcasterSubscriptionTierN2000 BroadcasterSubscriptionTier = "2000"
	BroadcasterSubscriptionTierN3000 BroadcasterSubscriptionTier = "3000"
)

// Defines values for ChannelEmoteEmoteType.
const (
	ChannelEmoteEmoteTypeBitstier      ChannelEmoteEmoteType = "bitstier"
	ChannelEmoteEmoteTypeFollower      ChannelEmoteEmoteType = "follower"
	ChannelEmoteEmoteTypeSubscriptions ChannelEmoteEmoteType = "subscriptions"
)

// Defines values for ChannelEmoteFormat.
const (
	ChannelEmoteFormatAnimated ChannelEmoteFormat = "animated"
	ChannelEmoteFormatStatic   ChannelEmoteFormat = "static"
)

// Defines values for ChannelEmoteScale.
const (
	ChannelEmoteScaleN10 ChannelEmoteScale = "1.0"
	ChannelEmoteScaleN20 ChannelEmoteScale = "2.0"
	ChannelEmoteScaleN30 ChannelEmoteScale = "3.0"
)

// Defines values for ChannelEmoteThemeMode.
const (
	ChannelEmoteThemeModeDark  ChannelEmoteThemeMode = "dark"
	ChannelEmoteThemeModeLight ChannelEmoteThemeMode = "light"
)

// Defines values for CheermoteTiersId.
const (
	CheermoteTiersIdN1      CheermoteTiersId = "1"
	CheermoteTiersIdN100    CheermoteTiersId = "100"
	CheermoteTiersIdN1000   CheermoteTiersId = "1000"
	CheermoteTiersIdN10000  CheermoteTiersId = "10000"
	CheermoteTiersIdN100000 CheermoteTiersId = "100000"
	CheermoteTiersIdN500    CheermoteTiersId = "500"
	CheermoteTiersIdN5000   CheermoteTiersId = "5000"
)

// Defines values for CheermoteType.
const (
	ChannelCustom    CheermoteType = "channel_custom"
	DisplayOnly      CheermoteType = "display_only"
	GlobalFirstParty CheermoteType = "global_first_party"
	GlobalThirdParty CheermoteType = "global_third_party"
	Sponsored        CheermoteType = "sponsored"
)

// Defines values for CreateEventSubSubscriptionBodyTransportMethod.
const (
	CreateEventSubSubscriptionBodyTransportMethodConduit   CreateEventSubSubscriptionBodyTransportMethod = "conduit"
	CreateEventSubSubscriptionBodyTransportMethodWebhook   CreateEventSubSubscriptionBodyTransportMethod = "webhook"
	CreateEventSubSubscriptionBodyTransportMethodWebsocket CreateEventSubSubscriptionBodyTransportMethod = "websocket"
)

// Defines values for CreateEventSubSubscriptionBodyType.
const (
	CreateEventSubSubscriptionBodyTypeAutomodMessageHold                               CreateEventSubSubscriptionBodyType = "automod.message.hold"
	CreateEventSubSubscriptionBodyTypeAutomodMessageUpdate                             CreateEventSubSubscriptionBodyType = "automod.message.update"
	CreateEventSubSubscriptionBodyTypeAutomodSettingsUpdate                            CreateEventSubSubscriptionBodyType = "automod.settings.update"
	CreateEventSubSubscriptionBodyTypeAutomodTermsUpdate                               CreateEventSubSubscriptionBodyType = "automod.terms.update"
	CreateEventSubSubscriptionBodyTypeChannelAdBreakBegin                              CreateEventSubSubscriptionBodyType = "channel.ad_break.begin"
	CreateEventSubSubscriptionBodyTypeChannelBan                                       CreateEventSubSubscriptionBodyType = "channel.ban"
	CreateEventSubSubscriptionBodyTypeChannelBitsUse                                   CreateEventSubSubscriptionBodyType = "channel.bits.use"
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsAutomaticRewardRedemptionAdd CreateEventSubSubscriptionBodyType = "channel.channel_points_automatic_reward_redemption.add"
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardAdd              CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward.add"
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionAdd    CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward_redemption.add"
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionUpdate CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward_redemption.update"
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRemove           CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward.remove"
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardUpdate           CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward.update"
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignDonate                     CreateEventSubSubscriptionBodyType = "channel.charity_campaign.donate"
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignProgress                   CreateEventSubSubscriptionBodyType = "channel.charity_campaign.progress"
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStart                      CreateEventSubSubscriptionBodyType = "channel.charity_campaign.start"
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStop                       CreateEventSubSubscriptionBodyType = "channel.charity_campaign.stop"
	CreateEventSubSubscriptionBodyTypeChannelChatClear                                 CreateEventSubSubscriptionBodyType = "channel.chat.clear"
	CreateEventSubSubscriptionBodyTypeChannelChatClearUserMessages                     CreateEventSubSubscriptionBodyType = "channel.chat.clear_user_messages"
	CreateEventSubSubscriptionBodyTypeChannelChatMessage                               CreateEventSubSubscriptionBodyType = "channel.chat.message"
	CreateEventSubSubscriptionBodyTypeChannelChatMessageDelete                         CreateEventSubSubscriptionBodyType = "channel.chat.message_delete"
	CreateEventSubSubscriptionBodyTypeChannelChatNotification                          CreateEventSubSubscriptionBodyType = "channel.chat.notification"
	CreateEventSubSubscriptionBodyTypeChannelChatSettingsUpdate                        CreateEventSubSubscriptionBodyType = "channel.chat_settings.update"
	CreateEventSubSubscriptionBodyTypeChannelChatUserMessageHold                       CreateEventSubSubscriptionBodyType = "channel.chat.user_message_hold"
	CreateEventSubSubscriptionBodyTypeChannelChatUserMessageUpdate                     CreateEventSubSubscriptionBodyType = "channel.chat.user_message_update"
	CreateEventSubSubscriptionBodyTypeChannelCheer                                     CreateEventSubSubscriptionBodyType = "channel.cheer"
	CreateEventSubSubscriptionBodyTypeChannelFollow                                    CreateEventSubSubscriptionBodyType = "channel.follow"
	CreateEventSubSubscriptionBodyTypeChannelGoalBegin                                 CreateEventSubSubscriptionBodyType = "channel.goal.begin"
	CreateEventSubSubscriptionBodyTypeChannelGoalEnd                                   CreateEventSubSubscriptionBodyType = "channel.goal.end"
	CreateEventSubSubscriptionBodyTypeChannelGoalProgress                              CreateEventSubSubscriptionBodyType = "channel.goal.progress"
	CreateEventSubSubscriptionBodyTypeChannelGuestStarGuestUpdate                      CreateEventSubSubscriptionBodyType = "channel.guest_star_guest.update"
	CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionBegin                     CreateEventSubSubscriptionBodyType = "channel.guest_star_session.begin"
	CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionEnd                       CreateEventSubSubscriptionBodyType = "channel.guest_star_session.end"
	CreateEventSubSubscriptionBodyTypeChannelGuestStarSettingsUpdate                   CreateEventSubSubscriptionBodyType = "channel.guest_star_settings.update"
	CreateEventSubSubscriptionBodyTypeChannelHypeTrainBegin                            CreateEventSubSubscriptionBodyType = "channel.hype_train.begin"
	CreateEventSubSubscriptionBodyTypeChannelHypeTrainEnd                              CreateEventSubSubscriptionBodyType = "channel.hype_train.end"
	CreateEventSubSubscriptionBodyTypeChannelHypeTrainProgress                         CreateEventSubSubscriptionBodyType = "channel.hype_train.progress"
	CreateEventSubSubscriptionBodyTypeChannelModerate                                  CreateEventSubSubscriptionBodyType = "channel.moderate"
	CreateEventSubSubscriptionBodyTypeChannelModeratorAdd                              CreateEventSubSubscriptionBodyType = "channel.moderator.add"
	CreateEventSubSubscriptionBodyTypeChannelModeratorRemove                           CreateEventSubSubscriptionBodyType = "channel.moderator.remove"
	CreateEventSubSubscriptionBodyTypeChannelPollBegin                                 CreateEventSubSubscriptionBodyType = "channel.poll.begin"
	CreateEventSubSubscriptionBodyTypeChannelPollEnd                                   CreateEventSubSubscriptionBodyType = "channel.poll.end"
	CreateEventSubSubscriptionBodyTypeChannelPollProgress                              CreateEventSubSubscriptionBodyType = "channel.poll.progress"
	CreateEventSubSubscriptionBodyTypeChannelPredictionBegin                           CreateEventSubSubscriptionBodyType = "channel.prediction.begin"
	CreateEventSubSubscriptionBodyTypeChannelPredictionEnd                             CreateEventSubSubscriptionBodyType = "channel.prediction.end"
	CreateEventSubSubscriptionBodyTypeChannelPredictionLock                            CreateEventSubSubscriptionBodyType = "channel.prediction.lock"
	CreateEventSubSubscriptionBodyTypeChannelPredictionProgress                        CreateEventSubSubscriptionBodyType = "channel.prediction.progress"
	CreateEventSubSubscriptionBodyTypeChannelRaid                                      CreateEventSubSubscriptionBodyType = "channel.raid"
	CreateEventSubSubscriptionBodyTypeChannelSharedChatBegin                           CreateEventSubSubscriptionBodyType = "channel.shared_chat.begin"
	CreateEventSubSubscriptionBodyTypeChannelSharedChatEnd                             CreateEventSubSubscriptionBodyType = "channel.shared_chat.end"
	CreateEventSubSubscriptionBodyTypeChannelSharedChatUpdate                          CreateEventSubSubscriptionBodyType = "channel.shared_chat.update"
	CreateEventSubSubscriptionBodyTypeChannelShieldModeBegin                           CreateEventSubSubscriptionBodyType = "channel.shield_mode.begin"
	CreateEventSubSubscriptionBodyTypeChannelShieldModeEnd                             CreateEventSubSubscriptionBodyType = "channel.shield_mode.end"
	CreateEventSubSubscriptionBodyTypeChannelShoutoutCreate                            CreateEventSubSubscriptionBodyType = "channel.shoutout.create"
	CreateEventSubSubscriptionBodyTypeChannelShoutoutReceive                           CreateEventSubSubscriptionBodyType = "channel.shoutout.receive"
	CreateEventSubSubscriptionBodyTypeChannelSubscribe                                 CreateEventSubSubscriptionBodyType = "channel.subscribe"
	CreateEventSubSubscriptionBodyTypeChannelSubscriptionEnd                           CreateEventSubSubscriptionBodyType = "channel.subscription.end"
	CreateEventSubSubscriptionBodyTypeChannelSubscriptionGift                          CreateEventSubSubscriptionBodyType = "channel.subscription.gift"
	CreateEventSubSubscriptionBodyTypeChannelSubscriptionMessage                       CreateEventSubSubscriptionBodyType = "channel.subscription.message"
	CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserMessage                     CreateEventSubSubscriptionBodyType = "channel.suspicious_user.message"
	CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserUpdate                      CreateEventSubSubscriptionBodyType = "channel.suspicious_user.update"
	CreateEventSubSubscriptionBodyTypeChannelUnban                                     CreateEventSubSubscriptionBodyType = "channel.unban"
	CreateEventSubSubscriptionBodyTypeChannelUnbanRequestCreate                        CreateEventSubSubscriptionBodyType = "channel.unban_request.create"
	CreateEventSubSubscriptionBodyTypeChannelUnbanRequestResolve                       CreateEventSubSubscriptionBodyType = "channel.unban_request.resolve"
	CreateEventSubSubscriptionBodyTypeChannelUpdate                                    CreateEventSubSubscriptionBodyType = "channel.update"
	CreateEventSubSubscriptionBodyTypeChannelVipAdd                                    CreateEventSubSubscriptionBodyType = "channel.vip.add"
	CreateEventSubSubscriptionBodyTypeChannelVipRemove                                 CreateEventSubSubscriptionBodyType = "channel.vip.remove"
	CreateEventSubSubscriptionBodyTypeChannelWarningAcknowledge                        CreateEventSubSubscriptionBodyType = "channel.warning.acknowledge"
	CreateEventSubSubscriptionBodyTypeChannelWarningSend                               CreateEventSubSubscriptionBodyType = "channel.warning.send"
	CreateEventSubSubscriptionBodyTypeConduitShardDisabled                             CreateEventSubSubscriptionBodyType = "conduit.shard.disabled"
	CreateEventSubSubscriptionBodyTypeDropEntitlementGrant                             CreateEventSubSubscriptionBodyType = "drop.entitlement.grant"
	CreateEventSubSubscriptionBodyTypeExtensionBitsTransactionCreate                   CreateEventSubSubscriptionBodyType = "extension.bits_transaction.create"
	CreateEventSubSubscriptionBodyTypeStreamOffline                                    CreateEventSubSubscriptionBodyType = "stream.offline"
	CreateEventSubSubscriptionBodyTypeStreamOnline                                     CreateEventSubSubscriptionBodyType = "stream.online"
	CreateEventSubSubscriptionBodyTypeUserAuthorizationGrant                           CreateEventSubSubscriptionBodyType = "user.authorization.grant"
	CreateEventSubSubscriptionBodyTypeUserAuthorizationRevoke                          CreateEventSubSubscriptionBodyType = "user.authorization.revoke"
	CreateEventSubSubscriptionBodyTypeUserUpdate                                       CreateEventSubSubscriptionBodyType = "user.update"
	CreateEventSubSubscriptionBodyTypeUserWhisperMessage                               CreateEventSubSubscriptionBodyType = "user.whisper.message"
)

// Defines values for CreatorGoalType.
const (
	CreatorGoalTypeFollower             CreatorGoalType = "follower"
	CreatorGoalTypeNewSubscription      CreatorGoalType = "new_subscription"
	CreatorGoalTypeNewSubscriptionCount CreatorGoalType = "new_subscription_count"
	CreatorGoalTypeSubscription         CreatorGoalType = "subscription"
	CreatorGoalTypeSubscriptionCount    CreatorGoalType = "subscription_count"
)

// Defines values for CustomRewardRedemptionStatus.
const (
	CustomRewardRedemptionStatusCANCELED    CustomRewardRedemptionStatus = "CANCELED"
	CustomRewardRedemptionStatusFULFILLED   CustomRewardRedemptionStatus = "FULFILLED"
	CustomRewardRedemptionStatusUNFULFILLED CustomRewardRedemptionStatus = "UNFULFILLED"
)

// Defines values for DropsEntitlementFulfillmentStatus.
const (
	DropsEntitlementFulfillmentStatusCLAIMED   DropsEntitlementFulfillmentStatus = "CLAIMED"
	DropsEntitlementFulfillmentStatusFULFILLED DropsEntitlementFulfillmentStatus = "FULFILLED"
)

// Defines values for DropsEntitlementUpdatedStatus.
const (
	INVALIDID    DropsEntitlementUpdatedStatus = "INVALID_ID"
	NOTFOUND     DropsEntitlementUpdatedStatus = "NOT_FOUND"
	SUCCESS      DropsEntitlementUpdatedStatus = "SUCCESS"
	UNAUTHORIZED DropsEntitlementUpdatedStatus = "UNAUTHORIZED"
	UPDATEFAILED DropsEntitlementUpdatedStatus = "UPDATE_FAILED"
)

// Defines values for EmoteEmoteType.
const (
	EmoteEmoteTypeBitstier      EmoteEmoteType = "bitstier"
	EmoteEmoteTypeFollower      EmoteEmoteType = "follower"
	EmoteEmoteTypeSubscriptions EmoteEmoteType = "subscriptions"
)

// Defines values for EmoteFormat.
const (
	EmoteFormatAnimated EmoteFormat = "animated"
	EmoteFormatStatic   EmoteFormat = "static"
)

// Defines values for EmoteScale.
const (
	EmoteScaleN10 EmoteScale = "1.0"
	EmoteScaleN20 EmoteScale = "2.0"
	EmoteScaleN30 EmoteScale = "3.0"
)

// Defines values for EmoteThemeMode.
const (
	EmoteThemeModeDark  EmoteThemeMode = "dark"
	EmoteThemeModeLight EmoteThemeMode = "light"
)

// Defines values for EndPollBodyStatus.
const (
	EndPollBodyStatusARCHIVED   EndPollBodyStatus = "ARCHIVED"
	EndPollBodyStatusTERMINATED EndPollBodyStatus = "TERMINATED"
)

// Defines values for EndPredictionBodyStatus.
const (
	EndPredictionBodyStatusCANCELED EndPredictionBodyStatus = "CANCELED"
	EndPredictionBodyStatusLOCKED   EndPredictionBodyStatus = "LOCKED"
	EndPredictionBodyStatusRESOLVED EndPredictionBodyStatus = "RESOLVED"
)

// Defines values for EventSubSubscriptionStatus.
const (
	EventSubSubscriptionStatusAuthorizationRevoked               EventSubSubscriptionStatus = "authorization_revoked"
	EventSubSubscriptionStatusBetaMaintenance                    EventSubSubscriptionStatus = "beta_maintenance"
	EventSubSubscriptionStatusEnabled                            EventSubSubscriptionStatus = "enabled"
	EventSubSubscriptionStatusModeratorRemoved                   EventSubSubscriptionStatus = "moderator_removed"
	EventSubSubscriptionStatusNotificationFailuresExceeded       EventSubSubscriptionStatus = "notification_failures_exceeded"
	EventSubSubscriptionStatusUserRemoved                        EventSubSubscriptionStatus = "user_removed"
	EventSubSubscriptionStatusVersionRemoved                     EventSubSubscriptionStatus = "version_removed"
	EventSubSubscriptionStatusWebhookCallbackVerificationFailed  EventSubSubscriptionStatus = "webhook_callback_verification_failed"
	EventSubSubscriptionStatusWebhookCallbackVerificationPending EventSubSubscriptionStatus = "webhook_callback_verification_pending"
	EventSubSubscriptionStatusWebsocketConnectionUnused          EventSubSubscriptionStatus = "websocket_connection_unused"
	EventSubSubscriptionStatusWebsocketDisconnected              EventSubSubscriptionStatus = "websocket_disconnected"
	EventSubSubscriptionStatusWebsocketFailedPingPong            EventSubSubscriptionStatus = "websocket_failed_ping_pong"
	EventSubSubscriptionStatusWebsocketInternalError             EventSubSubscriptionStatus = "websocket_internal_error"
	EventSubSubscriptionStatusWebsocketNetworkError              EventSubSubscriptionStatus = "websocket_network_error"
	EventSubSubscriptionStatusWebsocketNetworkTimeout            EventSubSubscriptionStatus = "websocket_network_timeout"
	EventSubSubscriptionStatusWebsocketReceivedInboundTraffic    EventSubSubscriptionStatus = "websocket_received_inbound_traffic"
)

// Defines values for EventSubSubscriptionTransportMethod.
const (
	EventSubSubscriptionTransportMethodWebhook   EventSubSubscriptionTransportMethod = "webhook"
	EventSubSubscriptionTransportMethodWebsocket EventSubSubscriptionTransportMethod = "websocket"
)

// Defines values for EventSubSubscriptionType.
const (
	EventSubSubscriptionTypeAutomodMessageHold                               EventSubSubscriptionType = "automod.message.hold"
	EventSubSubscriptionTypeAutomodMessageUpdate                             EventSubSubscriptionType = "automod.message.update"
	EventSubSubscriptionTypeAutomodSettingsUpdate                            EventSubSubscriptionType = "automod.settings.update"
	EventSubSubscriptionTypeAutomodTermsUpdate                               EventSubSubscriptionType = "automod.terms.update"
	EventSubSubscriptionTypeChannelAdBreakBegin                              EventSubSubscriptionType = "channel.ad_break.begin"
	EventSubSubscriptionTypeChannelBan                                       EventSubSubscriptionType = "channel.ban"
	EventSubSubscriptionTypeChannelBitsUse                                   EventSubSubscriptionType = "channel.bits.use"
	EventSubSubscriptionTypeChannelChannelPointsAutomaticRewardRedemptionAdd EventSubSubscriptionType = "channel.channel_points_automatic_reward_redemption.add"
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardAdd              EventSubSubscriptionType = "channel.channel_points_custom_reward.add"
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionAdd    EventSubSubscriptionType = "channel.channel_points_custom_reward_redemption.add"
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionUpdate EventSubSubscriptionType = "channel.channel_points_custom_reward_redemption.update"
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRemove           EventSubSubscriptionType = "channel.channel_points_custom_reward.remove"
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardUpdate           EventSubSubscriptionType = "channel.channel_points_custom_reward.update"
	EventSubSubscriptionTypeChannelCharityCampaignDonate                     EventSubSubscriptionType = "channel.charity_campaign.donate"
	EventSubSubscriptionTypeChannelCharityCampaignProgress                   EventSubSubscriptionType = "channel.charity_campaign.progress"
	EventSubSubscriptionTypeChannelCharityCampaignStart                      EventSubSubscriptionType = "channel.charity_campaign.start"
	EventSubSubscriptionTypeChannelCharityCampaignStop                       EventSubSubscriptionType = "channel.charity_campaign.stop"
	EventSubSubscriptionTypeChannelChatClear                                 EventSubSubscriptionType = "channel.chat.clear"
	EventSubSubscriptionTypeChannelChatClearUserMessages                     EventSubSubscriptionType = "channel.chat.clear_user_messages"
	EventSubSubscriptionTypeChannelChatMessage                               EventSubSubscriptionType = "channel.chat.message"
	EventSubSubscriptionTypeChannelChatMessageDelete                         EventSubSubscriptionType = "channel.chat.message_delete"
	EventSubSubscriptionTypeChannelChatNotification                          EventSubSubscriptionType = "channel.chat.notification"
	EventSubSubscriptionTypeChannelChatSettingsUpdate                        EventSubSubscriptionType = "channel.chat_settings.update"
	EventSubSubscriptionTypeChannelChatUserMessageHold                       EventSubSubscriptionType = "channel.chat.user_message_hold"
	EventSubSubscriptionTypeChannelChatUserMessageUpdate                     EventSubSubscriptionType = "channel.chat.user_message_update"
	EventSubSubscriptionTypeChannelCheer                                     EventSubSubscriptionType = "channel.cheer"
	EventSubSubscriptionTypeChannelFollow                                    EventSubSubscriptionType = "channel.follow"
	EventSubSubscriptionTypeChannelGoalBegin                                 EventSubSubscriptionType = "channel.goal.begin"
	EventSubSubscriptionTypeChannelGoalEnd                                   EventSubSubscriptionType = "channel.goal.end"
	EventSubSubscriptionTypeChannelGoalProgress                              EventSubSubscriptionType = "channel.goal.progress"
	EventSubSubscriptionTypeChannelGuestStarGuestUpdate                      EventSubSubscriptionType = "channel.guest_star_guest.update"
	EventSubSubscriptionTypeChannelGuestStarSessionBegin                     EventSubSubscriptionType = "channel.guest_star_session.begin"
	EventSubSubscriptionTypeChannelGuestStarSessionEnd                       EventSubSubscriptionType = "channel.guest_star_session.end"
	EventSubSubscriptionTypeChannelGuestStarSettingsUpdate                   EventSubSubscriptionType = "channel.guest_star_settings.update"
	EventSubSubscriptionTypeChannelHypeTrainBegin                            EventSubSubscriptionType = "channel.hype_train.begin"
	EventSubSubscriptionTypeChannelHypeTrainEnd                              EventSubSubscriptionType = "channel.hype_train.end"
	EventSubSubscriptionTypeChannelHypeTrainProgress                         EventSubSubscriptionType = "channel.hype_train.progress"
	EventSubSubscriptionTypeChannelModerate                                  EventSubSubscriptionType = "channel.moderate"
	EventSubSubscriptionTypeChannelModeratorAdd                              EventSubSubscriptionType = "channel.moderator.add"
	EventSubSubscriptionTypeChannelModeratorRemove                           EventSubSubscriptionType = "channel.moderator.remove"
	EventSubSubscriptionTypeChannelPollBegin                                 EventSubSubscriptionType = "channel.poll.begin"
	EventSubSubscriptionTypeChannelPollEnd                                   EventSubSubscriptionType = "channel.poll.end"
	EventSubSubscriptionTypeChannelPollProgress                              EventSubSubscriptionType = "channel.poll.progress"
	EventSubSubscriptionTypeChannelPredictionBegin                           EventSubSubscriptionType = "channel.prediction.begin"
	EventSubSubscriptionTypeChannelPredictionEnd                             EventSubSubscriptionType = "channel.prediction.end"
	EventSubSubscriptionTypeChannelPredictionLock                            EventSubSubscriptionType = "channel.prediction.lock"
	EventSubSubscriptionTypeChannelPredictionProgress                        EventSubSubscriptionType = "channel.prediction.progress"
	EventSubSubscriptionTypeChannelRaid                                      EventSubSubscriptionType = "channel.raid"
	EventSubSubscriptionTypeChannelSharedChatBegin                           EventSubSubscriptionType = "channel.shared_chat.begin"
	EventSubSubscriptionTypeChannelSharedChatEnd                             EventSubSubscriptionType = "channel.shared_chat.end"
	EventSubSubscriptionTypeChannelSharedChatUpdate                          EventSubSubscriptionType = "channel.shared_chat.update"
	EventSubSubscriptionTypeChannelShieldModeBegin                           EventSubSubscriptionType = "channel.shield_mode.begin"
	EventSubSubscriptionTypeChannelShieldModeEnd                             EventSubSubscriptionType = "channel.shield_mode.end"
	EventSubSubscriptionTypeChannelShoutoutCreate                            EventSubSubscriptionType = "channel.shoutout.create"
	EventSubSubscriptionTypeChannelShoutoutReceive                           EventSubSubscriptionType = "channel.shoutout.receive"
	EventSubSubscriptionTypeChannelSubscribe                                 EventSubSubscriptionType = "channel.subscribe"
	EventSubSubscriptionTypeChannelSubscriptionEnd                           EventSubSubscriptionType = "channel.subscription.end"
	EventSubSubscriptionTypeChannelSubscriptionGift                          EventSubSubscriptionType = "channel.subscription.gift"
	EventSubSubscriptionTypeChannelSubscriptionMessage                       EventSubSubscriptionType = "channel.subscription.message"
	EventSubSubscriptionTypeChannelSuspiciousUserMessage                     EventSubSubscriptionType = "channel.suspicious_user.message"
	EventSubSubscriptionTypeChannelSuspiciousUserUpdate                      EventSubSubscriptionType = "channel.suspicious_user.update"
	EventSubSubscriptionTypeChannelUnban                                     EventSubSubscriptionType = "channel.unban"
	EventSubSubscriptionTypeChannelUnbanRequestCreate                        EventSubSubscriptionType = "channel.unban_request.create"
	EventSubSubscriptionTypeChannelUnbanRequestResolve                       EventSubSubscriptionType = "channel.unban_request.resolve"
	EventSubSubscriptionTypeChannelUpdate                                    EventSubSubscriptionType = "channel.update"
	EventSubSubscriptionTypeChannelVipAdd                                    EventSubSubscriptionType = "channel.vip.add"
	EventSubSubscriptionTypeChannelVipRemove                                 EventSubSubscriptionType = "channel.vip.remove"
	EventSubSubscriptionTypeChannelWarningAcknowledge                        EventSubSubscriptionType = "channel.warning.acknowledge"
	EventSubSubscriptionTypeChannelWarningSend                               EventSubSubscriptionType = "channel.warning.send"
	EventSubSubscriptionTypeConduitShardDisabled                             EventSubSubscriptionType = "conduit.shard.disabled"
	EventSubSubscriptionTypeDropEntitlementGrant                             EventSubSubscriptionType = "drop.entitlement.grant"
	EventSubSubscriptionTypeExtensionBitsTransactionCreate                   EventSubSubscriptionType = "extension.bits_transaction.create"
	EventSubSubscriptionTypeStreamOffline                                    EventSubSubscriptionType = "stream.offline"
	EventSubSubscriptionTypeStreamOnline                                     EventSubSubscriptionType = "stream.online"
	EventSubSubscriptionTypeUserAuthorizationGrant                           EventSubSubscriptionType = "user.authorization.grant"
	EventSubSubscriptionTypeUserAuthorizationRevoke                          EventSubSubscriptionType = "user.authorization.revoke"
	EventSubSubscriptionTypeUserUpdate                                       EventSubSubscriptionType = "user.update"
	EventSubSubscriptionTypeUserWhisperMessage                               EventSubSubscriptionType = "user.whisper.message"
)

// Defines values for ExtensionConfigurationLocation.
const (
	ExtensionConfigurationLocationCustom ExtensionConfigurationLocation = "custom"
	ExtensionConfigurationLocationHosted ExtensionConfigurationLocation = "hosted"
	ExtensionConfigurationLocationNone   ExtensionConfigurationLocation = "none"
)

// Defines values for ExtensionState.
const (
	Approved       ExtensionState = "Approved"
	AssetsUploaded ExtensionState = "AssetsUploaded"
	Deleted        ExtensionState = "Deleted"
	Deprecated     ExtensionState = "Deprecated"
	InReview       ExtensionState = "InReview"
	InTest         ExtensionState = "InTest"
	PendingAction  ExtensionState = "PendingAction"
	Rejected       ExtensionState = "Rejected"
	Released       ExtensionState = "Released"
)

// Defines values for ExtensionSubscriptionsSupportLevel.
const (
	ExtensionSubscriptionsSupportLevelNone     ExtensionSubscriptionsSupportLevel = "none"
	ExtensionSubscriptionsSupportLevelOptional ExtensionSubscriptionsSupportLevel = "optional"
)

// Defines values for ExtensionBitsProductCostType.
const (
	ExtensionBitsProductCostTypeBits ExtensionBitsProductCostType = "bits"
)

// Defines values for ExtensionConfigurationSegmentSegment.
const (
	ExtensionConfigurationSegmentSegmentBroadcaster ExtensionConfigurationSegmentSegment = "broadcaster"
	ExtensionConfigurationSegmentSegmentDeveloper   ExtensionConfigurationSegmentSegment = "developer"
	ExtensionConfigurationSegmentSegmentGlobal      ExtensionConfigurationSegmentSegment = "global"
)

// Defines values for ExtensionTransactionProductDataCostType.
const (
	ExtensionTransactionProductDataCostTypeBits ExtensionTransactionProductDataCostType = "bits"
)

// Defines values for ExtensionTransactionProductType.
const (
	BITSINEXTENSION ExtensionTransactionProductType = "BITS_IN_EXTENSION"
)

// Defines values for GetChannelGuestStarSettingsResponseGroupLayout.
const (
	GetChannelGuestStarSettingsResponseGroupLayoutSCREENSHARELAYOUT GetChannelGuestStarSettingsResponseGroupLayout = "SCREENSHARE_LAYOUT"
	GetChannelGuestStarSettingsResponseGroupLayoutTILEDLAYOUT       GetChannelGuestStarSettingsResponseGroupLayout = "TILED_LAYOUT"
)

// Defines values for GetConduitShardsResponseDataStatus.
const (
	GetConduitShardsResponseDataStatusEnabled                            GetConduitShardsResponseDataStatus = "enabled"
	GetConduitShardsResponseDataStatusNotificationFailuresExceeded       GetConduitShardsResponseDataStatus = "notification_failures_exceeded"
	GetConduitShardsResponseDataStatusWebhookCallbackVerificationFailed  GetConduitShardsResponseDataStatus = "webhook_callback_verification_failed"
	GetConduitShardsResponseDataStatusWebhookCallbackVerificationPending GetConduitShardsResponseDataStatus = "webhook_callback_verification_pending"
	GetConduitShardsResponseDataStatusWebsocketDisconnected              GetConduitShardsResponseDataStatus = "websocket_disconnected"
	GetConduitShardsResponseDataStatusWebsocketFailedPingPong            GetConduitShardsResponseDataStatus = "websocket_failed_ping_pong"
	GetConduitShardsResponseDataStatusWebsocketFailedToReconnect         GetConduitShardsResponseDataStatus = "websocket_failed_to_reconnect"
	GetConduitShardsResponseDataStatusWebsocketInternalError             GetConduitShardsResponseDataStatus = "websocket_internal_error"
	GetConduitShardsResponseDataStatusWebsocketNetworkError              GetConduitShardsResponseDataStatus = "websocket_network_error"
	GetConduitShardsResponseDataStatusWebsocketNetworkTimeout            GetConduitShardsResponseDataStatus = "websocket_network_timeout"
	GetConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic    GetConduitShardsResponseDataStatus = "websocket_received_inbound_traffic"
)

// Defines values for GetConduitShardsResponseDataTransportMethod.
const (
	GetConduitShardsResponseDataTransportMethodWebhook   GetConduitShardsResponseDataTransportMethod = "webhook"
	GetConduitShardsResponseDataTransportMethodWebsocket GetConduitShardsResponseDataTransportMethod = "websocket"
)

// Defines values for GetHypeTrainStatusResponseDataCurrentTopContributionsType.
const (
	GoldenKappa GetHypeTrainStatusResponseDataCurrentTopContributionsType = "golden_kappa"
	Regular     GetHypeTrainStatusResponseDataCurrentTopContributionsType = "regular"
	Treasure    GetHypeTrainStatusResponseDataCurrentTopContributionsType = "treasure"
)

// Defines values for GetUserEmotesResponseDataEmoteType.
const (
	GetUserEmotesResponseDataEmoteTypeBitstier      GetUserEmotesResponseDataEmoteType = "bitstier"
	GetUserEmotesResponseDataEmoteTypeChannelpoints GetUserEmotesResponseDataEmoteType = "channelpoints"
	GetUserEmotesResponseDataEmoteTypeFollower      GetUserEmotesResponseDataEmoteType = "follower"
	GetUserEmotesResponseDataEmoteTypeGlobals       GetUserEmotesResponseDataEmoteType = "globals"
	GetUserEmotesResponseDataEmoteTypeHypetrain     GetUserEmotesResponseDataEmoteType = "hypetrain"
	GetUserEmotesResponseDataEmoteTypeLimitedtime   GetUserEmotesResponseDataEmoteType = "limitedtime"
	GetUserEmotesResponseDataEmoteTypeNone          GetUserEmotesResponseDataEmoteType = "none"
	GetUserEmotesResponseDataEmoteTypeOwl2019       GetUserEmotesResponseDataEmoteType = "owl2019"
	GetUserEmotesResponseDataEmoteTypePrime         GetUserEmotesResponseDataEmoteType = "prime"
	GetUserEmotesResponseDataEmoteTypeRewards       GetUserEmotesResponseDataEmoteType = "rewards"
	GetUserEmotesResponseDataEmoteTypeSmilies       GetUserEmotesResponseDataEmoteType = "smilies"
	GetUserEmotesResponseDataEmoteTypeSubscriptions GetUserEmotesResponseDataEmoteType = "subscriptions"
	GetUserEmotesResponseDataEmoteTypeTurbo         GetUserEmotesResponseDataEmoteType = "turbo"
	GetUserEmotesResponseDataEmoteTypeTwofactor     GetUserEmotesResponseDataEmoteType = "twofactor"
)

// Defines values for GlobalEmoteFormat.
const (
	Animated GlobalEmoteFormat = "animated"
	Static   GlobalEmoteFormat = "static"
)

// Defines values for GlobalEmoteScale.
const (
	N10 GlobalEmoteScale = "1.0"
	N20 GlobalEmoteScale = "2.0"
	N30 GlobalEmoteScale = "3.0"
)

// Defines values for GlobalEmoteThemeMode.
const (
	Dark  GlobalEmoteThemeMode = "dark"
	Light GlobalEmoteThemeMode = "light"
)

// Defines values for HypeTrainEventEventDataLastContributionType.
const (
	HypeTrainEventEventDataLastContributionTypeBITS  HypeTrainEventEventDataLastContributionType = "BITS"
	HypeTrainEventEventDataLastContributionTypeOTHER HypeTrainEventEventDataLastContributionType = "OTHER"
	HypeTrainEventEventDataLastContributionTypeSUBS  HypeTrainEventEventDataLastContributionType = "SUBS"
)

// Defines values for HypeTrainEventEventDataTopContributionsType.
const (
	HypeTrainEventEventDataTopContributionsTypeBITS  HypeTrainEventEventDataTopContributionsType = "BITS"
	HypeTrainEventEventDataTopContributionsTypeOTHER HypeTrainEventEventDataTopContributionsType = "OTHER"
	HypeTrainEventEventDataTopContributionsTypeSUBS  HypeTrainEventEventDataTopContributionsType = "SUBS"
)

// Defines values for ManageHeldAutoModMessagesBodyAction.
const (
	ALLOW ManageHeldAutoModMessagesBodyAction = "ALLOW"
	DENY  ManageHeldAutoModMessagesBodyAction = "DENY"
)

// Defines values for ModifyChannelInformationBodyContentClassificationLabelsId.
const (
	DebatedSocialIssuesAndPolitics ModifyChannelInformationBodyContentClassificationLabelsId = "DebatedSocialIssuesAndPolitics"
	DrugsIntoxication              ModifyChannelInformationBodyContentClassificationLabelsId = "DrugsIntoxication"
	Gambling                       ModifyChannelInformationBodyContentClassificationLabelsId = "Gambling"
	ProfanityVulgarity             ModifyChannelInformationBodyContentClassificationLabelsId = "ProfanityVulgarity"
	SexualThemes                   ModifyChannelInformationBodyContentClassificationLabelsId = "SexualThemes"
	ViolentGraphic                 ModifyChannelInformationBodyContentClassificationLabelsId = "ViolentGraphic"
)

// Defines values for PollStatus.
const (
	PollStatusACTIVE     PollStatus = "ACTIVE"
	PollStatusARCHIVED   PollStatus = "ARCHIVED"
	PollStatusCOMPLETED  PollStatus = "COMPLETED"
	PollStatusINVALID    PollStatus = "INVALID"
	PollStatusMODERATED  PollStatus = "MODERATED"
	PollStatusTERMINATED PollStatus = "TERMINATED"
)

// Defines values for PredictionStatus.
const (
	PredictionStatusACTIVE   PredictionStatus = "ACTIVE"
	PredictionStatusCANCELED PredictionStatus = "CANCELED"
	PredictionStatusLOCKED   PredictionStatus = "LOCKED"
	PredictionStatusRESOLVED PredictionStatus = "RESOLVED"
)

// Defines values for PredictionOutcomeColor.
const (
	BLUE PredictionOutcomeColor = "BLUE"
	PINK PredictionOutcomeColor = "PINK"
)

// Defines values for SendChatAnnouncementBodyColor.
const (
	SendChatAnnouncementBodyColorBlue    SendChatAnnouncementBodyColor = "blue"
	SendChatAnnouncementBodyColorGreen   SendChatAnnouncementBodyColor = "green"
	SendChatAnnouncementBodyColorOrange  SendChatAnnouncementBodyColor = "orange"
	SendChatAnnouncementBodyColorPrimary SendChatAnnouncementBodyColor = "primary"
	SendChatAnnouncementBodyColorPurple  SendChatAnnouncementBodyColor = "purple"
)

// Defines values for SendExtensionPubSubMessageBodyTarget.
const (
	SendExtensionPubSubMessageBodyTargetBroadcast     SendExtensionPubSubMessageBodyTarget = "broadcast"
	SendExtensionPubSubMessageBodyTargetGlobal        SendExtensionPubSubMessageBodyTarget = "global"
	SendExtensionPubSubMessageBodyTargetWhisperuserId SendExtensionPubSubMessageBodyTarget = "whisper-<user-id>"
)

// Defines values for SetExtensionConfigurationSegmentBodySegment.
const (
	SetExtensionConfigurationSegmentBodySegmentBroadcaster SetExtensionConfigurationSegmentBodySegment = "broadcaster"
	SetExtensionConfigurationSegmentBodySegmentDeveloper   SetExtensionConfigurationSegmentBodySegment = "developer"
	SetExtensionConfigurationSegmentBodySegmentGlobal      SetExtensionConfigurationSegmentBodySegment = "global"
)

// Defines values for StreamType.
const (
	StreamTypeLive StreamType = "live"
)

// Defines values for UpdateChannelGuestStarSettingsBodyGroupLayout.
const (
	UpdateChannelGuestStarSettingsBodyGroupLayoutHORIZONTALLAYOUT  UpdateChannelGuestStarSettingsBodyGroupLayout = "HORIZONTAL_LAYOUT"
	UpdateChannelGuestStarSettingsBodyGroupLayoutSCREENSHARELAYOUT UpdateChannelGuestStarSettingsBodyGroupLayout = "SCREENSHARE_LAYOUT"
	UpdateChannelGuestStarSettingsBodyGroupLayoutTILEDLAYOUT       UpdateChannelGuestStarSettingsBodyGroupLayout = "TILED_LAYOUT"
	UpdateChannelGuestStarSettingsBodyGroupLayoutVERTICALLAYOUT    UpdateChannelGuestStarSettingsBodyGroupLayout = "VERTICAL_LAYOUT"
)

// Defines values for UpdateChatSettingsBodyNonModeratorChatDelayDuration.
const (
	N2 UpdateChatSettingsBodyNonModeratorChatDelayDuration = 2
	N4 UpdateChatSettingsBodyNonModeratorChatDelayDuration = 4
	N6 UpdateChatSettingsBodyNonModeratorChatDelayDuration = 6
)

// Defines values for UpdateConduitShardsBodyShardsTransportMethod.
const (
	UpdateConduitShardsBodyShardsTransportMethodWebhook   UpdateConduitShardsBodyShardsTransportMethod = "webhook"
	UpdateConduitShardsBodyShardsTransportMethodWebsocket UpdateConduitShardsBodyShardsTransportMethod = "websocket"
)

// Defines values for UpdateConduitShardsResponseDataStatus.
const (
	UpdateConduitShardsResponseDataStatusEnabled                            UpdateConduitShardsResponseDataStatus = "enabled"
	UpdateConduitShardsResponseDataStatusNotificationFailuresExceeded       UpdateConduitShardsResponseDataStatus = "notification_failures_exceeded"
	UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationFailed  UpdateConduitShardsResponseDataStatus = "webhook_callback_verification_failed"
	UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationPending UpdateConduitShardsResponseDataStatus = "webhook_callback_verification_pending"
	UpdateConduitShardsResponseDataStatusWebsocketDisconnected              UpdateConduitShardsResponseDataStatus = "websocket_disconnected"
	UpdateConduitShardsResponseDataStatusWebsocketFailedPingPong            UpdateConduitShardsResponseDataStatus = "websocket_failed_ping_pong"
	UpdateConduitShardsResponseDataStatusWebsocketFailedToReconnect         UpdateConduitShardsResponseDataStatus = "websocket_failed_to_reconnect"
	UpdateConduitShardsResponseDataStatusWebsocketInternalError             UpdateConduitShardsResponseDataStatus = "websocket_internal_error"
	UpdateConduitShardsResponseDataStatusWebsocketNetworkError              UpdateConduitShardsResponseDataStatus = "websocket_network_error"
	UpdateConduitShardsResponseDataStatusWebsocketNetworkTimeout            UpdateConduitShardsResponseDataStatus = "websocket_network_timeout"
	UpdateConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic    UpdateConduitShardsResponseDataStatus = "websocket_received_inbound_traffic"
)

// Defines values for UpdateConduitShardsResponseDataTransportMethod.
const (
	Webhook   UpdateConduitShardsResponseDataTransportMethod = "webhook"
	Websocket UpdateConduitShardsResponseDataTransportMethod = "websocket"
)

// Defines values for UpdateDropsEntitlementsBodyFulfillmentStatus.
const (
	UpdateDropsEntitlementsBodyFulfillmentStatusCLAIMED   UpdateDropsEntitlementsBodyFulfillmentStatus = "CLAIMED"
	UpdateDropsEntitlementsBodyFulfillmentStatusFULFILLED UpdateDropsEntitlementsBodyFulfillmentStatus = "FULFILLED"
)

// Defines values for UpdateExtensionBitsProductBodyCostType.
const (
	Bits UpdateExtensionBitsProductBodyCostType = "bits"
)

// Defines values for UpdateRedemptionStatusBodyStatus.
const (
	UpdateRedemptionStatusBodyStatusCANCELED  UpdateRedemptionStatusBodyStatus = "CANCELED"
	UpdateRedemptionStatusBodyStatusFULFILLED UpdateRedemptionStatusBodyStatus = "FULFILLED"
)

// Defines values for UserBroadcasterType.
const (
	UserBroadcasterTypeAffiliate UserBroadcasterType = "affiliate"
	UserBroadcasterTypeEmpty     UserBroadcasterType = ""
	UserBroadcasterTypePartner   UserBroadcasterType = "partner"
)

// Defines values for UserType.
const (
	UserTypeAdmin     UserType = "admin"
	UserTypeEmpty     UserType = ""
	UserTypeGlobalMod UserType = "global_mod"
	UserTypeStaff     UserType = "staff"
)

// Defines values for UserExtensionType.
const (
	Component UserExtensionType = "component"
	Mobile    UserExtensionType = "mobile"
	Overlay   UserExtensionType = "overlay"
	Panel     UserExtensionType = "panel"
)

// Defines values for UserSubscriptionTier.
const (
	N1000 UserSubscriptionTier = "1000"
	N2000 UserSubscriptionTier = "2000"
	N3000 UserSubscriptionTier = "3000"
)

// Defines values for VideoType.
const (
	VideoTypeArchive   VideoType = "archive"
	VideoTypeHighlight VideoType = "highlight"
	VideoTypeUpload    VideoType = "upload"
)

// Defines values for GetExtensionAnalyticsParamsType.
const (
	GetExtensionAnalyticsParamsTypeOverviewV2 GetExtensionAnalyticsParamsType = "overview_v2"
)

// Defines values for GetGameAnalyticsParamsType.
const (
	GetGameAnalyticsParamsTypeOverviewV2 GetGameAnalyticsParamsType = "overview_v2"
)

// Defines values for GetBitsLeaderboardParamsPeriod.
const (
	GetBitsLeaderboardParamsPeriodAll   GetBitsLeaderboardParamsPeriod = "all"
	GetBitsLeaderboardParamsPeriodDay   GetBitsLeaderboardParamsPeriod = "day"
	GetBitsLeaderboardParamsPeriodMonth GetBitsLeaderboardParamsPeriod = "month"
	GetBitsLeaderboardParamsPeriodWeek  GetBitsLeaderboardParamsPeriod = "week"
	GetBitsLeaderboardParamsPeriodYear  GetBitsLeaderboardParamsPeriod = "year"
)

// Defines values for GetCustomRewardRedemptionParamsStatus.
const (
	GetCustomRewardRedemptionParamsStatusCANCELED    GetCustomRewardRedemptionParamsStatus = "CANCELED"
	GetCustomRewardRedemptionParamsStatusFULFILLED   GetCustomRewardRedemptionParamsStatus = "FULFILLED"
	GetCustomRewardRedemptionParamsStatusUNFULFILLED GetCustomRewardRedemptionParamsStatus = "UNFULFILLED"
)

// Defines values for GetCustomRewardRedemptionParamsSort.
const (
	NEWEST GetCustomRewardRedemptionParamsSort = "NEWEST"
	OLDEST GetCustomRewardRedemptionParamsSort = "OLDEST"
)

// Defines values for UpdateUserChatColorParamsColor.
const (
	UpdateUserChatColorParamsColorBlue        UpdateUserChatColorParamsColor = "blue"
	UpdateUserChatColorParamsColorBlueViolet  UpdateUserChatColorParamsColor = "blue_violet"
	UpdateUserChatColorParamsColorCadetBlue   UpdateUserChatColorParamsColor = "cadet_blue"
	UpdateUserChatColorParamsColorChocolate   UpdateUserChatColorParamsColor = "chocolate"
	UpdateUserChatColorParamsColorCoral       UpdateUserChatColorParamsColor = "coral"
	UpdateUserChatColorParamsColorDodgerBlue  UpdateUserChatColorParamsColor = "dodger_blue"
	UpdateUserChatColorParamsColorFirebrick   UpdateUserChatColorParamsColor = "firebrick"
	UpdateUserChatColorParamsColorGoldenRod   UpdateUserChatColorParamsColor = "golden_rod"
	UpdateUserChatColorParamsColorGreen       UpdateUserChatColorParamsColor = "green"
	UpdateUserChatColorParamsColorHotPink     UpdateUserChatColorParamsColor = "hot_pink"
	UpdateUserChatColorParamsColorOrangeRed   UpdateUserChatColorParamsColor = "orange_red"
	UpdateUserChatColorParamsColorRed         UpdateUserChatColorParamsColor = "red"
	UpdateUserChatColorParamsColorSeaGreen    UpdateUserChatColorParamsColor = "sea_green"
	UpdateUserChatColorParamsColorSpringGreen UpdateUserChatColorParamsColor = "spring_green"
	UpdateUserChatColorParamsColorYellowGreen UpdateUserChatColorParamsColor = "yellow_green"
)

// Defines values for GetDropsEntitlementsParamsFulfillmentStatus.
const (
	GetDropsEntitlementsParamsFulfillmentStatusCLAIMED   GetDropsEntitlementsParamsFulfillmentStatus = "CLAIMED"
	GetDropsEntitlementsParamsFulfillmentStatusFULFILLED GetDropsEntitlementsParamsFulfillmentStatus = "FULFILLED"
)

// Defines values for GetEventsubSubscriptionsParamsStatus.
const (
	GetEventsubSubscriptionsParamsStatusAuthorizationRevoked               GetEventsubSubscriptionsParamsStatus = "authorization_revoked"
	GetEventsubSubscriptionsParamsStatusBetaMaintenance                    GetEventsubSubscriptionsParamsStatus = "beta_maintenance"
	GetEventsubSubscriptionsParamsStatusChatUserBanned                     GetEventsubSubscriptionsParamsStatus = "chat_user_banned"
	GetEventsubSubscriptionsParamsStatusEnabled                            GetEventsubSubscriptionsParamsStatus = "enabled"
	GetEventsubSubscriptionsParamsStatusModeratorRemoved                   GetEventsubSubscriptionsParamsStatus = "moderator_removed"
	GetEventsubSubscriptionsParamsStatusNotificationFailuresExceeded       GetEventsubSubscriptionsParamsStatus = "notification_failures_exceeded"
	GetEventsubSubscriptionsParamsStatusUserRemoved                        GetEventsubSubscriptionsParamsStatus = "user_removed"
	GetEventsubSubscriptionsParamsStatusVersionRemoved                     GetEventsubSubscriptionsParamsStatus = "version_removed"
	GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationFailed  GetEventsubSubscriptionsParamsStatus = "webhook_callback_verification_failed"
	GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationPending GetEventsubSubscriptionsParamsStatus = "webhook_callback_verification_pending"
	GetEventsubSubscriptionsParamsStatusWebsocketConnectionUnused          GetEventsubSubscriptionsParamsStatus = "websocket_connection_unused"
	GetEventsubSubscriptionsParamsStatusWebsocketDisconnected              GetEventsubSubscriptionsParamsStatus = "websocket_disconnected"
	GetEventsubSubscriptionsParamsStatusWebsocketFailedPingPong            GetEventsubSubscriptionsParamsStatus = "websocket_failed_ping_pong"
	GetEventsubSubscriptionsParamsStatusWebsocketFailedToReconnect         GetEventsubSubscriptionsParamsStatus = "websocket_failed_to_reconnect"
	GetEventsubSubscriptionsParamsStatusWebsocketInternalError             GetEventsubSubscriptionsParamsStatus = "websocket_internal_error"
	GetEventsubSubscriptionsParamsStatusWebsocketNetworkError              GetEventsubSubscriptionsParamsStatus = "websocket_network_error"
	GetEventsubSubscriptionsParamsStatusWebsocketNetworkTimeout            GetEventsubSubscriptionsParamsStatus = "websocket_network_timeout"
	GetEventsubSubscriptionsParamsStatusWebsocketReceivedInboundTraffic    GetEventsubSubscriptionsParamsStatus = "websocket_received_inbound_traffic"
)

// Defines values for GetEventsubSubscriptionsParamsType.
const (
	AutomodMessageHold                               GetEventsubSubscriptionsParamsType = "automod.message.hold"
	AutomodMessageUpdate                             GetEventsubSubscriptionsParamsType = "automod.message.update"
	AutomodSettingsUpdate                            GetEventsubSubscriptionsParamsType = "automod.settings.update"
	AutomodTermsUpdate                               GetEventsubSubscriptionsParamsType = "automod.terms.update"
	ChannelAdBreakBegin                              GetEventsubSubscriptionsParamsType = "channel.ad_break.begin"
	ChannelBan                                       GetEventsubSubscriptionsParamsType = "channel.ban"
	ChannelBitsUse                                   GetEventsubSubscriptionsParamsType = "channel.bits.use"
	ChannelChannelPointsAutomaticRewardRedemptionAdd GetEventsubSubscriptionsParamsType = "channel.channel_points_automatic_reward_redemption.add"
	ChannelChannelPointsCustomRewardAdd              GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward.add"
	ChannelChannelPointsCustomRewardRedemptionAdd    GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward_redemption.add"
	ChannelChannelPointsCustomRewardRedemptionUpdate GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward_redemption.update"
	ChannelChannelPointsCustomRewardRemove           GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward.remove"
	ChannelChannelPointsCustomRewardUpdate           GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward.update"
	ChannelCharityCampaignDonate                     GetEventsubSubscriptionsParamsType = "channel.charity_campaign.donate"
	ChannelCharityCampaignProgress                   GetEventsubSubscriptionsParamsType = "channel.charity_campaign.progress"
	ChannelCharityCampaignStart                      GetEventsubSubscriptionsParamsType = "channel.charity_campaign.start"
	ChannelCharityCampaignStop                       GetEventsubSubscriptionsParamsType = "channel.charity_campaign.stop"
	ChannelChatClear                                 GetEventsubSubscriptionsParamsType = "channel.chat.clear"
	ChannelChatClearUserMessages                     GetEventsubSubscriptionsParamsType = "channel.chat.clear_user_messages"
	ChannelChatMessage                               GetEventsubSubscriptionsParamsType = "channel.chat.message"
	ChannelChatMessageDelete                         GetEventsubSubscriptionsParamsType = "channel.chat.message_delete"
	ChannelChatNotification                          GetEventsubSubscriptionsParamsType = "channel.chat.notification"
	ChannelChatSettingsUpdate                        GetEventsubSubscriptionsParamsType = "channel.chat_settings.update"
	ChannelChatUserMessageHold                       GetEventsubSubscriptionsParamsType = "channel.chat.user_message_hold"
	ChannelChatUserMessageUpdate                     GetEventsubSubscriptionsParamsType = "channel.chat.user_message_update"
	ChannelCheer                                     GetEventsubSubscriptionsParamsType = "channel.cheer"
	ChannelFollow                                    GetEventsubSubscriptionsParamsType = "channel.follow"
	ChannelGoalBegin                                 GetEventsubSubscriptionsParamsType = "channel.goal.begin"
	ChannelGoalEnd                                   GetEventsubSubscriptionsParamsType = "channel.goal.end"
	ChannelGoalProgress                              GetEventsubSubscriptionsParamsType = "channel.goal.progress"
	ChannelGuestStarGuestUpdate                      GetEventsubSubscriptionsParamsType = "channel.guest_star_guest.update"
	ChannelGuestStarSessionBegin                     GetEventsubSubscriptionsParamsType = "channel.guest_star_session.begin"
	ChannelGuestStarSessionEnd                       GetEventsubSubscriptionsParamsType = "channel.guest_star_session.end"
	ChannelGuestStarSettingsUpdate                   GetEventsubSubscriptionsParamsType = "channel.guest_star_settings.update"
	ChannelHypeTrainBegin                            GetEventsubSubscriptionsParamsType = "channel.hype_train.begin"
	ChannelHypeTrainEnd                              GetEventsubSubscriptionsParamsType = "channel.hype_train.end"
	ChannelHypeTrainProgress                         GetEventsubSubscriptionsParamsType = "channel.hype_train.progress"
	ChannelModerate                                  GetEventsubSubscriptionsParamsType = "channel.moderate"
	ChannelModeratorAdd                              GetEventsubSubscriptionsParamsType = "channel.moderator.add"
	ChannelModeratorRemove                           GetEventsubSubscriptionsParamsType = "channel.moderator.remove"
	ChannelPollBegin                                 GetEventsubSubscriptionsParamsType = "channel.poll.begin"
	ChannelPollEnd                                   GetEventsubSubscriptionsParamsType = "channel.poll.end"
	ChannelPollProgress                              GetEventsubSubscriptionsParamsType = "channel.poll.progress"
	ChannelPredictionBegin                           GetEventsubSubscriptionsParamsType = "channel.prediction.begin"
	ChannelPredictionEnd                             GetEventsubSubscriptionsParamsType = "channel.prediction.end"
	ChannelPredictionLock                            GetEventsubSubscriptionsParamsType = "channel.prediction.lock"
	ChannelPredictionProgress                        GetEventsubSubscriptionsParamsType = "channel.prediction.progress"
	ChannelRaid                                      GetEventsubSubscriptionsParamsType = "channel.raid"
	ChannelSharedChatBegin                           GetEventsubSubscriptionsParamsType = "channel.shared_chat.begin"
	ChannelSharedChatEnd                             GetEventsubSubscriptionsParamsType = "channel.shared_chat.end"
	ChannelSharedChatUpdate                          GetEventsubSubscriptionsParamsType = "channel.shared_chat.update"
	ChannelShieldModeBegin                           GetEventsubSubscriptionsParamsType = "channel.shield_mode.begin"
	ChannelShieldModeEnd                             GetEventsubSubscriptionsParamsType = "channel.shield_mode.end"
	ChannelShoutoutCreate                            GetEventsubSubscriptionsParamsType = "channel.shoutout.create"
	ChannelShoutoutReceive                           GetEventsubSubscriptionsParamsType = "channel.shoutout.receive"
	ChannelSubscribe                                 GetEventsubSubscriptionsParamsType = "channel.subscribe"
	ChannelSubscriptionEnd                           GetEventsubSubscriptionsParamsType = "channel.subscription.end"
	ChannelSubscriptionGift                          GetEventsubSubscriptionsParamsType = "channel.subscription.gift"
	ChannelSubscriptionMessage                       GetEventsubSubscriptionsParamsType = "channel.subscription.message"
	ChannelSuspiciousUserMessage                     GetEventsubSubscriptionsParamsType = "channel.suspicious_user.message"
	ChannelSuspiciousUserUpdate                      GetEventsubSubscriptionsParamsType = "channel.suspicious_user.update"
	ChannelUnban                                     GetEventsubSubscriptionsParamsType = "channel.unban"
	ChannelUnbanRequestCreate                        GetEventsubSubscriptionsParamsType = "channel.unban_request.create"
	ChannelUnbanRequestResolve                       GetEventsubSubscriptionsParamsType = "channel.unban_request.resolve"
	ChannelUpdate                                    GetEventsubSubscriptionsParamsType = "channel.update"
	ChannelVipAdd                                    GetEventsubSubscriptionsParamsType = "channel.vip.add"
	ChannelVipRemove                                 GetEventsubSubscriptionsParamsType = "channel.vip.remove"
	ChannelWarningAcknowledge                        GetEventsubSubscriptionsParamsType = "channel.warning.acknowledge"
	ChannelWarningSend                               GetEventsubSubscriptionsParamsType = "channel.warning.send"
	ConduitShardDisabled                             GetEventsubSubscriptionsParamsType = "conduit.shard.disabled"
	DropEntitlementGrant                             GetEventsubSubscriptionsParamsType = "drop.entitlement.grant"
	ExtensionBitsTransactionCreate                   GetEventsubSubscriptionsParamsType = "extension.bits_transaction.create"
	StreamOffline                                    GetEventsubSubscriptionsParamsType = "stream.offline"
	StreamOnline                                     GetEventsubSubscriptionsParamsType = "stream.online"
	UserAuthorizationGrant                           GetEventsubSubscriptionsParamsType = "user.authorization.grant"
	UserAuthorizationRevoke                          GetEventsubSubscriptionsParamsType = "user.authorization.revoke"
	UserUpdate                                       GetEventsubSubscriptionsParamsType = "user.update"
	UserWhisperMessage                               GetEventsubSubscriptionsParamsType = "user.whisper.message"
)

// Defines values for GetExtensionConfigurationSegmentParamsSegment.
const (
	GetExtensionConfigurationSegmentParamsSegmentBroadcaster GetExtensionConfigurationSegmentParamsSegment = "broadcaster"
	GetExtensionConfigurationSegmentParamsSegmentDeveloper   GetExtensionConfigurationSegmentParamsSegment = "developer"
	GetExtensionConfigurationSegmentParamsSegmentGlobal      GetExtensionConfigurationSegmentParamsSegment = "global"
)

// Defines values for GetStreamsParamsType.
const (
	GetStreamsParamsTypeAll  GetStreamsParamsType = "all"
	GetStreamsParamsTypeLive GetStreamsParamsType = "live"
)

// Defines values for BlockUserParamsSourceContext.
const (
	Chat    BlockUserParamsSourceContext = "chat"
	Whisper BlockUserParamsSourceContext = "whisper"
)

// Defines values for BlockUserParamsReason.
const (
	Harassment BlockUserParamsReason = "harassment"
	Other      BlockUserParamsReason = "other"
	Spam       BlockUserParamsReason = "spam"
)

// Defines values for GetVideosParamsPeriod.
const (
	GetVideosParamsPeriodAll   GetVideosParamsPeriod = "all"
	GetVideosParamsPeriodDay   GetVideosParamsPeriod = "day"
	GetVideosParamsPeriodMonth GetVideosParamsPeriod = "month"
	GetVideosParamsPeriodWeek  GetVideosParamsPeriod = "week"
)

// Defines values for GetVideosParamsSort.
const (
	Time     GetVideosParamsSort = "time"
	Trending GetVideosParamsSort = "trending"
	Views    GetVideosParamsSort = "views"
)

// Defines values for GetVideosParamsType.
const (
	GetVideosParamsTypeAll       GetVideosParamsType = "all"
	GetVideosParamsTypeArchive   GetVideosParamsType = "archive"
	GetVideosParamsTypeHighlight GetVideosParamsType = "highlight"
	GetVideosParamsTypeUpload    GetVideosParamsType = "upload"
)

//Generated with typedef.tmpl

// AddBlockedTermBody defines model for AddBlockedTermBody.
type AddBlockedTermBody struct {
	// Text The word or phrase to block from being used in the broadcasters chat room. The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters.
	//
	// Terms may include a wildcard character (\*). The wildcard character must appear at the beginning or end of a word or set of characters. For example, \*foo or foo\*.
	//
	// If the blocked term already exists, the response contains the existing blocked term.
	Text string `json:"text"`
}

func (datatype AddBlockedTermBody) GetText() string {
	return datatype.Text
}

// AddBlockedTermResponse defines model for AddBlockedTermResponse.
type AddBlockedTermResponse struct {
	// Data A list that contains the single blocked term that the broadcaster added.
	Data []BlockedTerm `json:"data"`
}

func (datatype AddBlockedTermResponse) GetData() []BlockedTerm {
	return datatype.Data
}

// AutoModSettings defines model for AutoModSettings.
type AutoModSettings struct {
	// Aggression The Automod level for hostility involving aggression.
	Aggression int32 `json:"aggression"`

	// BroadcasterId The broadcasters ID.
	BroadcasterId string `json:"broadcaster_id"`

	// Bullying The Automod level for hostility involving name calling or insults.
	Bullying int32 `json:"bullying"`

	// Disability The Automod level for discrimination against disability.
	Disability int32 `json:"disability"`

	// Misogyny The Automod level for discrimination against women.
	Misogyny int32 `json:"misogyny"`

	// ModeratorId The moderators ID.
	ModeratorId string `json:"moderator_id"`

	// OverallLevel The default AutoMod level for the broadcaster. This field is **null** if the broadcaster has set one or more of the individual settings.
	OverallLevel *int32 `json:"overall_level"`

	// RaceEthnicityOrReligion The Automod level for racial discrimination.
	RaceEthnicityOrReligion int32 `json:"race_ethnicity_or_religion"`

	// SexBasedTerms The Automod level for sexual content.
	SexBasedTerms int32 `json:"sex_based_terms"`

	// SexualitySexOrGender The AutoMod level for discrimination based on sexuality, sex, or gender.
	SexualitySexOrGender int32 `json:"sexuality_sex_or_gender"`

	// Swearing The Automod level for profanity.
	Swearing int32 `json:"swearing"`
}

func (datatype AutoModSettings) GetAggression() int32 {
	return datatype.Aggression
}
func (datatype AutoModSettings) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype AutoModSettings) GetBullying() int32 {
	return datatype.Bullying
}
func (datatype AutoModSettings) GetDisability() int32 {
	return datatype.Disability
}
func (datatype AutoModSettings) GetMisogyny() int32 {
	return datatype.Misogyny
}
func (datatype AutoModSettings) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype AutoModSettings) GetOverallLevel() int32 {
	if datatype.OverallLevel == nil {
		var empty int32
		return empty
	}
	return *datatype.OverallLevel
}
func (datatype AutoModSettings) GetRaceEthnicityOrReligion() int32 {
	return datatype.RaceEthnicityOrReligion
}
func (datatype AutoModSettings) GetSexBasedTerms() int32 {
	return datatype.SexBasedTerms
}
func (datatype AutoModSettings) GetSexualitySexOrGender() int32 {
	return datatype.SexualitySexOrGender
}
func (datatype AutoModSettings) GetSwearing() int32 {
	return datatype.Swearing
}

// AutoModStatus defines model for AutoModStatus.
type AutoModStatus struct {
	// IsPermitted A Boolean value that indicates whether Twitch would approve the message for chat or hold it for moderator review or block it from chat. Is **true** if Twitch would approve the message; otherwise, **false** if Twitch would hold the message for moderator review or block it from chat.
	IsPermitted bool `json:"is_permitted"`

	// MsgId The caller-defined ID passed in the request.
	MsgId string `json:"msg_id"`
}

func (datatype AutoModStatus) GetIsPermitted() bool {
	return datatype.IsPermitted
}
func (datatype AutoModStatus) GetMsgId() string {
	return datatype.MsgId
}

// BanUserBody defines model for BanUserBody.
type BanUserBody struct {
	// Data Identifies the user and type of ban.
	Data struct {
		// Duration To ban a user indefinitely, dont include this field.
		//
		// To put a user in a timeout, include this field and specify the timeout period, in seconds. The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks).
		//
		// To end a users timeout early, set this field to 1, or use the [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user) endpoint.
		Duration *int32 `json:"duration,omitempty"`

		// Reason The reason the youre banning the user or putting them in a timeout. The text is user defined and is limited to a maximum of 500 characters.
		Reason *string `json:"reason,omitempty"`

		// UserId The ID of the user to ban or put in a timeout.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype BanUserBody) GetData() struct {
	// Duration To ban a user indefinitely, dont include this field.
	//
	// To put a user in a timeout, include this field and specify the timeout period, in seconds. The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks).
	//
	// To end a users timeout early, set this field to 1, or use the [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user) endpoint.
	Duration *int32 `json:"duration,omitempty"`

	// Reason The reason the youre banning the user or putting them in a timeout. The text is user defined and is limited to a maximum of 500 characters.
	Reason *string `json:"reason,omitempty"`

	// UserId The ID of the user to ban or put in a timeout.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// BanUserResponse defines model for BanUserResponse.
type BanUserResponse struct {
	// Data A list that contains the user you successfully banned or put in a timeout.
	Data []struct {
		// BroadcasterId The broadcaster whose chat room the user was banned from chatting in.
		BroadcasterId string `json:"broadcaster_id"`

		// CreatedAt The UTC date and time (in RFC3339 format) that the ban or timeout was placed.
		CreatedAt time.Time `json:"created_at"`

		// EndTime The UTC date and time (in RFC3339 format) that the timeout will end. Is **null** if the user was banned instead of being put in a timeout.
		EndTime *time.Time `json:"end_time"`

		// ModeratorId The moderator that banned or put the user in the timeout.
		ModeratorId string `json:"moderator_id"`

		// UserId The user that was banned or put in a timeout.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype BanUserResponse) GetData() []struct {
	// BroadcasterId The broadcaster whose chat room the user was banned from chatting in.
	BroadcasterId string `json:"broadcaster_id"`

	// CreatedAt The UTC date and time (in RFC3339 format) that the ban or timeout was placed.
	CreatedAt time.Time `json:"created_at"`

	// EndTime The UTC date and time (in RFC3339 format) that the timeout will end. Is **null** if the user was banned instead of being put in a timeout.
	EndTime *time.Time `json:"end_time"`

	// ModeratorId The moderator that banned or put the user in the timeout.
	ModeratorId string `json:"moderator_id"`

	// UserId The user that was banned or put in a timeout.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// BannedUser defines model for BannedUser.
type BannedUser struct {
	// CreatedAt The UTC date and time (in RFC3339 format) of when the user was banned.
	CreatedAt time.Time `json:"created_at"`

	// ExpiresAt The UTC date and time (in RFC3339 format) of when the timeout expires, or an empty string if the user is permanently banned.
	ExpiresAt time.Time `json:"expires_at"`

	// ModeratorId The ID of the moderator that banned the user or put them in a timeout.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name.
	ModeratorName string `json:"moderator_name"`

	// Reason The reason the user was banned or put in a timeout if the moderator provided one.
	Reason string `json:"reason"`

	// UserId The ID of the banned user.
	UserId string `json:"user_id"`

	// UserLogin The banned users login name.
	UserLogin string `json:"user_login"`

	// UserName The banned users display name.
	UserName string `json:"user_name"`
}

func (datatype BannedUser) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype BannedUser) GetExpiresAt() time.Time {
	return datatype.ExpiresAt
}
func (datatype BannedUser) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype BannedUser) GetModeratorLogin() string {
	return datatype.ModeratorLogin
}
func (datatype BannedUser) GetModeratorName() string {
	return datatype.ModeratorName
}
func (datatype BannedUser) GetReason() string {
	return datatype.Reason
}
func (datatype BannedUser) GetUserId() string {
	return datatype.UserId
}
func (datatype BannedUser) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype BannedUser) GetUserName() string {
	return datatype.UserName
}

// BitsLeaderboard defines model for BitsLeaderboard.
type BitsLeaderboard struct {
	// Rank The users position on the leaderboard.
	Rank int32 `json:"rank"`

	// Score The number of Bits the user has cheered.
	Score int32 `json:"score"`

	// UserId An ID that identifies a user on the leaderboard.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype BitsLeaderboard) GetRank() int32 {
	return datatype.Rank
}
func (datatype BitsLeaderboard) GetScore() int32 {
	return datatype.Score
}
func (datatype BitsLeaderboard) GetUserId() string {
	return datatype.UserId
}
func (datatype BitsLeaderboard) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype BitsLeaderboard) GetUserName() string {
	return datatype.UserName
}

// BlockedTerm defines model for BlockedTerm.
type BlockedTerm struct {
	// BroadcasterId The broadcaster that owns the list of blocked terms.
	BroadcasterId string `json:"broadcaster_id"`

	// CreatedAt The UTC date and time (in RFC3339 format) that the term was blocked.
	CreatedAt time.Time `json:"created_at"`

	// ExpiresAt The UTC date and time (in RFC3339 format) that the blocked term is set to expire. After the block expires, users may use the term in the broadcasters chat room.
	//
	// This field is **null** if the term was added manually or was permanently blocked by AutoMod.
	ExpiresAt *time.Time `json:"expires_at"`

	// Id An ID that identifies this blocked term.
	Id string `json:"id"`

	// ModeratorId The moderator that blocked the word or phrase from being used in the broadcasters chat room.
	ModeratorId string `json:"moderator_id"`

	// Text The blocked word or phrase.
	Text string `json:"text"`

	// UpdatedAt The UTC date and time (in RFC3339 format) that the term was updated.
	//
	// When the term is added, this timestamp is the same as `created_at`. The timestamp changes as AutoMod continues to deny the term.
	UpdatedAt time.Time `json:"updated_at"`
}

func (datatype BlockedTerm) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype BlockedTerm) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype BlockedTerm) GetExpiresAt() time.Time {
	if datatype.ExpiresAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.ExpiresAt
}
func (datatype BlockedTerm) GetId() string {
	return datatype.Id
}
func (datatype BlockedTerm) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype BlockedTerm) GetText() string {
	return datatype.Text
}
func (datatype BlockedTerm) GetUpdatedAt() time.Time {
	return datatype.UpdatedAt
}

// BroadcasterSubscription defines model for BroadcasterSubscription.
type BroadcasterSubscription struct {
	// BroadcasterId An ID that identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// GifterId The ID of the user that gifted the subscription to the user. Is an empty string if `is_gift` is **false**.
	GifterId string `json:"gifter_id"`

	// GifterLogin The gifters login name. Is an empty string if `is_gift` is **false**.
	GifterLogin string `json:"gifter_login"`

	// GifterName The gifters display name. Is an empty string if `is_gift` is **false**.
	GifterName string `json:"gifter_name"`

	// IsGift A Boolean value that determines whether the subscription is a gift subscription. Is **true** if the subscription was gifted.
	IsGift bool `json:"is_gift"`

	// PlanName The name of the subscription.
	PlanName string `json:"plan_name"`

	// Tier The type of subscription. Possible values are:
	//
	// * 1000  Tier 1
	// * 2000  Tier 2
	// * 3000  Tier 3
	Tier BroadcasterSubscriptionTier `json:"tier"`

	// UserId An ID that identifies the subscribing user.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype BroadcasterSubscription) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype BroadcasterSubscription) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype BroadcasterSubscription) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype BroadcasterSubscription) GetGifterId() string {
	return datatype.GifterId
}
func (datatype BroadcasterSubscription) GetGifterLogin() string {
	return datatype.GifterLogin
}
func (datatype BroadcasterSubscription) GetGifterName() string {
	return datatype.GifterName
}
func (datatype BroadcasterSubscription) GetIsGift() bool {
	return datatype.IsGift
}
func (datatype BroadcasterSubscription) GetPlanName() string {
	return datatype.PlanName
}
func (datatype BroadcasterSubscription) GetTier() BroadcasterSubscriptionTier {
	return datatype.Tier
}
func (datatype BroadcasterSubscription) GetUserId() string {
	return datatype.UserId
}
func (datatype BroadcasterSubscription) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype BroadcasterSubscription) GetUserName() string {
	return datatype.UserName
}

// BroadcasterSubscriptionTier The type of subscription. Possible values are:
//
// * 1000  Tier 1
// * 2000  Tier 2
// * 3000  Tier 3
type BroadcasterSubscriptionTier string

// Category defines model for Category.
type Category struct {
	// BoxArtUrl A URL to an image of the games box art or streaming category.
	BoxArtUrl string `json:"box_art_url"`

	// Id An ID that uniquely identifies the game or category.
	Id string `json:"id"`

	// Name The name of the game or category.
	Name string `json:"name"`
}

func (datatype Category) GetBoxArtUrl() string {
	return datatype.BoxArtUrl
}
func (datatype Category) GetId() string {
	return datatype.Id
}
func (datatype Category) GetName() string {
	return datatype.Name
}

// Channel defines model for Channel.
type Channel struct {
	// BroadcasterLanguage The ISO 639-1 two-letter language code of the language used by the broadcaster. For example, _en_ for English. If the broadcaster uses a language not in the list of [supported stream languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang), the value is _other_.
	BroadcasterLanguage string `json:"broadcaster_language"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// DisplayName The broadcasters display name.
	DisplayName string `json:"display_name"`

	// GameId The ID of the game that the broadcaster is playing or last played.
	GameId string `json:"game_id"`

	// GameName The name of the game that the broadcaster is playing or last played.
	GameName string `json:"game_name"`

	// Id An ID that uniquely identifies the channel (this is the broadcasters ID).
	Id string `json:"id"`

	// IsLive A Boolean value that determines whether the broadcaster is streaming live. Is **true** if the broadcaster is streaming live; otherwise, **false**.
	IsLive bool `json:"is_live"`

	// StartedAt The UTC date and time (in RFC3339 format) of when the broadcaster started streaming. The string is empty if the broadcaster is not streaming live.
	StartedAt time.Time `json:"started_at"`

	// TagIds **IMPORTANT** As of February 28, 2023, this field is deprecated and returns only an empty array. If you use this field, please update your code to use the `tags` field.
	//
	// The list of tags that apply to the stream. The list contains IDs only when the channel is steaming live. For a list of possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags). The list doesnt include Category Tags.
	// Deprecated:
	TagIds []string `json:"tag_ids"`

	// Tags The tags applied to the channel.
	Tags []string `json:"tags"`

	// ThumbnailUrl A URL to a thumbnail of the broadcasters profile image.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The streams title. Is an empty string if the broadcaster didnt set it.
	Title string `json:"title"`
}

func (datatype Channel) GetBroadcasterLanguage() string {
	return datatype.BroadcasterLanguage
}
func (datatype Channel) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype Channel) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype Channel) GetGameId() string {
	return datatype.GameId
}
func (datatype Channel) GetGameName() string {
	return datatype.GameName
}
func (datatype Channel) GetId() string {
	return datatype.Id
}
func (datatype Channel) GetIsLive() bool {
	return datatype.IsLive
}
func (datatype Channel) GetStartedAt() time.Time {
	return datatype.StartedAt
}
func (datatype Channel) GetTagIds() []string {
	return datatype.TagIds
}
func (datatype Channel) GetTags() []string {
	return datatype.Tags
}
func (datatype Channel) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Channel) GetTitle() string {
	return datatype.Title
}

// ChannelEditor defines model for ChannelEditor.
type ChannelEditor struct {
	// CreatedAt The date and time, in RFC3339 format, when the user became one of the broadcasters editors.
	CreatedAt time.Time `json:"created_at"`

	// UserId An ID that uniquely identifies a user with editor permissions.
	UserId string `json:"user_id"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype ChannelEditor) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype ChannelEditor) GetUserId() string {
	return datatype.UserId
}
func (datatype ChannelEditor) GetUserName() string {
	return datatype.UserName
}

// ChannelEmote defines model for ChannelEmote.
type ChannelEmote struct {
	// EmoteSetId An ID that identifies the emote set that the emote belongs to.
	EmoteSetId string `json:"emote_set_id"`

	// EmoteType The type of emote. The possible values are:
	//
	// * bitstier  A custom Bits tier emote.
	// * follower  A custom follower emote.
	// * subscriptions  A custom subscriber emote.
	EmoteType ChannelEmoteEmoteType `json:"emote_type"`

	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:
	//
	// * animated  An animated GIF is available for this emote.
	// * static  A static PNG file is available for this emote.
	Format []ChannelEmoteFormat `json:"format"`

	// Id An ID that identifies this emote.
	Id string `json:"id"`

	// Images The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.
	//
	// **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
	Images struct {
		// Url1x A URL to the small version (28px x 28px) of the emote.
		Url1x string `json:"url_1x"`

		// Url2x A URL to the medium version (56px x 56px) of the emote.
		Url2x string `json:"url_2x"`

		// Url4x A URL to the large version (112px x 112px) of the emote.
		Url4x string `json:"url_4x"`
	} `json:"images"`

	// Name The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
	Name string `json:"name"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:
	//
	// * 1.0  A small version (28px x 28px) is available.
	// * 2.0  A medium version (56px x 56px) is available.
	// * 3.0  A large version (112px x 112px) is available.
	Scale []ChannelEmoteScale `json:"scale"`

	// ThemeMode The background themes that the emote is available in. Possible themes are:
	//
	// * dark
	// * light
	ThemeMode []ChannelEmoteThemeMode `json:"theme_mode"`

	// Tier The subscriber tier at which the emote is unlocked. This field contains the tier information only if `emote_type` is set to `subscriptions`, otherwise, it's an empty string.
	Tier string `json:"tier"`
}

func (datatype ChannelEmote) GetEmoteSetId() string {
	return datatype.EmoteSetId
}
func (datatype ChannelEmote) GetEmoteType() ChannelEmoteEmoteType {
	return datatype.EmoteType
}
func (datatype ChannelEmote) GetFormat() []ChannelEmoteFormat {
	return datatype.Format
}
func (datatype ChannelEmote) GetId() string {
	return datatype.Id
}
func (datatype ChannelEmote) GetImages() struct {
	// Url1x A URL to the small version (28px x 28px) of the emote.
	Url1x string `json:"url_1x"`

	// Url2x A URL to the medium version (56px x 56px) of the emote.
	Url2x string `json:"url_2x"`

	// Url4x A URL to the large version (112px x 112px) of the emote.
	Url4x string `json:"url_4x"`
} {
	return datatype.Images
}
func (datatype ChannelEmote) GetName() string {
	return datatype.Name
}
func (datatype ChannelEmote) GetScale() []ChannelEmoteScale {
	return datatype.Scale
}
func (datatype ChannelEmote) GetThemeMode() []ChannelEmoteThemeMode {
	return datatype.ThemeMode
}
func (datatype ChannelEmote) GetTier() string {
	return datatype.Tier
}

// ChannelEmoteEmoteType The type of emote. The possible values are:
//
// * bitstier  A custom Bits tier emote.
// * follower  A custom follower emote.
// * subscriptions  A custom subscriber emote.
type ChannelEmoteEmoteType string

// ChannelEmoteFormat defines model for ChannelEmote.Format.
type ChannelEmoteFormat string

// ChannelEmoteScale defines model for ChannelEmote.Scale.
type ChannelEmoteScale string

// ChannelEmoteThemeMode defines model for ChannelEmote.ThemeMode.
type ChannelEmoteThemeMode string

// ChannelInformation defines model for ChannelInformation.
type ChannelInformation struct {
	// BroadcasterId An ID that uniquely identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLanguage The broadcasters preferred language. The value is an ISO 639-1 two-letter language code (for example, _en_ for English). The value is set to other if the language is not a Twitch supported language.
	BroadcasterLanguage string `json:"broadcaster_language"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// ContentClassificationLabels The CCLs applied to the channel.
	ContentClassificationLabels []string `json:"content_classification_labels"`

	// Delay The value of the broadcasters stream delay setting, in seconds. This fields value defaults to zero unless 1) the request specifies a user access token, 2) the ID in the _broadcaster\_id_ query parameter matches the user ID in the access token, and 3) the broadcaster has partner status and they set a non-zero stream delay value.
	Delay int32 `json:"delay"`

	// GameId An ID that uniquely identifies the game that the broadcaster is playing or last played. The value is an empty string if the broadcaster has never played a game.
	GameId string `json:"game_id"`

	// GameName The name of the game that the broadcaster is playing or last played. The value is an empty string if the broadcaster has never played a game.
	GameName string `json:"game_name"`

	// IsBrandedContent Boolean flag indicating if the channel has branded content.
	IsBrandedContent bool `json:"is_branded_content"`

	// Tags The tags applied to the channel.
	Tags []string `json:"tags"`

	// Title The title of the stream that the broadcaster is currently streaming or last streamed. The value is an empty string if the broadcaster has never streamed.
	Title string `json:"title"`
}

func (datatype ChannelInformation) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChannelInformation) GetBroadcasterLanguage() string {
	return datatype.BroadcasterLanguage
}
func (datatype ChannelInformation) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype ChannelInformation) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ChannelInformation) GetContentClassificationLabels() []string {
	return datatype.ContentClassificationLabels
}
func (datatype ChannelInformation) GetDelay() int32 {
	return datatype.Delay
}
func (datatype ChannelInformation) GetGameId() string {
	return datatype.GameId
}
func (datatype ChannelInformation) GetGameName() string {
	return datatype.GameName
}
func (datatype ChannelInformation) GetIsBrandedContent() bool {
	return datatype.IsBrandedContent
}
func (datatype ChannelInformation) GetTags() []string {
	return datatype.Tags
}
func (datatype ChannelInformation) GetTitle() string {
	return datatype.Title
}

// ChannelStreamScheduleSegment defines model for ChannelStreamScheduleSegment.
type ChannelStreamScheduleSegment struct {
	// CanceledUntil Indicates whether the broadcaster canceled this segment of a recurring broadcast. If the broadcaster canceled this segment, this field is set to the same value thats in the `end_time` field; otherwise, its set to **null**.
	CanceledUntil *string `json:"canceled_until"`

	// Category The type of content that the broadcaster plans to stream or **null** if not specified.
	Category struct {
		// Id An ID that identifies the category that best represents the content that the broadcaster plans to stream. For example, the games ID if the broadcaster will play a game or the Just Chatting ID if the broadcaster will host a talk show.
		Id string `json:"id"`

		// Name The name of the category. For example, the games title if the broadcaster will play a game or Just Chatting if the broadcaster will host a talk show.
		Name string `json:"name"`
	} `json:"category"`

	// EndTime The UTC date and time (in RFC3339 format) of when the broadcast ends.
	EndTime time.Time `json:"end_time"`

	// Id An ID that identifies this broadcast segment.
	Id string `json:"id"`

	// IsRecurring A Boolean value that determines whether the broadcast is part of a recurring series that streams at the same time each week or is a one-time broadcast. Is **true** if the broadcast is part of a recurring series.
	IsRecurring bool `json:"is_recurring"`

	// StartTime The UTC date and time (in RFC3339 format) of when the broadcast starts.
	StartTime time.Time `json:"start_time"`

	// Title The broadcast segments title.
	Title string `json:"title"`
}

func (datatype ChannelStreamScheduleSegment) GetCanceledUntil() string {
	if datatype.CanceledUntil == nil {
		var empty string
		return empty
	}
	return *datatype.CanceledUntil
}
func (datatype ChannelStreamScheduleSegment) GetCategory() struct {
	// Id An ID that identifies the category that best represents the content that the broadcaster plans to stream. For example, the games ID if the broadcaster will play a game or the Just Chatting ID if the broadcaster will host a talk show.
	Id string `json:"id"`

	// Name The name of the category. For example, the games title if the broadcaster will play a game or Just Chatting if the broadcaster will host a talk show.
	Name string `json:"name"`
} {
	return datatype.Category
}
func (datatype ChannelStreamScheduleSegment) GetEndTime() time.Time {
	return datatype.EndTime
}
func (datatype ChannelStreamScheduleSegment) GetId() string {
	return datatype.Id
}
func (datatype ChannelStreamScheduleSegment) GetIsRecurring() bool {
	return datatype.IsRecurring
}
func (datatype ChannelStreamScheduleSegment) GetStartTime() time.Time {
	return datatype.StartTime
}
func (datatype ChannelStreamScheduleSegment) GetTitle() string {
	return datatype.Title
}

// ChannelTeam defines model for ChannelTeam.
type ChannelTeam struct {
	// BackgroundImageUrl A URL to the teams background image.
	BackgroundImageUrl string `json:"background_image_url"`

	// Banner A URL to the teams banner.
	Banner string `json:"banner"`

	// BroadcasterId An ID that identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The UTC date and time (in RFC3339 format) of when the team was created.
	CreatedAt time.Time `json:"created_at"`

	// Id An ID that identifies the team.
	Id string `json:"id"`

	// Info The teams description. The description may contain formatting such as Markdown, HTML, newline (\\n) characters, etc.
	Info string `json:"info"`

	// TeamDisplayName The teams display name.
	TeamDisplayName string `json:"team_display_name"`

	// TeamName The teams name.
	TeamName string `json:"team_name"`

	// ThumbnailUrl A URL to a thumbnail image of the teams logo.
	ThumbnailUrl string `json:"thumbnail_url"`

	// UpdatedAt The UTC date and time (in RFC3339 format) of the last time the team was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

func (datatype ChannelTeam) GetBackgroundImageUrl() string {
	return datatype.BackgroundImageUrl
}
func (datatype ChannelTeam) GetBanner() string {
	return datatype.Banner
}
func (datatype ChannelTeam) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChannelTeam) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype ChannelTeam) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ChannelTeam) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype ChannelTeam) GetId() string {
	return datatype.Id
}
func (datatype ChannelTeam) GetInfo() string {
	return datatype.Info
}
func (datatype ChannelTeam) GetTeamDisplayName() string {
	return datatype.TeamDisplayName
}
func (datatype ChannelTeam) GetTeamName() string {
	return datatype.TeamName
}
func (datatype ChannelTeam) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype ChannelTeam) GetUpdatedAt() time.Time {
	return datatype.UpdatedAt
}

// CharityCampaign defines model for CharityCampaign.
type CharityCampaign struct {
	// BroadcasterId An ID that identifies the broadcaster thats running the campaign.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CharityDescription A description of the charity.
	CharityDescription string `json:"charity_description"`

	// CharityLogo A URL to an image of the charitys logo. The images type is PNG and its size is 100px X 100px.
	CharityLogo string `json:"charity_logo"`

	// CharityName The charitys name.
	CharityName string `json:"charity_name"`

	// CharityWebsite A URL to the charitys website.
	CharityWebsite string `json:"charity_website"`

	// CurrentAmount The current amount of donations that the campaign has received.
	CurrentAmount struct {
		// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
		Currency string `json:"currency"`

		// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
		//
		// `value / 10^decimal_places`
		DecimalPlaces int32 `json:"decimal_places"`

		// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
		Value int32 `json:"value"`
	} `json:"current_amount"`

	// Id An ID that identifies the charity campaign.
	Id string `json:"id"`

	// TargetAmount The campaigns fundraising goal. This field is **null** if the broadcaster has not defined a fundraising goal.
	TargetAmount struct {
		// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
		Currency string `json:"currency"`

		// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
		//
		// `value / 10^decimal_places`
		DecimalPlaces int32 `json:"decimal_places"`

		// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
		Value int32 `json:"value"`
	} `json:"target_amount"`
}

func (datatype CharityCampaign) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CharityCampaign) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CharityCampaign) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CharityCampaign) GetCharityDescription() string {
	return datatype.CharityDescription
}
func (datatype CharityCampaign) GetCharityLogo() string {
	return datatype.CharityLogo
}
func (datatype CharityCampaign) GetCharityName() string {
	return datatype.CharityName
}
func (datatype CharityCampaign) GetCharityWebsite() string {
	return datatype.CharityWebsite
}
func (datatype CharityCampaign) GetCurrentAmount() struct {
	// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
	Currency string `json:"currency"`

	// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
	//
	// `value / 10^decimal_places`
	DecimalPlaces int32 `json:"decimal_places"`

	// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
	Value int32 `json:"value"`
} {
	return datatype.CurrentAmount
}
func (datatype CharityCampaign) GetId() string {
	return datatype.Id
}
func (datatype CharityCampaign) GetTargetAmount() struct {
	// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
	Currency string `json:"currency"`

	// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
	//
	// `value / 10^decimal_places`
	DecimalPlaces int32 `json:"decimal_places"`

	// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
	Value int32 `json:"value"`
} {
	return datatype.TargetAmount
}

// CharityCampaignDonation defines model for CharityCampaignDonation.
type CharityCampaignDonation struct {
	// Amount An object that contains the amount of money that the user donated.
	Amount struct {
		// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
		Currency string `json:"currency"`

		// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
		//
		// `value / 10^decimal_places`
		DecimalPlaces int32 `json:"decimal_places"`

		// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
		Value int32 `json:"value"`
	} `json:"amount"`

	// CampaignId An ID that identifies the charity campaign that the donation applies to.
	CampaignId string `json:"campaign_id"`

	// Id An ID that identifies the donation. The ID is unique across campaigns.
	Id string `json:"id"`

	// UserId An ID that identifies a user that donated money to the campaign.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype CharityCampaignDonation) GetAmount() struct {
	// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
	Currency string `json:"currency"`

	// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
	//
	// `value / 10^decimal_places`
	DecimalPlaces int32 `json:"decimal_places"`

	// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
	Value int32 `json:"value"`
} {
	return datatype.Amount
}
func (datatype CharityCampaignDonation) GetCampaignId() string {
	return datatype.CampaignId
}
func (datatype CharityCampaignDonation) GetId() string {
	return datatype.Id
}
func (datatype CharityCampaignDonation) GetUserId() string {
	return datatype.UserId
}
func (datatype CharityCampaignDonation) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype CharityCampaignDonation) GetUserName() string {
	return datatype.UserName
}

// ChatBadge defines model for ChatBadge.
type ChatBadge struct {
	// SetId An ID that identifies this set of chat badges. For example, Bits or Subscriber.
	SetId string `json:"set_id"`

	// Versions The list of chat badges in this set.
	Versions []struct {
		// ClickAction The action to take when clicking on the badge. Set to `null` if no action is specified.
		ClickAction string `json:"click_action"`

		// ClickUrl The URL to navigate to when clicking on the badge. Set to `null` if no URL is specified.
		ClickUrl string `json:"click_url"`

		// Description The description of the badge.
		Description string `json:"description"`

		// Id An ID that identifies this version of the badge. The ID can be any value. For example, for Bits, the ID is the Bits tier level, but for World of Warcraft, it could be Alliance or Horde.
		Id string `json:"id"`

		// ImageUrl1x A URL to the small version (18px x 18px) of the badge.
		ImageUrl1x string `json:"image_url_1x"`

		// ImageUrl2x A URL to the medium version (36px x 36px) of the badge.
		ImageUrl2x string `json:"image_url_2x"`

		// ImageUrl4x A URL to the large version (72px x 72px) of the badge.
		ImageUrl4x string `json:"image_url_4x"`

		// Title The title of the badge.
		Title string `json:"title"`
	} `json:"versions"`
}

func (datatype ChatBadge) GetSetId() string {
	return datatype.SetId
}
func (datatype ChatBadge) GetVersions() []struct {
	// ClickAction The action to take when clicking on the badge. Set to `null` if no action is specified.
	ClickAction string `json:"click_action"`

	// ClickUrl The URL to navigate to when clicking on the badge. Set to `null` if no URL is specified.
	ClickUrl string `json:"click_url"`

	// Description The description of the badge.
	Description string `json:"description"`

	// Id An ID that identifies this version of the badge. The ID can be any value. For example, for Bits, the ID is the Bits tier level, but for World of Warcraft, it could be Alliance or Horde.
	Id string `json:"id"`

	// ImageUrl1x A URL to the small version (18px x 18px) of the badge.
	ImageUrl1x string `json:"image_url_1x"`

	// ImageUrl2x A URL to the medium version (36px x 36px) of the badge.
	ImageUrl2x string `json:"image_url_2x"`

	// ImageUrl4x A URL to the large version (72px x 72px) of the badge.
	ImageUrl4x string `json:"image_url_4x"`

	// Title The title of the badge.
	Title string `json:"title"`
} {
	return datatype.Versions
}

// ChatSettings defines model for ChatSettings.
type ChatSettings struct {
	// BroadcasterId The ID of the broadcaster specified in the request.
	BroadcasterId string `json:"broadcaster_id"`

	// EmoteMode A Boolean value that determines whether chat messages must contain only emotes. Is **true** if chat messages may contain only emotes; otherwise, **false**.
	EmoteMode bool `json:"emote_mode"`

	// FollowerMode A Boolean value that determines whether the broadcaster restricts the chat room to followers only.
	//
	// Is **true** if the broadcaster restricts the chat room to followers only; otherwise, **false**.
	//
	// See the `follower_mode_duration` field for how long users must follow the broadcaster before being able to participate in the chat room.
	FollowerMode bool `json:"follower_mode"`

	// FollowerModeDuration The length of time, in minutes, that users must follow the broadcaster before being able to participate in the chat room. Is **null** if `follower_mode` is **false**.
	FollowerModeDuration *int32 `json:"follower_mode_duration"`

	// ModeratorId The moderators ID. The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope.
	ModeratorId *string `json:"moderator_id,omitempty"`

	// NonModeratorChatDelay A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room. This gives chat moderators and bots a chance to remove them before viewers can see the message. See the `non_moderator_chat_delay_duration` field for the length of the delay. Is **true** if the broadcaster applies a delay; otherwise, **false**.
	//
	// The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope and the user in the _moderator\_id_ query parameter is one of the broadcasters moderators.
	NonModeratorChatDelay *bool `json:"non_moderator_chat_delay,omitempty"`

	// NonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Is **null** if `non_moderator_chat_delay` is **false**.
	//
	// The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope and the user in the _moderator\_id_ query parameter is one of the broadcasters moderators.
	NonModeratorChatDelayDuration *int32 `json:"non_moderator_chat_delay_duration"`

	// SlowMode A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages.
	//
	// Is **true** if the broadcaster applies a delay; otherwise, **false**.
	//
	// See the `slow_mode_wait_time` field for the delay.
	SlowMode bool `json:"slow_mode"`

	// SlowModeWaitTime The amount of time, in seconds, that users must wait between sending messages.
	//
	// Is **null** if slow\_mode is **false**.
	SlowModeWaitTime *int32 `json:"slow_mode_wait_time"`

	// SubscriberMode A Boolean value that determines whether only users that subscribe to the broadcasters channel may talk in the chat room.
	//
	// Is **true** if the broadcaster restricts the chat room to subscribers only; otherwise, **false**.
	SubscriberMode bool `json:"subscriber_mode"`

	// UniqueChatMode A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room.
	//
	// Is **true** if the broadcaster requires unique messages only; otherwise, **false**.
	UniqueChatMode bool `json:"unique_chat_mode"`
}

func (datatype ChatSettings) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChatSettings) GetEmoteMode() bool {
	return datatype.EmoteMode
}
func (datatype ChatSettings) GetFollowerMode() bool {
	return datatype.FollowerMode
}
func (datatype ChatSettings) GetFollowerModeDuration() int32 {
	if datatype.FollowerModeDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.FollowerModeDuration
}
func (datatype ChatSettings) GetModeratorId() string {
	if datatype.ModeratorId == nil {
		var empty string
		return empty
	}
	return *datatype.ModeratorId
}
func (datatype ChatSettings) GetNonModeratorChatDelay() bool {
	if datatype.NonModeratorChatDelay == nil {
		var empty bool
		return empty
	}
	return *datatype.NonModeratorChatDelay
}
func (datatype ChatSettings) GetNonModeratorChatDelayDuration() int32 {
	if datatype.NonModeratorChatDelayDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.NonModeratorChatDelayDuration
}
func (datatype ChatSettings) GetSlowMode() bool {
	return datatype.SlowMode
}
func (datatype ChatSettings) GetSlowModeWaitTime() int32 {
	if datatype.SlowModeWaitTime == nil {
		var empty int32
		return empty
	}
	return *datatype.SlowModeWaitTime
}
func (datatype ChatSettings) GetSubscriberMode() bool {
	return datatype.SubscriberMode
}
func (datatype ChatSettings) GetUniqueChatMode() bool {
	return datatype.UniqueChatMode
}

// ChatSettingsUpdated defines model for ChatSettingsUpdated.
type ChatSettingsUpdated struct {
	// BroadcasterId The ID of the broadcaster specified in the request.
	BroadcasterId string `json:"broadcaster_id"`

	// EmoteMode A Boolean value that determines whether chat messages must contain only emotes. Is **true** if chat messages may contain only emotes; otherwise, **false**.
	EmoteMode bool `json:"emote_mode"`

	// FollowerMode A Boolean value that determines whether the broadcaster restricts the chat room to followers only.
	//
	// Is **true** if the broadcaster restricts the chat room to followers only; otherwise, **false**.
	//
	// See the `follower_mode_duration` field for how long users must follow the broadcaster before being able to participate in the chat room.
	FollowerMode bool `json:"follower_mode"`

	// FollowerModeDuration The length of time, in minutes, that users must follow the broadcaster before being able to participate in the chat room. Is **null** if `follower_mode` is **false**.
	FollowerModeDuration *int32 `json:"follower_mode_duration"`

	// ModeratorId The moderators ID. The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope.
	ModeratorId *string `json:"moderator_id,omitempty"`

	// NonModeratorChatDelay A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room. This gives chat moderators and bots a chance to remove them before viewers can see the message. See the `non_moderator_chat_delay_duration` field for the length of the delay. Is **true** if the broadcaster applies a delay; otherwise, **false**.
	NonModeratorChatDelay bool `json:"non_moderator_chat_delay"`

	// NonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Is **null** if `non_moderator_chat_delay` is **false**.
	NonModeratorChatDelayDuration *int32 `json:"non_moderator_chat_delay_duration"`

	// SlowMode A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages.
	//
	// Is **true** if the broadcaster applies a delay; otherwise, **false**.
	//
	// See the `slow_mode_wait_time` field for the delay.
	SlowMode bool `json:"slow_mode"`

	// SlowModeWaitTime The amount of time, in seconds, that users must wait between sending messages.
	//
	// Is **null** if slow\_mode is **false**.
	SlowModeWaitTime *int32 `json:"slow_mode_wait_time"`

	// SubscriberMode A Boolean value that determines whether only users that subscribe to the broadcasters channel may talk in the chat room.
	//
	// Is **true** if the broadcaster restricts the chat room to subscribers only; otherwise, **false**.
	SubscriberMode bool `json:"subscriber_mode"`

	// UniqueChatMode A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room.
	//
	// Is **true** if the broadcaster requires unique messages only; otherwise, **false**.
	UniqueChatMode bool `json:"unique_chat_mode"`
}

func (datatype ChatSettingsUpdated) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChatSettingsUpdated) GetEmoteMode() bool {
	return datatype.EmoteMode
}
func (datatype ChatSettingsUpdated) GetFollowerMode() bool {
	return datatype.FollowerMode
}
func (datatype ChatSettingsUpdated) GetFollowerModeDuration() int32 {
	if datatype.FollowerModeDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.FollowerModeDuration
}
func (datatype ChatSettingsUpdated) GetModeratorId() string {
	if datatype.ModeratorId == nil {
		var empty string
		return empty
	}
	return *datatype.ModeratorId
}
func (datatype ChatSettingsUpdated) GetNonModeratorChatDelay() bool {
	return datatype.NonModeratorChatDelay
}
func (datatype ChatSettingsUpdated) GetNonModeratorChatDelayDuration() int32 {
	if datatype.NonModeratorChatDelayDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.NonModeratorChatDelayDuration
}
func (datatype ChatSettingsUpdated) GetSlowMode() bool {
	return datatype.SlowMode
}
func (datatype ChatSettingsUpdated) GetSlowModeWaitTime() int32 {
	if datatype.SlowModeWaitTime == nil {
		var empty int32
		return empty
	}
	return *datatype.SlowModeWaitTime
}
func (datatype ChatSettingsUpdated) GetSubscriberMode() bool {
	return datatype.SubscriberMode
}
func (datatype ChatSettingsUpdated) GetUniqueChatMode() bool {
	return datatype.UniqueChatMode
}

// Chatter defines model for Chatter.
type Chatter struct {
	// UserId The ID of a user thats connected to the broadcasters chat room.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype Chatter) GetUserId() string {
	return datatype.UserId
}
func (datatype Chatter) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Chatter) GetUserName() string {
	return datatype.UserName
}

// CheckAutoModStatusBody defines model for CheckAutoModStatusBody.
type CheckAutoModStatusBody struct {
	// Data The list of messages to check. The list must contain at least one message and may contain up to a maximum of 100 messages.
	Data []struct {
		// MsgId A caller-defined ID used to correlate this message with the same message in the response.
		MsgId string `json:"msg_id"`

		// MsgText The message to check.
		MsgText string `json:"msg_text"`
	} `json:"data"`
}

func (datatype CheckAutoModStatusBody) GetData() []struct {
	// MsgId A caller-defined ID used to correlate this message with the same message in the response.
	MsgId string `json:"msg_id"`

	// MsgText The message to check.
	MsgText string `json:"msg_text"`
} {
	return datatype.Data
}

// CheckAutoModStatusResponse defines model for CheckAutoModStatusResponse.
type CheckAutoModStatusResponse struct {
	// Data The list of messages and whether Twitch would approve them for chat.
	Data []AutoModStatus `json:"data"`
}

func (datatype CheckAutoModStatusResponse) GetData() []AutoModStatus {
	return datatype.Data
}

// CheckUserSubscriptionResponse defines model for CheckUserSubscriptionResponse.
type CheckUserSubscriptionResponse struct {
	// Data A list that contains a single object with information about the users subscription.
	Data []UserSubscription `json:"data"`
}

func (datatype CheckUserSubscriptionResponse) GetData() []UserSubscription {
	return datatype.Data
}

// Cheermote defines model for Cheermote.
type Cheermote struct {
	// IsCharitable A Boolean value that indicates whether this Cheermote provides a charitable contribution match during charity campaigns.
	IsCharitable bool `json:"is_charitable"`

	// LastUpdated The date and time, in RFC3339 format, when this Cheermote was last updated.
	LastUpdated time.Time `json:"last_updated"`

	// Order The order that the Cheermotes are shown in the Bits card. The numbers may not be consecutive. For example, the numbers may jump from 1 to 7 to 13\. The order numbers are unique within a Cheermote type (for example, global\_first\_party) but may not be unique amongst all Cheermotes in the response.
	Order int32 `json:"order"`

	// Prefix The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is Cheer and you want to cheer 100 Bits, the full Cheermote string is Cheer100\. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	Prefix string `json:"prefix"`

	// Tiers A list of tier levels that the Cheermote supports. Each tier identifies the range of Bits that you can cheer at that tier level and an image that graphically identifies the tier level.
	Tiers []struct {
		// CanCheer A Boolean value that determines whether users can cheer at this tier level.
		CanCheer bool `json:"can_cheer"`

		// Color The hex code of the color associated with this tier level (for example, #979797).
		Color string `json:"color"`

		// Id The tier level. Possible tiers are:
		//
		// * 1
		// * 100
		// * 500
		// * 1000
		// * 5000
		// * 10000
		// * 100000
		Id     CheermoteTiersId `json:"id"`
		Images CheermoteImages  `json:"images"`

		// MinBits The minimum number of Bits that you must cheer at this tier level. The maximum number of Bits that you can cheer at this level is determined by the required minimum Bits of the next tier level minus 1\. For example, if `min_bits` is 1 and `min_bits` for the next tier is 100, the Bits range for this tier level is 1 through 99\. The minimum Bits value of the last tier is the maximum number of Bits you can cheer using this Cheermote. For example, 10000.
		MinBits int32 `json:"min_bits"`

		// ShowInBitsCard A Boolean value that determines whether this tier level is shown in the Bits card. Is **true** if this tier level is shown in the Bits card.
		ShowInBitsCard bool `json:"show_in_bits_card"`
	} `json:"tiers"`

	// Type The type of Cheermote. Possible values are:
	//
	// * global\_first\_party  A Twitch-defined Cheermote that is shown in the Bits card.
	// * global\_third\_party  A Twitch-defined Cheermote that is not shown in the Bits card.
	// * channel\_custom  A broadcaster-defined Cheermote.
	// * display\_only  Do not use; for internal use only.
	// * sponsored  A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor's 10 Bits contribution.
	Type CheermoteType `json:"type"`
}

func (datatype Cheermote) GetIsCharitable() bool {
	return datatype.IsCharitable
}
func (datatype Cheermote) GetLastUpdated() time.Time {
	return datatype.LastUpdated
}
func (datatype Cheermote) GetOrder() int32 {
	return datatype.Order
}
func (datatype Cheermote) GetPrefix() string {
	return datatype.Prefix
}
func (datatype Cheermote) GetTiers() []struct {
	// CanCheer A Boolean value that determines whether users can cheer at this tier level.
	CanCheer bool `json:"can_cheer"`

	// Color The hex code of the color associated with this tier level (for example, #979797).
	Color string `json:"color"`

	// Id The tier level. Possible tiers are:
	//
	// * 1
	// * 100
	// * 500
	// * 1000
	// * 5000
	// * 10000
	// * 100000
	Id     CheermoteTiersId `json:"id"`
	Images CheermoteImages  `json:"images"`

	// MinBits The minimum number of Bits that you must cheer at this tier level. The maximum number of Bits that you can cheer at this level is determined by the required minimum Bits of the next tier level minus 1\. For example, if `min_bits` is 1 and `min_bits` for the next tier is 100, the Bits range for this tier level is 1 through 99\. The minimum Bits value of the last tier is the maximum number of Bits you can cheer using this Cheermote. For example, 10000.
	MinBits int32 `json:"min_bits"`

	// ShowInBitsCard A Boolean value that determines whether this tier level is shown in the Bits card. Is **true** if this tier level is shown in the Bits card.
	ShowInBitsCard bool `json:"show_in_bits_card"`
} {
	return datatype.Tiers
}
func (datatype Cheermote) GetType() CheermoteType {
	return datatype.Type
}

// CheermoteTiersId The tier level. Possible tiers are:
//
// * 1
// * 100
// * 500
// * 1000
// * 5000
// * 10000
// * 100000
type CheermoteTiersId string

// CheermoteType The type of Cheermote. Possible values are:
//
// * global\_first\_party  A Twitch-defined Cheermote that is shown in the Bits card.
// * global\_third\_party  A Twitch-defined Cheermote that is not shown in the Bits card.
// * channel\_custom  A broadcaster-defined Cheermote.
// * display\_only  Do not use; for internal use only.
// * sponsored  A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor's 10 Bits contribution.
type CheermoteType string

// CheermoteImageFormat defines model for CheermoteImageFormat.
type CheermoteImageFormat struct {
	N1  *string `json:"1,omitempty"`
	N15 *string `json:"1.5,omitempty"`
	N2  *string `json:"2,omitempty"`
	N3  *string `json:"3,omitempty"`
	N4  *string `json:"4,omitempty"`
}

func (datatype CheermoteImageFormat) GetN1() string {
	if datatype.N1 == nil {
		var empty string
		return empty
	}
	return *datatype.N1
}
func (datatype CheermoteImageFormat) GetN15() string {
	if datatype.N15 == nil {
		var empty string
		return empty
	}
	return *datatype.N15
}
func (datatype CheermoteImageFormat) GetN2() string {
	if datatype.N2 == nil {
		var empty string
		return empty
	}
	return *datatype.N2
}
func (datatype CheermoteImageFormat) GetN3() string {
	if datatype.N3 == nil {
		var empty string
		return empty
	}
	return *datatype.N3
}
func (datatype CheermoteImageFormat) GetN4() string {
	if datatype.N4 == nil {
		var empty string
		return empty
	}
	return *datatype.N4
}

// CheermoteImageTheme defines model for CheermoteImageTheme.
type CheermoteImageTheme struct {
	Animated *CheermoteImageFormat `json:"animated,omitempty"`
	Static   *CheermoteImageFormat `json:"static,omitempty"`
}

func (datatype CheermoteImageTheme) GetAnimated() CheermoteImageFormat {
	if datatype.Animated == nil {
		var empty CheermoteImageFormat
		return empty
	}
	return *datatype.Animated
}
func (datatype CheermoteImageTheme) GetStatic() CheermoteImageFormat {
	if datatype.Static == nil {
		var empty CheermoteImageFormat
		return empty
	}
	return *datatype.Static
}

// CheermoteImages defines model for CheermoteImages.
type CheermoteImages struct {
	Dark  *CheermoteImageTheme `json:"dark,omitempty"`
	Light *CheermoteImageTheme `json:"light,omitempty"`
}

func (datatype CheermoteImages) GetDark() CheermoteImageTheme {
	if datatype.Dark == nil {
		var empty CheermoteImageTheme
		return empty
	}
	return *datatype.Dark
}
func (datatype CheermoteImages) GetLight() CheermoteImageTheme {
	if datatype.Light == nil {
		var empty CheermoteImageTheme
		return empty
	}
	return *datatype.Light
}

// Clip defines model for Clip.
type Clip struct {
	// BroadcasterId An ID that identifies the broadcaster that the video was clipped from.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The date and time of when the clip was created. The date and time is in RFC3339 format.
	CreatedAt time.Time `json:"created_at"`

	// CreatorId An ID that identifies the user that created the clip.
	CreatorId string `json:"creator_id"`

	// CreatorName The users display name.
	CreatorName string `json:"creator_name"`

	// Duration The length of the clip, in seconds. Precision is 0.1.
	Duration float32 `json:"duration"`

	// EmbedUrl A URL that you can use in an iframe to embed the clip (see [Embedding Video and Clips](https://dev.twitch.tv/docs/embed/video-and-clips/)).
	EmbedUrl string `json:"embed_url"`

	// GameId The ID of the game that was being played when the clip was created.
	GameId string `json:"game_id"`

	// Id An ID that uniquely identifies the clip.
	Id string `json:"id"`

	// IsFeatured A Boolean value that indicates if the clip is featured or not.
	IsFeatured bool `json:"is_featured"`

	// Language The ISO 639-1 two-letter language code that the broadcaster broadcasts in. For example, _en_ for English. The value is _other_ if the broadcaster uses a language that Twitch doesnt support.
	Language string `json:"language"`

	// ThumbnailUrl A URL to a thumbnail image of the clip.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The title of the clip.
	Title string `json:"title"`

	// Url A URL to the clip.
	Url string `json:"url"`

	// VideoId An ID that identifies the video that the clip came from. This field contains an empty string if the video is not available.
	VideoId string `json:"video_id"`

	// ViewCount The number of times the clip has been viewed.
	ViewCount int32 `json:"view_count"`

	// VodOffset The zero-based offset, in seconds, to where the clip starts in the video (VOD). Is **null** if the video is not available or hasnt been created yet from the live stream (see `video_id`).
	//
	// Note that theres a delay between when a clip is created during a broadcast and when the offset is set. During the delay period, `vod_offset` is **null**. The delay is indeterminant but is typically minutes long.
	VodOffset *int32 `json:"vod_offset"`
}

func (datatype Clip) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype Clip) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype Clip) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Clip) GetCreatorId() string {
	return datatype.CreatorId
}
func (datatype Clip) GetCreatorName() string {
	return datatype.CreatorName
}
func (datatype Clip) GetDuration() float32 {
	return datatype.Duration
}
func (datatype Clip) GetEmbedUrl() string {
	return datatype.EmbedUrl
}
func (datatype Clip) GetGameId() string {
	return datatype.GameId
}
func (datatype Clip) GetId() string {
	return datatype.Id
}
func (datatype Clip) GetIsFeatured() bool {
	return datatype.IsFeatured
}
func (datatype Clip) GetLanguage() string {
	return datatype.Language
}
func (datatype Clip) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Clip) GetTitle() string {
	return datatype.Title
}
func (datatype Clip) GetUrl() string {
	return datatype.Url
}
func (datatype Clip) GetVideoId() string {
	return datatype.VideoId
}
func (datatype Clip) GetViewCount() int32 {
	return datatype.ViewCount
}
func (datatype Clip) GetVodOffset() int32 {
	if datatype.VodOffset == nil {
		var empty int32
		return empty
	}
	return *datatype.VodOffset
}

// ContentClassificationLabel defines model for ContentClassificationLabel.
type ContentClassificationLabel struct {
	// Description Localized description of the CCL.
	Description string `json:"description"`

	// Id Unique identifier for the CCL.
	Id string `json:"id"`

	// Name Localized name of the CCL.
	Name string `json:"name"`
}

func (datatype ContentClassificationLabel) GetDescription() string {
	return datatype.Description
}
func (datatype ContentClassificationLabel) GetId() string {
	return datatype.Id
}
func (datatype ContentClassificationLabel) GetName() string {
	return datatype.Name
}

// CreateChannelStreamScheduleSegmentBody defines model for CreateChannelStreamScheduleSegmentBody.
type CreateChannelStreamScheduleSegmentBody struct {
	// CategoryId The ID of the category that best represents the broadcasts content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
	CategoryId *string `json:"category_id,omitempty"`

	// Duration The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).
	Duration string `json:"duration"`

	// IsRecurring A Boolean value that determines whether the broadcast recurs weekly. Is **true** if the broadcast recurs weekly. Only partners and affiliates may add non-recurring broadcasts.
	IsRecurring *bool `json:"is_recurring,omitempty"`

	// StartTime The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2021-07-01T18:00:00Z).
	StartTime time.Time `json:"start_time"`

	// Timezone The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\_York).
	Timezone string `json:"timezone"`

	// Title The broadcasts title. The title may contain a maximum of 140 characters.
	Title *string `json:"title,omitempty"`
}

func (datatype CreateChannelStreamScheduleSegmentBody) GetCategoryId() string {
	if datatype.CategoryId == nil {
		var empty string
		return empty
	}
	return *datatype.CategoryId
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetDuration() string {
	return datatype.Duration
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetIsRecurring() bool {
	if datatype.IsRecurring == nil {
		var empty bool
		return empty
	}
	return *datatype.IsRecurring
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetStartTime() time.Time {
	return datatype.StartTime
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetTimezone() string {
	return datatype.Timezone
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// CreateChannelStreamScheduleSegmentResponse defines model for CreateChannelStreamScheduleSegmentResponse.
type CreateChannelStreamScheduleSegmentResponse struct {
	// Data The broadcasters streaming scheduled.
	Data struct {
		// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// Segments A list that contains the single broadcast segment that you added.
		Segments []ChannelStreamScheduleSegment `json:"segments"`

		// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
		Vacation struct {
			// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
			EndTime time.Time `json:"end_time"`

			// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
			StartTime time.Time `json:"start_time"`
		} `json:"vacation"`
	} `json:"data"`
}

func (datatype CreateChannelStreamScheduleSegmentResponse) GetData() struct {
	// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Segments A list that contains the single broadcast segment that you added.
	Segments []ChannelStreamScheduleSegment `json:"segments"`

	// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	Vacation struct {
		// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
		EndTime time.Time `json:"end_time"`

		// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
		StartTime time.Time `json:"start_time"`
	} `json:"vacation"`
} {
	return datatype.Data
}

// CreateClipResponse defines model for CreateClipResponse.
type CreateClipResponse struct {
	Data []struct {
		// EditUrl A URL that you can use to edit the clips title, identify the part of the clip to publish, and publish the clip. [Learn More](https://help.twitch.tv/s/article/how-to-use-clips)
		//
		// The URL is valid for up to 24 hours or until the clip is published, whichever comes first.
		EditUrl string `json:"edit_url"`

		// Id An ID that uniquely identifies the clip.
		Id string `json:"id"`
	} `json:"data"`
}

func (datatype CreateClipResponse) GetData() []struct {
	// EditUrl A URL that you can use to edit the clips title, identify the part of the clip to publish, and publish the clip. [Learn More](https://help.twitch.tv/s/article/how-to-use-clips)
	//
	// The URL is valid for up to 24 hours or until the clip is published, whichever comes first.
	EditUrl string `json:"edit_url"`

	// Id An ID that uniquely identifies the clip.
	Id string `json:"id"`
} {
	return datatype.Data
}

// CreateConduitsBody defines model for CreateConduitsBody.
type CreateConduitsBody struct {
	// ShardCount The number of shards to create for this conduit.
	ShardCount int32 `json:"shard_count"`
}

func (datatype CreateConduitsBody) GetShardCount() int32 {
	return datatype.ShardCount
}

// CreateConduitsResponse defines model for CreateConduitsResponse.
type CreateConduitsResponse struct {
	// Data List of information about the clients conduits.
	Data []struct {
		// Id Conduit ID.
		Id string `json:"id"`

		// ShardCount Number of shards created for this conduit.
		ShardCount int32 `json:"shard_count"`
	} `json:"data"`
}

func (datatype CreateConduitsResponse) GetData() []struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount Number of shards created for this conduit.
	ShardCount int32 `json:"shard_count"`
} {
	return datatype.Data
}

// CreateCustomRewardsBody defines model for CreateCustomRewardsBody.
type CreateCustomRewardsBody struct {
	// BackgroundColor The background color to use for the reward. Specify the color using Hex format (for example, #9147FF).
	BackgroundColor *string `json:"background_color,omitempty"`

	// Cost The cost of the reward, in Channel Points. The minimum is 1 point.
	Cost int64 `json:"cost"`

	// GlobalCooldownSeconds The cooldown period, in seconds. Applied only if the `is_global_cooldown_enabled` field is **true**. The minimum value is 1; however, the minimum value is 60 for it to be shown in the Twitch UX.
	GlobalCooldownSeconds *int32 `json:"global_cooldown_seconds,omitempty"`

	// IsEnabled A Boolean value that determines whether the reward is enabled. Viewers see only enabled rewards. The default is **true**.
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// IsGlobalCooldownEnabled A Boolean value that determines whether to apply a cooldown period between redemptions (see the `global_cooldown_seconds` field for the duration of the cooldown period). The default is **false**.
	IsGlobalCooldownEnabled *bool `json:"is_global_cooldown_enabled,omitempty"`

	// IsMaxPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the `max_per_stream` field). The default is **false**.
	IsMaxPerStreamEnabled *bool `json:"is_max_per_stream_enabled,omitempty"`

	// IsMaxPerUserPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see the `max_per_user_per_stream` field). The default is **false**.
	IsMaxPerUserPerStreamEnabled *bool `json:"is_max_per_user_per_stream_enabled,omitempty"`

	// IsUserInputRequired A Boolean value that determines whether the user needs to enter information when redeeming the reward. See the `prompt` field. The default is **false**.
	IsUserInputRequired *bool `json:"is_user_input_required,omitempty"`

	// MaxPerStream The maximum number of redemptions allowed per live stream. Applied only if `is_max_per_stream_enabled` is **true**. The minimum value is 1.
	MaxPerStream *int32 `json:"max_per_stream,omitempty"`

	// MaxPerUserPerStream The maximum number of redemptions allowed per user per stream. Applied only if `is_max_per_user_per_stream_enabled` is **true**. The minimum value is 1.
	MaxPerUserPerStream *int32 `json:"max_per_user_per_stream,omitempty"`

	// Prompt The prompt shown to the viewer when they redeem the reward. Specify a prompt if `is_user_input_required` is **true**. The prompt is limited to a maximum of 200 characters.
	Prompt *string `json:"prompt,omitempty"`

	// ShouldRedemptionsSkipRequestQueue A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process. The default is **false**.
	ShouldRedemptionsSkipRequestQueue *bool `json:"should_redemptions_skip_request_queue,omitempty"`

	// Title The custom rewards title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcasters custom rewards.
	Title string `json:"title"`
}

func (datatype CreateCustomRewardsBody) GetBackgroundColor() string {
	if datatype.BackgroundColor == nil {
		var empty string
		return empty
	}
	return *datatype.BackgroundColor
}
func (datatype CreateCustomRewardsBody) GetCost() int64 {
	return datatype.Cost
}
func (datatype CreateCustomRewardsBody) GetGlobalCooldownSeconds() int32 {
	if datatype.GlobalCooldownSeconds == nil {
		var empty int32
		return empty
	}
	return *datatype.GlobalCooldownSeconds
}
func (datatype CreateCustomRewardsBody) GetIsEnabled() bool {
	if datatype.IsEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsEnabled
}
func (datatype CreateCustomRewardsBody) GetIsGlobalCooldownEnabled() bool {
	if datatype.IsGlobalCooldownEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsGlobalCooldownEnabled
}
func (datatype CreateCustomRewardsBody) GetIsMaxPerStreamEnabled() bool {
	if datatype.IsMaxPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerStreamEnabled
}
func (datatype CreateCustomRewardsBody) GetIsMaxPerUserPerStreamEnabled() bool {
	if datatype.IsMaxPerUserPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerUserPerStreamEnabled
}
func (datatype CreateCustomRewardsBody) GetIsUserInputRequired() bool {
	if datatype.IsUserInputRequired == nil {
		var empty bool
		return empty
	}
	return *datatype.IsUserInputRequired
}
func (datatype CreateCustomRewardsBody) GetMaxPerStream() int32 {
	if datatype.MaxPerStream == nil {
		var empty int32
		return empty
	}
	return *datatype.MaxPerStream
}
func (datatype CreateCustomRewardsBody) GetMaxPerUserPerStream() int32 {
	if datatype.MaxPerUserPerStream == nil {
		var empty int32
		return empty
	}
	return *datatype.MaxPerUserPerStream
}
func (datatype CreateCustomRewardsBody) GetPrompt() string {
	if datatype.Prompt == nil {
		var empty string
		return empty
	}
	return *datatype.Prompt
}
func (datatype CreateCustomRewardsBody) GetShouldRedemptionsSkipRequestQueue() bool {
	if datatype.ShouldRedemptionsSkipRequestQueue == nil {
		var empty bool
		return empty
	}
	return *datatype.ShouldRedemptionsSkipRequestQueue
}
func (datatype CreateCustomRewardsBody) GetTitle() string {
	return datatype.Title
}

// CreateCustomRewardsResponse defines model for CreateCustomRewardsResponse.
type CreateCustomRewardsResponse struct {
	// Data A list that contains the single custom reward you created.
	Data []CustomReward `json:"data"`
}

func (datatype CreateCustomRewardsResponse) GetData() []CustomReward {
	return datatype.Data
}

// CreateEventSubSubscriptionBody defines model for CreateEventSubSubscriptionBody.
type CreateEventSubSubscriptionBody struct {
	// Condition A JSON object that contains the parameter values that are specific to the specified subscription type. For the objects required and optional fields, see the subscription types documentation.
	Condition map[string]interface{} `json:"condition"`

	// Transport The transport details that you want Twitch to use when sending you notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See [Processing an event](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#processing-an-event). Specify this field only if `method` is set to **webhook**.
		//
		// **NOTE**: Redirects are not followed.
		Callback *string `json:"callback,omitempty"`

		// ConduitId An ID that identifies the conduit to send notifications to. When you create a conduit, the server returns the conduit ID. Specify this field only if `method` is set to **conduit**.
		ConduitId *string `json:"conduit_id,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		// * conduit
		Method CreateEventSubSubscriptionBodyTransportMethod `json:"method"`

		// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see [Verifying the event message](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#verifying-the-event-message). Specify this field only if `method` is set to **webhook**.
		Secret *string `json:"secret,omitempty"`

		// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message. Specify this field only if `method` is set to **websocket**.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`

	// Type The type of subscription to create. For a list of subscriptions that you can create, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). Set this field to the value in the **Name** column of the Subscription Types table.
	Type CreateEventSubSubscriptionBodyType `json:"type"`

	// Version The version number that identifies the definition of the subscription type that you want the response to use.
	Version string `json:"version"`
}

func (datatype CreateEventSubSubscriptionBody) GetCondition() map[string]interface{} {
	return datatype.Condition
}
func (datatype CreateEventSubSubscriptionBody) GetTransport() struct {
	// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See [Processing an event](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#processing-an-event). Specify this field only if `method` is set to **webhook**.
	//
	// **NOTE**: Redirects are not followed.
	Callback *string `json:"callback,omitempty"`

	// ConduitId An ID that identifies the conduit to send notifications to. When you create a conduit, the server returns the conduit ID. Specify this field only if `method` is set to **conduit**.
	ConduitId *string `json:"conduit_id,omitempty"`

	// Method The transport method. Possible values are:
	//
	// * webhook
	// * websocket
	// * conduit
	Method CreateEventSubSubscriptionBodyTransportMethod `json:"method"`

	// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see [Verifying the event message](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#verifying-the-event-message). Specify this field only if `method` is set to **webhook**.
	Secret *string `json:"secret,omitempty"`

	// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message. Specify this field only if `method` is set to **websocket**.
	SessionId *string `json:"session_id,omitempty"`
} {
	return datatype.Transport
}
func (datatype CreateEventSubSubscriptionBody) GetType() CreateEventSubSubscriptionBodyType {
	return datatype.Type
}
func (datatype CreateEventSubSubscriptionBody) GetVersion() string {
	return datatype.Version
}

// CreateEventSubSubscriptionBodyTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
// * conduit
type CreateEventSubSubscriptionBodyTransportMethod string

// CreateEventSubSubscriptionBodyType The type of subscription to create. For a list of subscriptions that you can create, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). Set this field to the value in the **Name** column of the Subscription Types table.
type CreateEventSubSubscriptionBodyType string

// CreateEventSubSubscriptionResponse defines model for CreateEventSubSubscriptionResponse.
type CreateEventSubSubscriptionResponse struct {
	// Data A list that contains the single subscription that you created.
	Data []EventSubSubscription `json:"data"`

	// MaxTotalCost The maximum total cost that youre allowed to incur for all subscriptions you create.
	MaxTotalCost int32 `json:"max_total_cost"`

	// Total The total number of subscriptions youve created.
	Total int32 `json:"total"`

	// TotalCost The sum of all of your subscription costs. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	TotalCost int32 `json:"total_cost"`
}

func (datatype CreateEventSubSubscriptionResponse) GetData() []EventSubSubscription {
	return datatype.Data
}
func (datatype CreateEventSubSubscriptionResponse) GetMaxTotalCost() int32 {
	return datatype.MaxTotalCost
}
func (datatype CreateEventSubSubscriptionResponse) GetTotal() int32 {
	return datatype.Total
}
func (datatype CreateEventSubSubscriptionResponse) GetTotalCost() int32 {
	return datatype.TotalCost
}

// CreateExtensionSecretResponse defines model for CreateExtensionSecretResponse.
type CreateExtensionSecretResponse struct {
	// Data A list that contains the newly added secrets.
	Data []ExtensionSecret `json:"data"`
}

func (datatype CreateExtensionSecretResponse) GetData() []ExtensionSecret {
	return datatype.Data
}

// CreateGuestStarSessionResponse defines model for CreateGuestStarSessionResponse.
type CreateGuestStarSessionResponse struct {
	// Data Summary of the session details.
	Data []GuestStarSession `json:"data"`
}

func (datatype CreateGuestStarSessionResponse) GetData() []GuestStarSession {
	return datatype.Data
}

// CreatePollBody defines model for CreatePollBody.
type CreatePollBody struct {
	// BroadcasterId The ID of the broadcaster thats running the poll. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// ChannelPointsPerVote The number of points that the viewer must spend to cast one additional vote. The minimum is 1 and the maximum is 1000000\. Set only if `ChannelPointsVotingEnabled` is **true**.
	ChannelPointsPerVote *int32 `json:"channel_points_per_vote,omitempty"`

	// ChannelPointsVotingEnabled A Boolean value that indicates whether viewers may cast additional votes using Channel Points. If **true**, the viewer may cast more than one vote but each additional vote costs the number of Channel Points specified in `channel_points_per_vote`. The default is **false** (viewers may cast only one vote). For information about Channel Points, see [Channel Points Guide](https://help.twitch.tv/s/article/channel-points-guide).
	ChannelPointsVotingEnabled *bool `json:"channel_points_voting_enabled,omitempty"`

	// Choices A list of choices that viewers may choose from. The list must contain a minimum of 2 choices and up to a maximum of 5 choices.
	Choices []struct {
		// Title One of the choices the viewer may select. The choice may contain a maximum of 25 characters.
		Title string `json:"title"`
	} `json:"choices"`

	// Duration The length of time (in seconds) that the poll will run for. The minimum is 15 seconds and the maximum is 1800 seconds (30 minutes).
	Duration int32 `json:"duration"`

	// Title The question that viewers will vote on. For example, _What game should I play next?_ The question may contain a maximum of 60 characters.
	Title string `json:"title"`
}

func (datatype CreatePollBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreatePollBody) GetChannelPointsPerVote() int32 {
	if datatype.ChannelPointsPerVote == nil {
		var empty int32
		return empty
	}
	return *datatype.ChannelPointsPerVote
}
func (datatype CreatePollBody) GetChannelPointsVotingEnabled() bool {
	if datatype.ChannelPointsVotingEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.ChannelPointsVotingEnabled
}
func (datatype CreatePollBody) GetChoices() []struct {
	// Title One of the choices the viewer may select. The choice may contain a maximum of 25 characters.
	Title string `json:"title"`
} {
	return datatype.Choices
}
func (datatype CreatePollBody) GetDuration() int32 {
	return datatype.Duration
}
func (datatype CreatePollBody) GetTitle() string {
	return datatype.Title
}

// CreatePollResponse defines model for CreatePollResponse.
type CreatePollResponse struct {
	// Data A list that contains the single poll that you created.
	Data []Poll `json:"data"`
}

func (datatype CreatePollResponse) GetData() []Poll {
	return datatype.Data
}

// CreatePredictionBody defines model for CreatePredictionBody.
type CreatePredictionBody struct {
	// BroadcasterId The ID of the broadcaster thats running the prediction. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// Outcomes The list of possible outcomes that the viewers may choose from. The list must contain a minimum of 2 choices and up to a maximum of 10 choices.
	Outcomes []struct {
		// Title The text of one of the outcomes that the viewer may select. The title is limited to a maximum of 25 characters.
		Title string `json:"title"`
	} `json:"outcomes"`

	// PredictionWindow The length of time (in seconds) that the prediction will run for. The minimum is 30 seconds and the maximum is 1800 seconds (30 minutes).
	PredictionWindow int32 `json:"prediction_window"`

	// Title The question that the broadcaster is asking. For example, _Will I finish this entire pizza?_ The title is limited to a maximum of 45 characters.
	Title string `json:"title"`
}

func (datatype CreatePredictionBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreatePredictionBody) GetOutcomes() []struct {
	// Title The text of one of the outcomes that the viewer may select. The title is limited to a maximum of 25 characters.
	Title string `json:"title"`
} {
	return datatype.Outcomes
}
func (datatype CreatePredictionBody) GetPredictionWindow() int32 {
	return datatype.PredictionWindow
}
func (datatype CreatePredictionBody) GetTitle() string {
	return datatype.Title
}

// CreatePredictionResponse defines model for CreatePredictionResponse.
type CreatePredictionResponse struct {
	// Data A list that contains the single prediction that you created.
	Data []Prediction `json:"data"`
}

func (datatype CreatePredictionResponse) GetData() []Prediction {
	return datatype.Data
}

// CreateStreamMarkerBody defines model for CreateStreamMarkerBody.
type CreateStreamMarkerBody struct {
	// Description A short description of the marker to help the user remember why they marked the location. The maximum length of the description is 140 characters.
	Description *string `json:"description,omitempty"`

	// UserId The ID of the broadcaster thats streaming content. This ID must match the user ID in the access token or the user in the access token must be one of the broadcasters editors.
	UserId string `json:"user_id"`
}

func (datatype CreateStreamMarkerBody) GetDescription() string {
	if datatype.Description == nil {
		var empty string
		return empty
	}
	return *datatype.Description
}
func (datatype CreateStreamMarkerBody) GetUserId() string {
	return datatype.UserId
}

// CreateStreamMarkerResponse defines model for CreateStreamMarkerResponse.
type CreateStreamMarkerResponse struct {
	// Data A list that contains the single marker that you added.
	Data []StreamMarkerCreated `json:"data"`
}

func (datatype CreateStreamMarkerResponse) GetData() []StreamMarkerCreated {
	return datatype.Data
}

// CreatorGoal defines model for CreatorGoal.
type CreatorGoal struct {
	// BroadcasterId An ID that identifies the broadcaster that created the goal.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The UTC date and time (in RFC3339 format) that the broadcaster created the goal.
	CreatedAt time.Time `json:"created_at"`

	// CurrentAmount The goals current value.
	//
	// The goals `type` determines how this value is increased or decreased.
	//
	// * If `type` is follower, this field is set to the broadcaster's current number of followers. This number increases with new followers and decreases when users unfollow the broadcaster.
	// * If `type` is subscription, this field is increased and decreased by the points value associated with the subscription tier. For example, if a tier-two subscription is worth 2 points, this field is increased or decreased by 2, not 1.
	// * If `type` is subscription\_count, this field is increased by 1 for each new subscription and decreased by 1 for each user that unsubscribes.
	// * If `type` is new\_subscription, this field is increased by the points value associated with the subscription tier. For example, if a tier-two subscription is worth 2 points, this field is increased by 2, not 1.
	// * If `type` is new\_subscription\_count, this field is increased by 1 for each new subscription.
	CurrentAmount int32 `json:"current_amount"`

	// Description A description of the goal. Is an empty string if not specified.
	Description string `json:"description"`

	// Id An ID that identifies this goal.
	Id string `json:"id"`

	// TargetAmount The goals target value. For example, if the broadcaster has 200 followers before creating the goal, and their goal is to double that number, this field is set to 400.
	TargetAmount int32 `json:"target_amount"`

	// Type The type of goal. Possible values are:
	//
	// * follower  The goal is to increase followers.
	// * subscription  The goal is to increase subscriptions. This type shows the net increase or decrease in tier points associated with the subscriptions.
	// * subscription\_count  The goal is to increase subscriptions. This type shows the net increase or decrease in the number of subscriptions.
	// * new\_subscription  The goal is to increase subscriptions. This type shows only the net increase in tier points associated with the subscriptions (it does not account for users that unsubscribed since the goal started).
	// * new\_subscription\_count  The goal is to increase subscriptions. This type shows only the net increase in the number of subscriptions (it does not account for users that unsubscribed since the goal started).
	Type CreatorGoalType `json:"type"`
}

func (datatype CreatorGoal) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreatorGoal) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CreatorGoal) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CreatorGoal) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype CreatorGoal) GetCurrentAmount() int32 {
	return datatype.CurrentAmount
}
func (datatype CreatorGoal) GetDescription() string {
	return datatype.Description
}
func (datatype CreatorGoal) GetId() string {
	return datatype.Id
}
func (datatype CreatorGoal) GetTargetAmount() int32 {
	return datatype.TargetAmount
}
func (datatype CreatorGoal) GetType() CreatorGoalType {
	return datatype.Type
}

// CreatorGoalType The type of goal. Possible values are:
//
// * follower  The goal is to increase followers.
// * subscription  The goal is to increase subscriptions. This type shows the net increase or decrease in tier points associated with the subscriptions.
// * subscription\_count  The goal is to increase subscriptions. This type shows the net increase or decrease in the number of subscriptions.
// * new\_subscription  The goal is to increase subscriptions. This type shows only the net increase in tier points associated with the subscriptions (it does not account for users that unsubscribed since the goal started).
// * new\_subscription\_count  The goal is to increase subscriptions. This type shows only the net increase in the number of subscriptions (it does not account for users that unsubscribed since the goal started).
type CreatorGoalType string

// CustomReward defines model for CustomReward.
type CustomReward struct {
	// BackgroundColor The background color to use for the reward. The color is in Hex format (for example, #00E5CB).
	BackgroundColor string `json:"background_color"`

	// BroadcasterId The ID that uniquely identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CooldownExpiresAt The timestamp of when the cooldown period expires. Is **null** if the reward isnt in a cooldown state. See the `global_cooldown_setting` field.
	CooldownExpiresAt *time.Time `json:"cooldown_expires_at"`

	// Cost The cost of the reward in Channel Points.
	Cost int64 `json:"cost"`

	// DefaultImage A set of default images for the reward.
	DefaultImage struct {
		// Url1x The URL to a small version of the image.
		Url1x string `json:"url_1x"`

		// Url2x The URL to a medium version of the image.
		Url2x string `json:"url_2x"`

		// Url4x The URL to a large version of the image.
		Url4x string `json:"url_4x"`
	} `json:"default_image"`

	// GlobalCooldownSetting The settings used to determine whether to apply a cooldown period between redemptions and the length of the cooldown.
	GlobalCooldownSetting struct {
		// GlobalCooldownSeconds The cooldown period, in seconds.
		GlobalCooldownSeconds int64 `json:"global_cooldown_seconds"`

		// IsEnabled A Boolean value that determines whether to apply a cooldown period. Is **true** if a cooldown period is enabled.
		IsEnabled bool `json:"is_enabled"`
	} `json:"global_cooldown_setting"`

	// Id The ID that uniquely identifies this custom reward.
	Id string `json:"id"`

	// Image A set of custom images for the reward. This field is **null** if the broadcaster didnt upload images.
	Image struct {
		// Url1x The URL to a small version of the image.
		Url1x string `json:"url_1x"`

		// Url2x The URL to a medium version of the image.
		Url2x string `json:"url_2x"`

		// Url4x The URL to a large version of the image.
		Url4x string `json:"url_4x"`
	} `json:"image"`

	// IsEnabled A Boolean value that determines whether the reward is enabled. Is **true** if enabled; otherwise, **false**. Disabled rewards arent shown to the user.
	IsEnabled bool `json:"is_enabled"`

	// IsInStock A Boolean value that determines whether the reward is currently in stock. Is **true** if the reward is in stock. Viewers cant redeem out of stock rewards.
	IsInStock bool `json:"is_in_stock"`

	// IsPaused A Boolean value that determines whether the reward is currently paused. Is **true** if the reward is paused. Viewers cant redeem paused rewards.
	IsPaused bool `json:"is_paused"`

	// IsUserInputRequired A Boolean value that determines whether the user must enter information when they redeem the reward. Is **true** if the user is prompted.
	IsUserInputRequired bool `json:"is_user_input_required"`

	// MaxPerStreamSetting The settings used to determine whether to apply a maximum to the number of redemptions allowed per live stream.
	MaxPerStreamSetting struct {
		// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per live stream. Is **true** if the reward applies a limit.
		IsEnabled bool `json:"is_enabled"`

		// MaxPerStream The maximum number of redemptions allowed per live stream.
		MaxPerStream int64 `json:"max_per_stream"`
	} `json:"max_per_stream_setting"`

	// MaxPerUserPerStreamSetting The settings used to determine whether to apply a maximum to the number of redemptions allowed per user per live stream.
	MaxPerUserPerStreamSetting struct {
		// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per user per live stream. Is **true** if the reward applies a limit.
		IsEnabled bool `json:"is_enabled"`

		// MaxPerUserPerStream The maximum number of redemptions allowed per user per live stream.
		MaxPerUserPerStream int64 `json:"max_per_user_per_stream"`
	} `json:"max_per_user_per_stream_setting"`

	// Prompt The prompt shown to the viewer when they redeem the reward if user input is required. See the `is_user_input_required` field.
	Prompt string `json:"prompt"`

	// RedemptionsRedeemedCurrentStream The number of redemptions redeemed during the current live stream. The number counts against the `max_per_stream_setting` limit. This field is **null** if the broadcasters stream isnt live or _max\_per\_stream\_setting_ isnt enabled.
	RedemptionsRedeemedCurrentStream *int32 `json:"redemptions_redeemed_current_stream"`

	// ShouldRedemptionsSkipRequestQueue A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.
	ShouldRedemptionsSkipRequestQueue bool `json:"should_redemptions_skip_request_queue"`

	// Title The title of the reward.
	Title string `json:"title"`
}

func (datatype CustomReward) GetBackgroundColor() string {
	return datatype.BackgroundColor
}
func (datatype CustomReward) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CustomReward) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CustomReward) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CustomReward) GetCooldownExpiresAt() time.Time {
	if datatype.CooldownExpiresAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.CooldownExpiresAt
}
func (datatype CustomReward) GetCost() int64 {
	return datatype.Cost
}
func (datatype CustomReward) GetDefaultImage() struct {
	// Url1x The URL to a small version of the image.
	Url1x string `json:"url_1x"`

	// Url2x The URL to a medium version of the image.
	Url2x string `json:"url_2x"`

	// Url4x The URL to a large version of the image.
	Url4x string `json:"url_4x"`
} {
	return datatype.DefaultImage
}
func (datatype CustomReward) GetGlobalCooldownSetting() struct {
	// GlobalCooldownSeconds The cooldown period, in seconds.
	GlobalCooldownSeconds int64 `json:"global_cooldown_seconds"`

	// IsEnabled A Boolean value that determines whether to apply a cooldown period. Is **true** if a cooldown period is enabled.
	IsEnabled bool `json:"is_enabled"`
} {
	return datatype.GlobalCooldownSetting
}
func (datatype CustomReward) GetId() string {
	return datatype.Id
}
func (datatype CustomReward) GetImage() struct {
	// Url1x The URL to a small version of the image.
	Url1x string `json:"url_1x"`

	// Url2x The URL to a medium version of the image.
	Url2x string `json:"url_2x"`

	// Url4x The URL to a large version of the image.
	Url4x string `json:"url_4x"`
} {
	return datatype.Image
}
func (datatype CustomReward) GetIsEnabled() bool {
	return datatype.IsEnabled
}
func (datatype CustomReward) GetIsInStock() bool {
	return datatype.IsInStock
}
func (datatype CustomReward) GetIsPaused() bool {
	return datatype.IsPaused
}
func (datatype CustomReward) GetIsUserInputRequired() bool {
	return datatype.IsUserInputRequired
}
func (datatype CustomReward) GetMaxPerStreamSetting() struct {
	// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per live stream. Is **true** if the reward applies a limit.
	IsEnabled bool `json:"is_enabled"`

	// MaxPerStream The maximum number of redemptions allowed per live stream.
	MaxPerStream int64 `json:"max_per_stream"`
} {
	return datatype.MaxPerStreamSetting
}
func (datatype CustomReward) GetMaxPerUserPerStreamSetting() struct {
	// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per user per live stream. Is **true** if the reward applies a limit.
	IsEnabled bool `json:"is_enabled"`

	// MaxPerUserPerStream The maximum number of redemptions allowed per user per live stream.
	MaxPerUserPerStream int64 `json:"max_per_user_per_stream"`
} {
	return datatype.MaxPerUserPerStreamSetting
}
func (datatype CustomReward) GetPrompt() string {
	return datatype.Prompt
}
func (datatype CustomReward) GetRedemptionsRedeemedCurrentStream() int32 {
	if datatype.RedemptionsRedeemedCurrentStream == nil {
		var empty int32
		return empty
	}
	return *datatype.RedemptionsRedeemedCurrentStream
}
func (datatype CustomReward) GetShouldRedemptionsSkipRequestQueue() bool {
	return datatype.ShouldRedemptionsSkipRequestQueue
}
func (datatype CustomReward) GetTitle() string {
	return datatype.Title
}

// CustomRewardRedemption defines model for CustomRewardRedemption.
type CustomRewardRedemption struct {
	// BroadcasterId The ID that uniquely identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Id The ID that uniquely identifies this redemption..
	Id string `json:"id"`

	// RedeemedAt The date and time of when the reward was redeemed, in RFC3339 format.
	RedeemedAt time.Time `json:"redeemed_at"`

	// Reward An object that describes the reward that the user redeemed.
	Reward struct {
		// Cost The rewards cost, in Channel Points.
		Cost int64 `json:"cost"`

		// Id The ID that uniquely identifies the reward.
		Id string `json:"id"`

		// Prompt The prompt displayed to the viewer if user input is required.
		Prompt string `json:"prompt"`

		// Title The rewards title.
		Title string `json:"title"`
	} `json:"reward"`

	// Status The state of the redemption. Possible values are:
	//
	// * CANCELED
	// * FULFILLED
	// * UNFULFILLED
	Status CustomRewardRedemptionStatus `json:"status"`

	// UserId The ID of the user that redeemed the reward.
	UserId string `json:"user_id"`

	// UserInput The text that the user entered at the prompt when they redeemed the reward; otherwise, an empty string if user input was not required.
	UserInput string `json:"user_input"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype CustomRewardRedemption) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CustomRewardRedemption) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CustomRewardRedemption) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CustomRewardRedemption) GetId() string {
	return datatype.Id
}
func (datatype CustomRewardRedemption) GetRedeemedAt() time.Time {
	return datatype.RedeemedAt
}
func (datatype CustomRewardRedemption) GetReward() struct {
	// Cost The rewards cost, in Channel Points.
	Cost int64 `json:"cost"`

	// Id The ID that uniquely identifies the reward.
	Id string `json:"id"`

	// Prompt The prompt displayed to the viewer if user input is required.
	Prompt string `json:"prompt"`

	// Title The rewards title.
	Title string `json:"title"`
} {
	return datatype.Reward
}
func (datatype CustomRewardRedemption) GetStatus() CustomRewardRedemptionStatus {
	return datatype.Status
}
func (datatype CustomRewardRedemption) GetUserId() string {
	return datatype.UserId
}
func (datatype CustomRewardRedemption) GetUserInput() string {
	return datatype.UserInput
}
func (datatype CustomRewardRedemption) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype CustomRewardRedemption) GetUserName() string {
	return datatype.UserName
}

// CustomRewardRedemptionStatus The state of the redemption. Possible values are:
//
// * CANCELED
// * FULFILLED
// * UNFULFILLED
type CustomRewardRedemptionStatus string

// DeleteVideosResponse defines model for DeleteVideosResponse.
type DeleteVideosResponse struct {
	// Data The list of IDs of the videos that were deleted.
	Data []string `json:"data"`
}

func (datatype DeleteVideosResponse) GetData() []string {
	return datatype.Data
}

// DropsEntitlement defines model for DropsEntitlement.
type DropsEntitlement struct {
	// BenefitId An ID that identifies the benefit (reward).
	BenefitId string `json:"benefit_id"`

	// FulfillmentStatus The entitlements fulfillment status. Possible values are:
	//
	// * CLAIMED
	// * FULFILLED
	FulfillmentStatus DropsEntitlementFulfillmentStatus `json:"fulfillment_status"`

	// GameId An ID that identifies the game the user was playing when the reward was entitled.
	GameId string `json:"game_id"`

	// Id An ID that identifies the entitlement.
	Id string `json:"id"`

	// LastUpdated The UTC date and time (in RFC3339 format) of when the entitlement was last updated.
	LastUpdated time.Time `json:"last_updated"`

	// Timestamp The UTC date and time (in RFC3339 format) of when the entitlement was granted.
	Timestamp time.Time `json:"timestamp"`

	// UserId An ID that identifies the user who was granted the entitlement.
	UserId string `json:"user_id"`
}

func (datatype DropsEntitlement) GetBenefitId() string {
	return datatype.BenefitId
}
func (datatype DropsEntitlement) GetFulfillmentStatus() DropsEntitlementFulfillmentStatus {
	return datatype.FulfillmentStatus
}
func (datatype DropsEntitlement) GetGameId() string {
	return datatype.GameId
}
func (datatype DropsEntitlement) GetId() string {
	return datatype.Id
}
func (datatype DropsEntitlement) GetLastUpdated() time.Time {
	return datatype.LastUpdated
}
func (datatype DropsEntitlement) GetTimestamp() time.Time {
	return datatype.Timestamp
}
func (datatype DropsEntitlement) GetUserId() string {
	return datatype.UserId
}

// DropsEntitlementFulfillmentStatus The entitlements fulfillment status. Possible values are:
//
// * CLAIMED
// * FULFILLED
type DropsEntitlementFulfillmentStatus string

// DropsEntitlementUpdated defines model for DropsEntitlementUpdated.
type DropsEntitlementUpdated struct {
	// Ids The list of entitlements that the status in the `status` field applies to.
	Ids []string `json:"ids"`

	// Status A string that indicates whether the status of the entitlements in the `ids` field were successfully updated. Possible values are:
	//
	// * INVALID\_ID  The entitlement IDs in the `ids` field are not valid.
	// * NOT\_FOUND  The entitlement IDs in the `ids` field were not found.
	// * SUCCESS  The status of the entitlements in the `ids` field were successfully updated.
	// * UNAUTHORIZED  The user or organization identified by the user access token is not authorized to update the entitlements.
	// * UPDATE\_FAILED  The update failed. These are considered transient errors and the request should be retried later.
	Status DropsEntitlementUpdatedStatus `json:"status"`
}

func (datatype DropsEntitlementUpdated) GetIds() []string {
	return datatype.Ids
}
func (datatype DropsEntitlementUpdated) GetStatus() DropsEntitlementUpdatedStatus {
	return datatype.Status
}

// DropsEntitlementUpdatedStatus A string that indicates whether the status of the entitlements in the `ids` field were successfully updated. Possible values are:
//
// * INVALID\_ID  The entitlement IDs in the `ids` field are not valid.
// * NOT\_FOUND  The entitlement IDs in the `ids` field were not found.
// * SUCCESS  The status of the entitlements in the `ids` field were successfully updated.
// * UNAUTHORIZED  The user or organization identified by the user access token is not authorized to update the entitlements.
// * UPDATE\_FAILED  The update failed. These are considered transient errors and the request should be retried later.
type DropsEntitlementUpdatedStatus string

// Emote defines model for Emote.
type Emote struct {
	// EmoteSetId An ID that identifies the emote set that the emote belongs to.
	EmoteSetId string `json:"emote_set_id"`

	// EmoteType The type of emote. The possible values are:
	//
	// * bitstier  A Bits tier emote.
	// * follower  A follower emote.
	// * subscriptions  A subscriber emote.
	EmoteType EmoteEmoteType `json:"emote_type"`

	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:
	//
	// * animated  An animated GIF is available for this emote.
	// * static  A static PNG file is available for this emote.
	Format []EmoteFormat `json:"format"`

	// Id An ID that uniquely identifies this emote.
	Id string `json:"id"`

	// Images The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.
	//
	// **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
	Images struct {
		// Url1x A URL to the small version (28px x 28px) of the emote.
		Url1x string `json:"url_1x"`

		// Url2x A URL to the medium version (56px x 56px) of the emote.
		Url2x string `json:"url_2x"`

		// Url4x A URL to the large version (112px x 112px) of the emote.
		Url4x string `json:"url_4x"`
	} `json:"images"`

	// Name The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
	Name string `json:"name"`

	// OwnerId The ID of the broadcaster who owns the emote.
	OwnerId string `json:"owner_id"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:
	//
	// * 1.0  A small version (28px x 28px) is available.
	// * 2.0  A medium version (56px x 56px) is available.
	// * 3.0  A large version (112px x 112px) is available.
	Scale []EmoteScale `json:"scale"`

	// ThemeMode The background themes that the emote is available in. Possible themes are:
	//
	// * dark
	// * light
	ThemeMode []EmoteThemeMode `json:"theme_mode"`
}

func (datatype Emote) GetEmoteSetId() string {
	return datatype.EmoteSetId
}
func (datatype Emote) GetEmoteType() EmoteEmoteType {
	return datatype.EmoteType
}
func (datatype Emote) GetFormat() []EmoteFormat {
	return datatype.Format
}
func (datatype Emote) GetId() string {
	return datatype.Id
}
func (datatype Emote) GetImages() struct {
	// Url1x A URL to the small version (28px x 28px) of the emote.
	Url1x string `json:"url_1x"`

	// Url2x A URL to the medium version (56px x 56px) of the emote.
	Url2x string `json:"url_2x"`

	// Url4x A URL to the large version (112px x 112px) of the emote.
	Url4x string `json:"url_4x"`
} {
	return datatype.Images
}
func (datatype Emote) GetName() string {
	return datatype.Name
}
func (datatype Emote) GetOwnerId() string {
	return datatype.OwnerId
}
func (datatype Emote) GetScale() []EmoteScale {
	return datatype.Scale
}
func (datatype Emote) GetThemeMode() []EmoteThemeMode {
	return datatype.ThemeMode
}

// EmoteEmoteType The type of emote. The possible values are:
//
// * bitstier  A Bits tier emote.
// * follower  A follower emote.
// * subscriptions  A subscriber emote.
type EmoteEmoteType string

// EmoteFormat defines model for Emote.Format.
type EmoteFormat string

// EmoteScale defines model for Emote.Scale.
type EmoteScale string

// EmoteThemeMode defines model for Emote.ThemeMode.
type EmoteThemeMode string

// EndGuestStarSessionResponse defines model for EndGuestStarSessionResponse.
type EndGuestStarSessionResponse struct {
	// Data Summary of the session details when the session was ended.
	Data []GuestStarSession `json:"data"`
}

func (datatype EndGuestStarSessionResponse) GetData() []GuestStarSession {
	return datatype.Data
}

// EndPollBody defines model for EndPollBody.
type EndPollBody struct {
	// BroadcasterId The ID of the broadcaster thats running the poll. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// Id The ID of the poll to update.
	Id string `json:"id"`

	// Status The status to set the poll to. Possible case-sensitive values are:
	//
	// * TERMINATED  Ends the poll before the poll is scheduled to end. The poll remains publicly visible.
	// * ARCHIVED  Ends the poll before the poll is scheduled to end, and then archives it so it's no longer publicly visible.
	Status EndPollBodyStatus `json:"status"`
}

func (datatype EndPollBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype EndPollBody) GetId() string {
	return datatype.Id
}
func (datatype EndPollBody) GetStatus() EndPollBodyStatus {
	return datatype.Status
}

// EndPollBodyStatus The status to set the poll to. Possible case-sensitive values are:
//
// * TERMINATED  Ends the poll before the poll is scheduled to end. The poll remains publicly visible.
// * ARCHIVED  Ends the poll before the poll is scheduled to end, and then archives it so it's no longer publicly visible.
type EndPollBodyStatus string

// EndPollResponse defines model for EndPollResponse.
type EndPollResponse struct {
	// Data A list that contains the poll that you ended.
	Data []Poll `json:"data"`
}

func (datatype EndPollResponse) GetData() []Poll {
	return datatype.Data
}

// EndPredictionBody defines model for EndPredictionBody.
type EndPredictionBody struct {
	// BroadcasterId The ID of the broadcaster thats running the prediction. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// Id The ID of the prediction to update.
	Id string `json:"id"`

	// Status The status to set the prediction to. Possible case-sensitive values are:
	//
	// * RESOLVED  The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome.
	// * CANCELED  The broadcaster is canceling the prediction and sending refunds to the participants.
	// * LOCKED  The broadcaster is locking the prediction, which means viewers may no longer make predictions.
	//
	// The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.
	//
	// The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.
	Status EndPredictionBodyStatus `json:"status"`

	// WinningOutcomeId The ID of the winning outcome. You must set this parameter if you set `status` to RESOLVED.
	WinningOutcomeId *string `json:"winning_outcome_id,omitempty"`
}

func (datatype EndPredictionBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype EndPredictionBody) GetId() string {
	return datatype.Id
}
func (datatype EndPredictionBody) GetStatus() EndPredictionBodyStatus {
	return datatype.Status
}
func (datatype EndPredictionBody) GetWinningOutcomeId() string {
	if datatype.WinningOutcomeId == nil {
		var empty string
		return empty
	}
	return *datatype.WinningOutcomeId
}

// EndPredictionBodyStatus The status to set the prediction to. Possible case-sensitive values are:
//
// * RESOLVED  The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome.
// * CANCELED  The broadcaster is canceling the prediction and sending refunds to the participants.
// * LOCKED  The broadcaster is locking the prediction, which means viewers may no longer make predictions.
//
// The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.
//
// The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.
type EndPredictionBodyStatus string

// EndPredictionResponse defines model for EndPredictionResponse.
type EndPredictionResponse struct {
	// Data A list that contains the single prediction that you updated.
	Data []Prediction `json:"data"`
}

func (datatype EndPredictionResponse) GetData() []Prediction {
	return datatype.Data
}

// EventSubSubscription defines model for EventSubSubscription.
type EventSubSubscription struct {
	// Condition The subscription's parameter values. This is a string-encoded JSON object whose contents are determined by the subscription type.
	Condition map[string]interface{} `json:"condition"`

	// Cost The amount that the subscription counts against your limit. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	Cost int32 `json:"cost"`

	// CreatedAt The date and time (in RFC3339 format) of when the subscription was created.
	CreatedAt time.Time `json:"created_at"`

	// Id An ID that identifies the subscription.
	Id string `json:"id"`

	// Status The subscription's status. The subscriber receives events only for **enabled** subscriptions. Possible values are:
	//
	// * enabled  The subscription is enabled.
	// * webhook\_callback\_verification\_pending  The subscription is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * authorization\_revoked  The authorization was revoked for one or more users specified in the **Condition** object.
	// * moderator\_removed  The moderator that authorized the subscription is no longer one of the broadcaster's moderators.
	// * user\_removed  One of the users specified in the **Condition** object was removed.
	// * version\_removed  The subscription to subscription type and version is no longer supported.
	// * beta\_maintenance  The subscription to the beta subscription type was removed due to maintenance.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_connection\_unused  The client failed to subscribe to events within the required time.
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	Status EventSubSubscriptionStatus `json:"status"`

	// Transport The transport details used to send the notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. Included only if `method` is set to **webhook**.
		Callback *string `json:"callback,omitempty"`

		// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if `method` is set to **websocket**.
		ConnectedAt *time.Time `json:"connected_at,omitempty"`

		// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if `method` is set to **websocket**.
		DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method EventSubSubscriptionTransportMethod `json:"method"`

		// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if `method` is set to **websocket**.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`

	// Type The subscription's type. See [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types).
	Type EventSubSubscriptionType `json:"type"`

	// Version The version number that identifies this definition of the subscription's data.
	Version string `json:"version"`
}

func (datatype EventSubSubscription) GetCondition() map[string]interface{} {
	return datatype.Condition
}
func (datatype EventSubSubscription) GetCost() int32 {
	return datatype.Cost
}
func (datatype EventSubSubscription) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype EventSubSubscription) GetId() string {
	return datatype.Id
}
func (datatype EventSubSubscription) GetStatus() EventSubSubscriptionStatus {
	return datatype.Status
}
func (datatype EventSubSubscription) GetTransport() struct {
	// Callback The callback URL where the notifications are sent. Included only if `method` is set to **webhook**.
	Callback *string `json:"callback,omitempty"`

	// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if `method` is set to **websocket**.
	ConnectedAt *time.Time `json:"connected_at,omitempty"`

	// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if `method` is set to **websocket**.
	DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

	// Method The transport method. Possible values are:
	//
	// * webhook
	// * websocket
	Method EventSubSubscriptionTransportMethod `json:"method"`

	// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if `method` is set to **websocket**.
	SessionId *string `json:"session_id,omitempty"`
} {
	return datatype.Transport
}
func (datatype EventSubSubscription) GetType() EventSubSubscriptionType {
	return datatype.Type
}
func (datatype EventSubSubscription) GetVersion() string {
	return datatype.Version
}

// EventSubSubscriptionStatus The subscription's status. The subscriber receives events only for **enabled** subscriptions. Possible values are:
//
// * enabled  The subscription is enabled.
// * webhook\_callback\_verification\_pending  The subscription is pending verification of the specified callback URL.
// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
// * authorization\_revoked  The authorization was revoked for one or more users specified in the **Condition** object.
// * moderator\_removed  The moderator that authorized the subscription is no longer one of the broadcaster's moderators.
// * user\_removed  One of the users specified in the **Condition** object was removed.
// * version\_removed  The subscription to subscription type and version is no longer supported.
// * beta\_maintenance  The subscription to the beta subscription type was removed due to maintenance.
// * websocket\_disconnected  The client closed the connection.
// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
// * websocket\_connection\_unused  The client failed to subscribe to events within the required time.
// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
type EventSubSubscriptionStatus string

// EventSubSubscriptionTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type EventSubSubscriptionTransportMethod string

// EventSubSubscriptionType The subscription's type. See [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types).
type EventSubSubscriptionType string

// Extension defines model for Extension.
type Extension struct {
	// AllowlistedConfigUrls Allowlisted configuration URLs for displaying the extension (the allowlist is configured on Twitchs [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \-> **Extension** \-> **Version** \-> **Capabilities**).
	AllowlistedConfigUrls []string `json:"allowlisted_config_urls"`

	// AllowlistedPanelUrls Allowlisted panel URLs for displaying the extension (the allowlist is configured on Twitchs [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \-> **Extension** \-> **Version** \-> **Capabilities**).
	AllowlistedPanelUrls []string `json:"allowlisted_panel_urls"`

	// AuthorName The name of the user or organization that owns the extension.
	AuthorName string `json:"author_name"`

	// BitsEnabled A Boolean value that determines whether the extension has features that use Bits. Is **true** if the extension has features that use Bits.
	BitsEnabled bool `json:"bits_enabled"`

	// CanInstall A Boolean value that determines whether a user can install the extension on their channel. Is **true** if a user can install the extension.
	//
	// Typically, this is set to **false** if the extension is currently in testing mode and requires users to be allowlisted (the allowlist is configured on Twitchs [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \-> **Extension** \-> **Version** \-> **Access**).
	CanInstall bool `json:"can_install"`

	// ConfigurationLocation The location of where the extensions configuration is stored. Possible values are:
	//
	// * hosted  The Extensions Configuration Service hosts the configuration.
	// * custom  The Extension Backend Service (EBS) hosts the configuration.
	// * none  The extension doesn't require configuration.
	ConfigurationLocation ExtensionConfigurationLocation `json:"configuration_location"`

	// Description A longer description of the extension. It appears on the details page.
	Description string `json:"description"`

	// EulaTosUrl A URL to the extensions Terms of Service.
	EulaTosUrl string `json:"eula_tos_url"`

	// HasChatSupport A Boolean value that determines whether the extension can communicate with the installed channels chat. Is **true** if the extension can communicate with the channels chat room.
	HasChatSupport bool `json:"has_chat_support"`

	// IconUrl A URL to the default icon thats displayed in the Extensions directory.
	IconUrl string `json:"icon_url"`

	// IconUrls A dictionary that contains URLs to different sizes of the default icon. The dictionarys key identifies the icons size (for example, 24x24), and the dictionarys value contains the URL to the icon.
	IconUrls ExtensionIconUrls `json:"icon_urls"`

	// Id The extensions ID.
	Id string `json:"id"`

	// Name The extensions name.
	Name string `json:"name"`

	// PrivacyPolicyUrl A URL to the extensions privacy policy.
	PrivacyPolicyUrl string `json:"privacy_policy_url"`

	// RequestIdentityLink A Boolean value that determines whether the extension wants to explicitly ask viewers to link their Twitch identity.
	RequestIdentityLink bool `json:"request_identity_link"`

	// ScreenshotUrls A list of URLs to screenshots that are shown in the Extensions marketplace.
	ScreenshotUrls []string `json:"screenshot_urls"`

	// State The extensions state. Possible values are:
	//
	// * Approved
	// * AssetsUploaded
	// * Deleted
	// * Deprecated
	// * InReview
	// * InTest
	// * PendingAction
	// * Rejected
	// * Released
	State ExtensionState `json:"state"`

	// SubscriptionsSupportLevel Indicates whether the extension can view the users subscription level on the channel that the extension is installed on. Possible values are:
	//
	// * none  The extension can't view the users subscription level.
	// * optional  The extension can view the users subscription level.
	SubscriptionsSupportLevel ExtensionSubscriptionsSupportLevel `json:"subscriptions_support_level"`

	// Summary A short description of the extension that streamers see when hovering over the discovery splash screen in the Extensions manager.
	Summary string `json:"summary"`

	// SupportEmail The email address that users use to get support for the extension.
	SupportEmail string `json:"support_email"`

	// Version The extensions version number.
	Version string `json:"version"`

	// ViewerSummary A brief description displayed on the channel to explain how the extension works.
	ViewerSummary string `json:"viewer_summary"`

	// Views Describes all views-related information such as how the extension is displayed on mobile devices.
	Views struct {
		// Component Describes how the extension is rendered if the extension may be activated as a video-component extension.
		Component struct {
			// AspectRatioX The width value of the ratio (width : height) which determines the extensions width, and how the extensions iframe will resize in different video player environments.
			AspectRatioX int32 `json:"aspect_ratio_x"`

			// AspectRatioY The height value of the ratio (width : height) which determines the extensions height, and how the extensions iframe will resize in different video player environments.
			AspectRatioY int32 `json:"aspect_ratio_y"`

			// Autoscale A Boolean value that determines whether to apply CSS zoom. If **true**, a CSS zoom is applied such that the size of the extension is variable but the inner dimensions are fixed based on Scale Pixels. This allows your extension to render as if it is of fixed width and height. If **false**, the inner dimensions of the extension iframe are variable, meaning your extension must implement responsiveness.
			Autoscale bool `json:"autoscale"`

			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// ScalePixels The base width, in pixels, of the extension to use when scaling (see `autoscale`). This value is ignored if `autoscale` is **false**.
			ScalePixels int32 `json:"scale_pixels"`

			// TargetHeight The height as a percent of the maximum height of a video component extension. Values are between 1% - 100%.
			TargetHeight int32 `json:"target_height"`

			// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Video - Component slot.
			ViewerUrl string `json:"viewer_url"`
		} `json:"component"`

		// Config Describes the view that is shown to broadcasters while they are configuring your extension within the Extension Manager.
		Config struct {
			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// ViewerUrl The HTML file shown to broadcasters while they are configuring your extension within the Extension Manager.
			ViewerUrl string `json:"viewer_url"`
		} `json:"config"`

		// Mobile Describes how the extension is displayed on mobile devices.
		Mobile struct {
			// ViewerUrl The HTML file that is shown to viewers on mobile devices. This page is presented to viewers as a panel behind the chat area of the mobile app.
			ViewerUrl string `json:"viewer_url"`
		} `json:"mobile"`

		// Panel Describes how the extension is rendered if the extension may be activated as a panel extension.
		Panel struct {
			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// Height The height, in pixels, of the panel component that the extension is rendered in.
			Height int32 `json:"height"`

			// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Panel slot.
			ViewerUrl string `json:"viewer_url"`
		} `json:"panel"`

		// VideoOverlay Describes how the extension is rendered if the extension may be activated as a video-overlay extension.
		VideoOverlay struct {
			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated on the Video - Overlay slot.
			ViewerUrl string `json:"viewer_url"`
		} `json:"video_overlay"`
	} `json:"views"`
}

func (datatype Extension) GetAllowlistedConfigUrls() []string {
	return datatype.AllowlistedConfigUrls
}
func (datatype Extension) GetAllowlistedPanelUrls() []string {
	return datatype.AllowlistedPanelUrls
}
func (datatype Extension) GetAuthorName() string {
	return datatype.AuthorName
}
func (datatype Extension) GetBitsEnabled() bool {
	return datatype.BitsEnabled
}
func (datatype Extension) GetCanInstall() bool {
	return datatype.CanInstall
}
func (datatype Extension) GetConfigurationLocation() ExtensionConfigurationLocation {
	return datatype.ConfigurationLocation
}
func (datatype Extension) GetDescription() string {
	return datatype.Description
}
func (datatype Extension) GetEulaTosUrl() string {
	return datatype.EulaTosUrl
}
func (datatype Extension) GetHasChatSupport() bool {
	return datatype.HasChatSupport
}
func (datatype Extension) GetIconUrl() string {
	return datatype.IconUrl
}
func (datatype Extension) GetIconUrls() ExtensionIconUrls {
	return datatype.IconUrls
}
func (datatype Extension) GetId() string {
	return datatype.Id
}
func (datatype Extension) GetName() string {
	return datatype.Name
}
func (datatype Extension) GetPrivacyPolicyUrl() string {
	return datatype.PrivacyPolicyUrl
}
func (datatype Extension) GetRequestIdentityLink() bool {
	return datatype.RequestIdentityLink
}
func (datatype Extension) GetScreenshotUrls() []string {
	return datatype.ScreenshotUrls
}
func (datatype Extension) GetState() ExtensionState {
	return datatype.State
}
func (datatype Extension) GetSubscriptionsSupportLevel() ExtensionSubscriptionsSupportLevel {
	return datatype.SubscriptionsSupportLevel
}
func (datatype Extension) GetSummary() string {
	return datatype.Summary
}
func (datatype Extension) GetSupportEmail() string {
	return datatype.SupportEmail
}
func (datatype Extension) GetVersion() string {
	return datatype.Version
}
func (datatype Extension) GetViewerSummary() string {
	return datatype.ViewerSummary
}
func (datatype Extension) GetViews() struct {
	// Component Describes how the extension is rendered if the extension may be activated as a video-component extension.
	Component struct {
		// AspectRatioX The width value of the ratio (width : height) which determines the extensions width, and how the extensions iframe will resize in different video player environments.
		AspectRatioX int32 `json:"aspect_ratio_x"`

		// AspectRatioY The height value of the ratio (width : height) which determines the extensions height, and how the extensions iframe will resize in different video player environments.
		AspectRatioY int32 `json:"aspect_ratio_y"`

		// Autoscale A Boolean value that determines whether to apply CSS zoom. If **true**, a CSS zoom is applied such that the size of the extension is variable but the inner dimensions are fixed based on Scale Pixels. This allows your extension to render as if it is of fixed width and height. If **false**, the inner dimensions of the extension iframe are variable, meaning your extension must implement responsiveness.
		Autoscale bool `json:"autoscale"`

		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// ScalePixels The base width, in pixels, of the extension to use when scaling (see `autoscale`). This value is ignored if `autoscale` is **false**.
		ScalePixels int32 `json:"scale_pixels"`

		// TargetHeight The height as a percent of the maximum height of a video component extension. Values are between 1% - 100%.
		TargetHeight int32 `json:"target_height"`

		// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Video - Component slot.
		ViewerUrl string `json:"viewer_url"`
	} `json:"component"`

	// Config Describes the view that is shown to broadcasters while they are configuring your extension within the Extension Manager.
	Config struct {
		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// ViewerUrl The HTML file shown to broadcasters while they are configuring your extension within the Extension Manager.
		ViewerUrl string `json:"viewer_url"`
	} `json:"config"`

	// Mobile Describes how the extension is displayed on mobile devices.
	Mobile struct {
		// ViewerUrl The HTML file that is shown to viewers on mobile devices. This page is presented to viewers as a panel behind the chat area of the mobile app.
		ViewerUrl string `json:"viewer_url"`
	} `json:"mobile"`

	// Panel Describes how the extension is rendered if the extension may be activated as a panel extension.
	Panel struct {
		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// Height The height, in pixels, of the panel component that the extension is rendered in.
		Height int32 `json:"height"`

		// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Panel slot.
		ViewerUrl string `json:"viewer_url"`
	} `json:"panel"`

	// VideoOverlay Describes how the extension is rendered if the extension may be activated as a video-overlay extension.
	VideoOverlay struct {
		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated on the Video - Overlay slot.
		ViewerUrl string `json:"viewer_url"`
	} `json:"video_overlay"`
} {
	return datatype.Views
}

// ExtensionConfigurationLocation The location of where the extensions configuration is stored. Possible values are:
//
// * hosted  The Extensions Configuration Service hosts the configuration.
// * custom  The Extension Backend Service (EBS) hosts the configuration.
// * none  The extension doesn't require configuration.
type ExtensionConfigurationLocation string

// ExtensionState The extensions state. Possible values are:
//
// * Approved
// * AssetsUploaded
// * Deleted
// * Deprecated
// * InReview
// * InTest
// * PendingAction
// * Rejected
// * Released
type ExtensionState string

// ExtensionSubscriptionsSupportLevel Indicates whether the extension can view the users subscription level on the channel that the extension is installed on. Possible values are:
//
// * none  The extension can't view the users subscription level.
// * optional  The extension can view the users subscription level.
type ExtensionSubscriptionsSupportLevel string

// ExtensionAnalytics defines model for ExtensionAnalytics.
type ExtensionAnalytics struct {
	// URL The URL that you use to download the report. The URL is valid for 5 minutes.
	URL string `json:"URL"`

	// DateRange The reporting windows start and end dates, in RFC3339 format.
	DateRange struct {
		// EndedAt The reporting windows end date.
		EndedAt time.Time `json:"ended_at"`

		// StartedAt The reporting windows start date.
		StartedAt time.Time `json:"started_at"`
	} `json:"date_range"`

	// ExtensionId An ID that identifies the extension that the report was generated for.
	ExtensionId string `json:"extension_id"`

	// Type The type of report.
	Type string `json:"type"`
}

func (datatype ExtensionAnalytics) GetURL() string {
	return datatype.URL
}
func (datatype ExtensionAnalytics) GetDateRange() struct {
	// EndedAt The reporting windows end date.
	EndedAt time.Time `json:"ended_at"`

	// StartedAt The reporting windows start date.
	StartedAt time.Time `json:"started_at"`
} {
	return datatype.DateRange
}
func (datatype ExtensionAnalytics) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype ExtensionAnalytics) GetType() string {
	return datatype.Type
}

// ExtensionBitsProduct defines model for ExtensionBitsProduct.
type ExtensionBitsProduct struct {
	// Cost An object that contains the product's cost information.
	Cost struct {
		// Amount The product's price.
		Amount int32 `json:"amount"`

		// Type The type of currency. Possible values are:
		//
		// * bits
		Type ExtensionBitsProductCostType `json:"type"`
	} `json:"cost"`

	// DisplayName The product's name as displayed in the extension.
	DisplayName string `json:"display_name"`

	// Expiration The date and time, in RFC3339 format, when the product expires.
	Expiration time.Time `json:"expiration"`

	// InDevelopment A Boolean value that indicates whether the product is in development. If **true**, the product is not available for public use.
	InDevelopment bool `json:"in_development"`

	// IsBroadcast A Boolean value that determines whether Bits product purchase events are broadcast to all instances of an extension on a channel. The events are broadcast via the `onTransactionComplete` helper callback. Is **true** if the event is broadcast to all instances.
	IsBroadcast bool `json:"is_broadcast"`

	// Sku The product's SKU. The SKU is unique across an extension's products.
	Sku string `json:"sku"`
}

func (datatype ExtensionBitsProduct) GetCost() struct {
	// Amount The product's price.
	Amount int32 `json:"amount"`

	// Type The type of currency. Possible values are:
	//
	// * bits
	Type ExtensionBitsProductCostType `json:"type"`
} {
	return datatype.Cost
}
func (datatype ExtensionBitsProduct) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype ExtensionBitsProduct) GetExpiration() time.Time {
	return datatype.Expiration
}
func (datatype ExtensionBitsProduct) GetInDevelopment() bool {
	return datatype.InDevelopment
}
func (datatype ExtensionBitsProduct) GetIsBroadcast() bool {
	return datatype.IsBroadcast
}
func (datatype ExtensionBitsProduct) GetSku() string {
	return datatype.Sku
}

// ExtensionBitsProductCostType The type of currency. Possible values are:
//
// * bits
type ExtensionBitsProductCostType string

// ExtensionConfigurationSegment defines model for ExtensionConfigurationSegment.
type ExtensionConfigurationSegment struct {
	// BroadcasterId The ID of the broadcaster that installed the extension. The object includes this field only if the `segment` query parameter is set to developer or broadcaster.
	BroadcasterId *string `json:"broadcaster_id,omitempty"`

	// Content The contents of the segment. This string may be a plain-text string or a string-encoded JSON object.
	Content string `json:"content"`

	// Segment The type of segment. Possible values are:
	//
	// * broadcaster
	// * developer
	// * global
	Segment ExtensionConfigurationSegmentSegment `json:"segment"`

	// Version The version number that identifies this definition of the segments data.
	Version string `json:"version"`
}

func (datatype ExtensionConfigurationSegment) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype ExtensionConfigurationSegment) GetContent() string {
	return datatype.Content
}
func (datatype ExtensionConfigurationSegment) GetSegment() ExtensionConfigurationSegmentSegment {
	return datatype.Segment
}
func (datatype ExtensionConfigurationSegment) GetVersion() string {
	return datatype.Version
}

// ExtensionConfigurationSegmentSegment The type of segment. Possible values are:
//
// * broadcaster
// * developer
// * global
type ExtensionConfigurationSegmentSegment string

// ExtensionIconUrls A dictionary that contains URLs to different sizes of the default icon. The dictionarys key identifies the icons size (for example, 24x24), and the dictionarys value contains the URL to the icon.
type ExtensionIconUrls struct {
	N100x100 *string `json:"100x100,omitempty"`
	N24x24   *string `json:"24x24,omitempty"`
	N300x200 *string `json:"300x200,omitempty"`
}

func (datatype ExtensionIconUrls) GetN100x100() string {
	if datatype.N100x100 == nil {
		var empty string
		return empty
	}
	return *datatype.N100x100
}
func (datatype ExtensionIconUrls) GetN24x24() string {
	if datatype.N24x24 == nil {
		var empty string
		return empty
	}
	return *datatype.N24x24
}
func (datatype ExtensionIconUrls) GetN300x200() string {
	if datatype.N300x200 == nil {
		var empty string
		return empty
	}
	return *datatype.N300x200
}

// ExtensionLiveChannel defines model for ExtensionLiveChannel.
type ExtensionLiveChannel struct {
	// BroadcasterId The ID of the broadcaster that is streaming live and has installed or activated the extension.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// GameId The ID of the category or game being streamed.
	GameId string `json:"game_id"`

	// GameName The name of the category or game being streamed.
	GameName string `json:"game_name"`

	// Title The title of the broadcasters stream. May be an empty string if not specified.
	Title string `json:"title"`
}

func (datatype ExtensionLiveChannel) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ExtensionLiveChannel) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ExtensionLiveChannel) GetGameId() string {
	return datatype.GameId
}
func (datatype ExtensionLiveChannel) GetGameName() string {
	return datatype.GameName
}
func (datatype ExtensionLiveChannel) GetTitle() string {
	return datatype.Title
}

// ExtensionSecret defines model for ExtensionSecret.
type ExtensionSecret struct {
	// FormatVersion The version number that identifies this definition of the secrets data.
	FormatVersion int32 `json:"format_version"`

	// Secrets The list of secrets.
	Secrets []struct {
		// ActiveAt The UTC date and time (in RFC3339 format) that you may begin using this secret to sign a JWT.
		ActiveAt time.Time `json:"active_at"`

		// Content The raw secret that you use with JWT encoding.
		Content string `json:"content"`

		// ExpiresAt The UTC date and time (in RFC3339 format) that you must stop using this secret to decode a JWT.
		ExpiresAt time.Time `json:"expires_at"`
	} `json:"secrets"`
}

func (datatype ExtensionSecret) GetFormatVersion() int32 {
	return datatype.FormatVersion
}
func (datatype ExtensionSecret) GetSecrets() []struct {
	// ActiveAt The UTC date and time (in RFC3339 format) that you may begin using this secret to sign a JWT.
	ActiveAt time.Time `json:"active_at"`

	// Content The raw secret that you use with JWT encoding.
	Content string `json:"content"`

	// ExpiresAt The UTC date and time (in RFC3339 format) that you must stop using this secret to decode a JWT.
	ExpiresAt time.Time `json:"expires_at"`
} {
	return datatype.Secrets
}

// ExtensionTransaction defines model for ExtensionTransaction.
type ExtensionTransaction struct {
	// BroadcasterId The ID of the broadcaster that owns the channel where the transaction occurred.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Id An ID that identifies the transaction.
	Id string `json:"id"`

	// ProductData Contains details about the digital product.
	ProductData struct {
		// Broadcast A Boolean value that determines whether the data was broadcast to all instances of the extension. Is **true** if the data was broadcast to all instances.
		Broadcast bool `json:"broadcast"`

		// Cost Contains details about the digital products cost.
		Cost struct {
			// Amount The amount exchanged for the digital product.
			Amount int32 `json:"amount"`

			// Type The type of currency exchanged. Possible values are:
			//
			// * bits
			Type ExtensionTransactionProductDataCostType `json:"type"`
		} `json:"cost"`

		// DisplayName The name of the digital product.
		DisplayName string `json:"displayName"`

		// Domain Set to `twitch.ext.` \+ `<the extension's ID>`.
		Domain string `json:"domain"`

		// Expiration This field is always empty since you may purchase only unexpired products.
		Expiration string `json:"expiration"`

		// InDevelopment A Boolean value that determines whether the product is in development. Is **true** if the digital product is in development and cannot be exchanged.
		InDevelopment bool `json:"inDevelopment"`

		// Sku An ID that identifies the digital product.
		Sku string `json:"sku"`
	} `json:"product_data"`

	// ProductType The type of transaction. Possible values are:
	//
	// * BITS\_IN\_EXTENSION
	ProductType ExtensionTransactionProductType `json:"product_type"`

	// Timestamp The UTC date and time (in RFC3339 format) of the transaction.
	Timestamp time.Time `json:"timestamp"`

	// UserId The ID of the user that purchased the digital product.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype ExtensionTransaction) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ExtensionTransaction) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype ExtensionTransaction) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ExtensionTransaction) GetId() string {
	return datatype.Id
}
func (datatype ExtensionTransaction) GetProductData() struct {
	// Broadcast A Boolean value that determines whether the data was broadcast to all instances of the extension. Is **true** if the data was broadcast to all instances.
	Broadcast bool `json:"broadcast"`

	// Cost Contains details about the digital products cost.
	Cost struct {
		// Amount The amount exchanged for the digital product.
		Amount int32 `json:"amount"`

		// Type The type of currency exchanged. Possible values are:
		//
		// * bits
		Type ExtensionTransactionProductDataCostType `json:"type"`
	} `json:"cost"`

	// DisplayName The name of the digital product.
	DisplayName string `json:"displayName"`

	// Domain Set to `twitch.ext.` \+ `<the extension's ID>`.
	Domain string `json:"domain"`

	// Expiration This field is always empty since you may purchase only unexpired products.
	Expiration string `json:"expiration"`

	// InDevelopment A Boolean value that determines whether the product is in development. Is **true** if the digital product is in development and cannot be exchanged.
	InDevelopment bool `json:"inDevelopment"`

	// Sku An ID that identifies the digital product.
	Sku string `json:"sku"`
} {
	return datatype.ProductData
}
func (datatype ExtensionTransaction) GetProductType() ExtensionTransactionProductType {
	return datatype.ProductType
}
func (datatype ExtensionTransaction) GetTimestamp() time.Time {
	return datatype.Timestamp
}
func (datatype ExtensionTransaction) GetUserId() string {
	return datatype.UserId
}
func (datatype ExtensionTransaction) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype ExtensionTransaction) GetUserName() string {
	return datatype.UserName
}

// ExtensionTransactionProductDataCostType The type of currency exchanged. Possible values are:
//
// * bits
type ExtensionTransactionProductDataCostType string

// ExtensionTransactionProductType The type of transaction. Possible values are:
//
// * BITS\_IN\_EXTENSION
type ExtensionTransactionProductType string

// Game defines model for Game.
type Game struct {
	// BoxArtUrl A URL to the categorys or games box art. You must replace the `{width}x{height}` placeholder with the size of image you want.
	BoxArtUrl string `json:"box_art_url"`

	// Id An ID that identifies the category or game.
	Id string `json:"id"`

	// IgdbId The ID that [IGDB](https://www.igdb.com/) uses to identify this game. If the IGDB ID is not available to Twitch, this field is set to an empty string.
	IgdbId string `json:"igdb_id"`

	// Name The categorys or games name.
	Name string `json:"name"`
}

func (datatype Game) GetBoxArtUrl() string {
	return datatype.BoxArtUrl
}
func (datatype Game) GetId() string {
	return datatype.Id
}
func (datatype Game) GetIgdbId() string {
	return datatype.IgdbId
}
func (datatype Game) GetName() string {
	return datatype.Name
}

// GameAnalytics defines model for GameAnalytics.
type GameAnalytics struct {
	// URL The URL that you use to download the report. The URL is valid for 5 minutes.
	URL string `json:"URL"`

	// DateRange The reporting windows start and end dates, in RFC3339 format.
	DateRange struct {
		// EndedAt The reporting windows end date.
		EndedAt time.Time `json:"ended_at"`

		// StartedAt The reporting windows start date.
		StartedAt time.Time `json:"started_at"`
	} `json:"date_range"`

	// GameId An ID that identifies the game that the report was generated for.
	GameId string `json:"game_id"`

	// Type The type of report.
	Type string `json:"type"`
}

func (datatype GameAnalytics) GetURL() string {
	return datatype.URL
}
func (datatype GameAnalytics) GetDateRange() struct {
	// EndedAt The reporting windows end date.
	EndedAt time.Time `json:"ended_at"`

	// StartedAt The reporting windows start date.
	StartedAt time.Time `json:"started_at"`
} {
	return datatype.DateRange
}
func (datatype GameAnalytics) GetGameId() string {
	return datatype.GameId
}
func (datatype GameAnalytics) GetType() string {
	return datatype.Type
}

// GetAdScheduleResponse defines model for GetAdScheduleResponse.
type GetAdScheduleResponse struct {
	// Data A list that contains information related to the channels ad schedule.
	Data []struct {
		// Duration The length in seconds of the scheduled upcoming ad break.
		Duration int32 `json:"duration"`

		// LastAdAt The UTC timestamp of the broadcasters last ad-break, in RFC3339 format. Empty if the channel has not run an ad or is not live.
		LastAdAt time.Time `json:"last_ad_at"`

		// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format. Empty if the channel has no ad scheduled or is not live.
		NextAdAt time.Time `json:"next_ad_at"`

		// PrerollFreeTime The amount of pre-roll free time remaining for the channel in seconds. Returns 0 if they are currently not pre-roll free.
		PrerollFreeTime int32 `json:"preroll_free_time"`

		// SnoozeCount The number of snoozes available for the broadcaster.
		SnoozeCount int32 `json:"snooze_count"`

		// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
		SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
	} `json:"data"`
}

func (datatype GetAdScheduleResponse) GetData() []struct {
	// Duration The length in seconds of the scheduled upcoming ad break.
	Duration int32 `json:"duration"`

	// LastAdAt The UTC timestamp of the broadcasters last ad-break, in RFC3339 format. Empty if the channel has not run an ad or is not live.
	LastAdAt time.Time `json:"last_ad_at"`

	// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format. Empty if the channel has no ad scheduled or is not live.
	NextAdAt time.Time `json:"next_ad_at"`

	// PrerollFreeTime The amount of pre-roll free time remaining for the channel in seconds. Returns 0 if they are currently not pre-roll free.
	PrerollFreeTime int32 `json:"preroll_free_time"`

	// SnoozeCount The number of snoozes available for the broadcaster.
	SnoozeCount int32 `json:"snooze_count"`

	// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
	SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
} {
	return datatype.Data
}

// GetAllStreamTagsResponse defines model for GetAllStreamTagsResponse.
type GetAllStreamTagsResponse struct {
	// Data The list of stream tags that the broadcaster can apply to their channel.
	Data []StreamTag `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forwards through the results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetAllStreamTagsResponse) GetData() []StreamTag {
	return datatype.Data
}
func (datatype GetAllStreamTagsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forwards through the results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forwards through the results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetAutoModSettingsResponse defines model for GetAutoModSettingsResponse.
type GetAutoModSettingsResponse struct {
	// Data The list of AutoMod settings. The list contains a single object that contains all the AutoMod settings.
	Data []AutoModSettings `json:"data"`
}

func (datatype GetAutoModSettingsResponse) GetData() []AutoModSettings {
	return datatype.Data
}

// GetBannedUsersResponse defines model for GetBannedUsersResponse.
type GetBannedUsersResponse struct {
	// Data The list of users that were banned or put in a timeout.
	Data []BannedUser `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetBannedUsersResponse) GetData() []BannedUser {
	return datatype.Data
}
func (datatype GetBannedUsersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetBitsLeaderboardResponse defines model for GetBitsLeaderboardResponse.
type GetBitsLeaderboardResponse struct {
	// Data A list of leaderboard leaders. The leaders are returned in rank order by how much theyve cheered. The array is empty if nobody has cheered bits.
	Data []BitsLeaderboard `json:"data"`

	// DateRange The reporting windows start and end dates, in RFC3339 format. The dates are calculated by using the _started\_at_ and _period_ query parameters. If you dont specify the _started\_at_ query parameter, the fields contain empty strings.
	DateRange struct {
		// EndedAt The reporting windows end date.
		EndedAt time.Time `json:"ended_at"`

		// StartedAt The reporting windows start date.
		StartedAt time.Time `json:"started_at"`
	} `json:"date_range"`

	// Total The number of ranked users in `data`. This is the value in the _count_ query parameter or the total number of entries on the leaderboard, whichever is less.
	Total int32 `json:"total"`
}

func (datatype GetBitsLeaderboardResponse) GetData() []BitsLeaderboard {
	return datatype.Data
}
func (datatype GetBitsLeaderboardResponse) GetDateRange() struct {
	// EndedAt The reporting windows end date.
	EndedAt time.Time `json:"ended_at"`

	// StartedAt The reporting windows start date.
	StartedAt time.Time `json:"started_at"`
} {
	return datatype.DateRange
}
func (datatype GetBitsLeaderboardResponse) GetTotal() int32 {
	return datatype.Total
}

// GetBlockedTermsResponse defines model for GetBlockedTermsResponse.
type GetBlockedTermsResponse struct {
	// Data The list of blocked terms. The list is in descending order of when they were created (see the `created_at` timestamp).
	Data []BlockedTerm `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetBlockedTermsResponse) GetData() []BlockedTerm {
	return datatype.Data
}
func (datatype GetBlockedTermsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetBroadcasterSubscriptionsResponse defines model for GetBroadcasterSubscriptionsResponse.
type GetBroadcasterSubscriptionsResponse struct {
	// Data The list of users that subscribe to the broadcaster. The list is empty if the broadcaster has no subscribers.
	Data []BroadcasterSubscription `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next or previous page of results. Use the cursor to set the requests _after_ or _before_ query parameter depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Points The current number of subscriber points earned by this broadcaster. Points are based on the subscription tier of each user that subscribes to this broadcaster. For example, a Tier 1 subscription is worth 1 point, Tier 2 is worth 2 points, and Tier 3 is worth 6 points. The number of points determines the number of emote slots that are unlocked for the broadcaster (see [Subscriber Emote Slots](https://help.twitch.tv/s/article/subscriber-emote-guide#emoteslots)).
	Points int32 `json:"points"`

	// Total The total number of users that subscribe to this broadcaster.
	Total int32 `json:"total"`
}

func (datatype GetBroadcasterSubscriptionsResponse) GetData() []BroadcasterSubscription {
	return datatype.Data
}
func (datatype GetBroadcasterSubscriptionsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next or previous page of results. Use the cursor to set the requests _after_ or _before_ query parameter depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next or previous page of results. Use the cursor to set the requests _after_ or _before_ query parameter depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetBroadcasterSubscriptionsResponse) GetPoints() int32 {
	return datatype.Points
}
func (datatype GetBroadcasterSubscriptionsResponse) GetTotal() int32 {
	return datatype.Total
}

// GetChannelChatBadgesResponse defines model for GetChannelChatBadgesResponse.
type GetChannelChatBadgesResponse struct {
	// Data The list of chat badges. The list is sorted in ascending order by `set_id`, and within a set, the list is sorted in ascending order by `id`.
	Data []ChatBadge `json:"data"`
}

func (datatype GetChannelChatBadgesResponse) GetData() []ChatBadge {
	return datatype.Data
}

// GetChannelEditorsResponse defines model for GetChannelEditorsResponse.
type GetChannelEditorsResponse struct {
	// Data A list of users that are editors for the specified broadcaster. The list is empty if the broadcaster doesnt have editors.
	Data []ChannelEditor `json:"data"`
}

func (datatype GetChannelEditorsResponse) GetData() []ChannelEditor {
	return datatype.Data
}

// GetChannelEmotesResponse defines model for GetChannelEmotesResponse.
type GetChannelEmotesResponse struct {
	// Data The list of emotes that the specified broadcaster created. If the broadcaster hasn't created custom emotes, the list is empty.
	Data []ChannelEmote `json:"data"`

	// Template A templated URL. Use the values from the `id`, `format`, `scale`, and `theme_mode` fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote. For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You should use this template instead of using the URLs in the `images` object.
	Template string `json:"template"`
}

func (datatype GetChannelEmotesResponse) GetData() []ChannelEmote {
	return datatype.Data
}
func (datatype GetChannelEmotesResponse) GetTemplate() string {
	return datatype.Template
}

// GetChannelFollowersResponse defines model for GetChannelFollowersResponse.
type GetChannelFollowersResponse struct {
	// Data The list of users that follow the specified broadcaster. The list is in descending order by `followed_at` (with the most recent follower first). The list is empty if nobody follows the broadcaster, the specified `user_id` isnt in the follower list, the user access token is missing the **moderator:read:followers** scope, or the user isnt the broadcaster or moderator for the channel.
	Data []struct {
		// FollowedAt The UTC timestamp when the user started following the broadcaster.
		FollowedAt time.Time `json:"followed_at"`

		// UserId An ID that uniquely identifies the user thats following the broadcaster.
		UserId string `json:"user_id"`

		// UserLogin The users login name.
		UserLogin string `json:"user_login"`

		// UserName The users display name.
		UserName string `json:"user_name"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of users that follow this broadcaster. As someone pages through the list, the number of users may change as users follow or unfollow the broadcaster.
	Total int32 `json:"total"`
}

func (datatype GetChannelFollowersResponse) GetData() []struct {
	// FollowedAt The UTC timestamp when the user started following the broadcaster.
	FollowedAt time.Time `json:"followed_at"`

	// UserId An ID that uniquely identifies the user thats following the broadcaster.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
} {
	return datatype.Data
}
func (datatype GetChannelFollowersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetChannelFollowersResponse) GetTotal() int32 {
	return datatype.Total
}

// GetChannelGuestStarSettingsResponse defines model for GetChannelGuestStarSettingsResponse.
type GetChannelGuestStarSettingsResponse struct {
	// BrowserSourceToken View only token to generate browser source URLs
	BrowserSourceToken string `json:"browser_source_token"`

	// GroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
	//
	// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
	// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
	GroupLayout GetChannelGuestStarSettingsResponseGroupLayout `json:"group_layout"`

	// IsBrowserSourceAudioEnabled Flag determining if Browser Sources subscribed to sessions on this channel should output audio
	IsBrowserSourceAudioEnabled bool `json:"is_browser_source_audio_enabled"`

	// IsModeratorSendLiveEnabled Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot.
	IsModeratorSendLiveEnabled bool `json:"is_moderator_send_live_enabled"`

	// SlotCount Number of slots the Guest Star call interface will allow the host to add to a call. Required to be between 1 and 6.
	SlotCount int32 `json:"slot_count"`
}

func (datatype GetChannelGuestStarSettingsResponse) GetBrowserSourceToken() string {
	return datatype.BrowserSourceToken
}
func (datatype GetChannelGuestStarSettingsResponse) GetGroupLayout() GetChannelGuestStarSettingsResponseGroupLayout {
	return datatype.GroupLayout
}
func (datatype GetChannelGuestStarSettingsResponse) GetIsBrowserSourceAudioEnabled() bool {
	return datatype.IsBrowserSourceAudioEnabled
}
func (datatype GetChannelGuestStarSettingsResponse) GetIsModeratorSendLiveEnabled() bool {
	return datatype.IsModeratorSendLiveEnabled
}
func (datatype GetChannelGuestStarSettingsResponse) GetSlotCount() int32 {
	return datatype.SlotCount
}

// GetChannelGuestStarSettingsResponseGroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
//
// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
type GetChannelGuestStarSettingsResponseGroupLayout string

// GetChannelInformationResponse defines model for GetChannelInformationResponse.
type GetChannelInformationResponse struct {
	// Data A list that contains information about the specified channels. The list is empty if the specified channels werent found.
	Data []ChannelInformation `json:"data"`
}

func (datatype GetChannelInformationResponse) GetData() []ChannelInformation {
	return datatype.Data
}

// GetChannelStreamScheduleResponse defines model for GetChannelStreamScheduleResponse.
type GetChannelStreamScheduleResponse struct {
	// Data The broadcasters streaming schedule.
	Data struct {
		// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// Pagination The information used to page through a list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
		Pagination *struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
			Cursor *string `json:"cursor,omitempty"`
		} `json:"pagination,omitempty"`

		// Segments The list of broadcasts in the broadcasters streaming schedule.
		Segments []ChannelStreamScheduleSegment `json:"segments"`

		// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
		Vacation struct {
			// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
			EndTime time.Time `json:"end_time"`

			// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
			StartTime time.Time `json:"start_time"`
		} `json:"vacation"`
	} `json:"data"`
}

func (datatype GetChannelStreamScheduleResponse) GetData() struct {
	// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Pagination The information used to page through a list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Segments The list of broadcasts in the broadcasters streaming schedule.
	Segments []ChannelStreamScheduleSegment `json:"segments"`

	// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	Vacation struct {
		// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
		EndTime time.Time `json:"end_time"`

		// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
		StartTime time.Time `json:"start_time"`
	} `json:"vacation"`
} {
	return datatype.Data
}

// GetChannelTeamsResponse defines model for GetChannelTeamsResponse.
type GetChannelTeamsResponse struct {
	// Data The list of teams that the broadcaster is a member of. Returns an empty array if the broadcaster is not a member of a team.
	Data []ChannelTeam `json:"data"`
}

func (datatype GetChannelTeamsResponse) GetData() []ChannelTeam {
	return datatype.Data
}

// GetCharityCampaignDonationsResponse defines model for GetCharityCampaignDonationsResponse.
type GetCharityCampaignDonationsResponse struct {
	// Data A list that contains the donations that users have made to the broadcasters charity campaign. The list is empty if the broadcaster is not currently running a charity campaign; the donation information is not available after the campaign ends.
	Data []CharityCampaignDonation `json:"data"`

	// Pagination An object that contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetCharityCampaignDonationsResponse) GetData() []CharityCampaignDonation {
	return datatype.Data
}
func (datatype GetCharityCampaignDonationsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetCharityCampaignResponse defines model for GetCharityCampaignResponse.
type GetCharityCampaignResponse struct {
	// Data A list that contains the charity campaign that the broadcaster is currently running. The list is empty if the broadcaster is not running a charity campaign; the campaign information is not available after the campaign ends.
	Data []CharityCampaign `json:"data"`
}

func (datatype GetCharityCampaignResponse) GetData() []CharityCampaign {
	return datatype.Data
}

// GetChatSettingsResponse defines model for GetChatSettingsResponse.
type GetChatSettingsResponse struct {
	// Data The list of chat settings. The list contains a single object with all the settings.
	Data []ChatSettings `json:"data"`
}

func (datatype GetChatSettingsResponse) GetData() []ChatSettings {
	return datatype.Data
}

// GetChattersResponse defines model for GetChattersResponse.
type GetChattersResponse struct {
	// Data The list of users that are connected to the broadcasters chat room. The list is empty if no users are connected to the chat room.
	Data []Chatter `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of users that are connected to the broadcasters chat room. As you page through the list, the number of users may change as users join and leave the chat room.
	Total int32 `json:"total"`
}

func (datatype GetChattersResponse) GetData() []Chatter {
	return datatype.Data
}
func (datatype GetChattersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetChattersResponse) GetTotal() int32 {
	return datatype.Total
}

// GetCheermotesResponse defines model for GetCheermotesResponse.
type GetCheermotesResponse struct {
	// Data The list of Cheermotes. The list is in ascending order by the `order` fields value.
	Data []Cheermote `json:"data"`
}

func (datatype GetCheermotesResponse) GetData() []Cheermote {
	return datatype.Data
}

// GetClipsResponse defines model for GetClipsResponse.
type GetClipsResponse struct {
	// Data The list of video clips. For clips returned by _game\_id_ or _broadcaster\_id_, the list is in descending order by view count. For lists returned by _id_, the list is in the same order as the input IDs.
	Data []Clip `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetClipsResponse) GetData() []Clip {
	return datatype.Data
}
func (datatype GetClipsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetConduitShardsResponse defines model for GetConduitShardsResponse.
type GetConduitShardsResponse struct {
	// Data List of information about a conduit's shards.
	Data []struct {
		// Id Shard ID.
		Id string `json:"id"`

		// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
		//
		// * enabled  The shard is enabled.
		// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
		// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
		// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
		// * websocket\_disconnected  The client closed the connection.
		// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
		// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
		// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
		// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
		// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
		// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
		Status GetConduitShardsResponseDataStatus `json:"status"`

		// Transport The transport details used to send the notifications.
		Transport struct {
			// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
			Callback *string `json:"callback,omitempty"`

			// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
			ConnectedAt *time.Time `json:"connected_at,omitempty"`

			// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
			DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

			// Method The transport method. Possible values are:
			//
			// * webhook
			// * websocket
			Method GetConduitShardsResponseDataTransportMethod `json:"method"`

			// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
			SessionId *string `json:"session_id,omitempty"`
		} `json:"transport"`
	} `json:"data"`

	// Pagination Contains information used to page through a list of results. The object is empty if there are no more pages left to page through.
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetConduitShardsResponse) GetData() []struct {
	// Id Shard ID.
	Id string `json:"id"`

	// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
	//
	// * enabled  The shard is enabled.
	// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	Status GetConduitShardsResponseDataStatus `json:"status"`

	// Transport The transport details used to send the notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
		Callback *string `json:"callback,omitempty"`

		// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
		ConnectedAt *time.Time `json:"connected_at,omitempty"`

		// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
		DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method GetConduitShardsResponseDataTransportMethod `json:"method"`

		// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`
} {
	return datatype.Data
}
func (datatype GetConduitShardsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetConduitShardsResponseDataStatus The shard status. The subscriber receives events only for enabled shards. Possible values are:
//
// * enabled  The shard is enabled.
// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
// * websocket\_disconnected  The client closed the connection.
// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
type GetConduitShardsResponseDataStatus string

// GetConduitShardsResponseDataTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type GetConduitShardsResponseDataTransportMethod string

// GetConduitsResponse defines model for GetConduitsResponse.
type GetConduitsResponse struct {
	// Data List of information about the clients conduits.
	Data []struct {
		// Id Conduit ID.
		Id string `json:"id"`

		// ShardCount Number of shards associated with this conduit.
		ShardCount int32 `json:"shard_count"`
	} `json:"data"`
}

func (datatype GetConduitsResponse) GetData() []struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount Number of shards associated with this conduit.
	ShardCount int32 `json:"shard_count"`
} {
	return datatype.Data
}

// GetContentClassificationLabelsResponse defines model for GetContentClassificationLabelsResponse.
type GetContentClassificationLabelsResponse struct {
	// Data A list that contains information about the available content classification labels.
	Data []ContentClassificationLabel `json:"data"`
}

func (datatype GetContentClassificationLabelsResponse) GetData() []ContentClassificationLabel {
	return datatype.Data
}

// GetCreatorGoalsResponse defines model for GetCreatorGoalsResponse.
type GetCreatorGoalsResponse struct {
	// Data The list of goals. The list is empty if the broadcaster hasnt created goals.
	Data []CreatorGoal `json:"data"`
}

func (datatype GetCreatorGoalsResponse) GetData() []CreatorGoal {
	return datatype.Data
}

// GetCustomRewardRedemptionResponse defines model for GetCustomRewardRedemptionResponse.
type GetCustomRewardRedemptionResponse struct {
	// Data The list of redemptions for the specified reward. The list is empty if there are no redemptions that match the redemption criteria.
	Data []CustomRewardRedemption `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.[Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetCustomRewardRedemptionResponse) GetData() []CustomRewardRedemption {
	return datatype.Data
}
func (datatype GetCustomRewardRedemptionResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetCustomRewardResponse defines model for GetCustomRewardResponse.
type GetCustomRewardResponse struct {
	// Data A list of custom rewards. The list is in ascending order by `id`. If the broadcaster hasnt created custom rewards, the list is empty.
	Data []CustomReward `json:"data"`
}

func (datatype GetCustomRewardResponse) GetData() []CustomReward {
	return datatype.Data
}

// GetDropsEntitlementsResponse defines model for GetDropsEntitlementsResponse.
type GetDropsEntitlementsResponse struct {
	// Data The list of entitlements.
	Data []DropsEntitlement `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forward through the results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetDropsEntitlementsResponse) GetData() []DropsEntitlement {
	return datatype.Data
}
func (datatype GetDropsEntitlementsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forward through the results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forward through the results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetEmoteSetsResponse defines model for GetEmoteSetsResponse.
type GetEmoteSetsResponse struct {
	// Data The list of emotes found in the specified emote sets. The list is empty if none of the IDs were found. The list is in the same order as the set IDs specified in the request. Each set contains one or more emoticons.
	Data []Emote `json:"data"`

	// Template A templated URL. Use the values from the `id`, `format`, `scale`, and `theme_mode` fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote. For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You should use this template instead of using the URLs in the `images` object.
	Template string `json:"template"`
}

func (datatype GetEmoteSetsResponse) GetData() []Emote {
	return datatype.Data
}
func (datatype GetEmoteSetsResponse) GetTemplate() string {
	return datatype.Template
}

// GetEventSubSubscriptionsResponse defines model for GetEventSubSubscriptionsResponse.
type GetEventSubSubscriptionsResponse struct {
	// Data The list of subscriptions. The list is ordered by the oldest subscription first. The list is empty if the client hasn't created subscriptions or there are no subscriptions that match the specified filter criteria.
	Data []EventSubSubscription `json:"data"`

	// MaxTotalCost The maximum total cost that you're allowed to incur for all subscriptions that you create.
	MaxTotalCost int32 `json:"max_total_cost"`

	// Pagination An object that contains the cursor used to get the next page of subscriptions. The object is empty if there are no more pages to get. The number of subscriptions returned per page is undertermined.
	Pagination *struct {
		// Cursor The cursor value that you set the _after_ query parameter to.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of subscriptions that you've created.
	Total int32 `json:"total"`

	// TotalCost The sum of all of your subscription costs. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	TotalCost int32 `json:"total_cost"`
}

func (datatype GetEventSubSubscriptionsResponse) GetData() []EventSubSubscription {
	return datatype.Data
}
func (datatype GetEventSubSubscriptionsResponse) GetMaxTotalCost() int32 {
	return datatype.MaxTotalCost
}
func (datatype GetEventSubSubscriptionsResponse) GetPagination() struct {
	// Cursor The cursor value that you set the _after_ query parameter to.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor value that you set the _after_ query parameter to.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetEventSubSubscriptionsResponse) GetTotal() int32 {
	return datatype.Total
}
func (datatype GetEventSubSubscriptionsResponse) GetTotalCost() int32 {
	return datatype.TotalCost
}

// GetExtensionAnalyticsResponse defines model for GetExtensionAnalyticsResponse.
type GetExtensionAnalyticsResponse struct {
	// Data A list of reports. The reports are returned in no particular order; however, the data within each report is in ascending order by date (newest first). The report contains one row of data per day of the reporting window; the report contains rows for only those days that the extension was used. The array is empty if there are no reports.
	Data []ExtensionAnalytics `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetExtensionAnalyticsResponse) GetData() []ExtensionAnalytics {
	return datatype.Data
}
func (datatype GetExtensionAnalyticsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetExtensionBitsProductsResponse defines model for GetExtensionBitsProductsResponse.
type GetExtensionBitsProductsResponse struct {
	// Data A list of Bits products that the extension created. The list is in ascending SKU order. The list is empty if the extension hasnt created any products or theyre all expired or disabled.
	Data []ExtensionBitsProduct `json:"data"`
}

func (datatype GetExtensionBitsProductsResponse) GetData() []ExtensionBitsProduct {
	return datatype.Data
}

// GetExtensionConfigurationSegmentResponse defines model for GetExtensionConfigurationSegmentResponse.
type GetExtensionConfigurationSegmentResponse struct {
	// Data The list of requested configuration segments. The list is returned in the same order that you specified the list of segments in the request.
	Data []ExtensionConfigurationSegment `json:"data"`
}

func (datatype GetExtensionConfigurationSegmentResponse) GetData() []ExtensionConfigurationSegment {
	return datatype.Data
}

// GetExtensionLiveChannelsResponse defines model for GetExtensionLiveChannelsResponse.
type GetExtensionLiveChannelsResponse struct {
	// Data The list of broadcasters that are streaming live and that have installed or activated the extension.
	Data []ExtensionLiveChannel `json:"data"`

	// Pagination This field contains the cursor used to page through the results. The field is empty if there are no more pages left to page through. Note that this field is a string compared to other endpoints that use a **Pagination** object. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *string `json:"pagination,omitempty"`
}

func (datatype GetExtensionLiveChannelsResponse) GetData() []ExtensionLiveChannel {
	return datatype.Data
}
func (datatype GetExtensionLiveChannelsResponse) GetPagination() string {
	if datatype.Pagination == nil {
		var empty string
		return empty
	}
	return *datatype.Pagination
}

// GetExtensionSecretsResponse defines model for GetExtensionSecretsResponse.
type GetExtensionSecretsResponse struct {
	// Data The list of shared secrets that the extension created.
	Data []ExtensionSecret `json:"data"`
}

func (datatype GetExtensionSecretsResponse) GetData() []ExtensionSecret {
	return datatype.Data
}

// GetExtensionTransactionsResponse defines model for GetExtensionTransactionsResponse.
type GetExtensionTransactionsResponse struct {
	// Data The list of transactions.
	Data []ExtensionTransaction `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetExtensionTransactionsResponse) GetData() []ExtensionTransaction {
	return datatype.Data
}
func (datatype GetExtensionTransactionsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetExtensionsResponse defines model for GetExtensionsResponse.
type GetExtensionsResponse struct {
	// Data A list that contains the specified extension.
	Data []Extension `json:"data"`
}

func (datatype GetExtensionsResponse) GetData() []Extension {
	return datatype.Data
}

// GetFollowedChannelsResponse defines model for GetFollowedChannelsResponse.
type GetFollowedChannelsResponse struct {
	// Data The list of broadcasters that the user follows. The list is in descending order by `followed_at` (with the most recently followed broadcaster first). The list is empty if the user doesnt follow anyone.
	Data []struct {
		// BroadcasterId An ID that uniquely identifies the broadcaster that this user is following.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// FollowedAt The UTC timestamp when the user started following the broadcaster.
		FollowedAt time.Time `json:"followed_at"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of broadcasters that the user follows. As someone pages through the list, the number may change as the user follows or unfollows broadcasters.
	Total int32 `json:"total"`
}

func (datatype GetFollowedChannelsResponse) GetData() []struct {
	// BroadcasterId An ID that uniquely identifies the broadcaster that this user is following.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// FollowedAt The UTC timestamp when the user started following the broadcaster.
	FollowedAt time.Time `json:"followed_at"`
} {
	return datatype.Data
}
func (datatype GetFollowedChannelsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetFollowedChannelsResponse) GetTotal() int32 {
	return datatype.Total
}

// GetFollowedStreamsResponse defines model for GetFollowedStreamsResponse.
type GetFollowedStreamsResponse struct {
	// Data The list of live streams of broadcasters that the specified user follows. The list is in descending order by the number of viewers watching the stream. Because viewers come and go during a stream, its possible to find duplicate or missing streams in the list as you page through the results. The list is empty if none of the followed broadcasters are streaming live.
	Data []Stream `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetFollowedStreamsResponse) GetData() []Stream {
	return datatype.Data
}
func (datatype GetFollowedStreamsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetGameAnalyticsResponse defines model for GetGameAnalyticsResponse.
type GetGameAnalyticsResponse struct {
	// Data A list of reports. The reports are returned in no particular order; however, the data within each report is in ascending order by date (newest first). The report contains one row of data per day of the reporting window; the report contains rows for only those days that the game was used. A report is available only if the game was broadcast for at least 5 hours over the reporting period. The array is empty if there are no reports.
	Data []GameAnalytics `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetGameAnalyticsResponse) GetData() []GameAnalytics {
	return datatype.Data
}
func (datatype GetGameAnalyticsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetGamesResponse defines model for GetGamesResponse.
type GetGamesResponse struct {
	// Data The list of categories and games. The list is empty if the specified categories and games werent found.
	Data []Game `json:"data"`
}

func (datatype GetGamesResponse) GetData() []Game {
	return datatype.Data
}

// GetGlobalChatBadgesResponse defines model for GetGlobalChatBadgesResponse.
type GetGlobalChatBadgesResponse struct {
	// Data The list of chat badges. The list is sorted in ascending order by `set_id`, and within a set, the list is sorted in ascending order by `id`.
	Data []ChatBadge `json:"data"`
}

func (datatype GetGlobalChatBadgesResponse) GetData() []ChatBadge {
	return datatype.Data
}

// GetGlobalEmotesResponse defines model for GetGlobalEmotesResponse.
type GetGlobalEmotesResponse struct {
	// Data The list of global emotes.
	Data []GlobalEmote `json:"data"`

	// Template A templated URL. Use the values from the `id`, `format`, `scale`, and `theme_mode` fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote. For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You should use this template instead of using the URLs in the `images` object.
	Template string `json:"template"`
}

func (datatype GetGlobalEmotesResponse) GetData() []GlobalEmote {
	return datatype.Data
}
func (datatype GetGlobalEmotesResponse) GetTemplate() string {
	return datatype.Template
}

// GetGuestStarInvitesResponse defines model for GetGuestStarInvitesResponse.
type GetGuestStarInvitesResponse struct {
	// Data A list of invite objects describing the invited user as well as their ready status.
	Data []GuestStarInvite `json:"data"`
}

func (datatype GetGuestStarInvitesResponse) GetData() []GuestStarInvite {
	return datatype.Data
}

// GetGuestStarSessionResponse defines model for GetGuestStarSessionResponse.
type GetGuestStarSessionResponse struct {
	// Data Summary of the session details
	Data []GuestStarSession `json:"data"`
}

func (datatype GetGuestStarSessionResponse) GetData() []GuestStarSession {
	return datatype.Data
}

// GetHypeTrainEventsResponse defines model for GetHypeTrainEventsResponse.
type GetHypeTrainEventsResponse struct {
	// Data The list of Hype Train events. The list is empty if the broadcaster hasnt run a Hype Train within the last 5 days.
	Data []HypeTrainEvent `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetHypeTrainEventsResponse) GetData() []HypeTrainEvent {
	return datatype.Data
}
func (datatype GetHypeTrainEventsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetHypeTrainStatusResponse defines model for GetHypeTrainStatusResponse.
type GetHypeTrainStatusResponse struct {
	// AllTimeHigh An object with information about the channels Hype Train records. Null if a Hype Train has not occurred.
	AllTimeHigh struct {
		// AchievedAt The time when the record was achieved.
		AchievedAt time.Time `json:"achieved_at"`

		// Level The level of the record Hype Train.
		Level int32 `json:"level"`

		// Total Total points contributed to the record Hype Train.
		Total int32 `json:"total"`
	} `json:"all_time_high"`

	// Data A list that contains information related to the channels Hype Train.
	Data []struct {
		// Current An object describing the current Hype Train. Null if a Hype Train is not active.
		Current struct {
			// BroadcasterUserId The broadcaster ID.
			BroadcasterUserId string `json:"broadcaster_user_id"`

			// BroadcasterUserLogin The broadcaster login.
			BroadcasterUserLogin string `json:"broadcaster_user_login"`

			// BroadcasterUserName The broadcaster display name.
			BroadcasterUserName string `json:"broadcaster_user_name"`

			// Goal The number of points required to reach the next level.
			Goal int32 `json:"goal"`

			// Id The Hype Train ID.
			Id string `json:"id"`

			// Level The current level of the Hype Train.
			Level int32 `json:"level"`

			// Progress The number of points contributed to the Hype Train at the current level.
			Progress int32 `json:"progress"`

			// TopContributions The contributors with the most points contributed.
			TopContributions []struct {
				// ExpiresAt The time when the Hype Train expires. The expiration is extended when the Hype Train reaches a new level.
				ExpiresAt time.Time `json:"expires_at"`

				// IsSharedTrain Indicates if the Hype Train is shared. When true, shared\_train\_participants will contain the list of broadcasters the train is shared with.
				IsSharedTrain bool `json:"is_shared_train"`

				// SharedTrainParticipants A list containing the broadcasters participating in the shared Hype Train. Null if the Hype Train is not shared.
				SharedTrainParticipants []struct {
					// BroadcasterUserId The broadcaster ID.
					BroadcasterUserId string `json:"broadcaster_user_id"`

					// BroadcasterUserLogin The broadcaster login.
					BroadcasterUserLogin string `json:"broadcaster_user_login"`

					// BroadcasterUserName The broadcaster display name.
					BroadcasterUserName string `json:"broadcaster_user_name"`
				} `json:"shared_train_participants"`

				// StartedAt The time when the Hype Train started.
				StartedAt time.Time `json:"started_at"`

				// Total The total number of points contributed for the type.
				Total int32 `json:"total"`

				// Type The type of the Hype Train. Possible values are:
				//
				// * **treasure**
				// * **golden\_kappa**
				// * **regular**
				//
				// [Learn More](https://help.twitch.tv/s/article/hype-train-guide#special)
				Type GetHypeTrainStatusResponseDataCurrentTopContributionsType `json:"type"`

				// UserId The ID of the user that made the contribution.
				UserId string `json:"user_id"`

				// UserLogin The users login name.
				UserLogin string `json:"user_login"`

				// UserName The users display name.
				UserName string `json:"user_name"`
			} `json:"top_contributions"`

			// Total Total points contributed to the Hype Train.
			Total int32 `json:"total"`
		} `json:"current"`
	} `json:"data"`

	// SharedAllTimeHigh An object with information about the channels shared Hype Train records. Null if a Hype Train has not occurred.
	SharedAllTimeHigh struct {
		// AchievedAt The time when the record was achieved.
		AchievedAt time.Time `json:"achieved_at"`

		// Level The level of the record Hype Train.
		Level int32 `json:"level"`

		// Total Total points contributed to the record Hype Train.
		Total int32 `json:"total"`
	} `json:"shared_all_time_high"`
}

func (datatype GetHypeTrainStatusResponse) GetAllTimeHigh() struct {
	// AchievedAt The time when the record was achieved.
	AchievedAt time.Time `json:"achieved_at"`

	// Level The level of the record Hype Train.
	Level int32 `json:"level"`

	// Total Total points contributed to the record Hype Train.
	Total int32 `json:"total"`
} {
	return datatype.AllTimeHigh
}
func (datatype GetHypeTrainStatusResponse) GetData() []struct {
	// Current An object describing the current Hype Train. Null if a Hype Train is not active.
	Current struct {
		// BroadcasterUserId The broadcaster ID.
		BroadcasterUserId string `json:"broadcaster_user_id"`

		// BroadcasterUserLogin The broadcaster login.
		BroadcasterUserLogin string `json:"broadcaster_user_login"`

		// BroadcasterUserName The broadcaster display name.
		BroadcasterUserName string `json:"broadcaster_user_name"`

		// Goal The number of points required to reach the next level.
		Goal int32 `json:"goal"`

		// Id The Hype Train ID.
		Id string `json:"id"`

		// Level The current level of the Hype Train.
		Level int32 `json:"level"`

		// Progress The number of points contributed to the Hype Train at the current level.
		Progress int32 `json:"progress"`

		// TopContributions The contributors with the most points contributed.
		TopContributions []struct {
			// ExpiresAt The time when the Hype Train expires. The expiration is extended when the Hype Train reaches a new level.
			ExpiresAt time.Time `json:"expires_at"`

			// IsSharedTrain Indicates if the Hype Train is shared. When true, shared\_train\_participants will contain the list of broadcasters the train is shared with.
			IsSharedTrain bool `json:"is_shared_train"`

			// SharedTrainParticipants A list containing the broadcasters participating in the shared Hype Train. Null if the Hype Train is not shared.
			SharedTrainParticipants []struct {
				// BroadcasterUserId The broadcaster ID.
				BroadcasterUserId string `json:"broadcaster_user_id"`

				// BroadcasterUserLogin The broadcaster login.
				BroadcasterUserLogin string `json:"broadcaster_user_login"`

				// BroadcasterUserName The broadcaster display name.
				BroadcasterUserName string `json:"broadcaster_user_name"`
			} `json:"shared_train_participants"`

			// StartedAt The time when the Hype Train started.
			StartedAt time.Time `json:"started_at"`

			// Total The total number of points contributed for the type.
			Total int32 `json:"total"`

			// Type The type of the Hype Train. Possible values are:
			//
			// * **treasure**
			// * **golden\_kappa**
			// * **regular**
			//
			// [Learn More](https://help.twitch.tv/s/article/hype-train-guide#special)
			Type GetHypeTrainStatusResponseDataCurrentTopContributionsType `json:"type"`

			// UserId The ID of the user that made the contribution.
			UserId string `json:"user_id"`

			// UserLogin The users login name.
			UserLogin string `json:"user_login"`

			// UserName The users display name.
			UserName string `json:"user_name"`
		} `json:"top_contributions"`

		// Total Total points contributed to the Hype Train.
		Total int32 `json:"total"`
	} `json:"current"`
} {
	return datatype.Data
}
func (datatype GetHypeTrainStatusResponse) GetSharedAllTimeHigh() struct {
	// AchievedAt The time when the record was achieved.
	AchievedAt time.Time `json:"achieved_at"`

	// Level The level of the record Hype Train.
	Level int32 `json:"level"`

	// Total Total points contributed to the record Hype Train.
	Total int32 `json:"total"`
} {
	return datatype.SharedAllTimeHigh
}

// GetHypeTrainStatusResponseDataCurrentTopContributionsType The type of the Hype Train. Possible values are:
//
// * **treasure**
// * **golden\_kappa**
// * **regular**
//
// [Learn More](https://help.twitch.tv/s/article/hype-train-guide#special)
type GetHypeTrainStatusResponseDataCurrentTopContributionsType string

// GetModeratedChannelsResponse defines model for GetModeratedChannelsResponse.
type GetModeratedChannelsResponse struct {
	// Data The list of channels that the user has moderator privileges in.
	Data []struct {
		// BroadcasterId An ID that uniquely identifies the channel this user can moderate.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The channels login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The channels display name.
		BroadcasterName string `json:"broadcaster_name"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetModeratedChannelsResponse) GetData() []struct {
	// BroadcasterId An ID that uniquely identifies the channel this user can moderate.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The channels login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The channels display name.
	BroadcasterName string `json:"broadcaster_name"`
} {
	return datatype.Data
}
func (datatype GetModeratedChannelsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetModeratorsResponse defines model for GetModeratorsResponse.
type GetModeratorsResponse struct {
	// Data The list of moderators.
	Data []UserModerator `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetModeratorsResponse) GetData() []UserModerator {
	return datatype.Data
}
func (datatype GetModeratorsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetPollsResponse defines model for GetPollsResponse.
type GetPollsResponse struct {
	// Data A list of polls. The polls are returned in descending order of start time unless you specify IDs in the request, in which case they're returned in the same order as you passed them in the request. The list is empty if the broadcaster hasn't created polls.
	Data []Poll `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetPollsResponse) GetData() []Poll {
	return datatype.Data
}
func (datatype GetPollsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetPredictionsResponse defines model for GetPredictionsResponse.
type GetPredictionsResponse struct {
	// Data The broadcasters list of Channel Points Predictions. The list is sorted in descending ordered by when the prediction began (the most recent prediction is first). The list is empty if the broadcaster hasnt created predictions.
	Data []Prediction `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetPredictionsResponse) GetData() []Prediction {
	return datatype.Data
}
func (datatype GetPredictionsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetReleasedExtensionsResponse defines model for GetReleasedExtensionsResponse.
type GetReleasedExtensionsResponse struct {
	// Data A list that contains the specified extension.
	Data []Extension `json:"data"`
}

func (datatype GetReleasedExtensionsResponse) GetData() []Extension {
	return datatype.Data
}

// GetSharedChatSessionResponse defines model for GetSharedChatSessionResponse.
type GetSharedChatSessionResponse struct {
	Data []struct {
		// CreatedAt The UTC date and time (in RFC3339 format) for when the session was created.
		CreatedAt time.Time `json:"created_at"`

		// HostBroadcasterId The User ID of the host channel.
		HostBroadcasterId string `json:"host_broadcaster_id"`

		// Participants The list of participants in the session.
		Participants []struct {
			// BroadcasterId The User ID of the participant channel.
			BroadcasterId string `json:"broadcaster_id"`
		} `json:"participants"`

		// SessionId The unique identifier for the shared chat session.
		SessionId string `json:"session_id"`

		// UpdatedAt The UTC date and time (in RFC3339 format) for when the session was last updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"data"`
}

func (datatype GetSharedChatSessionResponse) GetData() []struct {
	// CreatedAt The UTC date and time (in RFC3339 format) for when the session was created.
	CreatedAt time.Time `json:"created_at"`

	// HostBroadcasterId The User ID of the host channel.
	HostBroadcasterId string `json:"host_broadcaster_id"`

	// Participants The list of participants in the session.
	Participants []struct {
		// BroadcasterId The User ID of the participant channel.
		BroadcasterId string `json:"broadcaster_id"`
	} `json:"participants"`

	// SessionId The unique identifier for the shared chat session.
	SessionId string `json:"session_id"`

	// UpdatedAt The UTC date and time (in RFC3339 format) for when the session was last updated.
	UpdatedAt time.Time `json:"updated_at"`
} {
	return datatype.Data
}

// GetShieldModeStatusResponse defines model for GetShieldModeStatusResponse.
type GetShieldModeStatusResponse struct {
	// Data A list that contains a single object with the broadcasters Shield Mode status.
	Data []struct {
		// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if the broadcaster activated Shield Mode; otherwise, **false**.
		IsActive bool `json:"is_active"`

		// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated. Is an empty string if Shield Mode hasnt been previously activated.
		LastActivatedAt time.Time `json:"last_activated_at"`

		// ModeratorId An ID that identifies the moderator that last activated Shield Mode. Is an empty string if Shield Mode hasnt been previously activated.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderators login name. Is an empty string if Shield Mode hasnt been previously activated.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderators display name. Is an empty string if Shield Mode hasnt been previously activated.
		ModeratorName string `json:"moderator_name"`
	} `json:"data"`
}

func (datatype GetShieldModeStatusResponse) GetData() []struct {
	// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if the broadcaster activated Shield Mode; otherwise, **false**.
	IsActive bool `json:"is_active"`

	// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated. Is an empty string if Shield Mode hasnt been previously activated.
	LastActivatedAt time.Time `json:"last_activated_at"`

	// ModeratorId An ID that identifies the moderator that last activated Shield Mode. Is an empty string if Shield Mode hasnt been previously activated.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name. Is an empty string if Shield Mode hasnt been previously activated.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name. Is an empty string if Shield Mode hasnt been previously activated.
	ModeratorName string `json:"moderator_name"`
} {
	return datatype.Data
}

// GetStreamKeyResponse defines model for GetStreamKeyResponse.
type GetStreamKeyResponse struct {
	// Data A list that contains the channels stream key.
	Data []struct {
		// StreamKey The channels stream key.
		StreamKey string `json:"stream_key"`
	} `json:"data"`
}

func (datatype GetStreamKeyResponse) GetData() []struct {
	// StreamKey The channels stream key.
	StreamKey string `json:"stream_key"`
} {
	return datatype.Data
}

// GetStreamMarkersResponse defines model for GetStreamMarkersResponse.
type GetStreamMarkersResponse struct {
	// Data The list of markers grouped by the user that created the marks.
	Data []StreamMarkers `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetStreamMarkersResponse) GetData() []StreamMarkers {
	return datatype.Data
}
func (datatype GetStreamMarkersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetStreamTagsResponse defines model for GetStreamTagsResponse.
type GetStreamTagsResponse struct {
	// Data The list of stream tags. The list is empty if the broadcaster or Twitch hasnt added tags to the broadcasters channel.
	Data []StreamTag `json:"data"`
}

func (datatype GetStreamTagsResponse) GetData() []StreamTag {
	return datatype.Data
}

// GetStreamsResponse defines model for GetStreamsResponse.
type GetStreamsResponse struct {
	// Data The list of streams.
	Data []Stream `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetStreamsResponse) GetData() []Stream {
	return datatype.Data
}
func (datatype GetStreamsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetTeamsResponse defines model for GetTeamsResponse.
type GetTeamsResponse struct {
	// Data A list that contains the single team that you requested.
	Data []Team `json:"data"`
}

func (datatype GetTeamsResponse) GetData() []Team {
	return datatype.Data
}

// GetTopGamesResponse defines model for GetTopGamesResponse.
type GetTopGamesResponse struct {
	// Data The list of broadcasts. The broadcasts are sorted by the number of viewers, with the most popular first.
	Data []Game `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ or _before_ query parameter to get the next or previous page of results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetTopGamesResponse) GetData() []Game {
	return datatype.Data
}
func (datatype GetTopGamesResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ or _before_ query parameter to get the next or previous page of results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ or _before_ query parameter to get the next or previous page of results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetUnbanRequestsResponse defines model for GetUnbanRequestsResponse.
type GetUnbanRequestsResponse struct {
	// Data A list that contains information about the channel's unban requests.
	Data []struct {
		// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcaster's login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcaster's display name.
		BroadcasterName string `json:"broadcaster_name"`

		// CreatedAt Timestamp of when the unban request was created.
		CreatedAt time.Time `json:"created_at"`

		// Id Unban request ID.
		Id string `json:"id"`

		// ModeratorId User ID of moderator who approved/denied the request.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderator's login name.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderator's display name.
		ModeratorName string `json:"moderator_name"`

		// ResolutionText Text input by the resolver (moderator) of the unban. request
		ResolutionText string `json:"resolution_text"`

		// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
		ResolvedAt time.Time `json:"resolved_at"`

		// Status Status of the request. One of:
		//
		// * pending
		// * approved
		// * denied
		// * acknowledged
		// * canceled
		Status string `json:"status"`

		// Text Text of the request from the requesting user.
		Text string `json:"text"`

		// UserId User ID of the requestor who is asking for an unban.
		UserId string `json:"user_id"`

		// UserLogin The user's login name.
		UserLogin string `json:"user_login"`

		// UserName The user's display name.
		UserName string `json:"user_name"`
	} `json:"data"`

	// Pagination Contains information used to page through a list of results. The object is empty if there are no more pages left to page through.
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetUnbanRequestsResponse) GetData() []struct {
	// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcaster's login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcaster's display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt Timestamp of when the unban request was created.
	CreatedAt time.Time `json:"created_at"`

	// Id Unban request ID.
	Id string `json:"id"`

	// ModeratorId User ID of moderator who approved/denied the request.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderator's login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderator's display name.
	ModeratorName string `json:"moderator_name"`

	// ResolutionText Text input by the resolver (moderator) of the unban. request
	ResolutionText string `json:"resolution_text"`

	// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
	ResolvedAt time.Time `json:"resolved_at"`

	// Status Status of the request. One of:
	//
	// * pending
	// * approved
	// * denied
	// * acknowledged
	// * canceled
	Status string `json:"status"`

	// Text Text of the request from the requesting user.
	Text string `json:"text"`

	// UserId User ID of the requestor who is asking for an unban.
	UserId string `json:"user_id"`

	// UserLogin The user's login name.
	UserLogin string `json:"user_login"`

	// UserName The user's display name.
	UserName string `json:"user_name"`
} {
	return datatype.Data
}
func (datatype GetUnbanRequestsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetUserActiveExtensionsResponse defines model for GetUserActiveExtensionsResponse.
type GetUserActiveExtensionsResponse struct {
	// Data The active extensions that the broadcaster has installed.
	Data *struct {
		// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
		Component *map[string]UserExtensionComponent `json:"component,omitempty"`

		// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
		Overlay *map[string]UserExtensionOverlay `json:"overlay,omitempty"`

		// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
		Panel *map[string]UserExtensionPanel `json:"panel,omitempty"`
	} `json:"data,omitempty"`
}

func (datatype GetUserActiveExtensionsResponse) GetData() struct {
	// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
	Component *map[string]UserExtensionComponent `json:"component,omitempty"`

	// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
	Overlay *map[string]UserExtensionOverlay `json:"overlay,omitempty"`

	// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
	Panel *map[string]UserExtensionPanel `json:"panel,omitempty"`
} {
	if datatype.Data == nil {
		var empty struct {
			// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
			Component *map[string]UserExtensionComponent `json:"component,omitempty"`

			// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
			Overlay *map[string]UserExtensionOverlay `json:"overlay,omitempty"`

			// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
			Panel *map[string]UserExtensionPanel `json:"panel,omitempty"`
		}
		return empty
	}
	return *datatype.Data
}

// GetUserBlockListResponse defines model for GetUserBlockListResponse.
type GetUserBlockListResponse struct {
	// Data The list of blocked users. The list is in descending order by when the user was blocked.
	Data []UserBlockList `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.[Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetUserBlockListResponse) GetData() []UserBlockList {
	return datatype.Data
}
func (datatype GetUserBlockListResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetUserChatColorResponse defines model for GetUserChatColorResponse.
type GetUserChatColorResponse struct {
	// Data The list of users and the color code they use for their name.
	Data []UserChatColor `json:"data"`
}

func (datatype GetUserChatColorResponse) GetData() []UserChatColor {
	return datatype.Data
}

// GetUserEmotesResponse defines model for GetUserEmotesResponse.
type GetUserEmotesResponse struct {
	Data []struct {
		// EmoteSetId An ID that identifies the emote set that the emote belongs to.
		EmoteSetId string `json:"emote_set_id"`

		// EmoteType The type of emote. The possible values are:
		//
		// * **none**  No emote type was assigned to this emote.
		// * **bitstier**  A Bits tier emote.
		// * **follower**  A follower emote.
		// * **subscriptions**  A subscriber emote.
		// * **channelpoints**  An emote granted by using channel points.
		// * **rewards**  An emote granted to the user through a special event.
		// * **hypetrain**  An emote granted for participation in a Hype Train.
		// * **prime**  An emote granted for linking an Amazon Prime account.
		// * **turbo**  An emote granted for having Twitch Turbo.
		// * **smilies**  Emoticons supported by Twitch.
		// * **globals**  An emote accessible by everyone.
		// * **owl2019**  Emotes related to Overwatch League 2019.
		// * **twofactor**  Emotes granted by enabling two-factor authentication on an account.
		// * **limitedtime**  Emotes that were granted for only a limited time.
		EmoteType GetUserEmotesResponseDataEmoteType `json:"emote_type"`

		// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated.
		//
		// * **animated**  An animated GIF is available for this emote.
		// * **static**  A static PNG file is available for this emote.
		Format []string `json:"format"`

		// Id An ID that uniquely identifies this emote.
		Id string `json:"id"`

		// Name The User ID of broadcaster whose channel is receiving the unban request.
		Name string `json:"name"`

		// OwnerId The ID of the broadcaster who owns the emote.
		OwnerId string `json:"owner_id"`

		// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\.
		//
		// * **1.0**  A small version (28px x 28px) is available.
		// * **2.0**  A medium version (56px x 56px) is available.
		// * **3.0**  A large version (112px x 112px) is available.
		Scale []string `json:"scale"`

		// ThemeMode The background themes that the emote is available in.
		//
		// * **dark**
		// * **light**
		ThemeMode []string `json:"theme_mode"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.
	//
	//  For more information about pagination support, see [Twitch API Guide - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Template A templated URL. Uses the values from the _id_, _format_, _scale_, and _theme\_mode_ fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote.
	//
	//  For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL](https://dev.twitch.tv/docs/irc/emotes#cdn-template) format.
	Template string `json:"template"`
}

func (datatype GetUserEmotesResponse) GetData() []struct {
	// EmoteSetId An ID that identifies the emote set that the emote belongs to.
	EmoteSetId string `json:"emote_set_id"`

	// EmoteType The type of emote. The possible values are:
	//
	// * **none**  No emote type was assigned to this emote.
	// * **bitstier**  A Bits tier emote.
	// * **follower**  A follower emote.
	// * **subscriptions**  A subscriber emote.
	// * **channelpoints**  An emote granted by using channel points.
	// * **rewards**  An emote granted to the user through a special event.
	// * **hypetrain**  An emote granted for participation in a Hype Train.
	// * **prime**  An emote granted for linking an Amazon Prime account.
	// * **turbo**  An emote granted for having Twitch Turbo.
	// * **smilies**  Emoticons supported by Twitch.
	// * **globals**  An emote accessible by everyone.
	// * **owl2019**  Emotes related to Overwatch League 2019.
	// * **twofactor**  Emotes granted by enabling two-factor authentication on an account.
	// * **limitedtime**  Emotes that were granted for only a limited time.
	EmoteType GetUserEmotesResponseDataEmoteType `json:"emote_type"`

	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated.
	//
	// * **animated**  An animated GIF is available for this emote.
	// * **static**  A static PNG file is available for this emote.
	Format []string `json:"format"`

	// Id An ID that uniquely identifies this emote.
	Id string `json:"id"`

	// Name The User ID of broadcaster whose channel is receiving the unban request.
	Name string `json:"name"`

	// OwnerId The ID of the broadcaster who owns the emote.
	OwnerId string `json:"owner_id"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\.
	//
	// * **1.0**  A small version (28px x 28px) is available.
	// * **2.0**  A medium version (56px x 56px) is available.
	// * **3.0**  A large version (112px x 112px) is available.
	Scale []string `json:"scale"`

	// ThemeMode The background themes that the emote is available in.
	//
	// * **dark**
	// * **light**
	ThemeMode []string `json:"theme_mode"`
} {
	return datatype.Data
}
func (datatype GetUserEmotesResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetUserEmotesResponse) GetTemplate() string {
	return datatype.Template
}

// GetUserEmotesResponseDataEmoteType The type of emote. The possible values are:
//
// * **none**  No emote type was assigned to this emote.
// * **bitstier**  A Bits tier emote.
// * **follower**  A follower emote.
// * **subscriptions**  A subscriber emote.
// * **channelpoints**  An emote granted by using channel points.
// * **rewards**  An emote granted to the user through a special event.
// * **hypetrain**  An emote granted for participation in a Hype Train.
// * **prime**  An emote granted for linking an Amazon Prime account.
// * **turbo**  An emote granted for having Twitch Turbo.
// * **smilies**  Emoticons supported by Twitch.
// * **globals**  An emote accessible by everyone.
// * **owl2019**  Emotes related to Overwatch League 2019.
// * **twofactor**  Emotes granted by enabling two-factor authentication on an account.
// * **limitedtime**  Emotes that were granted for only a limited time.
type GetUserEmotesResponseDataEmoteType string

// GetUserExtensionsResponse defines model for GetUserExtensionsResponse.
type GetUserExtensionsResponse struct {
	// Data The list of extensions that the user has installed.
	Data []UserExtension `json:"data"`
}

func (datatype GetUserExtensionsResponse) GetData() []UserExtension {
	return datatype.Data
}

// GetUsersResponse defines model for GetUsersResponse.
type GetUsersResponse struct {
	// Data The list of users.
	Data []User `json:"data"`
}

func (datatype GetUsersResponse) GetData() []User {
	return datatype.Data
}

// GetVIPsResponse defines model for GetVIPsResponse.
type GetVIPsResponse struct {
	// Data The list of VIPs. The list is empty if the broadcaster doesnt have VIP users.
	Data []UserVip `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetVIPsResponse) GetData() []UserVip {
	return datatype.Data
}
func (datatype GetVIPsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetVideosResponse defines model for GetVideosResponse.
type GetVideosResponse struct {
	// Data The list of published videos that match the filter criteria.
	Data []Video `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ or _before_ query parameter depending on whether you're paging forwards or backwards through the results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetVideosResponse) GetData() []Video {
	return datatype.Data
}
func (datatype GetVideosResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ or _before_ query parameter depending on whether you're paging forwards or backwards through the results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ or _before_ query parameter depending on whether you're paging forwards or backwards through the results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GlobalEmote defines model for GlobalEmote.
type GlobalEmote struct {
	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:
	//
	// * animated  An animated GIF is available for this emote.
	// * static  A static PNG file is available for this emote.
	Format []GlobalEmoteFormat `json:"format"`

	// Id An ID that identifies this emote.
	Id string `json:"id"`

	// Images The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.
	//
	// **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
	Images struct {
		// Url1x A URL to the small version (28px x 28px) of the emote.
		Url1x string `json:"url_1x"`

		// Url2x A URL to the medium version (56px x 56px) of the emote.
		Url2x string `json:"url_2x"`

		// Url4x A URL to the large version (112px x 112px) of the emote.
		Url4x string `json:"url_4x"`
	} `json:"images"`

	// Name The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
	Name string `json:"name"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:
	//
	// * 1.0  A small version (28px x 28px) is available.
	// * 2.0  A medium version (56px x 56px) is available.
	// * 3.0  A large version (112px x 112px) is available.
	Scale []GlobalEmoteScale `json:"scale"`

	// ThemeMode The background themes that the emote is available in. Possible themes are:
	//
	// * dark
	// * light
	ThemeMode []GlobalEmoteThemeMode `json:"theme_mode"`
}

func (datatype GlobalEmote) GetFormat() []GlobalEmoteFormat {
	return datatype.Format
}
func (datatype GlobalEmote) GetId() string {
	return datatype.Id
}
func (datatype GlobalEmote) GetImages() struct {
	// Url1x A URL to the small version (28px x 28px) of the emote.
	Url1x string `json:"url_1x"`

	// Url2x A URL to the medium version (56px x 56px) of the emote.
	Url2x string `json:"url_2x"`

	// Url4x A URL to the large version (112px x 112px) of the emote.
	Url4x string `json:"url_4x"`
} {
	return datatype.Images
}
func (datatype GlobalEmote) GetName() string {
	return datatype.Name
}
func (datatype GlobalEmote) GetScale() []GlobalEmoteScale {
	return datatype.Scale
}
func (datatype GlobalEmote) GetThemeMode() []GlobalEmoteThemeMode {
	return datatype.ThemeMode
}

// GlobalEmoteFormat defines model for GlobalEmote.Format.
type GlobalEmoteFormat string

// GlobalEmoteScale defines model for GlobalEmote.Scale.
type GlobalEmoteScale string

// GlobalEmoteThemeMode defines model for GlobalEmote.ThemeMode.
type GlobalEmoteThemeMode string

// Guest defines model for Guest.
type Guest struct {
	// AssignedAt Timestamp when this guest was assigned a slot in the session.
	AssignedAt time.Time `json:"assigned_at"`

	// AudioSettings Information about the guests audio settings
	AudioSettings struct {
		// IsAvailable Flag determining whether the guest has an appropriate audio device available to be transmitted to the session.
		IsAvailable bool `json:"is_available"`

		// IsGuestEnabled Flag determining whether the guest is allowing their audio to be transmitted to the session.
		IsGuestEnabled bool `json:"is_guest_enabled"`

		// IsHostEnabled Flag determining whether the host is allowing the guests audio to be seen or heard within the session.
		IsHostEnabled bool `json:"is_host_enabled"`
	} `json:"audio_settings"`

	// IsLive Flag determining whether or not the guest is visible in the browser source in the hosts streaming software.
	IsLive bool `json:"is_live"`

	// SlotId ID representing this guests slot assignment.
	//
	// * Host is always in slot "0"
	// * Guests are assigned the following consecutive IDs (e.g, "1", "2", "3", etc)
	// * Screen Share is represented as a special guest with the ID "SCREENSHARE"
	// * The identifier here matches the ID referenced in browser source links used in broadcasting software.
	SlotId string `json:"slot_id"`

	// UserDisplayName Display name of the guest assigned to this slot.
	UserDisplayName string `json:"user_display_name"`

	// UserId User ID of the guest assigned to this slot.
	UserId string `json:"user_id"`

	// UserLogin Login of the guest assigned to this slot.
	UserLogin string `json:"user_login"`

	// VideoSettings Information about the guests video settings
	VideoSettings struct {
		// IsAvailable Flag determining whether the guest has an appropriate video device available to be transmitted to the session.
		IsAvailable bool `json:"is_available"`

		// IsGuestEnabled Flag determining whether the guest is allowing their video to be transmitted to the session.
		IsGuestEnabled bool `json:"is_guest_enabled"`

		// IsHostEnabled Flag determining whether the host is allowing the guests video to be seen or heard within the session.
		IsHostEnabled bool `json:"is_host_enabled"`
	} `json:"video_settings"`

	// Volume Value from 0 to 100 representing the hosts volume setting for this guest.
	Volume int32 `json:"volume"`
}

func (datatype Guest) GetAssignedAt() time.Time {
	return datatype.AssignedAt
}
func (datatype Guest) GetAudioSettings() struct {
	// IsAvailable Flag determining whether the guest has an appropriate audio device available to be transmitted to the session.
	IsAvailable bool `json:"is_available"`

	// IsGuestEnabled Flag determining whether the guest is allowing their audio to be transmitted to the session.
	IsGuestEnabled bool `json:"is_guest_enabled"`

	// IsHostEnabled Flag determining whether the host is allowing the guests audio to be seen or heard within the session.
	IsHostEnabled bool `json:"is_host_enabled"`
} {
	return datatype.AudioSettings
}
func (datatype Guest) GetIsLive() bool {
	return datatype.IsLive
}
func (datatype Guest) GetSlotId() string {
	return datatype.SlotId
}
func (datatype Guest) GetUserDisplayName() string {
	return datatype.UserDisplayName
}
func (datatype Guest) GetUserId() string {
	return datatype.UserId
}
func (datatype Guest) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Guest) GetVideoSettings() struct {
	// IsAvailable Flag determining whether the guest has an appropriate video device available to be transmitted to the session.
	IsAvailable bool `json:"is_available"`

	// IsGuestEnabled Flag determining whether the guest is allowing their video to be transmitted to the session.
	IsGuestEnabled bool `json:"is_guest_enabled"`

	// IsHostEnabled Flag determining whether the host is allowing the guests video to be seen or heard within the session.
	IsHostEnabled bool `json:"is_host_enabled"`
} {
	return datatype.VideoSettings
}
func (datatype Guest) GetVolume() int32 {
	return datatype.Volume
}

// GuestStarInvite defines model for GuestStarInvite.
type GuestStarInvite struct {
	// InvitedAt Timestamp when this user was invited to the session.
	InvitedAt time.Time `json:"invited_at"`

	// IsAudioAvailable Flag signaling that the invited user has an audio device available for sharing.
	IsAudioAvailable bool `json:"is_audio_available"`

	// IsAudioEnabled Flag signaling that the invited user has chosen to disable their local audio device. The user has muted themselves, but they may choose to unmute their audio feed upon joining the session.
	IsAudioEnabled bool `json:"is_audio_enabled"`

	// IsVideoAvailable Flag signaling that the invited user has a video device available for sharing.
	IsVideoAvailable bool `json:"is_video_available"`

	// IsVideoEnabled Flag signaling that the invited user has chosen to disable their local video device. The user has hidden themselves, but they may choose to reveal their video feed upon joining the session.
	IsVideoEnabled bool `json:"is_video_enabled"`

	// Status Status representing the invited users join state. Can be one of the following:
	//
	// * `INVITED`: The user has been invited to the session but has not acknowledged it.
	// * `ACCEPTED`: The invited user has acknowledged the invite and joined the waiting room, but may still be setting up their media devices or otherwise preparing to join the call.
	// * `READY`: The invited user has signaled they are ready to join the call from the waiting room.
	Status string `json:"status"`

	// UserId Twitch User ID corresponding to the invited guest
	UserId string `json:"user_id"`
}

func (datatype GuestStarInvite) GetInvitedAt() time.Time {
	return datatype.InvitedAt
}
func (datatype GuestStarInvite) GetIsAudioAvailable() bool {
	return datatype.IsAudioAvailable
}
func (datatype GuestStarInvite) GetIsAudioEnabled() bool {
	return datatype.IsAudioEnabled
}
func (datatype GuestStarInvite) GetIsVideoAvailable() bool {
	return datatype.IsVideoAvailable
}
func (datatype GuestStarInvite) GetIsVideoEnabled() bool {
	return datatype.IsVideoEnabled
}
func (datatype GuestStarInvite) GetStatus() string {
	return datatype.Status
}
func (datatype GuestStarInvite) GetUserId() string {
	return datatype.UserId
}

// GuestStarSession defines model for GuestStarSession.
type GuestStarSession struct {
	// Guests List of guests currently interacting with the Guest Star session.
	Guests []Guest `json:"guests"`

	// Id ID uniquely representing the Guest Star session.
	Id string `json:"id"`
}

func (datatype GuestStarSession) GetGuests() []Guest {
	return datatype.Guests
}
func (datatype GuestStarSession) GetId() string {
	return datatype.Id
}

// HypeTrainEvent defines model for HypeTrainEvent.
type HypeTrainEvent struct {
	// EventData The events data.
	EventData struct {
		// BroadcasterId The ID of the broadcaster thats running the Hype Train.
		BroadcasterId string `json:"broadcaster_id"`

		// CooldownEndTime The UTC date and time (in RFC3339 format) that another Hype Train can start.
		CooldownEndTime time.Time `json:"cooldown_end_time"`

		// ExpiresAt The UTC date and time (in RFC3339 format) that the Hype Train ends.
		ExpiresAt time.Time `json:"expires_at"`

		// Goal The value needed to reach the next level.
		Goal int32 `json:"goal"`

		// Id An ID that identifies this Hype Train.
		Id string `json:"id"`

		// LastContribution The most recent contribution towards the Hype Trains goal.
		LastContribution struct {
			// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
			Total int32 `json:"total"`

			// Type The contribution method used. Possible values are:
			//
			// * BITS  Cheering with Bits.
			// * SUBS  Subscription activity like subscribing or gifting subscriptions.
			// * OTHER  Covers other contribution methods not listed.
			Type HypeTrainEventEventDataLastContributionType `json:"type"`

			// User The ID of the user that made the contribution.
			User string `json:"user"`
		} `json:"last_contribution"`

		// Level The highest level that the Hype Train reached (the levels are 1 through 5).
		Level int32 `json:"level"`

		// StartedAt The UTC date and time (in RFC3339 format) that this Hype Train started.
		StartedAt time.Time `json:"started_at"`

		// TopContributions The top contributors for each contribution type. For example, the top contributor using BITS (by aggregate) and the top contributor using SUBS (by count).
		TopContributions []struct {
			// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
			Total int32 `json:"total"`

			// Type The contribution method used. Possible values are:
			//
			// * BITS  Cheering with Bits.
			// * SUBS  Subscription activity like subscribing or gifting subscriptions.
			// * OTHER  Covers other contribution methods not listed.
			Type HypeTrainEventEventDataTopContributionsType `json:"type"`

			// User The ID of the user that made the contribution.
			User string `json:"user"`
		} `json:"top_contributions"`

		// Total The current total amount raised.
		Total int32 `json:"total"`
	} `json:"event_data"`

	// EventTimestamp The UTC date and time (in RFC3339 format) that the event occurred.
	EventTimestamp time.Time `json:"event_timestamp"`

	// EventType The type of event. The string is in the form, hypetrain.{event\_name}. The request returns only progress event types (i.e., hypetrain.progression).
	EventType string `json:"event_type"`

	// Id An ID that identifies this event.
	Id string `json:"id"`

	// Version The version number of the definition of the events data. For example, the value is 1 if the data in `event_data` uses the first definition of the events data.
	Version string `json:"version"`
}

func (datatype HypeTrainEvent) GetEventData() struct {
	// BroadcasterId The ID of the broadcaster thats running the Hype Train.
	BroadcasterId string `json:"broadcaster_id"`

	// CooldownEndTime The UTC date and time (in RFC3339 format) that another Hype Train can start.
	CooldownEndTime time.Time `json:"cooldown_end_time"`

	// ExpiresAt The UTC date and time (in RFC3339 format) that the Hype Train ends.
	ExpiresAt time.Time `json:"expires_at"`

	// Goal The value needed to reach the next level.
	Goal int32 `json:"goal"`

	// Id An ID that identifies this Hype Train.
	Id string `json:"id"`

	// LastContribution The most recent contribution towards the Hype Trains goal.
	LastContribution struct {
		// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
		Total int32 `json:"total"`

		// Type The contribution method used. Possible values are:
		//
		// * BITS  Cheering with Bits.
		// * SUBS  Subscription activity like subscribing or gifting subscriptions.
		// * OTHER  Covers other contribution methods not listed.
		Type HypeTrainEventEventDataLastContributionType `json:"type"`

		// User The ID of the user that made the contribution.
		User string `json:"user"`
	} `json:"last_contribution"`

	// Level The highest level that the Hype Train reached (the levels are 1 through 5).
	Level int32 `json:"level"`

	// StartedAt The UTC date and time (in RFC3339 format) that this Hype Train started.
	StartedAt time.Time `json:"started_at"`

	// TopContributions The top contributors for each contribution type. For example, the top contributor using BITS (by aggregate) and the top contributor using SUBS (by count).
	TopContributions []struct {
		// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
		Total int32 `json:"total"`

		// Type The contribution method used. Possible values are:
		//
		// * BITS  Cheering with Bits.
		// * SUBS  Subscription activity like subscribing or gifting subscriptions.
		// * OTHER  Covers other contribution methods not listed.
		Type HypeTrainEventEventDataTopContributionsType `json:"type"`

		// User The ID of the user that made the contribution.
		User string `json:"user"`
	} `json:"top_contributions"`

	// Total The current total amount raised.
	Total int32 `json:"total"`
} {
	return datatype.EventData
}
func (datatype HypeTrainEvent) GetEventTimestamp() time.Time {
	return datatype.EventTimestamp
}
func (datatype HypeTrainEvent) GetEventType() string {
	return datatype.EventType
}
func (datatype HypeTrainEvent) GetId() string {
	return datatype.Id
}
func (datatype HypeTrainEvent) GetVersion() string {
	return datatype.Version
}

// HypeTrainEventEventDataLastContributionType The contribution method used. Possible values are:
//
// * BITS  Cheering with Bits.
// * SUBS  Subscription activity like subscribing or gifting subscriptions.
// * OTHER  Covers other contribution methods not listed.
type HypeTrainEventEventDataLastContributionType string

// HypeTrainEventEventDataTopContributionsType The contribution method used. Possible values are:
//
// * BITS  Cheering with Bits.
// * SUBS  Subscription activity like subscribing or gifting subscriptions.
// * OTHER  Covers other contribution methods not listed.
type HypeTrainEventEventDataTopContributionsType string

// ManageHeldAutoModMessagesBody defines model for ManageHeldAutoModMessagesBody.
type ManageHeldAutoModMessagesBody struct {
	// Action The action to take for the message. Possible values are:
	//
	// * ALLOW
	// * DENY
	Action ManageHeldAutoModMessagesBodyAction `json:"action"`

	// MsgId The ID of the message to allow or deny.
	MsgId string `json:"msg_id"`

	// UserId The moderator who is approving or denying the held message. This ID must match the user ID in the access token.
	UserId string `json:"user_id"`
}

func (datatype ManageHeldAutoModMessagesBody) GetAction() ManageHeldAutoModMessagesBodyAction {
	return datatype.Action
}
func (datatype ManageHeldAutoModMessagesBody) GetMsgId() string {
	return datatype.MsgId
}
func (datatype ManageHeldAutoModMessagesBody) GetUserId() string {
	return datatype.UserId
}

// ManageHeldAutoModMessagesBodyAction The action to take for the message. Possible values are:
//
// * ALLOW
// * DENY
type ManageHeldAutoModMessagesBodyAction string

// ModifyChannelInformationBody defines model for ModifyChannelInformationBody.
type ModifyChannelInformationBody struct {
	// BroadcasterLanguage The users preferred language. Set the value to an ISO 639-1 two-letter language code (for example, _en_ for English). Set to other if the users preferred language is not a Twitch supported language. The language isnt updated if the language code isnt a Twitch supported language.
	BroadcasterLanguage *string `json:"broadcaster_language,omitempty"`

	// ContentClassificationLabels List of labels that should be set as the Channels CCLs.
	ContentClassificationLabels *[]struct {
		// Id ID of the [Content Classification Labels](https://help.twitch.tv/s/article/content-classification-labels) that must be added/removed from the channel. Can be one of the following values:
		//
		// * DebatedSocialIssuesAndPolitics
		// * DrugsIntoxication
		// * SexualThemes
		// * ViolentGraphic
		// * Gambling
		// * ProfanityVulgarity
		Id ModifyChannelInformationBodyContentClassificationLabelsId `json:"id"`

		// IsEnabled Boolean flag indicating whether the label should be enabled (true) or disabled for the channel.
		IsEnabled bool `json:"is_enabled"`
	} `json:"content_classification_labels,omitempty"`

	// Delay The number of seconds you want your broadcast buffered before streaming it live. The delay helps ensure fairness during competitive play. Only users with Partner status may set this field. The maximum delay is 900 seconds (15 minutes).
	Delay *int32 `json:"delay,omitempty"`

	// GameId The ID of the game that the user plays. The game is not updated if the ID isnt a game ID that Twitch recognizes. To unset this field, use 0 or  (an empty string).
	GameId *string `json:"game_id,omitempty"`

	// IsBrandedContent Boolean flag indicating if the channel has branded content.
	IsBrandedContent *bool `json:"is_branded_content,omitempty"`

	// Tags A list of channel-defined tags to apply to the channel. To remove all tags from the channel, set tags to an empty array. Tags help identify the content that the channel streams. [Learn More](https://help.twitch.tv/s/article/guide-to-tags)
	//
	// A channel may specify a maximum of 10 tags. Each tag is limited to a maximum of 25 characters and may not be an empty string or contain spaces or special characters. Tags are case insensitive. For readability, consider using camelCasing or PascalCasing.
	Tags *[]string `json:"tags,omitempty"`

	// Title The title of the users stream. You may not set this field to an empty string.
	Title *string `json:"title,omitempty"`
}

func (datatype ModifyChannelInformationBody) GetBroadcasterLanguage() string {
	if datatype.BroadcasterLanguage == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterLanguage
}
func (datatype ModifyChannelInformationBody) GetContentClassificationLabels() []struct {
	// Id ID of the [Content Classification Labels](https://help.twitch.tv/s/article/content-classification-labels) that must be added/removed from the channel. Can be one of the following values:
	//
	// * DebatedSocialIssuesAndPolitics
	// * DrugsIntoxication
	// * SexualThemes
	// * ViolentGraphic
	// * Gambling
	// * ProfanityVulgarity
	Id ModifyChannelInformationBodyContentClassificationLabelsId `json:"id"`

	// IsEnabled Boolean flag indicating whether the label should be enabled (true) or disabled for the channel.
	IsEnabled bool `json:"is_enabled"`
} {
	if datatype.ContentClassificationLabels == nil {
		var empty []struct {
			// Id ID of the [Content Classification Labels](https://help.twitch.tv/s/article/content-classification-labels) that must be added/removed from the channel. Can be one of the following values:
			//
			// * DebatedSocialIssuesAndPolitics
			// * DrugsIntoxication
			// * SexualThemes
			// * ViolentGraphic
			// * Gambling
			// * ProfanityVulgarity
			Id ModifyChannelInformationBodyContentClassificationLabelsId `json:"id"`

			// IsEnabled Boolean flag indicating whether the label should be enabled (true) or disabled for the channel.
			IsEnabled bool `json:"is_enabled"`
		}
		return empty
	}
	return *datatype.ContentClassificationLabels
}
func (datatype ModifyChannelInformationBody) GetDelay() int32 {
	if datatype.Delay == nil {
		var empty int32
		return empty
	}
	return *datatype.Delay
}
func (datatype ModifyChannelInformationBody) GetGameId() string {
	if datatype.GameId == nil {
		var empty string
		return empty
	}
	return *datatype.GameId
}
func (datatype ModifyChannelInformationBody) GetIsBrandedContent() bool {
	if datatype.IsBrandedContent == nil {
		var empty bool
		return empty
	}
	return *datatype.IsBrandedContent
}
func (datatype ModifyChannelInformationBody) GetTags() []string {
	if datatype.Tags == nil {
		var empty []string
		return empty
	}
	return *datatype.Tags
}
func (datatype ModifyChannelInformationBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// ModifyChannelInformationBodyContentClassificationLabelsId ID of the [Content Classification Labels](https://help.twitch.tv/s/article/content-classification-labels) that must be added/removed from the channel. Can be one of the following values:
//
// * DebatedSocialIssuesAndPolitics
// * DrugsIntoxication
// * SexualThemes
// * ViolentGraphic
// * Gambling
// * ProfanityVulgarity
type ModifyChannelInformationBodyContentClassificationLabelsId string

// Poll defines model for Poll.
type Poll struct {
	// BitsPerVote Not used; will be set to 0.
	BitsPerVote int32 `json:"bits_per_vote"`

	// BitsVotingEnabled Not used; will be set to **false**.
	BitsVotingEnabled bool `json:"bits_voting_enabled"`

	// BroadcasterId An ID that identifies the broadcaster that created the poll.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// ChannelPointsPerVote The number of points the viewer must spend to cast one additional vote.
	ChannelPointsPerVote int32 `json:"channel_points_per_vote"`

	// ChannelPointsVotingEnabled A Boolean value that indicates whether viewers may cast additional votes using Channel Points. For information about Channel Points, see [Channel Points Guide](https://help.twitch.tv/s/article/channel-points-guide).
	ChannelPointsVotingEnabled bool `json:"channel_points_voting_enabled"`

	// Choices A list of choices that viewers can choose from. The list will contain a minimum of two choices and up to a maximum of five choices.
	Choices []struct {
		// BitsVotes Not used; will be set to 0.
		BitsVotes int32 `json:"bits_votes"`

		// ChannelPointsVotes The number of votes cast using Channel Points.
		ChannelPointsVotes int32 `json:"channel_points_votes"`

		// Id An ID that identifies this choice.
		Id string `json:"id"`

		// Title The choices title. The title may contain a maximum of 25 characters.
		Title string `json:"title"`

		// Votes The total number of votes cast for this choice.
		Votes int32 `json:"votes"`
	} `json:"choices"`

	// Duration The length of time (in seconds) that the poll will run for.
	Duration int32 `json:"duration"`

	// EndedAt The UTC date and time (in RFC3339 format) of when the poll ended. If `status` is ACTIVE, this field is set to **null**.
	EndedAt *time.Time `json:"ended_at"`

	// Id An ID that identifies the poll.
	Id string `json:"id"`

	// StartedAt The UTC date and time (in RFC3339 format) of when the poll began.
	StartedAt time.Time `json:"started_at"`

	// Status The polls status. Valid values are:
	//
	// * ACTIVE  The poll is running.
	// * COMPLETED  The poll ended on schedule (see the `duration` field).
	// * TERMINATED  The poll was terminated before its scheduled end.
	// * ARCHIVED  The poll has been archived and is no longer visible on the channel.
	// * MODERATED  The poll was deleted.
	// * INVALID  Something went wrong while determining the state.
	Status PollStatus `json:"status"`

	// Title The question that viewers are voting on. For example, _What game should I play next?_ The title may contain a maximum of 60 characters.
	Title string `json:"title"`
}

func (datatype Poll) GetBitsPerVote() int32 {
	return datatype.BitsPerVote
}
func (datatype Poll) GetBitsVotingEnabled() bool {
	return datatype.BitsVotingEnabled
}
func (datatype Poll) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype Poll) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype Poll) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype Poll) GetChannelPointsPerVote() int32 {
	return datatype.ChannelPointsPerVote
}
func (datatype Poll) GetChannelPointsVotingEnabled() bool {
	return datatype.ChannelPointsVotingEnabled
}
func (datatype Poll) GetChoices() []struct {
	// BitsVotes Not used; will be set to 0.
	BitsVotes int32 `json:"bits_votes"`

	// ChannelPointsVotes The number of votes cast using Channel Points.
	ChannelPointsVotes int32 `json:"channel_points_votes"`

	// Id An ID that identifies this choice.
	Id string `json:"id"`

	// Title The choices title. The title may contain a maximum of 25 characters.
	Title string `json:"title"`

	// Votes The total number of votes cast for this choice.
	Votes int32 `json:"votes"`
} {
	return datatype.Choices
}
func (datatype Poll) GetDuration() int32 {
	return datatype.Duration
}
func (datatype Poll) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype Poll) GetId() string {
	return datatype.Id
}
func (datatype Poll) GetStartedAt() time.Time {
	return datatype.StartedAt
}
func (datatype Poll) GetStatus() PollStatus {
	return datatype.Status
}
func (datatype Poll) GetTitle() string {
	return datatype.Title
}

// PollStatus The polls status. Valid values are:
//
// * ACTIVE  The poll is running.
// * COMPLETED  The poll ended on schedule (see the `duration` field).
// * TERMINATED  The poll was terminated before its scheduled end.
// * ARCHIVED  The poll has been archived and is no longer visible on the channel.
// * MODERATED  The poll was deleted.
// * INVALID  Something went wrong while determining the state.
type PollStatus string

// Prediction defines model for Prediction.
type Prediction struct {
	// BroadcasterId An ID that identifies the broadcaster that created the prediction.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The UTC date and time of when the Prediction began.
	CreatedAt time.Time `json:"created_at"`

	// EndedAt The UTC date and time of when the Prediction ended. If `status` is ACTIVE, this is set to **null**.
	EndedAt *time.Time `json:"ended_at"`

	// Id An ID that identifies this prediction.
	Id string `json:"id"`

	// LockedAt The UTC date and time of when the Prediction was locked. If `status` is not LOCKED, this is set to **null**.
	LockedAt *time.Time `json:"locked_at"`

	// Outcomes The list of possible outcomes for the prediction.
	Outcomes []PredictionOutcome `json:"outcomes"`

	// PredictionWindow The length of time (in seconds) that the prediction will run for.
	PredictionWindow int32 `json:"prediction_window"`

	// Status The predictions status. Valid values are:
	//
	// * ACTIVE  The Prediction is running and viewers can make predictions.
	// * CANCELED  The broadcaster canceled the Prediction and refunded the Channel Points to the participants.
	// * LOCKED  The broadcaster locked the Prediction, which means viewers can no longer make predictions.
	// * RESOLVED  The winning outcome was determined and the Channel Points were distributed to the viewers who predicted the correct outcome.
	Status PredictionStatus `json:"status"`

	// Title The question that the prediction asks. For example, _Will I finish this entire pizza?_
	Title string `json:"title"`

	// WinningOutcomeId The ID of the winning outcome. Is **null** unless `status` is RESOLVED.
	WinningOutcomeId *string `json:"winning_outcome_id"`
}

func (datatype Prediction) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype Prediction) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype Prediction) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype Prediction) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Prediction) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype Prediction) GetId() string {
	return datatype.Id
}
func (datatype Prediction) GetLockedAt() time.Time {
	if datatype.LockedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.LockedAt
}
func (datatype Prediction) GetOutcomes() []PredictionOutcome {
	return datatype.Outcomes
}
func (datatype Prediction) GetPredictionWindow() int32 {
	return datatype.PredictionWindow
}
func (datatype Prediction) GetStatus() PredictionStatus {
	return datatype.Status
}
func (datatype Prediction) GetTitle() string {
	return datatype.Title
}
func (datatype Prediction) GetWinningOutcomeId() string {
	if datatype.WinningOutcomeId == nil {
		var empty string
		return empty
	}
	return *datatype.WinningOutcomeId
}

// PredictionStatus The predictions status. Valid values are:
//
// * ACTIVE  The Prediction is running and viewers can make predictions.
// * CANCELED  The broadcaster canceled the Prediction and refunded the Channel Points to the participants.
// * LOCKED  The broadcaster locked the Prediction, which means viewers can no longer make predictions.
// * RESOLVED  The winning outcome was determined and the Channel Points were distributed to the viewers who predicted the correct outcome.
type PredictionStatus string

// PredictionOutcome defines model for PredictionOutcome.
type PredictionOutcome struct {
	// ChannelPoints The number of Channel Points spent by viewers on this outcome.
	ChannelPoints int32 `json:"channel_points"`

	// Color The color that visually identifies this outcome in the UX. Possible values are:
	//
	// * BLUE
	// * PINK
	//
	// If the number of outcomes is two, the color is BLUE for the first outcome and PINK for the second outcome. If there are more than two outcomes, the color is BLUE for all outcomes.
	Color PredictionOutcomeColor `json:"color"`

	// Id An ID that identifies this outcome.
	Id string `json:"id"`

	// Title The outcomes text.
	Title string `json:"title"`

	// TopPredictors A list of viewers who were the top predictors; otherwise, **null** if none.
	TopPredictors *[]struct {
		// ChannelPointsUsed The number of Channel Points the viewer spent.
		ChannelPointsUsed int32 `json:"channel_points_used"`

		// ChannelPointsWon The number of Channel Points distributed to the viewer.
		ChannelPointsWon int32 `json:"channel_points_won"`

		// UserId An ID that identifies the viewer.
		UserId string `json:"user_id"`

		// UserLogin The viewers login name.
		UserLogin string `json:"user_login"`

		// UserName The viewers display name.
		UserName string `json:"user_name"`
	} `json:"top_predictors"`

	// Users The number of unique viewers that chose this outcome.
	Users int32 `json:"users"`
}

func (datatype PredictionOutcome) GetChannelPoints() int32 {
	return datatype.ChannelPoints
}
func (datatype PredictionOutcome) GetColor() PredictionOutcomeColor {
	return datatype.Color
}
func (datatype PredictionOutcome) GetId() string {
	return datatype.Id
}
func (datatype PredictionOutcome) GetTitle() string {
	return datatype.Title
}
func (datatype PredictionOutcome) GetTopPredictors() []struct {
	// ChannelPointsUsed The number of Channel Points the viewer spent.
	ChannelPointsUsed int32 `json:"channel_points_used"`

	// ChannelPointsWon The number of Channel Points distributed to the viewer.
	ChannelPointsWon int32 `json:"channel_points_won"`

	// UserId An ID that identifies the viewer.
	UserId string `json:"user_id"`

	// UserLogin The viewers login name.
	UserLogin string `json:"user_login"`

	// UserName The viewers display name.
	UserName string `json:"user_name"`
} {
	if datatype.TopPredictors == nil {
		var empty []struct {
			// ChannelPointsUsed The number of Channel Points the viewer spent.
			ChannelPointsUsed int32 `json:"channel_points_used"`

			// ChannelPointsWon The number of Channel Points distributed to the viewer.
			ChannelPointsWon int32 `json:"channel_points_won"`

			// UserId An ID that identifies the viewer.
			UserId string `json:"user_id"`

			// UserLogin The viewers login name.
			UserLogin string `json:"user_login"`

			// UserName The viewers display name.
			UserName string `json:"user_name"`
		}
		return empty
	}
	return *datatype.TopPredictors
}
func (datatype PredictionOutcome) GetUsers() int32 {
	return datatype.Users
}

// PredictionOutcomeColor The color that visually identifies this outcome in the UX. Possible values are:
//
// * BLUE
// * PINK
//
// If the number of outcomes is two, the color is BLUE for the first outcome and PINK for the second outcome. If there are more than two outcomes, the color is BLUE for all outcomes.
type PredictionOutcomeColor string

// ResolveUnbanRequestsResponse defines model for ResolveUnbanRequestsResponse.
type ResolveUnbanRequestsResponse struct {
	Data []struct {
		// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// CreatedAt Timestamp of when the unban request was created.
		CreatedAt time.Time `json:"created_at"`

		// Id Unban request ID.
		Id string `json:"id"`

		// ModeratorId User ID of moderator who approved/denied the request.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderators login name.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderators display name.
		ModeratorName string `json:"moderator_name"`

		// ResolutionText Text input by the resolver (moderator) of the unban request.
		ResolutionText string `json:"resolution_text"`

		// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
		ResolvedAt time.Time `json:"resolved_at"`

		// Status Status of the request. One of:
		//
		// * approved
		// * denied
		Status string `json:"status"`

		// Text Text of the request from the requesting user.
		Text string `json:"text"`

		// UserId User ID of the requestor who is asking for an unban.
		UserId string `json:"user_id"`

		// UserLogin The users login name.
		UserLogin string `json:"user_login"`

		// UserName The users display name.
		UserName string `json:"user_name"`
	} `json:"data"`
}

func (datatype ResolveUnbanRequestsResponse) GetData() []struct {
	// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt Timestamp of when the unban request was created.
	CreatedAt time.Time `json:"created_at"`

	// Id Unban request ID.
	Id string `json:"id"`

	// ModeratorId User ID of moderator who approved/denied the request.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name.
	ModeratorName string `json:"moderator_name"`

	// ResolutionText Text input by the resolver (moderator) of the unban request.
	ResolutionText string `json:"resolution_text"`

	// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
	ResolvedAt time.Time `json:"resolved_at"`

	// Status Status of the request. One of:
	//
	// * approved
	// * denied
	Status string `json:"status"`

	// Text Text of the request from the requesting user.
	Text string `json:"text"`

	// UserId User ID of the requestor who is asking for an unban.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
} {
	return datatype.Data
}

// SearchCategoriesResponse defines model for SearchCategoriesResponse.
type SearchCategoriesResponse struct {
	// Data The list of games or categories that match the query. The list is empty if there are no matches.
	Data []Category `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.[Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype SearchCategoriesResponse) GetData() []Category {
	return datatype.Data
}
func (datatype SearchCategoriesResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// SearchChannelsResponse defines model for SearchChannelsResponse.
type SearchChannelsResponse struct {
	// Data The list of channels that match the query. The list is empty if there are no matches.
	Data []Channel `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.[Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype SearchChannelsResponse) GetData() []Channel {
	return datatype.Data
}
func (datatype SearchChannelsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// SendChatAnnouncementBody defines model for SendChatAnnouncementBody.
type SendChatAnnouncementBody struct {
	// Color The color used to highlight the announcement. Possible case-sensitive values are:
	//
	// * blue
	// * green
	// * orange
	// * purple
	// * primary (default)
	//
	// If `color` is set to _primary_ or is not set, the channels accent color is used to highlight the announcement (see **Profile Accent Color** under [profile settings](https://www.twitch.tv/settings/profile), **Channel and Videos**, and **Brand**).
	Color *SendChatAnnouncementBodyColor `json:"color,omitempty"`

	// Message The announcement to make in the broadcasters chat room. Announcements are limited to a maximum of 500 characters; announcements longer than 500 characters are truncated.
	Message string `json:"message"`
}

func (datatype SendChatAnnouncementBody) GetColor() SendChatAnnouncementBodyColor {
	if datatype.Color == nil {
		var empty SendChatAnnouncementBodyColor
		return empty
	}
	return *datatype.Color
}
func (datatype SendChatAnnouncementBody) GetMessage() string {
	return datatype.Message
}

// SendChatAnnouncementBodyColor The color used to highlight the announcement. Possible case-sensitive values are:
//
// * blue
// * green
// * orange
// * purple
// * primary (default)
//
// If `color` is set to _primary_ or is not set, the channels accent color is used to highlight the announcement (see **Profile Accent Color** under [profile settings](https://www.twitch.tv/settings/profile), **Channel and Videos**, and **Brand**).
type SendChatAnnouncementBodyColor string

// SendChatMessageBody defines model for SendChatMessageBody.
type SendChatMessageBody struct {
	// BroadcasterId The ID of the broadcaster whose chat room the message will be sent to.
	BroadcasterId string `json:"broadcaster_id"`

	// ForSourceOnly **NOTE:** This parameter can only be set when utilizing an App Access Token. It cannot be specified when a User Access Token is used, and will instead result in an HTTP 400 error.
	//
	// Determines if the chat message is sent only to the source channel (defined by _broadcaster\_id_) during a shared chat session. This has no effect if the message is sent during a shared chat session.
	//
	// If this parameter is not set, the default value when using an App Access Token is `false`. On May 19, 2025 the default value for this parameter will be updated to `true`, and chat messages sent using an App Access Token will only be shared with the source channel by default. If you prefer to send a chat message to both channels in a shared chat session, make sure this parameter is explicitly set to `false` in your API request before May 19.
	ForSourceOnly *bool `json:"for_source_only,omitempty"`

	// Message The message to send. The message is limited to a maximum of 500 characters. Chat messages can also include emoticons. To include emoticons, use the name of the emote. The names are case sensitive. Dont include colons around the name (e.g., :bleedPurple:). If Twitch recognizes the name, Twitch converts the name to the emote before writing the chat message to the chat room
	Message string `json:"message"`

	// ReplyParentMessageId The ID of the chat message being replied to.
	ReplyParentMessageId *string `json:"reply_parent_message_id,omitempty"`

	// SenderId The ID of the user sending the message. This ID must match the user ID in the user access token.
	SenderId string `json:"sender_id"`
}

func (datatype SendChatMessageBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype SendChatMessageBody) GetForSourceOnly() bool {
	if datatype.ForSourceOnly == nil {
		var empty bool
		return empty
	}
	return *datatype.ForSourceOnly
}
func (datatype SendChatMessageBody) GetMessage() string {
	return datatype.Message
}
func (datatype SendChatMessageBody) GetReplyParentMessageId() string {
	if datatype.ReplyParentMessageId == nil {
		var empty string
		return empty
	}
	return *datatype.ReplyParentMessageId
}
func (datatype SendChatMessageBody) GetSenderId() string {
	return datatype.SenderId
}

// SendChatMessageResponse defines model for SendChatMessageResponse.
type SendChatMessageResponse struct {
	Data []struct {
		// DropReason The reason the message was dropped, if any.
		DropReason *struct {
			// Code Code for why the message was dropped.
			Code string `json:"code"`

			// Message Message for why the message was dropped.
			Message string `json:"message"`
		} `json:"drop_reason,omitempty"`

		// IsSent If the message passed all checks and was sent.
		IsSent bool `json:"is_sent"`

		// MessageId The message id for the message that was sent.
		MessageId string `json:"message_id"`
	} `json:"data"`
}

func (datatype SendChatMessageResponse) GetData() []struct {
	// DropReason The reason the message was dropped, if any.
	DropReason *struct {
		// Code Code for why the message was dropped.
		Code string `json:"code"`

		// Message Message for why the message was dropped.
		Message string `json:"message"`
	} `json:"drop_reason,omitempty"`

	// IsSent If the message passed all checks and was sent.
	IsSent bool `json:"is_sent"`

	// MessageId The message id for the message that was sent.
	MessageId string `json:"message_id"`
} {
	return datatype.Data
}

// SendExtensionChatMessageBody defines model for SendExtensionChatMessageBody.
type SendExtensionChatMessageBody struct {
	// ExtensionId The ID of the extension thats sending the chat message.
	ExtensionId string `json:"extension_id"`

	// ExtensionVersion The extensions version number.
	ExtensionVersion string `json:"extension_version"`

	// Text The message. The message may contain a maximum of 280 characters.
	Text string `json:"text"`
}

func (datatype SendExtensionChatMessageBody) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype SendExtensionChatMessageBody) GetExtensionVersion() string {
	return datatype.ExtensionVersion
}
func (datatype SendExtensionChatMessageBody) GetText() string {
	return datatype.Text
}

// SendExtensionPubSubMessageBody defines model for SendExtensionPubSubMessageBody.
type SendExtensionPubSubMessageBody struct {
	// BroadcasterId The ID of the broadcaster to send the message to. Dont include this field if `is_global_broadcast` is set to **true**.
	BroadcasterId string `json:"broadcaster_id"`

	// IsGlobalBroadcast A Boolean value that determines whether the message should be sent to all channels where your extension is active. Set to **true** if the message should be sent to all channels. The default is **false**.
	IsGlobalBroadcast *bool `json:"is_global_broadcast,omitempty"`

	// Message The message to send. The message can be a plain-text string or a string-encoded JSON object. The message is limited to a maximum of 5 KB.
	Message string `json:"message"`

	// Target The target of the message. Possible values are:
	//
	// * broadcast
	// * global
	// * whisper-<user-id>
	//
	// If `is_global_broadcast` is **true**, you must set this field to global. The broadcast and global values are mutually exclusive; specify only one of them.
	Target []SendExtensionPubSubMessageBodyTarget `json:"target"`
}

func (datatype SendExtensionPubSubMessageBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype SendExtensionPubSubMessageBody) GetIsGlobalBroadcast() bool {
	if datatype.IsGlobalBroadcast == nil {
		var empty bool
		return empty
	}
	return *datatype.IsGlobalBroadcast
}
func (datatype SendExtensionPubSubMessageBody) GetMessage() string {
	return datatype.Message
}
func (datatype SendExtensionPubSubMessageBody) GetTarget() []SendExtensionPubSubMessageBodyTarget {
	return datatype.Target
}

// SendExtensionPubSubMessageBodyTarget defines model for SendExtensionPubSubMessageBody.Target.
type SendExtensionPubSubMessageBodyTarget string

// SendWhisperBody defines model for SendWhisperBody.
type SendWhisperBody struct {
	// Message The whisper message to send. The message must not be empty.
	//
	// The maximum message lengths are:
	//
	// * 500 characters if the user you're sending the message to hasn't whispered you before.
	// * 10,000 characters if the user you're sending the message to has whispered you before.
	//
	// Messages that exceed the maximum length are truncated.
	Message string `json:"message"`
}

func (datatype SendWhisperBody) GetMessage() string {
	return datatype.Message
}

// SetExtensionConfigurationSegmentBody defines model for SetExtensionConfigurationSegmentBody.
type SetExtensionConfigurationSegmentBody struct {
	// BroadcasterId The ID of the broadcaster that installed the extension. Include this field only if the `segment` is set to developer or broadcaster.
	BroadcasterId *string `json:"broadcaster_id,omitempty"`

	// Content The contents of the segment. This string may be a plain-text string or a string-encoded JSON object.
	Content *string `json:"content,omitempty"`

	// ExtensionId The ID of the extension to update.
	ExtensionId string `json:"extension_id"`

	// Segment The configuration segment to update. Possible case-sensitive values are:
	//
	// * broadcaster
	// * developer
	// * global
	Segment SetExtensionConfigurationSegmentBodySegment `json:"segment"`

	// Version The version number that identifies this definition of the segments data. If not specified, the latest definition is updated.
	Version *string `json:"version,omitempty"`
}

func (datatype SetExtensionConfigurationSegmentBody) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype SetExtensionConfigurationSegmentBody) GetContent() string {
	if datatype.Content == nil {
		var empty string
		return empty
	}
	return *datatype.Content
}
func (datatype SetExtensionConfigurationSegmentBody) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype SetExtensionConfigurationSegmentBody) GetSegment() SetExtensionConfigurationSegmentBodySegment {
	return datatype.Segment
}
func (datatype SetExtensionConfigurationSegmentBody) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// SetExtensionConfigurationSegmentBodySegment The configuration segment to update. Possible case-sensitive values are:
//
// * broadcaster
// * developer
// * global
type SetExtensionConfigurationSegmentBodySegment string

// SetExtensionRequiredConfigurationBody defines model for SetExtensionRequiredConfigurationBody.
type SetExtensionRequiredConfigurationBody struct {
	// ExtensionId The ID of the extension to update.
	ExtensionId string `json:"extension_id"`

	// ExtensionVersion The version of the extension to update.
	ExtensionVersion string `json:"extension_version"`

	// RequiredConfiguration The required\_configuration string to use with the extension.
	RequiredConfiguration string `json:"required_configuration"`
}

func (datatype SetExtensionRequiredConfigurationBody) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype SetExtensionRequiredConfigurationBody) GetExtensionVersion() string {
	return datatype.ExtensionVersion
}
func (datatype SetExtensionRequiredConfigurationBody) GetRequiredConfiguration() string {
	return datatype.RequiredConfiguration
}

// SnoozeNextAdResponse defines model for SnoozeNextAdResponse.
type SnoozeNextAdResponse struct {
	// Data A list that contains information about the channels snoozes and next upcoming ad after successfully snoozing.
	Data []struct {
		// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format.
		NextAdAt time.Time `json:"next_ad_at"`

		// SnoozeCount The number of snoozes available for the broadcaster.
		SnoozeCount int32 `json:"snooze_count"`

		// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
		SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
	} `json:"data"`
}

func (datatype SnoozeNextAdResponse) GetData() []struct {
	// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format.
	NextAdAt time.Time `json:"next_ad_at"`

	// SnoozeCount The number of snoozes available for the broadcaster.
	SnoozeCount int32 `json:"snooze_count"`

	// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
	SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
} {
	return datatype.Data
}

// StartCommercialBody defines model for StartCommercialBody.
type StartCommercialBody struct {
	// BroadcasterId The ID of the partner or affiliate broadcaster that wants to run the commercial. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `json:"broadcaster_id"`

	// Length The length of the commercial to run, in seconds. Twitch tries to serve a commercial thats the requested length, but it may be shorter or longer. The maximum length you should request is 180 seconds.
	Length int32 `json:"length"`
}

func (datatype StartCommercialBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype StartCommercialBody) GetLength() int32 {
	return datatype.Length
}

// StartCommercialResponse defines model for StartCommercialResponse.
type StartCommercialResponse struct {
	// Data An array that contains a single object with the status of your start commercial request.
	Data []struct {
		// Length The length of the commercial you requested. If you request a commercial thats longer than 180 seconds, the API uses 180 seconds.
		Length int32 `json:"length"`

		// Message A message that indicates whether Twitch was able to serve an ad.
		Message string `json:"message"`

		// RetryAfter The number of seconds you must wait before running another commercial.
		RetryAfter int32 `json:"retry_after"`
	} `json:"data"`
}

func (datatype StartCommercialResponse) GetData() []struct {
	// Length The length of the commercial you requested. If you request a commercial thats longer than 180 seconds, the API uses 180 seconds.
	Length int32 `json:"length"`

	// Message A message that indicates whether Twitch was able to serve an ad.
	Message string `json:"message"`

	// RetryAfter The number of seconds you must wait before running another commercial.
	RetryAfter int32 `json:"retry_after"`
} {
	return datatype.Data
}

// StartRaidResponse defines model for StartRaidResponse.
type StartRaidResponse struct {
	// Data A list that contains a single object with information about the pending raid.
	Data []struct {
		// CreatedAt The UTC date and time, in RFC3339 format, of when the raid was requested.
		CreatedAt time.Time `json:"created_at"`

		// IsMature A Boolean value that indicates whether the channel being raided contains mature content.
		IsMature bool `json:"is_mature"`
	} `json:"data"`
}

func (datatype StartRaidResponse) GetData() []struct {
	// CreatedAt The UTC date and time, in RFC3339 format, of when the raid was requested.
	CreatedAt time.Time `json:"created_at"`

	// IsMature A Boolean value that indicates whether the channel being raided contains mature content.
	IsMature bool `json:"is_mature"`
} {
	return datatype.Data
}

// Stream defines model for Stream.
type Stream struct {
	// GameId The ID of the category or game being played.
	GameId string `json:"game_id"`

	// GameName The ID of the category or game being played.
	GameName string `json:"game_name"`

	// Id An ID that identifies the stream. You can use this ID later to look up the video on demand (VOD).
	Id string `json:"id"`

	// IsMature A Boolean value that indicates whether the stream is meant for mature audiences.
	IsMature bool `json:"is_mature"`

	// Language The language that the stream uses. This is an ISO 639-1 two-letter language code or _other_ if the stream uses a language not in the list of [supported stream languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang).
	Language string `json:"language"`

	// StartedAt The UTC date and time (in RFC3339 format) of when the broadcast began.
	StartedAt time.Time `json:"started_at"`

	// TagIds **IMPORTANT** As of February 28, 2023, this field is deprecated and returns only an empty array. If you use this field, please update your code to use the `tags` field.
	//
	// The list of tags that apply to the stream. The list contains IDs only when the channel is steaming live. For a list of possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags). The list doesnt include Category Tags.
	// Deprecated:
	TagIds []string `json:"tag_ids"`

	// Tags The tags applied to the stream.
	Tags []string `json:"tags"`

	// ThumbnailUrl A URL to an image of a frame from the last 5 minutes of the stream. Replace the width and height placeholders in the URL (`{width}x{height}`) with the size of the image you want, in pixels.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The streams title. Is an empty string if not set.
	Title string `json:"title"`

	// Type The type of stream. Possible values are:
	//
	// * live
	//
	// If an error occurs, this field is set to an empty string.
	Type StreamType `json:"type"`

	// UserId The ID of the user thats broadcasting the stream.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`

	// ViewerCount The number of users watching the stream.
	ViewerCount int32 `json:"viewer_count"`
}

func (datatype Stream) GetGameId() string {
	return datatype.GameId
}
func (datatype Stream) GetGameName() string {
	return datatype.GameName
}
func (datatype Stream) GetId() string {
	return datatype.Id
}
func (datatype Stream) GetIsMature() bool {
	return datatype.IsMature
}
func (datatype Stream) GetLanguage() string {
	return datatype.Language
}
func (datatype Stream) GetStartedAt() time.Time {
	return datatype.StartedAt
}
func (datatype Stream) GetTagIds() []string {
	return datatype.TagIds
}
func (datatype Stream) GetTags() []string {
	return datatype.Tags
}
func (datatype Stream) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Stream) GetTitle() string {
	return datatype.Title
}
func (datatype Stream) GetType() StreamType {
	return datatype.Type
}
func (datatype Stream) GetUserId() string {
	return datatype.UserId
}
func (datatype Stream) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Stream) GetUserName() string {
	return datatype.UserName
}
func (datatype Stream) GetViewerCount() int32 {
	return datatype.ViewerCount
}

// StreamType The type of stream. Possible values are:
//
// * live
//
// If an error occurs, this field is set to an empty string.
type StreamType string

// StreamMarkerCreated defines model for StreamMarkerCreated.
type StreamMarkerCreated struct {
	// CreatedAt The UTC date and time (in RFC3339 format) of when the user created the marker.
	CreatedAt time.Time `json:"created_at"`

	// Description A description that the user gave the marker to help them remember why they marked the location.
	Description string `json:"description"`

	// Id An ID that identifies this marker.
	Id string `json:"id"`

	// PositionSeconds The relative offset (in seconds) of the marker from the beginning of the stream.
	PositionSeconds int32 `json:"position_seconds"`
}

func (datatype StreamMarkerCreated) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype StreamMarkerCreated) GetDescription() string {
	return datatype.Description
}
func (datatype StreamMarkerCreated) GetId() string {
	return datatype.Id
}
func (datatype StreamMarkerCreated) GetPositionSeconds() int32 {
	return datatype.PositionSeconds
}

// StreamMarkers defines model for StreamMarkers.
type StreamMarkers struct {
	// Markers The list of markers in this video. The list in ascending order by when the marker was created.
	Markers []struct {
		// CreatedAt The UTC date and time (in RFC3339 format) of when the user created the marker.
		CreatedAt time.Time `json:"created_at"`

		// Description The description that the user gave the marker to help them remember why they marked the location. Is an empty string if the user didnt provide one.
		Description string `json:"description"`

		// Id An ID that identifies this marker.
		Id string `json:"id"`

		// PositionSeconds The relative offset (in seconds) of the marker from the beginning of the stream.
		PositionSeconds int32 `json:"position_seconds"`

		// Url A URL that opens the video in Twitch Highlighter.
		Url string `json:"url"`
	} `json:"markers"`

	// UserId The ID of the user that created the marker.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`

	// VideoId An ID that identifies this video.
	VideoId string `json:"video_id"`

	// Videos A list of videos that contain markers. The list contains a single video.
	Videos []map[string]interface{} `json:"videos"`
}

func (datatype StreamMarkers) GetMarkers() []struct {
	// CreatedAt The UTC date and time (in RFC3339 format) of when the user created the marker.
	CreatedAt time.Time `json:"created_at"`

	// Description The description that the user gave the marker to help them remember why they marked the location. Is an empty string if the user didnt provide one.
	Description string `json:"description"`

	// Id An ID that identifies this marker.
	Id string `json:"id"`

	// PositionSeconds The relative offset (in seconds) of the marker from the beginning of the stream.
	PositionSeconds int32 `json:"position_seconds"`

	// Url A URL that opens the video in Twitch Highlighter.
	Url string `json:"url"`
} {
	return datatype.Markers
}
func (datatype StreamMarkers) GetUserId() string {
	return datatype.UserId
}
func (datatype StreamMarkers) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype StreamMarkers) GetUserName() string {
	return datatype.UserName
}
func (datatype StreamMarkers) GetVideoId() string {
	return datatype.VideoId
}
func (datatype StreamMarkers) GetVideos() []map[string]interface{} {
	return datatype.Videos
}

// StreamTag defines model for StreamTag.
type StreamTag struct {
	// IsAuto A Boolean value that determines whether the tag is an automatic tag. An automatic tag is one that Twitch adds to the stream. Broadcasters may not add automatic tags to their channel. The value is **true** if the tag is an automatic tag; otherwise, **false**.
	IsAuto bool `json:"is_auto"`

	// LocalizationDescriptions A dictionary that contains the localized descriptions of the tag. The key is in the form, <locale>-<coutry/region>. For example, en-us. The value is the localized description.
	LocalizationDescriptions map[string]string `json:"localization_descriptions"`

	// LocalizationNames A dictionary that contains the localized names of the tag. The key is in the form, <locale>-<coutry/region>. For example, en-us. The value is the localized name.
	LocalizationNames map[string]string `json:"localization_names"`

	// TagId An ID that identifies this tag.
	TagId string `json:"tag_id"`
}

func (datatype StreamTag) GetIsAuto() bool {
	return datatype.IsAuto
}
func (datatype StreamTag) GetLocalizationDescriptions() map[string]string {
	return datatype.LocalizationDescriptions
}
func (datatype StreamTag) GetLocalizationNames() map[string]string {
	return datatype.LocalizationNames
}
func (datatype StreamTag) GetTagId() string {
	return datatype.TagId
}

// Team defines model for Team.
type Team struct {
	// BackgroundImageUrl A URL to the teams background image.
	BackgroundImageUrl string `json:"background_image_url"`

	// Banner A URL to the teams banner.
	Banner string `json:"banner"`

	// CreatedAt The UTC date and time (in RFC3339 format) of when the team was created.
	CreatedAt time.Time `json:"created_at"`

	// Id An ID that identifies the team.
	Id string `json:"id"`

	// Info The teams description. The description may contain formatting such as Markdown, HTML, newline (\\n) characters, etc.
	Info string `json:"info"`

	// TeamDisplayName The teams display name.
	TeamDisplayName string `json:"team_display_name"`

	// TeamName The teams name.
	TeamName string `json:"team_name"`

	// ThumbnailUrl A URL to a thumbnail image of the teams logo.
	ThumbnailUrl string `json:"thumbnail_url"`

	// UpdatedAt The UTC date and time (in RFC3339 format) of the last time the team was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Users The list of team members.
	Users []struct {
		// UserId An ID that identifies the team member.
		UserId string `json:"user_id"`

		// UserLogin The team members login name.
		UserLogin string `json:"user_login"`

		// UserName The team members display name.
		UserName string `json:"user_name"`
	} `json:"users"`
}

func (datatype Team) GetBackgroundImageUrl() string {
	return datatype.BackgroundImageUrl
}
func (datatype Team) GetBanner() string {
	return datatype.Banner
}
func (datatype Team) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Team) GetId() string {
	return datatype.Id
}
func (datatype Team) GetInfo() string {
	return datatype.Info
}
func (datatype Team) GetTeamDisplayName() string {
	return datatype.TeamDisplayName
}
func (datatype Team) GetTeamName() string {
	return datatype.TeamName
}
func (datatype Team) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Team) GetUpdatedAt() time.Time {
	return datatype.UpdatedAt
}
func (datatype Team) GetUsers() []struct {
	// UserId An ID that identifies the team member.
	UserId string `json:"user_id"`

	// UserLogin The team members login name.
	UserLogin string `json:"user_login"`

	// UserName The team members display name.
	UserName string `json:"user_name"`
} {
	return datatype.Users
}

// UpdateAutoModSettingsBody defines model for UpdateAutoModSettingsBody.
type UpdateAutoModSettingsBody struct {
	// Aggression The Automod level for hostility involving aggression.
	Aggression *int32 `json:"aggression,omitempty"`

	// Bullying The Automod level for hostility involving name calling or insults.
	Bullying *int32 `json:"bullying,omitempty"`

	// Disability The Automod level for discrimination against disability.
	Disability *int32 `json:"disability,omitempty"`

	// Misogyny The Automod level for discrimination against women.
	Misogyny *int32 `json:"misogyny,omitempty"`

	// OverallLevel The default AutoMod level for the broadcaster.
	OverallLevel *int32 `json:"overall_level,omitempty"`

	// RaceEthnicityOrReligion The Automod level for racial discrimination.
	RaceEthnicityOrReligion *int32 `json:"race_ethnicity_or_religion,omitempty"`

	// SexBasedTerms The Automod level for sexual content.
	SexBasedTerms *int32 `json:"sex_based_terms,omitempty"`

	// SexualitySexOrGender The AutoMod level for discrimination based on sexuality, sex, or gender.
	SexualitySexOrGender *int32 `json:"sexuality_sex_or_gender,omitempty"`

	// Swearing The Automod level for profanity.
	Swearing *int32 `json:"swearing,omitempty"`
}

func (datatype UpdateAutoModSettingsBody) GetAggression() int32 {
	if datatype.Aggression == nil {
		var empty int32
		return empty
	}
	return *datatype.Aggression
}
func (datatype UpdateAutoModSettingsBody) GetBullying() int32 {
	if datatype.Bullying == nil {
		var empty int32
		return empty
	}
	return *datatype.Bullying
}
func (datatype UpdateAutoModSettingsBody) GetDisability() int32 {
	if datatype.Disability == nil {
		var empty int32
		return empty
	}
	return *datatype.Disability
}
func (datatype UpdateAutoModSettingsBody) GetMisogyny() int32 {
	if datatype.Misogyny == nil {
		var empty int32
		return empty
	}
	return *datatype.Misogyny
}
func (datatype UpdateAutoModSettingsBody) GetOverallLevel() int32 {
	if datatype.OverallLevel == nil {
		var empty int32
		return empty
	}
	return *datatype.OverallLevel
}
func (datatype UpdateAutoModSettingsBody) GetRaceEthnicityOrReligion() int32 {
	if datatype.RaceEthnicityOrReligion == nil {
		var empty int32
		return empty
	}
	return *datatype.RaceEthnicityOrReligion
}
func (datatype UpdateAutoModSettingsBody) GetSexBasedTerms() int32 {
	if datatype.SexBasedTerms == nil {
		var empty int32
		return empty
	}
	return *datatype.SexBasedTerms
}
func (datatype UpdateAutoModSettingsBody) GetSexualitySexOrGender() int32 {
	if datatype.SexualitySexOrGender == nil {
		var empty int32
		return empty
	}
	return *datatype.SexualitySexOrGender
}
func (datatype UpdateAutoModSettingsBody) GetSwearing() int32 {
	if datatype.Swearing == nil {
		var empty int32
		return empty
	}
	return *datatype.Swearing
}

// UpdateAutoModSettingsResponse defines model for UpdateAutoModSettingsResponse.
type UpdateAutoModSettingsResponse struct {
	// Data The list of AutoMod settings. The list contains a single object that contains all the AutoMod settings.
	Data []AutoModSettings `json:"data"`
}

func (datatype UpdateAutoModSettingsResponse) GetData() []AutoModSettings {
	return datatype.Data
}

// UpdateChannelGuestStarSettingsBody defines model for UpdateChannelGuestStarSettingsBody.
type UpdateChannelGuestStarSettingsBody struct {
	// GroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
	//
	// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
	// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
	// * `HORIZONTAL_LAYOUT`: All live guests are arranged in a horizontal bar within the browser source
	// * `VERTICAL_LAYOUT`: All live guests are arranged in a vertical bar within the browser source
	GroupLayout *UpdateChannelGuestStarSettingsBodyGroupLayout `json:"group_layout,omitempty"`

	// IsBrowserSourceAudioEnabled Flag determining if Browser Sources subscribed to sessions on this channel should output audio
	IsBrowserSourceAudioEnabled *bool `json:"is_browser_source_audio_enabled,omitempty"`

	// IsModeratorSendLiveEnabled Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot.
	IsModeratorSendLiveEnabled *bool `json:"is_moderator_send_live_enabled,omitempty"`

	// RegenerateBrowserSources Flag determining if Guest Star should regenerate the auth token associated with the channels browser sources. Providing a true value for this will immediately invalidate all browser sources previously configured in your streaming software.
	RegenerateBrowserSources *bool `json:"regenerate_browser_sources,omitempty"`

	// SlotCount Number of slots the Guest Star call interface will allow the host to add to a call. Required to be between 1 and 6.
	SlotCount *int32 `json:"slot_count,omitempty"`
}

func (datatype UpdateChannelGuestStarSettingsBody) GetGroupLayout() UpdateChannelGuestStarSettingsBodyGroupLayout {
	if datatype.GroupLayout == nil {
		var empty UpdateChannelGuestStarSettingsBodyGroupLayout
		return empty
	}
	return *datatype.GroupLayout
}
func (datatype UpdateChannelGuestStarSettingsBody) GetIsBrowserSourceAudioEnabled() bool {
	if datatype.IsBrowserSourceAudioEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsBrowserSourceAudioEnabled
}
func (datatype UpdateChannelGuestStarSettingsBody) GetIsModeratorSendLiveEnabled() bool {
	if datatype.IsModeratorSendLiveEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsModeratorSendLiveEnabled
}
func (datatype UpdateChannelGuestStarSettingsBody) GetRegenerateBrowserSources() bool {
	if datatype.RegenerateBrowserSources == nil {
		var empty bool
		return empty
	}
	return *datatype.RegenerateBrowserSources
}
func (datatype UpdateChannelGuestStarSettingsBody) GetSlotCount() int32 {
	if datatype.SlotCount == nil {
		var empty int32
		return empty
	}
	return *datatype.SlotCount
}

// UpdateChannelGuestStarSettingsBodyGroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
//
// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
// * `HORIZONTAL_LAYOUT`: All live guests are arranged in a horizontal bar within the browser source
// * `VERTICAL_LAYOUT`: All live guests are arranged in a vertical bar within the browser source
type UpdateChannelGuestStarSettingsBodyGroupLayout string

// UpdateChannelStreamScheduleSegmentBody defines model for UpdateChannelStreamScheduleSegmentBody.
type UpdateChannelStreamScheduleSegmentBody struct {
	// CategoryId The ID of the category that best represents the broadcasts content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
	CategoryId *string `json:"category_id,omitempty"`

	// Duration The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).
	Duration *string `json:"duration,omitempty"`

	// IsCanceled A Boolean value that indicates whether the broadcast is canceled. Set to **true** to cancel the segment.
	//
	// **NOTE**: For recurring segments, the API cancels the first segment after the current UTC date and time and not the specified segment (unless the specified segment is the next segment after the current UTC date and time).
	IsCanceled *bool `json:"is_canceled,omitempty"`

	// StartTime The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2022-08-02T06:00:00Z).
	//
	// **NOTE**: Only partners and affiliates may update a broadcasts start time and only for non-recurring segments.
	StartTime *time.Time `json:"start_time,omitempty"`

	// Timezone The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\_York).
	Timezone *string `json:"timezone,omitempty"`

	// Title The broadcasts title. The title may contain a maximum of 140 characters.
	Title *string `json:"title,omitempty"`
}

func (datatype UpdateChannelStreamScheduleSegmentBody) GetCategoryId() string {
	if datatype.CategoryId == nil {
		var empty string
		return empty
	}
	return *datatype.CategoryId
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetDuration() string {
	if datatype.Duration == nil {
		var empty string
		return empty
	}
	return *datatype.Duration
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetIsCanceled() bool {
	if datatype.IsCanceled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsCanceled
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetStartTime() time.Time {
	if datatype.StartTime == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartTime
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetTimezone() string {
	if datatype.Timezone == nil {
		var empty string
		return empty
	}
	return *datatype.Timezone
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// UpdateChannelStreamScheduleSegmentResponse defines model for UpdateChannelStreamScheduleSegmentResponse.
type UpdateChannelStreamScheduleSegmentResponse struct {
	// Data The broadcasters streaming scheduled.
	Data struct {
		// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// Segments A list that contains the single broadcast segment that you updated.
		Segments []ChannelStreamScheduleSegment `json:"segments"`

		// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
		Vacation struct {
			// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
			EndTime time.Time `json:"end_time"`

			// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
			StartTime time.Time `json:"start_time"`
		} `json:"vacation"`
	} `json:"data"`
}

func (datatype UpdateChannelStreamScheduleSegmentResponse) GetData() struct {
	// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Segments A list that contains the single broadcast segment that you updated.
	Segments []ChannelStreamScheduleSegment `json:"segments"`

	// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	Vacation struct {
		// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
		EndTime time.Time `json:"end_time"`

		// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
		StartTime time.Time `json:"start_time"`
	} `json:"vacation"`
} {
	return datatype.Data
}

// UpdateChatSettingsBody defines model for UpdateChatSettingsBody.
type UpdateChatSettingsBody struct {
	// EmoteMode A Boolean value that determines whether chat messages must contain only emotes.
	//
	// Set to **true** if only emotes are allowed; otherwise, **false**. The default is **false**.
	EmoteMode *bool `json:"emote_mode,omitempty"`

	// FollowerMode A Boolean value that determines whether the broadcaster restricts the chat room to followers only.
	//
	// Set to **true** if the broadcaster restricts the chat room to followers only; otherwise, **false**. The default is **true**.
	//
	// To specify how long users must follow the broadcaster before being able to participate in the chat room, see the `follower_mode_duration` field.
	FollowerMode *bool `json:"follower_mode,omitempty"`

	// FollowerModeDuration The length of time, in minutes, that users must follow the broadcaster before being able to participate in the chat room. Set only if `follower_mode` is **true**. Possible values are: 0 (no restriction) through 129600 (3 months). The default is 0.
	FollowerModeDuration *int32 `json:"follower_mode_duration,omitempty"`

	// NonModeratorChatDelay A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room. This gives chat moderators and bots a chance to remove them before viewers can see the message.
	//
	// Set to **true** if the broadcaster applies a delay; otherwise, **false**. The default is **false**.
	//
	// To specify the length of the delay, see the `non_moderator_chat_delay_duration` field.
	NonModeratorChatDelay *bool `json:"non_moderator_chat_delay,omitempty"`

	// NonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Set only if `non_moderator_chat_delay` is **true**. Possible values are:
	//
	// * 2  2 second delay (recommended)
	// * 4  4 second delay
	// * 6  6 second delay
	NonModeratorChatDelayDuration *UpdateChatSettingsBodyNonModeratorChatDelayDuration `json:"non_moderator_chat_delay_duration,omitempty"`

	// SlowMode A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages. Set to **true** if the broadcaster applies a wait period between messages; otherwise, **false**. The default is **false**.
	//
	// To specify the delay, see the `slow_mode_wait_time` field.
	SlowMode *bool `json:"slow_mode,omitempty"`

	// SlowModeWaitTime The amount of time, in seconds, that users must wait between sending messages. Set only if `slow_mode` is **true**.
	//
	// Possible values are: 3 (3 second delay) through 120 (2 minute delay). The default is 30 seconds.
	SlowModeWaitTime *int32 `json:"slow_mode_wait_time,omitempty"`

	// SubscriberMode A Boolean value that determines whether only users that subscribe to the broadcasters channel may talk in the chat room.
	//
	// Set to **true** if the broadcaster restricts the chat room to subscribers only; otherwise, **false**. The default is **false**.
	SubscriberMode *bool `json:"subscriber_mode,omitempty"`

	// UniqueChatMode A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room.
	//
	// Set to **true** if the broadcaster allows only unique messages; otherwise, **false**. The default is **false**.
	UniqueChatMode *bool `json:"unique_chat_mode,omitempty"`
}

func (datatype UpdateChatSettingsBody) GetEmoteMode() bool {
	if datatype.EmoteMode == nil {
		var empty bool
		return empty
	}
	return *datatype.EmoteMode
}
func (datatype UpdateChatSettingsBody) GetFollowerMode() bool {
	if datatype.FollowerMode == nil {
		var empty bool
		return empty
	}
	return *datatype.FollowerMode
}
func (datatype UpdateChatSettingsBody) GetFollowerModeDuration() int32 {
	if datatype.FollowerModeDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.FollowerModeDuration
}
func (datatype UpdateChatSettingsBody) GetNonModeratorChatDelay() bool {
	if datatype.NonModeratorChatDelay == nil {
		var empty bool
		return empty
	}
	return *datatype.NonModeratorChatDelay
}
func (datatype UpdateChatSettingsBody) GetNonModeratorChatDelayDuration() UpdateChatSettingsBodyNonModeratorChatDelayDuration {
	if datatype.NonModeratorChatDelayDuration == nil {
		var empty UpdateChatSettingsBodyNonModeratorChatDelayDuration
		return empty
	}
	return *datatype.NonModeratorChatDelayDuration
}
func (datatype UpdateChatSettingsBody) GetSlowMode() bool {
	if datatype.SlowMode == nil {
		var empty bool
		return empty
	}
	return *datatype.SlowMode
}
func (datatype UpdateChatSettingsBody) GetSlowModeWaitTime() int32 {
	if datatype.SlowModeWaitTime == nil {
		var empty int32
		return empty
	}
	return *datatype.SlowModeWaitTime
}
func (datatype UpdateChatSettingsBody) GetSubscriberMode() bool {
	if datatype.SubscriberMode == nil {
		var empty bool
		return empty
	}
	return *datatype.SubscriberMode
}
func (datatype UpdateChatSettingsBody) GetUniqueChatMode() bool {
	if datatype.UniqueChatMode == nil {
		var empty bool
		return empty
	}
	return *datatype.UniqueChatMode
}

// UpdateChatSettingsBodyNonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Set only if `non_moderator_chat_delay` is **true**. Possible values are:
//
// * 2  2 second delay (recommended)
// * 4  4 second delay
// * 6  6 second delay
type UpdateChatSettingsBodyNonModeratorChatDelayDuration int32

// UpdateChatSettingsResponse defines model for UpdateChatSettingsResponse.
type UpdateChatSettingsResponse struct {
	// Data The list of chat settings. The list contains a single object with all the settings.
	Data []ChatSettingsUpdated `json:"data"`
}

func (datatype UpdateChatSettingsResponse) GetData() []ChatSettingsUpdated {
	return datatype.Data
}

// UpdateConduitShardsBody defines model for UpdateConduitShardsBody.
type UpdateConduitShardsBody struct {
	// ConduitId Conduit ID.
	ConduitId string `json:"conduit_id"`

	// Shards List of shards to update.
	Shards []struct {
		// Id Shard ID.
		Id string `json:"id"`

		// Transport The transport details that you want Twitch to use when sending you notifications.
		Transport struct {
			// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See Processing an event.Specify this field only if method is set to webhook.NOTE: Redirects are not followed.
			Callback *string `json:"callback,omitempty"`

			// Method The transport method. Possible values are:
			//
			// * webhook
			// * websocket
			Method *UpdateConduitShardsBodyShardsTransportMethod `json:"method,omitempty"`

			// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see Verifying the event message.Specify this field only if method is set to webhook.
			Secret *string `json:"secret,omitempty"`

			// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message.Specify this field only if method is set to websocket.
			SessionId *string `json:"session_id,omitempty"`
		} `json:"transport"`
	} `json:"shards"`
}

func (datatype UpdateConduitShardsBody) GetConduitId() string {
	return datatype.ConduitId
}
func (datatype UpdateConduitShardsBody) GetShards() []struct {
	// Id Shard ID.
	Id string `json:"id"`

	// Transport The transport details that you want Twitch to use when sending you notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See Processing an event.Specify this field only if method is set to webhook.NOTE: Redirects are not followed.
		Callback *string `json:"callback,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method *UpdateConduitShardsBodyShardsTransportMethod `json:"method,omitempty"`

		// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see Verifying the event message.Specify this field only if method is set to webhook.
		Secret *string `json:"secret,omitempty"`

		// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message.Specify this field only if method is set to websocket.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`
} {
	return datatype.Shards
}

// UpdateConduitShardsBodyShardsTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type UpdateConduitShardsBodyShardsTransportMethod string

// UpdateConduitShardsResponse defines model for UpdateConduitShardsResponse.
type UpdateConduitShardsResponse struct {
	// Data List of successful shard updates.
	Data []struct {
		// Id Shard ID.
		Id string `json:"id"`

		// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
		//
		// * enabled  The shard is enabled.
		// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
		// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
		// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
		// * websocket\_disconnected  The client closed the connection.
		// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
		// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
		// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
		// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
		// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
		// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
		Status UpdateConduitShardsResponseDataStatus `json:"status"`

		// Transport The transport details used to send the notifications.
		Transport struct {
			// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
			Callback *string `json:"callback,omitempty"`

			// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
			ConnectedAt *time.Time `json:"connected_at,omitempty"`

			// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
			DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

			// Method The transport method. Possible values are:
			//
			// * webhook
			// * websocket
			Method UpdateConduitShardsResponseDataTransportMethod `json:"method"`

			// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
			SessionId *string `json:"session_id,omitempty"`
		} `json:"transport"`
	} `json:"data"`

	// Errors List of unsuccessful updates.
	Errors []struct {
		// Code Error codes used to represent a specific error condition while attempting to update shards.
		Code string `json:"code"`

		// Id Shard ID.
		Id string `json:"id"`

		// Message The error that occurred while updating the shard. Possible errors:
		//
		// * The length of the string in the secret field is not valid.
		// * The URL in the transport's callback field is not valid. The URL must use the HTTPS protocol and the 443 port number.
		// * The value specified in the method field is not valid.
		// * The callback field is required if you specify the webhook transport method.
		// * The session\_id field is required if you specify the WebSocket transport method.
		// * The websocket session is not connected.
		// * The shard id is outside of the conduits range.
		Message string `json:"message"`
	} `json:"errors"`
}

func (datatype UpdateConduitShardsResponse) GetData() []struct {
	// Id Shard ID.
	Id string `json:"id"`

	// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
	//
	// * enabled  The shard is enabled.
	// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	Status UpdateConduitShardsResponseDataStatus `json:"status"`

	// Transport The transport details used to send the notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
		Callback *string `json:"callback,omitempty"`

		// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
		ConnectedAt *time.Time `json:"connected_at,omitempty"`

		// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
		DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method UpdateConduitShardsResponseDataTransportMethod `json:"method"`

		// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`
} {
	return datatype.Data
}
func (datatype UpdateConduitShardsResponse) GetErrors() []struct {
	// Code Error codes used to represent a specific error condition while attempting to update shards.
	Code string `json:"code"`

	// Id Shard ID.
	Id string `json:"id"`

	// Message The error that occurred while updating the shard. Possible errors:
	//
	// * The length of the string in the secret field is not valid.
	// * The URL in the transport's callback field is not valid. The URL must use the HTTPS protocol and the 443 port number.
	// * The value specified in the method field is not valid.
	// * The callback field is required if you specify the webhook transport method.
	// * The session\_id field is required if you specify the WebSocket transport method.
	// * The websocket session is not connected.
	// * The shard id is outside of the conduits range.
	Message string `json:"message"`
} {
	return datatype.Errors
}

// UpdateConduitShardsResponseDataStatus The shard status. The subscriber receives events only for enabled shards. Possible values are:
//
// * enabled  The shard is enabled.
// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
// * websocket\_disconnected  The client closed the connection.
// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
type UpdateConduitShardsResponseDataStatus string

// UpdateConduitShardsResponseDataTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type UpdateConduitShardsResponseDataTransportMethod string

// UpdateConduitsBody defines model for UpdateConduitsBody.
type UpdateConduitsBody struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount The new number of shards for this conduit.
	ShardCount int32 `json:"shard_count"`
}

func (datatype UpdateConduitsBody) GetId() string {
	return datatype.Id
}
func (datatype UpdateConduitsBody) GetShardCount() int32 {
	return datatype.ShardCount
}

// UpdateConduitsResponse defines model for UpdateConduitsResponse.
type UpdateConduitsResponse struct {
	// Data List of information about the clients conduits.
	Data []struct {
		// Id Conduit ID.
		Id string `json:"id"`

		// ShardCount Number of shards associated with this conduit after the update.
		ShardCount int32 `json:"shard_count"`
	} `json:"data"`
}

func (datatype UpdateConduitsResponse) GetData() []struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount Number of shards associated with this conduit after the update.
	ShardCount int32 `json:"shard_count"`
} {
	return datatype.Data
}

// UpdateCustomRewardBody defines model for UpdateCustomRewardBody.
type UpdateCustomRewardBody struct {
	// BackgroundColor The background color to use for the reward. Specify the color using Hex format (for example, \\#00E5CB).
	BackgroundColor *string `json:"background_color,omitempty"`

	// Cost The cost of the reward, in channel points. The minimum is 1 point.
	Cost *int64 `json:"cost,omitempty"`

	// GlobalCooldownSeconds The cooldown period, in seconds. Applied only if `is_global_cooldown_enabled` is **true**. The minimum value is 1; however, for it to be shown in the Twitch UX, the minimum value is 60.
	GlobalCooldownSeconds *int64 `json:"global_cooldown_seconds,omitempty"`

	// IsEnabled A Boolean value that indicates whether the reward is enabled. Set to **true** to enable the reward. Viewers see only enabled rewards.
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// IsGlobalCooldownEnabled A Boolean value that determines whether to apply a cooldown period between redemptions. Set to **true** to apply a cooldown period. For the duration of the cooldown period, see `global_cooldown_seconds`.
	IsGlobalCooldownEnabled *bool `json:"is_global_cooldown_enabled,omitempty"`

	// IsMaxPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the `max_per_stream` field). Set to **true** to limit redemptions.
	IsMaxPerStreamEnabled *bool `json:"is_max_per_stream_enabled,omitempty"`

	// IsMaxPerUserPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see `max_per_user_per_stream`). The minimum value is 1\. Set to **true** to limit redemptions.
	IsMaxPerUserPerStreamEnabled *bool `json:"is_max_per_user_per_stream_enabled,omitempty"`

	// IsPaused A Boolean value that determines whether to pause the reward. Set to **true** to pause the reward. Viewers cant redeem paused rewards..
	IsPaused *bool `json:"is_paused,omitempty"`

	// IsUserInputRequired A Boolean value that determines whether users must enter information to redeem the reward. Set to **true** if user input is required. See the `prompt` field.
	IsUserInputRequired *bool `json:"is_user_input_required,omitempty"`

	// MaxPerStream The maximum number of redemptions allowed per live stream. Applied only if `is_max_per_stream_enabled` is **true**. The minimum value is 1.
	MaxPerStream *int64 `json:"max_per_stream,omitempty"`

	// MaxPerUserPerStream The maximum number of redemptions allowed per user per stream. Applied only if `is_max_per_user_per_stream_enabled` is **true**.
	MaxPerUserPerStream *int64 `json:"max_per_user_per_stream,omitempty"`

	// Prompt The prompt shown to the viewer when they redeem the reward. Specify a prompt if `is_user_input_required` is **true**. The prompt is limited to a maximum of 200 characters.
	Prompt *string `json:"prompt,omitempty"`

	// ShouldRedemptionsSkipRequestQueue A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.
	ShouldRedemptionsSkipRequestQueue *bool `json:"should_redemptions_skip_request_queue,omitempty"`

	// Title The rewards title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcasters custom rewards.
	Title *string `json:"title,omitempty"`
}

func (datatype UpdateCustomRewardBody) GetBackgroundColor() string {
	if datatype.BackgroundColor == nil {
		var empty string
		return empty
	}
	return *datatype.BackgroundColor
}
func (datatype UpdateCustomRewardBody) GetCost() int64 {
	if datatype.Cost == nil {
		var empty int64
		return empty
	}
	return *datatype.Cost
}
func (datatype UpdateCustomRewardBody) GetGlobalCooldownSeconds() int64 {
	if datatype.GlobalCooldownSeconds == nil {
		var empty int64
		return empty
	}
	return *datatype.GlobalCooldownSeconds
}
func (datatype UpdateCustomRewardBody) GetIsEnabled() bool {
	if datatype.IsEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsEnabled
}
func (datatype UpdateCustomRewardBody) GetIsGlobalCooldownEnabled() bool {
	if datatype.IsGlobalCooldownEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsGlobalCooldownEnabled
}
func (datatype UpdateCustomRewardBody) GetIsMaxPerStreamEnabled() bool {
	if datatype.IsMaxPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerStreamEnabled
}
func (datatype UpdateCustomRewardBody) GetIsMaxPerUserPerStreamEnabled() bool {
	if datatype.IsMaxPerUserPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerUserPerStreamEnabled
}
func (datatype UpdateCustomRewardBody) GetIsPaused() bool {
	if datatype.IsPaused == nil {
		var empty bool
		return empty
	}
	return *datatype.IsPaused
}
func (datatype UpdateCustomRewardBody) GetIsUserInputRequired() bool {
	if datatype.IsUserInputRequired == nil {
		var empty bool
		return empty
	}
	return *datatype.IsUserInputRequired
}
func (datatype UpdateCustomRewardBody) GetMaxPerStream() int64 {
	if datatype.MaxPerStream == nil {
		var empty int64
		return empty
	}
	return *datatype.MaxPerStream
}
func (datatype UpdateCustomRewardBody) GetMaxPerUserPerStream() int64 {
	if datatype.MaxPerUserPerStream == nil {
		var empty int64
		return empty
	}
	return *datatype.MaxPerUserPerStream
}
func (datatype UpdateCustomRewardBody) GetPrompt() string {
	if datatype.Prompt == nil {
		var empty string
		return empty
	}
	return *datatype.Prompt
}
func (datatype UpdateCustomRewardBody) GetShouldRedemptionsSkipRequestQueue() bool {
	if datatype.ShouldRedemptionsSkipRequestQueue == nil {
		var empty bool
		return empty
	}
	return *datatype.ShouldRedemptionsSkipRequestQueue
}
func (datatype UpdateCustomRewardBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// UpdateCustomRewardResponse defines model for UpdateCustomRewardResponse.
type UpdateCustomRewardResponse struct {
	// Data The list contains the single reward that you updated.
	Data []CustomReward `json:"data"`
}

func (datatype UpdateCustomRewardResponse) GetData() []CustomReward {
	return datatype.Data
}

// UpdateDropsEntitlementsBody defines model for UpdateDropsEntitlementsBody.
type UpdateDropsEntitlementsBody struct {
	// EntitlementIds A list of IDs that identify the entitlements to update. You may specify a maximum of 100 IDs.
	EntitlementIds *[]string `json:"entitlement_ids,omitempty"`

	// FulfillmentStatus The fulfillment status to set the entitlements to. Possible values are:
	//
	// * CLAIMED  The user claimed the benefit.
	// * FULFILLED  The developer granted the benefit that the user claimed.
	FulfillmentStatus *UpdateDropsEntitlementsBodyFulfillmentStatus `json:"fulfillment_status,omitempty"`
}

func (datatype UpdateDropsEntitlementsBody) GetEntitlementIds() []string {
	if datatype.EntitlementIds == nil {
		var empty []string
		return empty
	}
	return *datatype.EntitlementIds
}
func (datatype UpdateDropsEntitlementsBody) GetFulfillmentStatus() UpdateDropsEntitlementsBodyFulfillmentStatus {
	if datatype.FulfillmentStatus == nil {
		var empty UpdateDropsEntitlementsBodyFulfillmentStatus
		return empty
	}
	return *datatype.FulfillmentStatus
}

// UpdateDropsEntitlementsBodyFulfillmentStatus The fulfillment status to set the entitlements to. Possible values are:
//
// * CLAIMED  The user claimed the benefit.
// * FULFILLED  The developer granted the benefit that the user claimed.
type UpdateDropsEntitlementsBodyFulfillmentStatus string

// UpdateDropsEntitlementsResponse defines model for UpdateDropsEntitlementsResponse.
type UpdateDropsEntitlementsResponse struct {
	// Data A list that indicates which entitlements were successfully updated and those that werent.
	Data []DropsEntitlementUpdated `json:"data"`
}

func (datatype UpdateDropsEntitlementsResponse) GetData() []DropsEntitlementUpdated {
	return datatype.Data
}

// UpdateExtensionBitsProductBody defines model for UpdateExtensionBitsProductBody.
type UpdateExtensionBitsProductBody struct {
	// Cost An object that contains the product's cost information.
	Cost struct {
		// Amount The product's price.
		Amount int32 `json:"amount"`

		// Type The type of currency. Possible values are:
		//
		// * bits  The minimum price is 1 and the maximum is 10000.
		Type UpdateExtensionBitsProductBodyCostType `json:"type"`
	} `json:"cost"`

	// DisplayName The product's name as displayed in the extension. The maximum length is 255 characters.
	DisplayName string `json:"display_name"`

	// Expiration The date and time, in RFC3339 format, when the product expires. If not set, the product does not expire. To disable the product, set the expiration date to a date in the past.
	Expiration *time.Time `json:"expiration,omitempty"`

	// InDevelopment A Boolean value that indicates whether the product is in development. Set to **true** if the product is in development and not available for public use. The default is **false**.
	InDevelopment *bool `json:"in_development,omitempty"`

	// IsBroadcast A Boolean value that determines whether Bits product purchase events are broadcast to all instances of the extension on a channel. The events are broadcast via the `onTransactionComplete` helper callback. The default is **false**.
	IsBroadcast *bool `json:"is_broadcast,omitempty"`

	// Sku The product's SKU. The SKU must be unique within an extension. The product's SKU cannot be changed. The SKU may contain only alphanumeric characters, dashes (-), underscores (\_), and periods (.) and is limited to a maximum of 255 characters. No spaces.
	Sku string `json:"sku"`
}

func (datatype UpdateExtensionBitsProductBody) GetCost() struct {
	// Amount The product's price.
	Amount int32 `json:"amount"`

	// Type The type of currency. Possible values are:
	//
	// * bits  The minimum price is 1 and the maximum is 10000.
	Type UpdateExtensionBitsProductBodyCostType `json:"type"`
} {
	return datatype.Cost
}
func (datatype UpdateExtensionBitsProductBody) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype UpdateExtensionBitsProductBody) GetExpiration() time.Time {
	if datatype.Expiration == nil {
		var empty time.Time
		return empty
	}
	return *datatype.Expiration
}
func (datatype UpdateExtensionBitsProductBody) GetInDevelopment() bool {
	if datatype.InDevelopment == nil {
		var empty bool
		return empty
	}
	return *datatype.InDevelopment
}
func (datatype UpdateExtensionBitsProductBody) GetIsBroadcast() bool {
	if datatype.IsBroadcast == nil {
		var empty bool
		return empty
	}
	return *datatype.IsBroadcast
}
func (datatype UpdateExtensionBitsProductBody) GetSku() string {
	return datatype.Sku
}

// UpdateExtensionBitsProductBodyCostType The type of currency. Possible values are:
//
// * bits  The minimum price is 1 and the maximum is 10000.
type UpdateExtensionBitsProductBodyCostType string

// UpdateExtensionBitsProductResponse defines model for UpdateExtensionBitsProductResponse.
type UpdateExtensionBitsProductResponse struct {
	// Data A list of Bits products that the extension created. The list is in ascending SKU order. The list is empty if the extension hasn't created any products or they're all expired or disabled.
	Data []ExtensionBitsProduct `json:"data"`
}

func (datatype UpdateExtensionBitsProductResponse) GetData() []ExtensionBitsProduct {
	return datatype.Data
}

// UpdateRedemptionStatusBody defines model for UpdateRedemptionStatusBody.
type UpdateRedemptionStatusBody struct {
	// Status The status to set the redemption to. Possible values are:
	//
	// * CANCELED
	// * FULFILLED
	//
	// Setting the status to CANCELED refunds the users channel points.
	Status UpdateRedemptionStatusBodyStatus `json:"status"`
}

func (datatype UpdateRedemptionStatusBody) GetStatus() UpdateRedemptionStatusBodyStatus {
	return datatype.Status
}

// UpdateRedemptionStatusBodyStatus The status to set the redemption to. Possible values are:
//
// * CANCELED
// * FULFILLED
//
// Setting the status to CANCELED refunds the users channel points.
type UpdateRedemptionStatusBodyStatus string

// UpdateRedemptionStatusResponse defines model for UpdateRedemptionStatusResponse.
type UpdateRedemptionStatusResponse struct {
	// Data The list contains the single redemption that you updated.
	Data []CustomRewardRedemption `json:"data"`
}

func (datatype UpdateRedemptionStatusResponse) GetData() []CustomRewardRedemption {
	return datatype.Data
}

// UpdateShieldModeStatusBody defines model for UpdateShieldModeStatusBody.
type UpdateShieldModeStatusBody struct {
	// IsActive A Boolean value that determines whether to activate Shield Mode. Set to **true** to activate Shield Mode; otherwise, **false** to deactivate Shield Mode.
	IsActive bool `json:"is_active"`
}

func (datatype UpdateShieldModeStatusBody) GetIsActive() bool {
	return datatype.IsActive
}

// UpdateShieldModeStatusResponse defines model for UpdateShieldModeStatusResponse.
type UpdateShieldModeStatusResponse struct {
	// Data A list that contains a single object with the broadcasters updated Shield Mode status.
	Data []struct {
		// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if Shield Mode is active; otherwise, **false**.
		IsActive bool `json:"is_active"`

		// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated.
		LastActivatedAt time.Time `json:"last_activated_at"`

		// ModeratorId An ID that identifies the moderator that last activated Shield Mode.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderators login name.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderators display name.
		ModeratorName string `json:"moderator_name"`
	} `json:"data"`
}

func (datatype UpdateShieldModeStatusResponse) GetData() []struct {
	// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if Shield Mode is active; otherwise, **false**.
	IsActive bool `json:"is_active"`

	// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated.
	LastActivatedAt time.Time `json:"last_activated_at"`

	// ModeratorId An ID that identifies the moderator that last activated Shield Mode.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name.
	ModeratorName string `json:"moderator_name"`
} {
	return datatype.Data
}

// UpdateUserExtensionsBody defines model for UpdateUserExtensionsBody.
type UpdateUserExtensionsBody struct {
	// Data The extensions to update. The `data` field is a dictionary of extension types. The dictionarys possible keys are: panel, overlay, or component. The keys value is a dictionary of extensions.
	//
	// For the extensions dictionary, the key is a sequential number beginning with 1\. For panel and overlay extensions, the keys value is an object that contains the following fields: `active` (true/false), `id` (the extensions ID), and `version` (the extensions version).
	//
	// For component extensions, the keys value includes the above fields plus the `x` and `y` fields, which identify the coordinate where the extension is placed.
	Data struct {
		Component *map[string]UserExtensionComponentUpdate `json:"component,omitempty"`
		Overlay   *map[string]UserExtensionOverlayUpdate   `json:"overlay,omitempty"`
		Panel     *map[string]UserExtensionPanelUpdate     `json:"panel,omitempty"`
	} `json:"data"`
}

func (datatype UpdateUserExtensionsBody) GetData() struct {
	Component *map[string]UserExtensionComponentUpdate `json:"component,omitempty"`
	Overlay   *map[string]UserExtensionOverlayUpdate   `json:"overlay,omitempty"`
	Panel     *map[string]UserExtensionPanelUpdate     `json:"panel,omitempty"`
} {
	return datatype.Data
}

// UpdateUserExtensionsResponse defines model for UpdateUserExtensionsResponse.
type UpdateUserExtensionsResponse struct {
	// Data The extensions that the broadcaster updated.
	Data struct {
		// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
		Component map[string]UserExtensionComponent `json:"component"`

		// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
		Overlay map[string]UserExtensionOverlay `json:"overlay"`

		// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
		Panel map[string]UserExtensionPanel `json:"panel"`
	} `json:"data"`
}

func (datatype UpdateUserExtensionsResponse) GetData() struct {
	// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
	Component map[string]UserExtensionComponent `json:"component"`

	// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
	Overlay map[string]UserExtensionOverlay `json:"overlay"`

	// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
	Panel map[string]UserExtensionPanel `json:"panel"`
} {
	return datatype.Data
}

// UpdateUserResponse defines model for UpdateUserResponse.
type UpdateUserResponse struct {
	// Data A list contains the single user that you updated.
	Data []User `json:"data"`
}

func (datatype UpdateUserResponse) GetData() []User {
	return datatype.Data
}

// User defines model for User.
type User struct {
	// BroadcasterType The type of broadcaster. Possible values are:
	//
	// * affiliate  An [affiliate broadcaster](https://help.twitch.tv/s/article/joining-the-affiliate-program)
	// * partner  A [partner broadcaster](https://help.twitch.tv/s/article/partner-program-overview)
	// * ""  A normal broadcaster
	BroadcasterType UserBroadcasterType `json:"broadcaster_type"`

	// CreatedAt The UTC date and time that the user's account was created. The timestamp is in RFC3339 format.
	CreatedAt time.Time `json:"created_at"`

	// Description The user's description of their channel.
	Description string `json:"description"`

	// DisplayName The user's display name.
	DisplayName string `json:"display_name"`

	// Email The user's verified email address. The object includes this field only if the user access token includes the **user:read:email** scope.
	//
	// If the request contains more than one user, only the user associated with the access token that provided consent will include an email address  the email address for all other users will be empty.
	Email *string `json:"email,omitempty"`

	// Id An ID that identifies the user.
	Id string `json:"id"`

	// Login The user's login name.
	Login string `json:"login"`

	// OfflineImageUrl A URL to the user's offline image.
	OfflineImageUrl string `json:"offline_image_url"`

	// ProfileImageUrl A URL to the user's profile image.
	ProfileImageUrl string `json:"profile_image_url"`

	// Type The type of user. Possible values are:
	//
	// * admin  Twitch administrator
	// * global\_mod
	// * staff  Twitch staff
	// * ""  Normal user
	Type UserType `json:"type"`

	// ViewCount The number of times the user's channel has been viewed.
	//
	// **NOTE**: This field has been deprecated (see [Get Users API endpoint  "view\_count" deprecation](https://discuss.dev.twitch.tv/t/get-users-api-endpoint-view-count-deprecation/37777)). Any data in this field is not valid and should not be used.
	ViewCount int32 `json:"view_count"`
}

func (datatype User) GetBroadcasterType() UserBroadcasterType {
	return datatype.BroadcasterType
}
func (datatype User) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype User) GetDescription() string {
	return datatype.Description
}
func (datatype User) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype User) GetEmail() string {
	if datatype.Email == nil {
		var empty string
		return empty
	}
	return *datatype.Email
}
func (datatype User) GetId() string {
	return datatype.Id
}
func (datatype User) GetLogin() string {
	return datatype.Login
}
func (datatype User) GetOfflineImageUrl() string {
	return datatype.OfflineImageUrl
}
func (datatype User) GetProfileImageUrl() string {
	return datatype.ProfileImageUrl
}
func (datatype User) GetType() UserType {
	return datatype.Type
}
func (datatype User) GetViewCount() int32 {
	return datatype.ViewCount
}

// UserBroadcasterType The type of broadcaster. Possible values are:
//
// * affiliate  An [affiliate broadcaster](https://help.twitch.tv/s/article/joining-the-affiliate-program)
// * partner  A [partner broadcaster](https://help.twitch.tv/s/article/partner-program-overview)
// * ""  A normal broadcaster
type UserBroadcasterType string

// UserType The type of user. Possible values are:
//
// * admin  Twitch administrator
// * global\_mod
// * staff  Twitch staff
// * ""  Normal user
type UserType string

// UserBlockList defines model for UserBlockList.
type UserBlockList struct {
	// DisplayName The blocked users display name.
	DisplayName string `json:"display_name"`

	// UserId An ID that identifies the blocked user.
	UserId string `json:"user_id"`

	// UserLogin The blocked users login name.
	UserLogin string `json:"user_login"`
}

func (datatype UserBlockList) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype UserBlockList) GetUserId() string {
	return datatype.UserId
}
func (datatype UserBlockList) GetUserLogin() string {
	return datatype.UserLogin
}

// UserChatColor defines model for UserChatColor.
type UserChatColor struct {
	// Color The Hex color code that the user uses in chat for their name. If the user hasnt specified a color in their settings, the string is empty.
	Color string `json:"color"`

	// UserId An ID that uniquely identifies the user.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype UserChatColor) GetColor() string {
	return datatype.Color
}
func (datatype UserChatColor) GetUserId() string {
	return datatype.UserId
}
func (datatype UserChatColor) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype UserChatColor) GetUserName() string {
	return datatype.UserName
}

// UserExtension defines model for UserExtension.
type UserExtension struct {
	// CanActivate A Boolean value that determines whether the extension is configured and can be activated. Is **true** if the extension is configured and can be activated.
	CanActivate bool `json:"can_activate"`

	// Id An ID that identifies the extension.
	Id string `json:"id"`

	// Name The extension's name.
	Name string `json:"name"`

	// Type The extension types that you can activate for this extension. Possible values are:
	//
	// * component
	// * mobile
	// * overlay
	// * panel
	Type []UserExtensionType `json:"type"`

	// Version The extension's version.
	Version string `json:"version"`
}

func (datatype UserExtension) GetCanActivate() bool {
	return datatype.CanActivate
}
func (datatype UserExtension) GetId() string {
	return datatype.Id
}
func (datatype UserExtension) GetName() string {
	return datatype.Name
}
func (datatype UserExtension) GetType() []UserExtensionType {
	return datatype.Type
}
func (datatype UserExtension) GetVersion() string {
	return datatype.Version
}

// UserExtensionType defines model for UserExtension.Type.
type UserExtensionType string

// UserExtensionComponent defines model for UserExtensionComponent.
type UserExtensionComponent struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a component extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Name The extensions name.
	Name *string `json:"name,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`

	// X The x-coordinate where the extension is placed.
	X *int32 `json:"x,omitempty"`

	// Y The y-coordinate where the extension is placed.
	Y *int32 `json:"y,omitempty"`
}

func (datatype UserExtensionComponent) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionComponent) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionComponent) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype UserExtensionComponent) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}
func (datatype UserExtensionComponent) GetX() int32 {
	if datatype.X == nil {
		var empty int32
		return empty
	}
	return *datatype.X
}
func (datatype UserExtensionComponent) GetY() int32 {
	if datatype.Y == nil {
		var empty int32
		return empty
	}
	return *datatype.Y
}

// UserExtensionComponentUpdate defines model for UserExtensionComponentUpdate.
type UserExtensionComponentUpdate struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a component extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`

	// X The x-coordinate where the extension is placed.
	X *int32 `json:"x,omitempty"`

	// Y The y-coordinate where the extension is placed.
	Y *int32 `json:"y,omitempty"`
}

func (datatype UserExtensionComponentUpdate) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionComponentUpdate) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionComponentUpdate) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}
func (datatype UserExtensionComponentUpdate) GetX() int32 {
	if datatype.X == nil {
		var empty int32
		return empty
	}
	return *datatype.X
}
func (datatype UserExtensionComponentUpdate) GetY() int32 {
	if datatype.Y == nil {
		var empty int32
		return empty
	}
	return *datatype.Y
}

// UserExtensionOverlay defines model for UserExtensionOverlay.
type UserExtensionOverlay struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured an overlay extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Name The extensions name.
	Name *string `json:"name,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionOverlay) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionOverlay) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionOverlay) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype UserExtensionOverlay) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserExtensionOverlayUpdate defines model for UserExtensionOverlayUpdate.
type UserExtensionOverlayUpdate struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured an overlay extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionOverlayUpdate) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionOverlayUpdate) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionOverlayUpdate) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserExtensionPanel defines model for UserExtensionPanel.
type UserExtensionPanel struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a panel extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Name The extensions name.
	Name *string `json:"name,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionPanel) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionPanel) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionPanel) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype UserExtensionPanel) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserExtensionPanelUpdate defines model for UserExtensionPanelUpdate.
type UserExtensionPanelUpdate struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a panel extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionPanelUpdate) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionPanelUpdate) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionPanelUpdate) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserModerator defines model for UserModerator.
type UserModerator struct {
	// UserId The ID of the user that has permission to moderate the broadcasters channel.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype UserModerator) GetUserId() string {
	return datatype.UserId
}
func (datatype UserModerator) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype UserModerator) GetUserName() string {
	return datatype.UserName
}

// UserSubscription defines model for UserSubscription.
type UserSubscription struct {
	// BroadcasterId An ID that identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// GifterId The ID of the user that gifted the subscription. The object includes this field only if `is_gift` is **true**.
	GifterId *string `json:"gifter_id,omitempty"`

	// GifterLogin The gifters login name. The object includes this field only if `is_gift` is **true**.
	GifterLogin *string `json:"gifter_login,omitempty"`

	// GifterName The gifters display name. The object includes this field only if `is_gift` is **true**.
	GifterName *string `json:"gifter_name,omitempty"`

	// IsGift A Boolean value that determines whether the subscription is a gift subscription. Is **true** if the subscription was gifted.
	IsGift bool `json:"is_gift"`

	// Tier The type of subscription. Possible values are:
	//
	// * 1000  Tier 1
	// * 2000  Tier 2
	// * 3000  Tier 3
	Tier UserSubscriptionTier `json:"tier"`
}

func (datatype UserSubscription) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UserSubscription) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype UserSubscription) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype UserSubscription) GetGifterId() string {
	if datatype.GifterId == nil {
		var empty string
		return empty
	}
	return *datatype.GifterId
}
func (datatype UserSubscription) GetGifterLogin() string {
	if datatype.GifterLogin == nil {
		var empty string
		return empty
	}
	return *datatype.GifterLogin
}
func (datatype UserSubscription) GetGifterName() string {
	if datatype.GifterName == nil {
		var empty string
		return empty
	}
	return *datatype.GifterName
}
func (datatype UserSubscription) GetIsGift() bool {
	return datatype.IsGift
}
func (datatype UserSubscription) GetTier() UserSubscriptionTier {
	return datatype.Tier
}

// UserSubscriptionTier The type of subscription. Possible values are:
//
// * 1000  Tier 1
// * 2000  Tier 2
// * 3000  Tier 3
type UserSubscriptionTier string

// UserVip defines model for UserVip.
type UserVip struct {
	// UserId An ID that uniquely identifies the VIP user.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype UserVip) GetUserId() string {
	return datatype.UserId
}
func (datatype UserVip) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype UserVip) GetUserName() string {
	return datatype.UserName
}

// Video defines model for Video.
type Video struct {
	// CreatedAt The date and time, in UTC, of when the video was created. The timestamp is in RFC3339 format.
	CreatedAt time.Time `json:"created_at"`

	// Description The video's description.
	Description string `json:"description"`

	// Duration The video's length in ISO 8601 duration format. For example, 3m21s represents 3 minutes, 21 seconds.
	Duration string `json:"duration"`

	// Id An ID that identifies the video.
	Id string `json:"id"`

	// Language The ISO 639-1 two-letter language code that the video was broadcast in. For example, the language code is DE if the video was broadcast in German. For a list of supported languages, see [Supported Stream Language](https://help.twitch.tv/s/article/languages-on-twitch#streamlang). The language value is "other" if the video was broadcast in a language not in the list of supported languages.
	Language string `json:"language"`

	// MutedSegments The segments that Twitch Audio Recognition muted; otherwise, **null**.
	MutedSegments *[]struct {
		// Duration The duration of the muted segment, in seconds.
		Duration int32 `json:"duration"`

		// Offset The offset, in seconds, from the beginning of the video to where the muted segment begins.
		Offset int32 `json:"offset"`
	} `json:"muted_segments"`

	// PublishedAt The date and time, in UTC, of when the video was published. The timestamp is in RFC3339 format.
	PublishedAt time.Time `json:"published_at"`

	// StreamId The ID of the stream that the video originated from if the video's type is "archive;" otherwise, **null**.
	StreamId *string `json:"stream_id"`

	// ThumbnailUrl A URL to a thumbnail image of the video. Before using the URL, you must replace the `%{width}` and `%{height}` placeholders with the width and height of the thumbnail you want returned. Due to current limitations, `${width}` must be 320 and `${height}` must be 180.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The video's title.
	Title string `json:"title"`

	// Type The video's type. Possible values are:
	//
	// * archive  An on-demand video (VOD) of one of the broadcaster's past streams.
	// * highlight  A highlight reel of one of the broadcaster's past streams. See [Creating Highlights](https://help.twitch.tv/s/article/creating-highlights-and-stream-markers).
	// * upload  A video that the broadcaster uploaded to their video library. See Upload under [Video Producer](https://help.twitch.tv/s/article/video-on-demand?language=en%5FUS#videoproducer).
	Type VideoType `json:"type"`

	// Url The video's URL.
	Url string `json:"url"`

	// UserId The ID of the broadcaster that owns the video.
	UserId string `json:"user_id"`

	// UserLogin The broadcaster's login name.
	UserLogin string `json:"user_login"`

	// UserName The broadcaster's display name.
	UserName string `json:"user_name"`

	// ViewCount The number of times that users have watched the video.
	ViewCount int32 `json:"view_count"`

	// Viewable The video's viewable state. Always set to **public**.
	Viewable string `json:"viewable"`
}

func (datatype Video) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Video) GetDescription() string {
	return datatype.Description
}
func (datatype Video) GetDuration() string {
	return datatype.Duration
}
func (datatype Video) GetId() string {
	return datatype.Id
}
func (datatype Video) GetLanguage() string {
	return datatype.Language
}
func (datatype Video) GetMutedSegments() []struct {
	// Duration The duration of the muted segment, in seconds.
	Duration int32 `json:"duration"`

	// Offset The offset, in seconds, from the beginning of the video to where the muted segment begins.
	Offset int32 `json:"offset"`
} {
	if datatype.MutedSegments == nil {
		var empty []struct {
			// Duration The duration of the muted segment, in seconds.
			Duration int32 `json:"duration"`

			// Offset The offset, in seconds, from the beginning of the video to where the muted segment begins.
			Offset int32 `json:"offset"`
		}
		return empty
	}
	return *datatype.MutedSegments
}
func (datatype Video) GetPublishedAt() time.Time {
	return datatype.PublishedAt
}
func (datatype Video) GetStreamId() string {
	if datatype.StreamId == nil {
		var empty string
		return empty
	}
	return *datatype.StreamId
}
func (datatype Video) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Video) GetTitle() string {
	return datatype.Title
}
func (datatype Video) GetType() VideoType {
	return datatype.Type
}
func (datatype Video) GetUrl() string {
	return datatype.Url
}
func (datatype Video) GetUserId() string {
	return datatype.UserId
}
func (datatype Video) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Video) GetUserName() string {
	return datatype.UserName
}
func (datatype Video) GetViewCount() int32 {
	return datatype.ViewCount
}
func (datatype Video) GetViewable() string {
	return datatype.Viewable
}

// VideoType The video's type. Possible values are:
//
// * archive  An on-demand video (VOD) of one of the broadcaster's past streams.
// * highlight  A highlight reel of one of the broadcaster's past streams. See [Creating Highlights](https://help.twitch.tv/s/article/creating-highlights-and-stream-markers).
// * upload  A video that the broadcaster uploaded to their video library. See Upload under [Video Producer](https://help.twitch.tv/s/article/video-on-demand?language=en%5FUS#videoproducer).
type VideoType string

// WarnChatUserBody defines model for WarnChatUserBody.
type WarnChatUserBody struct {
	// Data A list that contains information about the warning.
	Data struct {
		// Reason A custom reason for the warning. **Max 500 chars.**
		Reason string `json:"reason"`

		// UserId The ID of the twitch user to be warned.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype WarnChatUserBody) GetData() struct {
	// Reason A custom reason for the warning. **Max 500 chars.**
	Reason string `json:"reason"`

	// UserId The ID of the twitch user to be warned.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// WarnChatUserResponse defines model for WarnChatUserResponse.
type WarnChatUserResponse struct {
	// Data A list that contains information about the warning.
	Data []struct {
		// BroadcasterId The ID of the channel in which the warning will take effect.
		BroadcasterId string `json:"broadcaster_id"`

		// ModeratorId The ID of the user who applied the warning.
		ModeratorId string `json:"moderator_id"`

		// Reason The reason provided for warning.
		Reason string `json:"reason"`

		// UserId The ID of the warned user.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype WarnChatUserResponse) GetData() []struct {
	// BroadcasterId The ID of the channel in which the warning will take effect.
	BroadcasterId string `json:"broadcaster_id"`

	// ModeratorId The ID of the user who applied the warning.
	ModeratorId string `json:"moderator_id"`

	// Reason The reason provided for warning.
	Reason string `json:"reason"`

	// UserId The ID of the warned user.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// GetExtensionAnalyticsParams defines parameters for GetExtensionAnalytics.
type GetExtensionAnalyticsParams struct {
	// ExtensionId The extension's client ID. If specified, the response contains a report for the specified extension. If not specified, the response includes a report for each extension that the authenticated user owns.
	ExtensionId *string `form:"extension_id,omitempty" json:"extension_id,omitempty"`

	// Type The type of analytics report to get. Possible values are:
	//
	// * overview\_v2
	Type *GetExtensionAnalyticsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// StartedAt The reporting window's start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z).
	//
	// The start date must be on or after January 31, 2018\. If you specify an earlier date, the API ignores it and uses January 31, 2018\. If you specify a start date, you must specify an end date. If you don't specify a start and end date, the report includes all available data since January 31, 2018.
	//
	// The report contains one row of data for each day in the reporting window.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// EndedAt The reporting window's end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-27T00:00:00Z). The report is inclusive of the end date.
	//
	// Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that's earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days.
	EndedAt *time.Time `form:"ended_at,omitempty" json:"ended_at,omitempty"`

	// First The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.
	//
	// **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// This parameter is ignored if the _extension\_id_ parameter is set.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetExtensionAnalyticsParamsType defines parameters for GetExtensionAnalytics.
type GetExtensionAnalyticsParamsType string

// GetGameAnalyticsParams defines parameters for GetGameAnalytics.
type GetGameAnalyticsParams struct {
	// GameId The games client ID. If specified, the response contains a report for the specified game. If not specified, the response includes a report for each of the authenticated users games.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Type The type of analytics report to get. Possible values are:
	//
	// * overview\_v2
	Type *GetGameAnalyticsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// StartedAt The reporting windows start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). If you specify a start date, you must specify an end date.
	//
	// The start date must be within one year of todays date. If you specify an earlier date, the API ignores it and uses a date thats one year prior to todays date. If you dont specify a start and end date, the report includes all available data for the last 365 days from today.
	//
	// The report contains one row of data for each day in the reporting window.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// EndedAt The reporting windows end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). The report is inclusive of the end date.
	//
	// Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date thats earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days.
	EndedAt *time.Time `form:"ended_at,omitempty" json:"ended_at,omitempty"`

	// First The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.
	//
	// **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// This parameter is ignored if _game\_id_ parameter is set.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetGameAnalyticsParamsType defines parameters for GetGameAnalytics.
type GetGameAnalyticsParamsType string

// GetCheermotesParams defines parameters for GetCheermotes.
type GetCheermotesParams struct {
	// BroadcasterId The ID of the broadcaster whose custom Cheermotes you want to get. Specify the broadcasters ID if you want to include the broadcasters Cheermotes in the response (not all broadcasters upload Cheermotes). If not specified, the response contains only global Cheermotes.
	//
	// If the broadcaster uploaded Cheermotes, the `type` field in the response is set to **channel\_custom**.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`
}

// GetExtensionBitsProductsParams defines parameters for GetExtensionBitsProducts.
type GetExtensionBitsProductsParams struct {
	// ShouldIncludeAll A Boolean value that determines whether to include disabled or expired Bits products in the response. The default is **false**.
	ShouldIncludeAll *bool `form:"should_include_all,omitempty" json:"should_include_all,omitempty"`
}

// GetBitsLeaderboardParams defines parameters for GetBitsLeaderboard.
type GetBitsLeaderboardParams struct {
	// Count The number of results to return. The minimum count is 1 and the maximum is 100\. The default is 10.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// Period The time period over which data is aggregated (uses the PST time zone). Possible values are:
	//
	// * day  A day spans from 00:00:00 on the day specified in _started\_at_ and runs through 00:00:00 of the next day.
	// * week  A week spans from 00:00:00 on the Monday of the week specified in _started\_at_ and runs through 00:00:00 of the next Monday.
	// * month  A month spans from 00:00:00 on the first day of the month specified in _started\_at_ and runs through 00:00:00 of the first day of the next month.
	// * year  A year spans from 00:00:00 on the first day of the year specified in _started\_at_ and runs through 00:00:00 of the first day of the next year.
	// * all  Default. The lifetime of the broadcaster's channel.
	Period *GetBitsLeaderboardParamsPeriod `form:"period,omitempty" json:"period,omitempty"`

	// StartedAt The start date, in RFC3339 format, used for determining the aggregation period. Specify this parameter only if you specify the _period_ query parameter. The start date is ignored if _period_ is all.
	//
	// Note that the date is converted to PST before being used, so if you set the start time to `2022-01-01T00:00:00.0Z` and _period_ to month, the actual reporting period is December 2021, not January 2022\. If you want the reporting period to be January 2022, you must set the start time to `2022-01-01T08:00:00.0Z` or `2022-01-01T00:00:00.0-08:00`.
	//
	// If your start date uses the + offset operator (for example, `2022-01-01T00:00:00.0+05:00`), you must URL encode the start date.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// UserId An ID that identifies a user that cheered bits in the channel. If _count_ is greater than 1, the response may include users ranked above and below the specified user. To get the leaderboards top leaders, dont specify a user ID.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// GetBitsLeaderboardParamsPeriod defines parameters for GetBitsLeaderboard.
type GetBitsLeaderboardParamsPeriod string

// DeleteCustomRewardParams defines parameters for DeleteCustomReward.
type DeleteCustomRewardParams struct {
	// BroadcasterId The ID of the broadcaster that created the custom reward. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the custom reward to delete.
	Id string `form:"id" json:"id"`
}

// GetCustomRewardParams defines parameters for GetCustomReward.
type GetCustomRewardParams struct {
	// BroadcasterId The ID of the broadcaster whose custom rewards you want to get. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id A list of IDs to filter the rewards by. To specify more than one ID, include this parameter for each reward you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 50 IDs.
	//
	// Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyManageableRewards A Boolean value that determines whether the response contains only the custom rewards that the app may manage (the app is identified by the ID in the Client-Id header). Set to **true** to get only the custom rewards that the app may manage. The default is **false**.
	OnlyManageableRewards *bool `form:"only_manageable_rewards,omitempty" json:"only_manageable_rewards,omitempty"`
}

// UpdateCustomRewardParams defines parameters for UpdateCustomReward.
type UpdateCustomRewardParams struct {
	// BroadcasterId The ID of the broadcaster thats updating the reward. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the reward to update.
	Id string `form:"id" json:"id"`
}

// CreateCustomRewardsParams defines parameters for CreateCustomRewards.
type CreateCustomRewardsParams struct {
	// BroadcasterId The ID of the broadcaster to add the custom reward to. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetCustomRewardRedemptionParams defines parameters for GetCustomRewardRedemption.
type GetCustomRewardRedemptionParams struct {
	// BroadcasterId The ID of the broadcaster that owns the custom reward. This ID must match the user ID found in the user OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// RewardId The ID that identifies the custom reward whose redemptions you want to get.
	RewardId string `form:"reward_id" json:"reward_id"`

	// Status The status of the redemptions to return. The possible case-sensitive values are:
	//
	// * CANCELED
	// * FULFILLED
	// * UNFULFILLED
	//
	// **NOTE**: This field is required only if you dont specify the _id_ query parameter.
	//
	// **NOTE**: Canceled and fulfilled redemptions are returned for only a few days after theyre canceled or fulfilled.
	Status *GetCustomRewardRedemptionParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Id A list of IDs to filter the redemptions by. To specify more than one ID, include this parameter for each redemption you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 50 IDs.
	//
	// Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Sort The order to sort redemptions by. The possible case-sensitive values are:
	//
	// * OLDEST
	// * NEWEST
	//
	// The default is OLDEST.
	Sort *GetCustomRewardRedemptionParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of redemptions to return per page in the response. The minimum page size is 1 redemption per page and the maximum is 50\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

// GetCustomRewardRedemptionParamsStatus defines parameters for GetCustomRewardRedemption.
type GetCustomRewardRedemptionParamsStatus string

// GetCustomRewardRedemptionParamsSort defines parameters for GetCustomRewardRedemption.
type GetCustomRewardRedemptionParamsSort string

// UpdateRedemptionStatusParams defines parameters for UpdateRedemptionStatus.
type UpdateRedemptionStatusParams struct {
	// Id A list of IDs that identify the redemptions to update. To specify more than one ID, include this parameter for each redemption you want to update. For example, `id=1234&id=5678`. You may specify a maximum of 50 IDs.
	Id []string `form:"id" json:"id"`

	// BroadcasterId The ID of the broadcaster thats updating the redemption. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// RewardId The ID that identifies the reward thats been redeemed.
	RewardId string `form:"reward_id" json:"reward_id"`
}

// GetChannelInformationParams defines parameters for GetChannelInformation.
type GetChannelInformationParams struct {
	// BroadcasterId The ID of the broadcaster whose channel you want to get. To specify more than one ID, include this parameter for each broadcaster you want to get. For example, `broadcaster_id=1234&broadcaster_id=5678`. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that are not found.
	BroadcasterId []string `form:"broadcaster_id" json:"broadcaster_id"`
}

// ModifyChannelInformationParams defines parameters for ModifyChannelInformation.
type ModifyChannelInformationParams struct {
	// BroadcasterId The ID of the broadcaster whose channel you want to update. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetAdScheduleParams defines parameters for GetAdSchedule.
type GetAdScheduleParams struct {
	// BroadcasterId Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// SnoozeNextAdParams defines parameters for SnoozeNextAd.
type SnoozeNextAdParams struct {
	// BroadcasterId Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetChannelEditorsParams defines parameters for GetChannelEditors.
type GetChannelEditorsParams struct {
	// BroadcasterId The ID of the broadcaster that owns the channel. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetFollowedChannelsParams defines parameters for GetFollowedChannels.
type GetFollowedChannelsParams struct {
	// UserId A users ID. Returns the list of broadcasters that this user follows. This ID must match the user ID in the user OAuth token.
	UserId string `form:"user_id" json:"user_id"`

	// BroadcasterId A broadcasters ID. Use this parameter to see whether the user follows this broadcaster. If specified, the response contains this broadcaster if the user follows them. If not specified, the response contains all broadcasters that the user follows.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetChannelFollowersParams defines parameters for GetChannelFollowers.
type GetChannelFollowersParams struct {
	// UserId A users ID. Use this parameter to see whether the user follows this broadcaster. If specified, the response contains this user if they follow the broadcaster. If not specified, the response contains all users that follow the broadcaster.
	//
	// Using this parameter requires both a user access token with the **moderator:read:followers** scope and the user ID in the access token match the broadcaster\_id or be the user ID for a moderator of the specified broadcaster.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// BroadcasterId The broadcasters ID. Returns the list of users that follow this broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// RemoveChannelVipParams defines parameters for RemoveChannelVip.
type RemoveChannelVipParams struct {
	// UserId The ID of the user to remove VIP status from.
	UserId string `form:"user_id" json:"user_id"`

	// BroadcasterId The ID of the broadcaster who owns the channel where the user has VIP status.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetVipsParams defines parameters for GetVips.
type GetVipsParams struct {
	// UserId Filters the list for specific VIPs. To specify more than one user, include the _user\_id_ parameter for each user to get. For example, `&user_id=1234&user_id=5678`. The maximum number of IDs that you may specify is 100\. Ignores the ID of those users in the list that arent VIPs.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// BroadcasterId The ID of the broadcaster whose list of VIPs you want to get. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// AddChannelVipParams defines parameters for AddChannelVip.
type AddChannelVipParams struct {
	// UserId The ID of the user to give VIP status to.
	UserId string `form:"user_id" json:"user_id"`

	// BroadcasterId The ID of the broadcaster thats adding the user as a VIP. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetCharityCampaignParams defines parameters for GetCharityCampaign.
type GetCharityCampaignParams struct {
	// BroadcasterId The ID of the broadcaster thats currently running a charity campaign. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetCharityCampaignDonationsParams defines parameters for GetCharityCampaignDonations.
type GetCharityCampaignDonationsParams struct {
	// BroadcasterId The ID of the broadcaster thats currently running a charity campaign. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// SendChatAnnouncementParams defines parameters for SendChatAnnouncement.
type SendChatAnnouncementParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room to send the announcement to.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of a user who has permission to moderate the broadcasters chat room, or the broadcasters ID if theyre sending the announcement. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// GetChannelChatBadgesParams defines parameters for GetChannelChatBadges.
type GetChannelChatBadgesParams struct {
	// BroadcasterId The ID of the broadcaster whose chat badges you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetChattersParams defines parameters for GetChatters.
type GetChattersParams struct {
	// BroadcasterId The ID of the broadcaster whose list of chatters you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or one of the broadcasters moderators. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 1,000\. The default is 100.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetUserChatColorParams defines parameters for GetUserChatColor.
type GetUserChatColorParams struct {
	// UserId The ID of the user whose username color you want to get. To specify more than one user, include the _user\_id_ parameter for each user to get. For example, `&user_id=1234&user_id=5678`. The maximum number of IDs that you may specify is 100.
	//
	// The API ignores duplicate IDs and IDs that werent found.
	UserId []string `form:"user_id" json:"user_id"`
}

// UpdateUserChatColorParams defines parameters for UpdateUserChatColor.
type UpdateUserChatColorParams struct {
	// UserId The ID of the user whose chat color you want to update. This ID must match the user ID in the access token.
	UserId string `form:"user_id" json:"user_id"`

	// Color The color to use for the user's name in chat. All users may specify one of the following named color values.
	//
	// * blue
	// * blue\_violet
	// * cadet\_blue
	// * chocolate
	// * coral
	// * dodger\_blue
	// * firebrick
	// * golden\_rod
	// * green
	// * hot\_pink
	// * orange\_red
	// * red
	// * sea\_green
	// * spring\_green
	// * yellow\_green
	//
	// Turbo and Prime users may specify a named color or a Hex color code like #9146FF. If you use a Hex color code, remember to URL encode it.
	Color UpdateUserChatColorParamsColor `form:"color" json:"color"`
}

// UpdateUserChatColorParamsColor defines parameters for UpdateUserChatColor.
type UpdateUserChatColorParamsColor string

// GetChannelEmotesParams defines parameters for GetChannelEmotes.
type GetChannelEmotesParams struct {
	// BroadcasterId An ID that identifies the broadcaster whose emotes you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetEmoteSetsParams defines parameters for GetEmoteSets.
type GetEmoteSetsParams struct {
	// EmoteSetId An ID that identifies the emote set to get. Include this parameter for each emote set you want to get. For example, `emote_set_id=1234&emote_set_id=5678`. You may specify a maximum of 25 IDs. The response contains only the IDs that were found and ignores duplicate IDs.
	//
	// To get emote set IDs, use the [Get Channel Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.
	EmoteSetId []string `form:"emote_set_id" json:"emote_set_id"`
}

// GetUserEmotesParams defines parameters for GetUserEmotes.
type GetUserEmotesParams struct {
	// UserId The ID of the user. This ID must match the user ID in the user access token.
	UserId string `form:"user_id" json:"user_id"`

	// After The cursor used to get the next page of results. The Pagination object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// BroadcasterId The User ID of a broadcaster you wish to get follower emotes of. Using this query parameter will guarantee inclusion of the broadcasters follower emotes in the response body.
	//
	// **Note:** If the user specified in `user_id` is subscribed to the broadcaster specified, their follower emotes will appear in the response body regardless if this query parameter is used.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`
}

// GetChatSettingsParams defines parameters for GetChatSettings.
type GetChatSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose chat settings you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or one of the broadcasters moderators.
	//
	// This field is required only if you want to include the `non_moderator_chat_delay` and `non_moderator_chat_delay_duration` settings in the response.
	//
	// If you specify this field, this ID must match the user ID in the user access token.
	ModeratorId *string `form:"moderator_id,omitempty" json:"moderator_id,omitempty"`
}

// UpdateChatSettingsParams defines parameters for UpdateChatSettings.
type UpdateChatSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose chat settings you want to update.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of a user that has permission to moderate the broadcasters chat room, or the broadcasters ID if theyre making the update. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// SendAShoutoutParams defines parameters for SendAShoutout.
type SendAShoutoutParams struct {
	// FromBroadcasterId The ID of the broadcaster thats sending the Shoutout.
	FromBroadcasterId string `form:"from_broadcaster_id" json:"from_broadcaster_id"`

	// ToBroadcasterId The ID of the broadcaster thats receiving the Shoutout.
	ToBroadcasterId string `form:"to_broadcaster_id" json:"to_broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that is one of the broadcasters moderators. This ID must match the user ID in the access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// GetClipsParams defines parameters for GetClips.
type GetClipsParams struct {
	// BroadcasterId An ID that identifies the broadcaster whose video clips you want to get. Use this parameter to get clips that were captured from the broadcasters streams.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`

	// GameId An ID that identifies the game whose clips you want to get. Use this parameter to get clips that were captured from streams that were playing this game.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Id An ID that identifies the clip to get. To specify more than one ID, include this parameter for each clip you want to get. For example, `id=foo&id=bar`. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that arent found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// StartedAt The start date used to filter clips. The API returns only clips within the start and end date window. Specify the date and time in RFC3339 format.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// EndedAt The end date used to filter clips. If not specified, the time window is the start date plus one week. Specify the date and time in RFC3339 format.
	EndedAt *time.Time `form:"ended_at,omitempty" json:"ended_at,omitempty"`

	// First The maximum number of clips to return per page in the response. The minimum page size is 1 clip per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// IsFeatured A Boolean value that determines whether the response includes featured clips. If **true**, returns only clips that are featured. If **false**, returns only clips that arent featured. All clips are returned if this parameter is not present.
	IsFeatured *bool `form:"is_featured,omitempty" json:"is_featured,omitempty"`
}

// CreateClipParams defines parameters for CreateClip.
type CreateClipParams struct {
	// BroadcasterId The ID of the broadcaster whose stream you want to create a clip from.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// HasDelay A Boolean value that determines whether the API captures the clip at the moment the viewer requests it or after a delay. If **false** (default), Twitch captures the clip at the moment the viewer requests it (this is the same clip experience as the Twitch UX). If **true**, Twitch adds a delay before capturing the clip (this basically shifts the capture window to the right slightly).
	HasDelay *bool `form:"has_delay,omitempty" json:"has_delay,omitempty"`
}

// GetContentClassificationLabelsParams defines parameters for GetContentClassificationLabels.
type GetContentClassificationLabelsParams struct {
	// Locale Locale for the Content Classification Labels. You may specify a maximum of 1 locale. Default: `en-US`
	// Supported locales: `"bg-BG", "cs-CZ", "da-DK", "da-DK", "de-DE", "el-GR", "en-GB", "en-US", "es-ES", "es-MX", "fi-FI", "fr-FR", "hu-HU", "it-IT", "ja-JP", "ko-KR", "nl-NL", "no-NO", "pl-PL", "pt-BT", "pt-PT", "ro-RO", "ru-RU", "sk-SK", "sv-SE", "th-TH", "tr-TR", "vi-VN", "zh-CN", "zh-TW"`
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

// GetDropsEntitlementsParams defines parameters for GetDropsEntitlements.
type GetDropsEntitlementsParams struct {
	// Id An ID that identifies the entitlement to get. Include this parameter for each entitlement you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// UserId An ID that identifies a user that was granted entitlements.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// GameId An ID that identifies a game that offered entitlements.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// FulfillmentStatus The entitlements fulfillment status. Used to filter the list to only those with the specified status. Possible values are:
	//
	// * CLAIMED
	// * FULFILLED
	FulfillmentStatus *GetDropsEntitlementsParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of entitlements to return per page in the response. The minimum page size is 1 entitlement per page and the maximum is 1000\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

// GetDropsEntitlementsParamsFulfillmentStatus defines parameters for GetDropsEntitlements.
type GetDropsEntitlementsParamsFulfillmentStatus string

// DeleteConduitParams defines parameters for DeleteConduit.
type DeleteConduitParams struct {
	// Id Conduit ID.
	Id string `form:"id" json:"id"`
}

// GetConduitShardsParams defines parameters for GetConduitShards.
type GetConduitShardsParams struct {
	// ConduitId Conduit ID.
	ConduitId string `form:"conduit_id" json:"conduit_id"`

	// Status Status to filter by.
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// After The cursor used to get the next page of results. The pagination object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// DeleteEventsubSubscriptionParams defines parameters for DeleteEventsubSubscription.
type DeleteEventsubSubscriptionParams struct {
	// Id The ID of the subscription to delete.
	Id string `form:"id" json:"id"`
}

// GetEventsubSubscriptionsParams defines parameters for GetEventsubSubscriptions.
type GetEventsubSubscriptionsParams struct {
	// Status Filter subscriptions by its status. Possible values are:
	//
	// * enabled  The subscription is enabled.
	// * webhook\_callback\_verification\_pending  The subscription is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * authorization\_revoked  The authorization was revoked for one or more users specified in the **Condition** object.
	// * moderator\_removed  The moderator that authorized the subscription is no longer one of the broadcaster's moderators.
	// * user\_removed  One of the users specified in the **Condition** object was removed.
	// * chat\_user\_banned - The user specified in the **Condition** object was banned from the broadcaster's chat.
	// * version\_removed  The subscription to subscription type and version is no longer supported.
	// * beta\_maintenance  The subscription to the beta subscription type was removed due to maintenance.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_connection\_unused  The client failed to subscribe to events within the required time.
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	Status *GetEventsubSubscriptionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Type Filter subscriptions by subscription type. For a list of subscription types, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types).
	Type *GetEventsubSubscriptionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// UserId Filter subscriptions by user ID. The response contains subscriptions where this ID matches a user ID that you specified in the **Condition** object when you [created the subscription](https://dev.twitch.tv/docs/api/reference#create-eventsub-subscription).
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// SubscriptionId Returns an array with the subscription matching the ID (as long as it is owned by the client making the request), or an empty array if there is no matching subscription.
	SubscriptionId *string `form:"subscription_id,omitempty" json:"subscription_id,omitempty"`

	// After The cursor used to get the next page of results. The `pagination` object in the response contains the cursor's value.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetEventsubSubscriptionsParamsStatus defines parameters for GetEventsubSubscriptions.
type GetEventsubSubscriptionsParamsStatus string

// GetEventsubSubscriptionsParamsType defines parameters for GetEventsubSubscriptions.
type GetEventsubSubscriptionsParamsType string

// GetExtensionsParams defines parameters for GetExtensions.
type GetExtensionsParams struct {
	// ExtensionId The ID of the extension to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// ExtensionVersion The version of the extension to get. If not specified, it returns the latest, released version. If you dont have a released version, you must specify a version; otherwise, the list is empty.
	ExtensionVersion *string `form:"extension_version,omitempty" json:"extension_version,omitempty"`
}

// SendExtensionChatMessageParams defines parameters for SendExtensionChatMessage.
type SendExtensionChatMessageParams struct {
	// BroadcasterId The ID of the broadcaster that has activated the extension.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetExtensionConfigurationSegmentParams defines parameters for GetExtensionConfigurationSegment.
type GetExtensionConfigurationSegmentParams struct {
	// BroadcasterId The ID of the broadcaster that installed the extension. This parameter is required if you set the _segment_ parameter to broadcaster or developer. Do not specify this parameter if you set _segment_ to global.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`

	// ExtensionId The ID of the extension that contains the configuration segment you want to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// Segment The type of configuration segment to get. Possible case-sensitive values are:
	//
	// * broadcaster
	// * developer
	// * global
	//
	// You may specify one or more segments. To specify multiple segments, include the `segment` parameter for each segment to get. For example, `segment=broadcaster&segment=developer`. Ignores duplicate segments.
	Segment GetExtensionConfigurationSegmentParamsSegment `form:"segment" json:"segment"`
}

// GetExtensionConfigurationSegmentParamsSegment defines parameters for GetExtensionConfigurationSegment.
type GetExtensionConfigurationSegmentParamsSegment string

// CreateExtensionSecretParams defines parameters for CreateExtensionSecret.
type CreateExtensionSecretParams struct {
	// ExtensionId The ID of the extension to apply the shared secret to.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// Delay The amount of time, in seconds, to delay activating the secret. The delay should provide enough time for instances of the extension to gracefully switch over to the new secret. The minimum delay is 300 seconds (5 minutes). The default is 300 seconds.
	Delay *int32 `form:"delay,omitempty" json:"delay,omitempty"`
}

// GetExtensionLiveChannelsParams defines parameters for GetExtensionLiveChannels.
type GetExtensionLiveChannelsParams struct {
	// ExtensionId The ID of the extension to get. Returns the list of broadcasters that are live and that have installed or activated this extension.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// First The specific maximum number of items per page in the response. The actual number returned may be less than this limit. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The `pagination` field in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetReleasedExtensionsParams defines parameters for GetReleasedExtensions.
type GetReleasedExtensionsParams struct {
	// ExtensionId The ID of the extension to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// ExtensionVersion The version of the extension to get. If not specified, it returns the latest version.
	ExtensionVersion *string `form:"extension_version,omitempty" json:"extension_version,omitempty"`
}

// SetExtensionRequiredConfigurationParams defines parameters for SetExtensionRequiredConfiguration.
type SetExtensionRequiredConfigurationParams struct {
	// BroadcasterId The ID of the broadcaster that installed the extension on their channel.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetExtensionTransactionsParams defines parameters for GetExtensionTransactions.
type GetExtensionTransactionsParams struct {
	// ExtensionId The ID of the extension whose list of transactions you want to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// Id A transaction ID used to filter the list of transactions. Specify this parameter for each transaction you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// Id The ID of the category or game to get. Include this parameter for each category or game you want to get. For example, `&id=1234&id=5678`. You may specify a maximum of 100 IDs. The endpoint ignores duplicate and invalid IDs or IDs that werent found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Name The name of the category or game to get. The name must exactly match the categorys or games title. Include this parameter for each category or game you want to get. For example, `&name=foo&name=bar`. You may specify a maximum of 100 names. The endpoint ignores duplicate names and names that werent found.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// IgdbId The [IGDB](https://www.igdb.com/) ID of the game to get. Include this parameter for each game you want to get. For example, `&igdb_id=1234&igdb_id=5678`. You may specify a maximum of 100 IDs. The endpoint ignores duplicate and invalid IDs or IDs that werent found.
	IgdbId *[]string `form:"igdb_id,omitempty" json:"igdb_id,omitempty"`
}

// GetTopGamesParams defines parameters for GetTopGames.
type GetTopGamesParams struct {
	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetCreatorGoalsParams defines parameters for GetCreatorGoals.
type GetCreatorGoalsParams struct {
	// BroadcasterId The ID of the broadcaster that created the goals. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetChannelGuestStarSettingsParams defines parameters for GetChannelGuestStarSettings.
type GetChannelGuestStarSettingsParams struct {
	// BroadcasterId The ID of the broadcaster you want to get guest star settings for.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// UpdateChannelGuestStarSettingsParams defines parameters for UpdateChannelGuestStarSettings.
type UpdateChannelGuestStarSettingsParams struct {
	// BroadcasterId The ID of the broadcaster you want to update Guest Star settings for.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// DeleteGuestStarInviteParams defines parameters for DeleteGuestStarInvite.
type DeleteGuestStarInviteParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the session for the invite to be revoked on behalf of the broadcaster.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId Twitch User ID for the guest to revoke the Guest Star session invite from.
	GuestId string `form:"guest_id" json:"guest_id"`
}

// GetGuestStarInvitesParams defines parameters for GetGuestStarInvites.
type GetGuestStarInvitesParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The session ID to query for invite status.
	SessionId string `form:"session_id" json:"session_id"`
}

// SendGuestStarInviteParams defines parameters for SendGuestStarInvite.
type SendGuestStarInviteParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The session ID for the invite to be sent on behalf of the broadcaster.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId Twitch User ID for the guest to invite to the Guest Star session.
	GuestId string `form:"guest_id" json:"guest_id"`
}

// EndGuestStarSessionParams defines parameters for EndGuestStarSession.
type EndGuestStarSessionParams struct {
	// BroadcasterId The ID of the broadcaster you want to end a Guest Star session for. Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// SessionId ID for the session to end on behalf of the broadcaster.
	SessionId string `form:"session_id" json:"session_id"`
}

// GetGuestStarSessionParams defines parameters for GetGuestStarSession.
type GetGuestStarSessionParams struct {
	// BroadcasterId ID for the user hosting the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// CreateGuestStarSessionParams defines parameters for CreateGuestStarSession.
type CreateGuestStarSessionParams struct {
	// BroadcasterId The ID of the broadcaster you want to create a Guest Star session for. Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// DeleteGuestStarSlotParams defines parameters for DeleteGuestStarSlot.
type DeleteGuestStarSlotParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to remove the slot assignment.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId The Twitch User ID corresponding to the guest to remove from the session.
	GuestId string `form:"guest_id" json:"guest_id"`

	// SlotId The slot ID representing the slot assignment to remove from the session.
	SlotId string `form:"slot_id" json:"slot_id"`

	// ShouldReinviteGuest Flag signaling that the guest should be reinvited to the session, sending them back to the invite queue.
	ShouldReinviteGuest *string `form:"should_reinvite_guest,omitempty" json:"should_reinvite_guest,omitempty"`
}

// UpdateGuestStarSlotParams defines parameters for UpdateGuestStarSlot.
type UpdateGuestStarSlotParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to update slot settings.
	SessionId string `form:"session_id" json:"session_id"`

	// SourceSlotId The slot assignment previously assigned to a user.
	SourceSlotId string `form:"source_slot_id" json:"source_slot_id"`

	// DestinationSlotId The slot to move this user assignment to. If the destination slot is occupied, the user assigned will be swapped into `source_slot_id`.
	DestinationSlotId *string `form:"destination_slot_id,omitempty" json:"destination_slot_id,omitempty"`
}

// AssignGuestStarSlotParams defines parameters for AssignGuestStarSlot.
type AssignGuestStarSlotParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to assign the slot.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId The Twitch User ID corresponding to the guest to assign a slot in the session. This user must already have an invite to this session, and have indicated that they are ready to join.
	GuestId string `form:"guest_id" json:"guest_id"`

	// SlotId The slot assignment to give to the user. Must be a numeric identifier between 1 and N where N is the max number of slots for the session. Max number of slots allowed for the session is reported by [Get Channel Guest Star Settings](https://dev.twitch.tv/docs/api/reference#get-channel-guest-star-settings).
	SlotId string `form:"slot_id" json:"slot_id"`
}

// UpdateGuestStarSlotSettingsParams defines parameters for UpdateGuestStarSlotSettings.
type UpdateGuestStarSlotSettingsParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to update a slots settings.
	SessionId string `form:"session_id" json:"session_id"`

	// SlotId The slot assignment that has previously been assigned to a user.
	SlotId string `form:"slot_id" json:"slot_id"`

	// IsAudioEnabled Flag indicating whether the slot is allowed to share their audio with the rest of the session. If false, the slot will be muted in any views containing the slot.
	IsAudioEnabled *bool `form:"is_audio_enabled,omitempty" json:"is_audio_enabled,omitempty"`

	// IsVideoEnabled Flag indicating whether the slot is allowed to share their video with the rest of the session. If false, the slot will have no video shared in any views containing the slot.
	IsVideoEnabled *bool `form:"is_video_enabled,omitempty" json:"is_video_enabled,omitempty"`

	// IsLive Flag indicating whether the user assigned to this slot is visible/can be heard from any public subscriptions. Generally, this determines whether or not the slot is enabled in any broadcasting software integrations.
	IsLive *bool `form:"is_live,omitempty" json:"is_live,omitempty"`

	// Volume Value from 0-100 that controls the audio volume for shared views containing the slot.
	Volume *int32 `form:"volume,omitempty" json:"volume,omitempty"`
}

// GetHypeTrainEventsParams defines parameters for GetHypeTrainEvents.
type GetHypeTrainEventsParams struct {
	// BroadcasterId The ID of the broadcaster thats running the Hype Train. This ID must match the User ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 1.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetHypeTrainStatusParams defines parameters for GetHypeTrainStatus.
type GetHypeTrainStatusParams struct {
	// BroadcasterId The User ID of the channel broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetAutomodSettingsParams defines parameters for GetAutomodSettings.
type GetAutomodSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose AutoMod settings you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// UpdateAutomodSettingsParams defines parameters for UpdateAutomodSettings.
type UpdateAutomodSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose AutoMod settings you want to update.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// GetBannedUsersParams defines parameters for GetBannedUsers.
type GetBannedUsersParams struct {
	// BroadcasterId The ID of the broadcaster whose list of banned users you want to get. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each user you want to get. For example, `user_id=1234&user_id=5678`. You may specify a maximum of 100 IDs.
	//
	// The returned list includes only those users that were banned or put in a timeout. The list is returned in the same order that you specified the IDs.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// UnbanUserParams defines parameters for UnbanUser.
type UnbanUserParams struct {
	// BroadcasterId The ID of the broadcaster whose chat room the user is banned from chatting in.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// UserId The ID of the user to remove the ban or timeout from.
	UserId string `form:"user_id" json:"user_id"`
}

// BanUserParams defines parameters for BanUser.
type BanUserParams struct {
	// BroadcasterId The ID of the broadcaster whose chat room the user is being banned from.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// RemoveBlockedTermParams defines parameters for RemoveBlockedTerm.
type RemoveBlockedTermParams struct {
	// BroadcasterId The ID of the broadcaster that owns the list of blocked terms.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// Id The ID of the blocked term to remove from the broadcasters list of blocked terms.
	Id string `form:"id" json:"id"`
}

// GetBlockedTermsParams defines parameters for GetBlockedTerms.
type GetBlockedTermsParams struct {
	// BroadcasterId The ID of the broadcaster whose blocked terms youre getting.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// AddBlockedTermParams defines parameters for AddBlockedTerm.
type AddBlockedTermParams struct {
	// BroadcasterId The ID of the broadcaster that owns the list of blocked terms.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// GetModeratedChannelsParams defines parameters for GetModeratedChannels.
type GetModeratedChannelsParams struct {
	// UserId A users ID. Returns the list of channels that this user has moderator privileges in. This ID must match the user ID in the user OAuth token
	UserId string `form:"user_id" json:"user_id"`

	// After The cursor used to get the next page of results. The Pagination object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of items to return per page in the response.
	//
	// Minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

// DeleteChatMessagesParams defines parameters for DeleteChatMessages.
type DeleteChatMessagesParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room to remove messages from.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// MessageId The ID of the message to remove. The `id` tag in the [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains the messages ID. Restrictions:
	//
	// * The message must have been created within the last 6 hours.
	// * The message must not belong to the broadcaster.
	// * The message must not belong to another moderator.
	//
	// If not specified, the request removes all messages in the broadcasters chat room.
	MessageId *string `form:"message_id,omitempty" json:"message_id,omitempty"`
}

// CheckAutomodStatusParams defines parameters for CheckAutomodStatus.
type CheckAutomodStatusParams struct {
	// BroadcasterId The ID of the broadcaster whose AutoMod settings and list of blocked terms are used to check the message. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// RemoveChannelModeratorParams defines parameters for RemoveChannelModerator.
type RemoveChannelModeratorParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId The ID of the user to remove as a moderator from the broadcasters chat room.
	UserId string `form:"user_id" json:"user_id"`
}

// GetModeratorsParams defines parameters for GetModerators.
type GetModeratorsParams struct {
	// BroadcasterId The ID of the broadcaster whose list of moderators you want to get. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each moderator you want to get. For example, `user_id=1234&user_id=5678`. You may specify a maximum of 100 IDs.
	//
	// The returned list includes only the users from the list who are moderators in the broadcasters channel. The list is returned in the same order as you specified the IDs.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// AddChannelModeratorParams defines parameters for AddChannelModerator.
type AddChannelModeratorParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId The ID of the user to add as a moderator in the broadcasters chat room.
	UserId string `form:"user_id" json:"user_id"`
}

// GetShieldModeStatusParams defines parameters for GetShieldModeStatus.
type GetShieldModeStatusParams struct {
	// BroadcasterId The ID of the broadcaster whose Shield Mode activation status you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that is one of the broadcasters moderators. This ID must match the user ID in the access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// UpdateShieldModeStatusParams defines parameters for UpdateShieldModeStatus.
type UpdateShieldModeStatusParams struct {
	// BroadcasterId The ID of the broadcaster whose Shield Mode you want to activate or deactivate.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that is one of the broadcasters moderators. This ID must match the user ID in the access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// GetUnbanRequestsParams defines parameters for GetUnbanRequests.
type GetUnbanRequestsParams struct {
	// BroadcasterId The ID of the broadcaster whose channel is receiving unban requests.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters unban requests. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// Status Filter by a status.
	//
	// * pending
	// * approved
	// * denied
	// * acknowledged
	// * canceled
	Status string `form:"status" json:"status"`

	// UserId The ID used to filter what unban requests are returned.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// After Cursor used to get next page of results. Pagination object in response contains cursor value.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of items to return per page in response
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

// ResolveUnbanRequestsParams defines parameters for ResolveUnbanRequests.
type ResolveUnbanRequestsParams struct {
	// BroadcasterId The ID of the broadcaster whose channel is approving or denying the unban request.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters unban requests. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// UnbanRequestId The ID of the broadcaster or a user that has permission to moderate the broadcasters unban requests. This ID must match the user ID in the user access token.
	UnbanRequestId string `form:"unban_request_id" json:"unban_request_id"`

	// Status Resolution status.
	//
	// * approved
	// * denied
	Status string `form:"status" json:"status"`

	// ResolutionText Message supplied by the unban request resolver. The message is limited to a maximum of 500 characters.
	ResolutionText *string `form:"resolution_text,omitempty" json:"resolution_text,omitempty"`
}

// WarnChatUserParams defines parameters for WarnChatUser.
type WarnChatUserParams struct {
	// BroadcasterId The ID of the channel in which the warning will take effect.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the twitch user who requested the warning.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

// GetPollsParams defines parameters for GetPolls.
type GetPollsParams struct {
	// BroadcasterId The ID of the broadcaster that created the polls. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id A list of IDs that identify the polls to return. To specify more than one ID, include this parameter for each poll you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 20 IDs.
	//
	// Specify this parameter only if you want to filter the list that the request returns. The endpoint ignores duplicate IDs and those not owned by this broadcaster.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 20 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetPredictionsParams defines parameters for GetPredictions.
type GetPredictionsParams struct {
	// BroadcasterId The ID of the broadcaster whose predictions you want to get. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the prediction to get. To specify more than one ID, include this parameter for each prediction you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 25 IDs. The endpoint ignores duplicate IDs and those not owned by the broadcaster.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// CancelARaidParams defines parameters for CancelARaid.
type CancelARaidParams struct {
	// BroadcasterId The ID of the broadcaster that initiated the raid. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// StartARaidParams defines parameters for StartARaid.
type StartARaidParams struct {
	// FromBroadcasterId The ID of the broadcaster thats sending the raiding party. This ID must match the user ID in the user access token.
	FromBroadcasterId *string `form:"from_broadcaster_id,omitempty" json:"from_broadcaster_id,omitempty"`

	// ToBroadcasterId The ID of the broadcaster to raid.
	ToBroadcasterId *string `form:"to_broadcaster_id,omitempty" json:"to_broadcaster_id,omitempty"`
}

// GetChannelStreamScheduleParams defines parameters for GetChannelStreamSchedule.
type GetChannelStreamScheduleParams struct {
	// BroadcasterId The ID of the broadcaster that owns the streaming schedule you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// StartTime The UTC date and time that identifies when in the broadcasters schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, `2022-09-01T00:00:00Z`).
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// UtcOffset Not supported.
	UtcOffset *string `form:"utc_offset,omitempty" json:"utc_offset,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetChannelIcalendarParams defines parameters for GetChannelIcalendar.
type GetChannelIcalendarParams struct {
	// BroadcasterId The ID of the broadcaster that owns the streaming schedule you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// DeleteChannelStreamScheduleSegmentParams defines parameters for DeleteChannelStreamScheduleSegment.
type DeleteChannelStreamScheduleSegmentParams struct {
	// BroadcasterId The ID of the broadcaster that owns the streaming schedule. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the broadcast segment to remove.
	Id string `form:"id" json:"id"`
}

// UpdateChannelStreamScheduleSegmentParams defines parameters for UpdateChannelStreamScheduleSegment.
type UpdateChannelStreamScheduleSegmentParams struct {
	// BroadcasterId The ID of the broadcaster who owns the broadcast segment to update. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the broadcast segment to update.
	Id string `form:"id" json:"id"`
}

// CreateChannelStreamScheduleSegmentParams defines parameters for CreateChannelStreamScheduleSegment.
type CreateChannelStreamScheduleSegmentParams struct {
	// BroadcasterId The ID of the broadcaster that owns the schedule to add the broadcast segment to. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// UpdateChannelStreamScheduleParams defines parameters for UpdateChannelStreamSchedule.
type UpdateChannelStreamScheduleParams struct {
	// BroadcasterId The ID of the broadcaster whose schedule settings you want to update. The ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// IsVacationEnabled A Boolean value that indicates whether the broadcaster has scheduled a vacation. Set to **true** to enable Vacation Mode and add vacation dates, or **false** to cancel a previously scheduled vacation.
	IsVacationEnabled *bool `form:"is_vacation_enabled,omitempty" json:"is_vacation_enabled,omitempty"`

	// VacationStartTime The UTC date and time of when the broadcasters vacation starts. Specify the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z). Required if _is\_vacation\_enabled_ is **true**.
	VacationStartTime *time.Time `form:"vacation_start_time,omitempty" json:"vacation_start_time,omitempty"`

	// VacationEndTime The UTC date and time of when the broadcasters vacation ends. Specify the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z). Required if _is\_vacation\_enabled_ is **true**.
	VacationEndTime *time.Time `form:"vacation_end_time,omitempty" json:"vacation_end_time,omitempty"`

	// Timezone The time zone that the broadcaster broadcasts from. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\_York). Required if _is\_vacation\_enabled_ is **true**.
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty"`
}

// SearchCategoriesParams defines parameters for SearchCategories.
type SearchCategoriesParams struct {
	// Query The URI-encoded search string. For example, encode _#archery_ as `%23archery` and search strings like _angel of death_ as `angel%20of%20death`.
	Query string `form:"query" json:"query"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// SearchChannelsParams defines parameters for SearchChannels.
type SearchChannelsParams struct {
	// Query The URI-encoded search string. For example, encode search strings like _angel of death_ as `angel%20of%20death`.
	Query string `form:"query" json:"query"`

	// LiveOnly A Boolean value that determines whether the response includes only channels that are currently streaming live. Set to **true** to get only channels that are streaming live; otherwise, **false** to get live and offline channels. The default is **false**.
	LiveOnly *bool `form:"live_only,omitempty" json:"live_only,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetSharedChatSessionParams defines parameters for GetSharedChatSession.
type GetSharedChatSessionParams struct {
	// BroadcasterId The User ID of the channel broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetStreamsParams defines parameters for GetStreams.
type GetStreamsParams struct {
	// UserId A user ID used to filter the list of streams. Returns only the streams of those users that are broadcasting. You may specify a maximum of 100 IDs. To specify multiple IDs, include the _user\_id_ parameter for each user. For example, `&user_id=1234&user_id=5678`.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// UserLogin A user login name used to filter the list of streams. Returns only the streams of those users that are broadcasting. You may specify a maximum of 100 login names. To specify multiple names, include the _user\_login_ parameter for each user. For example, `&user_login=foo&user_login=bar`.
	UserLogin *[]string `form:"user_login,omitempty" json:"user_login,omitempty"`

	// GameId A game (category) ID used to filter the list of streams. Returns only the streams that are broadcasting the game (category). You may specify a maximum of 100 IDs. To specify multiple IDs, include the _game\_id_ parameter for each game. For example, `&game_id=9876&game_id=5432`.
	GameId *[]string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Type The type of stream to filter the list of streams by. Possible values are:
	//
	// * all
	// * live
	//
	// The default is _all_.
	Type *GetStreamsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Language A language code used to filter the list of streams. Returns only streams that broadcast in the specified language. Specify the language using an ISO 639-1 two-letter language code or _other_ if the broadcast uses a language not in the list of [supported stream languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang).
	//
	// You may specify a maximum of 100 language codes. To specify multiple languages, include the _language_ parameter for each language. For example, `&language=de&language=fr`.
	Language *[]string `form:"language,omitempty" json:"language,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetStreamsParamsType defines parameters for GetStreams.
type GetStreamsParamsType string

// GetFollowedStreamsParams defines parameters for GetFollowedStreams.
type GetFollowedStreamsParams struct {
	// UserId The ID of the user whose list of followed streams you want to get. This ID must match the user ID in the access token.
	UserId string `form:"user_id" json:"user_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 100.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetStreamKeyParams defines parameters for GetStreamKey.
type GetStreamKeyParams struct {
	// BroadcasterId The ID of the broadcaster that owns the channel. The ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetStreamMarkersParams defines parameters for GetStreamMarkers.
type GetStreamMarkersParams struct {
	// UserId A user ID. The request returns the markers from this users most recent video. This ID must match the user ID in the access token or the user in the access token must be one of the broadcasters editors.
	//
	// This parameter and the _video\_id_ query parameter are mutually exclusive.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// VideoId A video on demand (VOD)/video ID. The request returns the markers from this VOD/video. The user in the access token must own the video or the user must be one of the broadcasters editors.
	//
	// This parameter and the _user\_id_ query parameter are mutually exclusive.
	VideoId *string `form:"video_id,omitempty" json:"video_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetStreamTagsParams defines parameters for GetStreamTags.
type GetStreamTagsParams struct {
	// BroadcasterId The ID of the broadcaster whose stream tags you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetBroadcasterSubscriptionsParams defines parameters for GetBroadcasterSubscriptions.
type GetBroadcasterSubscriptionsParams struct {
	// BroadcasterId The broadcasters ID. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId Filters the list to include only the specified subscribers. To specify more than one subscriber, include this parameter for each subscriber. For example, `&user_id=1234&user_id=5678`. You may specify a maximum of 100 subscribers.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. Do not specify if you set the _user\_id_ query parameter. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. Do not specify if you set the _user\_id_ query parameter. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// CheckUserSubscriptionParams defines parameters for CheckUserSubscription.
type CheckUserSubscriptionParams struct {
	// BroadcasterId The ID of a partner or affiliate broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId The ID of the user that youre checking to see whether they subscribe to the broadcaster in _broadcaster\_id_. This ID must match the user ID in the access Token.
	UserId string `form:"user_id" json:"user_id"`
}

// GetAllStreamTagsParams defines parameters for GetAllStreamTags.
type GetAllStreamTagsParams struct {
	// TagId The ID of the tag to get. Used to filter the list of tags. To specify more than one tag, include the _tag\_id_ parameter for each tag to get. For example, `tag_id=1234&tag_id=5678`. The maximum number of IDs you may specify is 100\. Ignores invalid IDs but not duplicate IDs.
	TagId *[]string `form:"tag_id,omitempty" json:"tag_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// Name The name of the team to get. This parameter and the _id_ parameter are mutually exclusive; you must specify the teams name or ID but not both.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Id The ID of the team to get. This parameter and the _name_ parameter are mutually exclusive; you must specify the teams name or ID but not both.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

// GetChannelTeamsParams defines parameters for GetChannelTeams.
type GetChannelTeamsParams struct {
	// BroadcasterId The ID of the broadcaster whose teams you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Id The ID of the user to get. To specify more than one user, include the _id_ parameter for each user to get. For example, `id=1234&id=5678`. The maximum number of IDs you may specify is 100.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Login The login name of the user to get. To specify more than one user, include the _login_ parameter for each user to get. For example, `login=foo&login=bar`. The maximum number of login names you may specify is 100.
	Login *[]string `form:"login,omitempty" json:"login,omitempty"`
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// Description The string to update the channels description to. The description is limited to a maximum of 300 characters.
	//
	// To remove the description, specify this parameter but dont set its value (for example, `?description=`).
	Description *string `form:"description,omitempty" json:"description,omitempty"`
}

// UnblockUserParams defines parameters for UnblockUser.
type UnblockUserParams struct {
	// TargetUserId The ID of the user to remove from the broadcasters list of blocked users. The API ignores the request if the broadcaster hasnt blocked the user.
	TargetUserId string `form:"target_user_id" json:"target_user_id"`
}

// GetUserBlockListParams defines parameters for GetUserBlockList.
type GetUserBlockListParams struct {
	// BroadcasterId The ID of the broadcaster whose list of blocked users you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

// BlockUserParams defines parameters for BlockUser.
type BlockUserParams struct {
	// TargetUserId The ID of the user to block. The API ignores the request if the broadcaster has already blocked the user.
	TargetUserId string `form:"target_user_id" json:"target_user_id"`

	// SourceContext The location where the harassment took place that is causing the brodcaster to block the user. Possible values are:
	//
	// * chat
	// * whisper
	//
	// .
	SourceContext *BlockUserParamsSourceContext `form:"source_context,omitempty" json:"source_context,omitempty"`

	// Reason The reason that the broadcaster is blocking the user. Possible values are:
	//
	// * harassment
	// * spam
	// * other
	Reason *BlockUserParamsReason `form:"reason,omitempty" json:"reason,omitempty"`
}

// BlockUserParamsSourceContext defines parameters for BlockUser.
type BlockUserParamsSourceContext string

// BlockUserParamsReason defines parameters for BlockUser.
type BlockUserParamsReason string

// GetUserActiveExtensionsParams defines parameters for GetUserActiveExtensions.
type GetUserActiveExtensionsParams struct {
	// UserId The ID of the broadcaster whose active extensions you want to get.
	//
	// This parameter is required if you specify an app access token and is optional if you specify a user access token. If you specify a user access token and dont specify this parameter, the API uses the user ID from the access token.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

// DeleteVideosParams defines parameters for DeleteVideos.
type DeleteVideosParams struct {
	// Id The list of videos to delete. To specify more than one video, include the _id_ parameter for each video to delete. For example, `id=1234&id=5678`. You can delete a maximum of 5 videos per request. Ignores invalid video IDs.
	//
	// If the user doesnt have permission to delete one of the videos in the list, none of the videos are deleted.
	Id []string `form:"id" json:"id"`
}

// GetVideosParams defines parameters for GetVideos.
type GetVideosParams struct {
	// Id A list of IDs that identify the videos you want to get. To get more than one video, include this parameter for each video you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs. The endpoint ignores duplicate IDs and IDs that weren't found (if there's at least one valid ID).
	//
	// The _id_, _user\_id_, and _game\_id_ parameters are mutually exclusive.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// UserId The ID of the user whose list of videos you want to get.
	//
	// The _id_, _user\_id_, and _game\_id_ parameters are mutually exclusive.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// GameId A category or game ID. The response contains a maximum of 500 videos that show this content. To get category/game IDs, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
	//
	// The _id_, _user\_id_, and _game\_id_ parameters are mutually exclusive.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Language A filter used to filter the list of videos by the language that the video owner broadcasts in. For example, to get videos that were broadcast in German, set this parameter to the ISO 639-1 two-letter code for German (i.e., DE). For a list of supported languages, see [Supported Stream Language](https://help.twitch.tv/s/article/languages-on-twitch#streamlang). If the language is not supported, use other.
	//
	// Specify this parameter only if you specify the _game\_id_ query parameter.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Period A filter used to filter the list of videos by when they were published. For example, videos published in the last week. Possible values are:
	//
	// * all
	// * day
	// * month
	// * week
	//
	// The default is "all," which returns videos published in all periods.
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	Period *GetVideosParamsPeriod `form:"period,omitempty" json:"period,omitempty"`

	// Sort The order to sort the returned videos in. Possible values are:
	//
	// * time  Sort the results in descending order by when they were created (i.e., latest video first).
	// * trending  Sort the results in descending order by biggest gains in viewership (i.e., highest trending video first).
	// * views  Sort the results in descending order by most views (i.e., highest number of views first).
	//
	// The default is "time."
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	Sort *GetVideosParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Type A filter used to filter the list of videos by the video's type. Possible case-sensitive values are:
	//
	// * all
	// * archive  On-demand videos (VODs) of past streams.
	// * highlight  Highlight reels of past streams.
	// * upload  External videos that the broadcaster uploaded using the Video Producer.
	//
	// The default is "all," which returns all video types.
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	Type *GetVideosParamsType `form:"type,omitempty" json:"type,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// Specify this parameter only if you specify the _user\_id_ query parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// Specify this parameter only if you specify the _user\_id_ query parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

// GetVideosParamsPeriod defines parameters for GetVideos.
type GetVideosParamsPeriod string

// GetVideosParamsSort defines parameters for GetVideos.
type GetVideosParamsSort string

// GetVideosParamsType defines parameters for GetVideos.
type GetVideosParamsType string

// SendWhisperParams defines parameters for SendWhisper.
type SendWhisperParams struct {
	// FromUserId The ID of the user sending the whisper. This user must have a verified phone number. This ID must match the user ID in the user access token.
	FromUserId string `form:"from_user_id" json:"from_user_id"`

	// ToUserId The ID of the user to receive the whisper.
	ToUserId string `form:"to_user_id" json:"to_user_id"`
}

// UpdateExtensionBitsProductJSONRequestBody defines body for UpdateExtensionBitsProduct for application/json ContentType.
type UpdateExtensionBitsProductJSONRequestBody = UpdateExtensionBitsProductBody

// UpdateCustomRewardJSONRequestBody defines body for UpdateCustomReward for application/json ContentType.
type UpdateCustomRewardJSONRequestBody = UpdateCustomRewardBody

// CreateCustomRewardsJSONRequestBody defines body for CreateCustomRewards for application/json ContentType.
type CreateCustomRewardsJSONRequestBody = CreateCustomRewardsBody

// UpdateRedemptionStatusJSONRequestBody defines body for UpdateRedemptionStatus for application/json ContentType.
type UpdateRedemptionStatusJSONRequestBody = UpdateRedemptionStatusBody

// ModifyChannelInformationJSONRequestBody defines body for ModifyChannelInformation for application/json ContentType.
type ModifyChannelInformationJSONRequestBody = ModifyChannelInformationBody

// StartCommercialJSONRequestBody defines body for StartCommercial for application/json ContentType.
type StartCommercialJSONRequestBody = StartCommercialBody

// SendChatAnnouncementJSONRequestBody defines body for SendChatAnnouncement for application/json ContentType.
type SendChatAnnouncementJSONRequestBody = SendChatAnnouncementBody

// SendChatMessageJSONRequestBody defines body for SendChatMessage for application/json ContentType.
type SendChatMessageJSONRequestBody = SendChatMessageBody

// UpdateChatSettingsJSONRequestBody defines body for UpdateChatSettings for application/json ContentType.
type UpdateChatSettingsJSONRequestBody = UpdateChatSettingsBody

// UpdateDropsEntitlementsJSONRequestBody defines body for UpdateDropsEntitlements for application/json ContentType.
type UpdateDropsEntitlementsJSONRequestBody = UpdateDropsEntitlementsBody

// UpdateConduitsJSONRequestBody defines body for UpdateConduits for application/json ContentType.
type UpdateConduitsJSONRequestBody = UpdateConduitsBody

// CreateConduitsJSONRequestBody defines body for CreateConduits for application/json ContentType.
type CreateConduitsJSONRequestBody = CreateConduitsBody

// UpdateConduitShardsJSONRequestBody defines body for UpdateConduitShards for application/json ContentType.
type UpdateConduitShardsJSONRequestBody = UpdateConduitShardsBody

// CreateEventsubSubscriptionJSONRequestBody defines body for CreateEventsubSubscription for application/json ContentType.
type CreateEventsubSubscriptionJSONRequestBody = CreateEventSubSubscriptionBody

// SendExtensionChatMessageJSONRequestBody defines body for SendExtensionChatMessage for application/json ContentType.
type SendExtensionChatMessageJSONRequestBody = SendExtensionChatMessageBody

// SetExtensionConfigurationSegmentJSONRequestBody defines body for SetExtensionConfigurationSegment for application/json ContentType.
type SetExtensionConfigurationSegmentJSONRequestBody = SetExtensionConfigurationSegmentBody

// SendExtensionPubsubMessageJSONRequestBody defines body for SendExtensionPubsubMessage for application/json ContentType.
type SendExtensionPubsubMessageJSONRequestBody = SendExtensionPubSubMessageBody

// SetExtensionRequiredConfigurationJSONRequestBody defines body for SetExtensionRequiredConfiguration for application/json ContentType.
type SetExtensionRequiredConfigurationJSONRequestBody = SetExtensionRequiredConfigurationBody

// UpdateChannelGuestStarSettingsJSONRequestBody defines body for UpdateChannelGuestStarSettings for application/json ContentType.
type UpdateChannelGuestStarSettingsJSONRequestBody = UpdateChannelGuestStarSettingsBody

// ManageHeldAutomodMessagesJSONRequestBody defines body for ManageHeldAutomodMessages for application/json ContentType.
type ManageHeldAutomodMessagesJSONRequestBody = ManageHeldAutoModMessagesBody

// UpdateAutomodSettingsJSONRequestBody defines body for UpdateAutomodSettings for application/json ContentType.
type UpdateAutomodSettingsJSONRequestBody = UpdateAutoModSettingsBody

// BanUserJSONRequestBody defines body for BanUser for application/json ContentType.
type BanUserJSONRequestBody = BanUserBody

// AddBlockedTermJSONRequestBody defines body for AddBlockedTerm for application/json ContentType.
type AddBlockedTermJSONRequestBody = AddBlockedTermBody

// CheckAutomodStatusJSONRequestBody defines body for CheckAutomodStatus for application/json ContentType.
type CheckAutomodStatusJSONRequestBody = CheckAutoModStatusBody

// UpdateShieldModeStatusJSONRequestBody defines body for UpdateShieldModeStatus for application/json ContentType.
type UpdateShieldModeStatusJSONRequestBody = UpdateShieldModeStatusBody

// WarnChatUserJSONRequestBody defines body for WarnChatUser for application/json ContentType.
type WarnChatUserJSONRequestBody = WarnChatUserBody

// EndPollJSONRequestBody defines body for EndPoll for application/json ContentType.
type EndPollJSONRequestBody = EndPollBody

// CreatePollJSONRequestBody defines body for CreatePoll for application/json ContentType.
type CreatePollJSONRequestBody = CreatePollBody

// EndPredictionJSONRequestBody defines body for EndPrediction for application/json ContentType.
type EndPredictionJSONRequestBody = EndPredictionBody

// CreatePredictionJSONRequestBody defines body for CreatePrediction for application/json ContentType.
type CreatePredictionJSONRequestBody = CreatePredictionBody

// UpdateChannelStreamScheduleSegmentJSONRequestBody defines body for UpdateChannelStreamScheduleSegment for application/json ContentType.
type UpdateChannelStreamScheduleSegmentJSONRequestBody = UpdateChannelStreamScheduleSegmentBody

// CreateChannelStreamScheduleSegmentJSONRequestBody defines body for CreateChannelStreamScheduleSegment for application/json ContentType.
type CreateChannelStreamScheduleSegmentJSONRequestBody = CreateChannelStreamScheduleSegmentBody

// CreateStreamMarkerJSONRequestBody defines body for CreateStreamMarker for application/json ContentType.
type CreateStreamMarkerJSONRequestBody = CreateStreamMarkerBody

// UpdateUserExtensionsJSONRequestBody defines body for UpdateUserExtensions for application/json ContentType.
type UpdateUserExtensionsJSONRequestBody = UpdateUserExtensionsBody

// SendWhisperJSONRequestBody defines body for SendWhisper for application/json ContentType.
type SendWhisperJSONRequestBody = SendWhisperBody

// Generated with client.tmpl
// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetExtensionAnalytics request

	/*
		    Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
	*/
	GetExtensionAnalytics(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGameAnalytics request

	/*
		    Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
	*/
	GetGameAnalytics(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCheermotes request

	/*
		    Gets a list of Cheermotes that users can use to cheer Bits in any Bits-enabled channels chat room. Cheermotes are animated emotes that viewers can assign Bits to.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetCheermotes(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionBitsProducts request

	/*
		    Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extensions client ID.
	*/
	GetExtensionBitsProducts(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExtensionBitsProductWithBody request with any body

	/*
		    Adds or updates a Bits product that the extension created. If the SKU doesnt exist, the product is added. You may update all fields except the `sku` field.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extensions client ID.
	*/
	UpdateExtensionBitsProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Adds or updates a Bits product that the extension created. If the SKU doesnt exist, the product is added. You may update all fields except the `sku` field.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extensions client ID.
	*/
	UpdateExtensionBitsProduct(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBitsLeaderboard request

	/*
		    Gets the Bits leaderboard for the authenticated broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **bits:read** scope.
	*/
	GetBitsLeaderboard(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomReward request

	/*
		    Deletes a custom reward that the broadcaster created.

		The app used to create the reward is the only app that may delete it. If the rewards redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	DeleteCustomReward(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomReward request

	/*
		    Gets a list of custom rewards that the specified broadcaster created.

		**NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
	*/
	GetCustomReward(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomRewardWithBody request with any body

	/*
		    Updates a custom reward. The app used to create the reward is the only app that may update the reward.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.

		__Request Body:__

		The body of the request should contain only the fields youre updating.
	*/
	UpdateCustomRewardWithBody(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates a custom reward. The app used to create the reward is the only app that may update the reward.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.

		__Request Body:__

		The body of the request should contain only the fields youre updating.
	*/
	UpdateCustomReward(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomRewardsWithBody request with any body

	/*
		    Creates a Custom Reward in the broadcasters channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	CreateCustomRewardsWithBody(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Creates a Custom Reward in the broadcasters channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	CreateCustomRewards(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomRewardRedemption request

	/*
		    Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
	*/
	GetCustomRewardRedemption(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRedemptionStatusWithBody request with any body

	/*
		    Updates a redemptions status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	UpdateRedemptionStatusWithBody(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates a redemptions status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	UpdateRedemptionStatus(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelInformation request

	/*
		    Gets information about one or more channels.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelInformation(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyChannelInformationWithBody request with any body

	/*
		    Updates a channels properties.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.

		__Request Body:__

		All fields are optional, but you must specify at least one field.
	*/
	ModifyChannelInformationWithBody(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates a channels properties.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.

		__Request Body:__

		All fields are optional, but you must specify at least one field.
	*/
	ModifyChannelInformation(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdSchedule request

	/*
		    This endpoint returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time. Note that a new ad cannot be run until 8 minutes after running a previous ad.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:ads** scope. The `user_id` in the user access token must match the `broadcaster_id`.
	*/
	GetAdSchedule(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnoozeNextAd request

	/*
		    If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes. This endpoint duplicates the snooze functionality in the creator dashboards Ads Manager.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:ads** scope. The `user_id` in the user access token must match the `broadcaster_id`.
	*/
	SnoozeNextAd(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartCommercialWithBody request with any body

	/*
		    Starts a commercial on the specified channel.

		**NOTE**: Only partners and affiliates may run commercials and they must be streaming live at the time.

		**NOTE**: Only the broadcaster may start a commercial; the broadcasters editors and moderators may not start commercials on behalf of the broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:edit:commercial** scope.
	*/
	StartCommercialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Starts a commercial on the specified channel.

		**NOTE**: Only partners and affiliates may run commercials and they must be streaming live at the time.

		**NOTE**: Only the broadcaster may start a commercial; the broadcasters editors and moderators may not start commercials on behalf of the broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:edit:commercial** scope.
	*/
	StartCommercial(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelEditors request

	/*
		    Gets the broadcasters list editors.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:editors** scope.
	*/
	GetChannelEditors(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFollowedChannels request

	/*
		    Gets a list of broadcasters that the specified user follows. You can also use this endpoint to see whether a user follows a specific broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:follows** scope.
	*/
	GetFollowedChannels(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelFollowers request

	/*
		    Gets a list of users that follow the specified broadcaster. You can also use this endpoint to see whether a specific user follows the broadcaster.

		__Authorization:__

		* Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:followers** scope.
		* The ID in the broadcaster\_id query parameter must match the user ID in the access token or the user ID in the access token must be a moderator for the specified broadcaster.

		This endpoint will return specific follower information only if both of the above are true. If a scope is not provided or the user isnt the broadcaster or a moderator for the specified channel, only the total follower count will be included in the response.
	*/
	GetChannelFollowers(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveChannelVip request

	/*
		    Removes the specified user as a VIP in the broadcasters channel.

		If the broadcaster is removing the users VIP status, the ID in the _broadcaster\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\_id_ query parameter must match the user ID in the access token.

		**Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
	*/
	RemoveChannelVip(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVips request

	/*
		    Gets a list of the broadcasters VIPs.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
	*/
	GetVips(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelVip request

	/*
		    Adds the specified user as a VIP in the broadcasters channel.

		**Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
	*/
	AddChannelVip(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharityCampaign request

	/*
		    Gets information about the charity campaign that a broadcaster is running. For example, the campaigns fundraising goal and the current amount of donations.

		To receive events when progress is made towards the campaigns goal or the broadcaster changes the fundraising goal, subscribe to the [channel.charity\_campaign.progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelcharity%5Fcampaignprogress) subscription type.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:charity** scope.
	*/
	GetCharityCampaign(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharityCampaignDonations request

	/*
		    Gets the list of donations that users have made to the broadcasters active charity campaign.

		To receive events as donations occur, subscribe to the [channel.charity\_campaign.donate](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelcharity%5Fcampaigndonate) subscription type.

		__Authorization:__

		Requires a user access token that includes the **channel:read:charity** scope.
	*/
	GetCharityCampaignDonations(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendChatAnnouncementWithBody request with any body

	/*
		    Sends an announcement to the broadcasters chat room.

		**Rate Limits**: One announcement may be sent every 2 seconds.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
	*/
	SendChatAnnouncementWithBody(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Sends an announcement to the broadcasters chat room.

		**Rate Limits**: One announcement may be sent every 2 seconds.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
	*/
	SendChatAnnouncement(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelChatBadges request

	/*
		    Gets the broadcasters list of custom chat badges. The list is empty if the broadcaster hasnt created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelChatBadges(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalChatBadges request

	/*
		    Gets Twitchs list of chat badges, which users may use in any channels chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

		__Request Query Parameters:__

		None
	*/
	GetGlobalChatBadges(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChatters request

	/*
		    Gets the list of users that are connected to the broadcasters chat session.

		**NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.

		To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
	*/
	GetChatters(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserChatColor request

	/*
		    Gets the color used for the users name in chat.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetUserChatColor(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserChatColor request

	/*
		    Updates the color used for the users name in chat.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\_color** scope.
	*/
	UpdateUserChatColor(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelEmotes request

	/*
		    Gets the broadcasters list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channels chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)

		For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language=bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).

		**NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelEmotes(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalEmotes request

	/*
		    Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.

		[Learn More](https://dev.twitch.tv/docs/irc/emotes)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

		__Request Query Parameters:__

		None
	*/
	GetGlobalEmotes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmoteSets request

	/*
		    Gets emotes for one or more specified emote sets.

		An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.

		[Learn More](https://dev.twitch.tv/docs/irc/emotes)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetEmoteSets(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEmotes request

	/*
		    NEW Retrieves emotes available to the user across all channels.

		__Authorization:__

		* Requires a user access token that includes the **user:read:emotes** scope.
		* Query parameter `user_id` must match the `user_id` in the user access token.
	*/
	GetUserEmotes(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendChatMessageWithBody request with any body

	/*
		    NEW Sends a message to the broadcasters chat room.

		**NOTE:** When sending messages to a Shared Chat session, behaviors differ depending on your authentication token type:

		* When using an _App Access Token_, messages will only be sent to the source channel (defined by the `broadcaster_id` parameter) by default starting on May 19, 2025\. Messages can be sent to all channels by using the `for_source_only` parameter and setting it to `false`.
		* When using a _User Access Token_, messages will be sent to all channels in the shared chat session, including the source channel. This behavior cannot be changed with this token type.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the `user:write:chat` scope. If app access token used, then additionally requires `user:bot` scope from chatting user, and either `channel:bot` scope from broadcaster or moderator status.
	*/
	SendChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    NEW Sends a message to the broadcasters chat room.

		**NOTE:** When sending messages to a Shared Chat session, behaviors differ depending on your authentication token type:

		* When using an _App Access Token_, messages will only be sent to the source channel (defined by the `broadcaster_id` parameter) by default starting on May 19, 2025\. Messages can be sent to all channels by using the `for_source_only` parameter and setting it to `false`.
		* When using a _User Access Token_, messages will be sent to all channels in the shared chat session, including the source channel. This behavior cannot be changed with this token type.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the `user:write:chat` scope. If app access token used, then additionally requires `user:bot` scope from chatting user, and either `channel:bot` scope from broadcaster or moderator status.
	*/
	SendChatMessage(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChatSettings request

	/*
		    Gets the broadcasters chat settings.

		For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChatSettings(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChatSettingsWithBody request with any body

	/*
		    Updates the broadcasters chat settings.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_settings** scope.

		__Request Body:__

		All fields are optional. Specify only those fields that you want to update.

		To set the `slow_mode_wait_time` or `follower_mode_duration` field to its default value, set the corresponding `slow_mode` or `follower_mode` field to **true** (and dont include the `slow_mode_wait_time` or `follower_mode_duration` field).

		To set the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, you must set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **true**.

		To remove the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **false** (and dont include the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
	*/
	UpdateChatSettingsWithBody(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates the broadcasters chat settings.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_settings** scope.

		__Request Body:__

		All fields are optional. Specify only those fields that you want to update.

		To set the `slow_mode_wait_time` or `follower_mode_duration` field to its default value, set the corresponding `slow_mode` or `follower_mode` field to **true** (and dont include the `slow_mode_wait_time` or `follower_mode_duration` field).

		To set the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, you must set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **true**.

		To remove the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **false** (and dont include the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
	*/
	UpdateChatSettings(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendAShoutout request

	/*
		    Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.

		Twitchs Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)

		**Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.

		To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoints rate limit.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
	*/
	SendAShoutout(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClips request

	/*
		    Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).

		When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\. If additional results are necessary, paginate over different query parameters such as multiple `started_at` and `ended_at` timeframes to refine the search.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

		__Request Query Parameters:__

		The _id_, _game\_id_, and _broadcaster\_id_ query parameters are mutually exclusive.
	*/
	GetClips(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClip request

	/*
		    Creates a clip from the broadcasters stream.

		This API captures up to 90 seconds of the broadcasters stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.

		By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window thats used for the clip, use the URL in the responses `edit_url` field. You can specify a clip thats from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.

		Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasnt returned the clip, assume it failed.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
	*/
	CreateClip(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentClassificationLabels request

	/*
		    Gets information about Twitch content classification labels.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetContentClassificationLabels(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDropsEntitlements request

	/*
		    Gets an organizations list of entitlements that have been granted to a game, a user, or both.

		**NOTE:** Entitlements returned in the response body data are not guaranteed to be sorted by any field returned by the API. To retrieve **CLAIMED** or **FULFILLED** entitlements, use the `fulfillment_status` query parameter to filter results. To retrieve entitlements for a specific game, use the `game_id` query parameter to filter results.

		The following table identifies the request parameters that you may specify based on the type of access token used.

		| Access token type | Parameter | Description |
		| - | - | - |
		| App | None | If you dont specify request parameters, the request returns all entitlements that your organization owns. |
		| App | user_id | The request returns all entitlements for any game that the organization granted to the specified user. |
		| App | user_id, game_id | The request returns all entitlements that the specified game granted to the specified user. |
		| App | game_id | The request returns all entitlements that the specified game granted to all entitled users. |
		| User | None | If you dont specify request parameters, the request returns all entitlements for any game that the organization granted to the user identified in the access token. |
		| User | user_id | Invalid. |
		| User | user_id, game_id | Invalid. |
		| User | game_id | The request returns all entitlements that the specified game granted to the user identified in the access token. |


		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
	*/
	GetDropsEntitlements(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDropsEntitlementsWithBody request with any body

	/*
		    Updates the Drop entitlements fulfillment status.

		The following table identifies which entitlements are updated based on the type of access token used.

		| Access token type | Data thats updated |
		| - | - |
		| App | Updates all entitlements with benefits owned by the organization in the access token. |
		| User | Updates all entitlements owned by the user in the access token and where the benefits are owned by the organization in the access token. |


		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
	*/
	UpdateDropsEntitlementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates the Drop entitlements fulfillment status.

		The following table identifies which entitlements are updated based on the type of access token used.

		| Access token type | Data thats updated |
		| - | - |
		| App | Updates all entitlements with benefits owned by the organization in the access token. |
		| User | Updates all entitlements owned by the user in the access token and where the benefits are owned by the organization in the access token. |


		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
	*/
	UpdateDropsEntitlements(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConduit request

	/*
		    NEW Deletes a specified [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/). Note that it may take some time for Eventsub subscriptions on a deleted [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to show as disabled when calling [Get Eventsub Subscriptions](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	DeleteConduit(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConduits request

	/*
		    NEW Gets the [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) for a client ID.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	GetConduits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConduitsWithBody request with any body

	/*
		    NEW Updates a [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) shard count. To delete shards, update the count to a lower number, and the shards above the count will be deleted. For example, if the existing shard count is 100, by resetting shard count to 50, shards 50-99 are disabled.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    NEW Updates a [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) shard count. To delete shards, update the count to a lower number, and the shards above the count will be deleted. For example, if the existing shard count is 100, by resetting shard count to 50, shards 50-99 are disabled.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduits(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConduitsWithBody request with any body

	/*
		    NEW Creates a new [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	CreateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    NEW Creates a new [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	CreateConduits(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConduitShards request

	/*
		    NEW Gets a lists of all shards for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	GetConduitShards(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConduitShardsWithBody request with any body

	/*
		    NEW Updates shard(s) for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		**NOTE:** Shard IDs are indexed starting at 0, so a conduit with a `shard_count` of 5 will have shards with IDs 0 through 4.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitShardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    NEW Updates shard(s) for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		**NOTE:** Shard IDs are indexed starting at 0, so a conduit with a `shard_count` of 5 will have shards with IDs 0 through 4.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitShards(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEventsubSubscription request

	/*
		    Deletes an EventSub subscription.

		__Authorization:__

		If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
	*/
	DeleteEventsubSubscription(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsubSubscriptions request

	/*
		    Gets a list of EventSub subscriptions that the client in the access token created.

		__Authorization:__

		If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.

		__Request Query Parameters:__

		Use the _status_, _type_, _user\_id_, and _subscription\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
	*/
	GetEventsubSubscriptions(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEventsubSubscriptionWithBody request with any body

	/*
		    Creates an EventSub subscription.

		__Authorization:__

		If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the `channel:read:subscriptions` scope, which adds the required permission to your app access tokens client ID.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesnt include user authorization, the token may include any scopes or no scopes.

		If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
	*/
	CreateEventsubSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Creates an EventSub subscription.

		__Authorization:__

		If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the `channel:read:subscriptions` scope, which adds the required permission to your app access tokens client ID.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesnt include user authorization, the token may include any scopes or no scopes.

		If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
	*/
	CreateEventsubSubscription(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensions request

	/*
		    Gets information about an extension.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the `role` field must be set to _external_.
	*/
	GetExtensions(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendExtensionChatMessageWithBody request with any body

	/*
		    Sends a message to the specified broadcasters chat room. The extensions name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extensions **Capabilities** tab).

		**Rate Limits**: You may send a maximum of 12 messages per minute per channel.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` and `user_id` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SendExtensionChatMessageWithBody(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Sends a message to the specified broadcasters chat room. The extensions name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extensions **Capabilities** tab).

		**Rate Limits**: You may send a maximum of 12 messages per minute per channel.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` and `user_id` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SendExtensionChatMessage(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionConfigurationSegment request

	/*
		    Gets the specified configuration segment from the specified extension.

		**Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	GetExtensionConfigurationSegment(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetExtensionConfigurationSegmentWithBody request with any body

	/*
		    Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.

		**Rate Limits**: You may update the configuration a maximum of 20 times per minute.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SetExtensionConfigurationSegmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.

		**Rate Limits**: You may update the configuration a maximum of 20 times per minute.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SetExtensionConfigurationSegment(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionSecrets request

	/*
		    Gets an extensions list of shared secrets.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	GetExtensionSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExtensionSecret request

	/*
		    Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	CreateExtensionSecret(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionLiveChannels request

	/*
		    Gets a list of broadcasters that are streaming live and have installed or activated the extension.

		It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetExtensionLiveChannels(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendExtensionPubsubMessageWithBody request with any body

	/*
		    Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.

		**Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the `channel_id` and `pubsub_perms` fields. The `role` field must be set to _external_.

		To send the message to a specific channel, set the `channel_id` field in the JWT to the channels ID and set the `pubsub_perms.send` array to _broadcast_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "27419011",
		  "pubsub_perms": {
		    "send":[
		      "broadcast"
		    ]
		  }
		}

		```

		To send the message to all channels on which your extension is active, set the `channel_id` field to _all_ and set the `pubsub_perms.send` array to _global_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "all",
		  "pubsub_perms": {
		    "send":[
		      "global"
		    ]
		  }
		}

		```
	*/
	SendExtensionPubsubMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.

		**Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the `channel_id` and `pubsub_perms` fields. The `role` field must be set to _external_.

		To send the message to a specific channel, set the `channel_id` field in the JWT to the channels ID and set the `pubsub_perms.send` array to _broadcast_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "27419011",
		  "pubsub_perms": {
		    "send":[
		      "broadcast"
		    ]
		  }
		}

		```

		To send the message to all channels on which your extension is active, set the `channel_id` field to _all_ and set the `pubsub_perms.send` array to _global_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "all",
		  "pubsub_perms": {
		    "send":[
		      "global"
		    ]
		  }
		}

		```
	*/
	SendExtensionPubsubMessage(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleasedExtensions request

	/*
		    Gets information about a released extension. Returns the extension if its `state` is Released.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetReleasedExtensions(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetExtensionRequiredConfigurationWithBody request with any body

	/*
		    Updates the extensions required\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the `role` field to _external_ and the `user_id` field to the ID of the user that owns the extension.
	*/
	SetExtensionRequiredConfigurationWithBody(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates the extensions required\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the `role` field to _external_ and the `user_id` field to the ID of the user that owns the extension.
	*/
	SetExtensionRequiredConfiguration(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionTransactions request

	/*
		    Gets an extensions list of transactions. A transaction records the exchange of a currency (for example, Bits) for a digital product.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	GetExtensionTransactions(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGames request

	/*
		    Gets information about specified categories or games.

		You may get up to 100 categories or games by specifying their ID or name. You may specify all IDs, all names, or a combination of IDs and names. If you specify a combination of IDs and names, the total number of IDs and names must not exceed 100.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetGames(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopGames request

	/*
		    Gets information about all broadcasts on Twitch.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetTopGames(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCreatorGoals request

	/*
		    Gets the broadcasters list of active goals. Use this endpoint to get the current progress of each goal.

		Instead of polling for the progress of a goal, consider [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to receive notifications when a goal makes progress using the [channel.goal.progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelgoalprogress) subscription type. [Read More](https://dev.twitch.tv/docs/api/goals#requesting-event-notifications)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:goals** scope.
	*/
	GetCreatorGoals(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelGuestStarSettings request

	/*
		    BETA Gets the channel settings for configuration of the Guest Star feature for a particular host.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
	*/
	GetChannelGuestStarSettings(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelGuestStarSettingsWithBody request with any body

	/*
		    BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	UpdateChannelGuestStarSettingsWithBody(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	UpdateChannelGuestStarSettings(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGuestStarInvite request

	/*
		    BETA Revokes a previously sent invite for a Guest Star session.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	DeleteGuestStarInvite(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGuestStarInvites request

	/*
		    BETA Provides the caller with a list of pending invites to a Guest Star session, including the invitees ready status while joining the waiting room.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
	*/
	GetGuestStarInvites(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendGuestStarInvite request

	/*
		    BETA Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	SendGuestStarInvite(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndGuestStarSession request

	/*
		    BETA Programmatically ends a Guest Star session on behalf of the broadcaster. Performs the same action as if the host clicked the End Call button in the Guest Star UI.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	EndGuestStarSession(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGuestStarSession request

	/*
		    BETA Gets information about an ongoing Guest Star session for a particular channel.

		__Authorization:__

		* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
		* Guests must be either invited or assigned a slot within the session
	*/
	GetGuestStarSession(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGuestStarSession request

	/*
		    BETA Programmatically creates a Guest Star session on behalf of the broadcaster. Requires the broadcaster to be present in the call interface, or the call will be ended automatically.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	CreateGuestStarSession(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGuestStarSlot request

	/*
		    BETA Allows a caller to remove a slot assignment from a user participating in an active Guest Star session. This revokes their access to the session immediately and disables their access to publish or subscribe to media within the session.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	DeleteGuestStarSlot(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGuestStarSlot request

	/*
		    BETA Allows a user to update the assigned slot for a particular user within the active Guest Star session.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	UpdateGuestStarSlot(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignGuestStarSlot request

	/*
		    BETA Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	AssignGuestStarSlot(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGuestStarSlotSettings request

	/*
		    BETA Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host. These settings will be broadcasted to all subscribers which control their view of the guest in that slot. One or more of the optional parameters to this API can be specified at any time.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	UpdateGuestStarSlotSettings(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHypeTrainEvents request

	/*
		    DEPRECATED Scheduled for removal on December 4, 2025\. Use Get Hype Train Status instead. See [announcement](https://discuss.dev.twitch.com/t/legacy-get-hype-train-events-api-and-eventsub-hype-train-v1-subscription-types-deprecation-and-withdrawal-timeline/64299).

		Gets information about the broadcasters current or most recent Hype Train event.

		Instead of polling for events, consider [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to Hype Train events ([Begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainbegin), [Progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainprogress), [End](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainend)).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:hype\_train** scope.
	*/
	GetHypeTrainEvents(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHypeTrainStatus request

	/*
		    NEW Get the status of a Hype Train for the specified broadcaster.

		__Authorization:__

		* Requires an [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
		* Requires OAuth Scope: `channel:read:hype_train`.
		* Requires that `broadcaster_id` and `user_id` match in the User-Access token.
	*/
	GetHypeTrainStatus(ctx context.Context, params *GetHypeTrainStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManageHeldAutomodMessagesWithBody request with any body

	/*
		    Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		To get messages that AutoMod is holding for review, subscribe to the **automod-queue.<moderator\_id>.<channel\_id>** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
	*/
	ManageHeldAutomodMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		To get messages that AutoMod is holding for review, subscribe to the **automod-queue.<moderator\_id>.<channel\_id>** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
	*/
	ManageHeldAutomodMessages(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomodSettings request

	/*
		    Gets the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\_settings** scope.
	*/
	GetAutomodSettings(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomodSettingsWithBody request with any body

	/*
		    Updates the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\_settings** scope.

		__Request Body:__

		Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, youll send a GET request, update the fields you want to change, and pass that object in the PUT request.

		You may set either `overall_level` or the individual settings like `aggression`, but not both.

		Setting `overall_level` applies default values to the individual settings. However, setting `overall_level` to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set `overall_level` to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).

		If `overall_level` is currently set and you update `swearing` to 3, `overall_level` will be set to **null** and all settings other than `swearing` will be set to 0\. The same is true if individual settings are set and you update `overall_level` to 3  all the individual settings are updated to reflect the default level.

		Note that if you set all the individual settings to values that match what `overall_level` would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.

		Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
	*/
	UpdateAutomodSettingsWithBody(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\_settings** scope.

		__Request Body:__

		Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, youll send a GET request, update the fields you want to change, and pass that object in the PUT request.

		You may set either `overall_level` or the individual settings like `aggression`, but not both.

		Setting `overall_level` applies default values to the individual settings. However, setting `overall_level` to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set `overall_level` to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).

		If `overall_level` is currently set and you update `swearing` to 3, `overall_level` will be set to **null** and all settings other than `swearing` will be set to 0\. The same is true if individual settings are set and you update `overall_level` to 3  all the individual settings are updated to reflect the default level.

		Note that if you set all the individual settings to values that match what `overall_level` would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.

		Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
	*/
	UpdateAutomodSettings(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBannedUsers request

	/*
		    Gets all users that the broadcaster banned or put in a timeout.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\_users** scope.
	*/
	GetBannedUsers(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnbanUser request

	/*
		    Removes the ban or timeout that was placed on the specified user.

		To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
	*/
	UnbanUser(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BanUserWithBody request with any body

	/*
		    Bans a user from participating in the specified broadcasters chat room or puts them in a timeout.

		For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).

		If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.

		To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
	*/
	BanUserWithBody(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Bans a user from participating in the specified broadcasters chat room or puts them in a timeout.

		For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).

		If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.

		To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
	*/
	BanUser(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveBlockedTerm request

	/*
		    Removes the word or phrase from the broadcasters list of blocked terms.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
	*/
	RemoveBlockedTerm(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockedTerms request

	/*
		    Gets the broadcasters list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\_terms** or **moderator:manage:blocked\_terms** scope.
	*/
	GetBlockedTerms(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBlockedTermWithBody request with any body

	/*
		    Adds a word or phrase to the broadcasters list of blocked terms. These are the terms that the broadcaster doesnt want used in their chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
	*/
	AddBlockedTermWithBody(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Adds a word or phrase to the broadcasters list of blocked terms. These are the terms that the broadcaster doesnt want used in their chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
	*/
	AddBlockedTerm(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModeratedChannels request

	/*
		    Gets a list of channels that the specified user has moderator privileges in.

		__Authorization:__

		* Query parameter `user_id` must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `user:read:moderated_channels`
	*/
	GetModeratedChannels(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChatMessages request

	/*
		    Removes a single chat message or all chat messages from the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_messages** scope.
	*/
	DeleteChatMessages(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAutomodStatusWithBody request with any body

	/*
		    Checks whether AutoMod would flag the specified message for review.

		AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		**Rate Limits**: Rates are limited per channel based on the account type rather than per access token.

		| Account type | Limit per minute | Limit per hour |
		| - | - | - |
		| Normal | 5 | 50 |
		| Affiliate | 10 | 100 |
		| Partner | 30 | 300 |


		The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
	*/
	CheckAutomodStatusWithBody(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Checks whether AutoMod would flag the specified message for review.

		AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		**Rate Limits**: Rates are limited per channel based on the account type rather than per access token.

		| Account type | Limit per minute | Limit per hour |
		| - | - | - |
		| Normal | 5 | 50 |
		| Affiliate | 10 | 100 |
		| Partner | 30 | 300 |


		The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
	*/
	CheckAutomodStatus(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveChannelModerator request

	/*
		    Removes a moderator from the broadcasters chat room.

		**Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
	*/
	RemoveChannelModerator(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModerators request

	/*
		    Gets all users allowed to moderate the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
	*/
	GetModerators(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelModerator request

	/*
		    Adds a moderator to the broadcasters chat room.

		**Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
	*/
	AddChannelModerator(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShieldModeStatus request

	/*
		    Gets the broadcasters Shield Mode activation status.

		To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\_mode** or **moderator:manage:shield\_mode** scope.
	*/
	GetShieldModeStatus(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShieldModeStatusWithBody request with any body

	/*
		    Activates or deactivates the broadcasters Shield Mode.

		Twitchs Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasnt configured Shield Mode, it applies default overrides.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\_mode** scope.
	*/
	UpdateShieldModeStatusWithBody(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Activates or deactivates the broadcasters Shield Mode.

		Twitchs Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasnt configured Shield Mode, it applies default overrides.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\_mode** scope.
	*/
	UpdateShieldModeStatus(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnbanRequests request

	/*
		    NEW Gets a list of unban requests for a broadcasters channel.

		__Authorization:__

		* Requires a user access token that includes the **moderator:read:unban\_requests** or **moderator:manage:unban\_requests** scope.
		* Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	GetUnbanRequests(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveUnbanRequests request

	/*
		    NEW Resolves an unban request by approving or denying it.

		__Authorization:__

		* Requires a user access token that includes the **moderator:manage:unban\_requests** scope.
		* Query parameter `moderator_id` must match the `user_id` in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	ResolveUnbanRequests(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WarnChatUserWithBody request with any body

	/*
		    NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).

		__Authorization:__

		Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	WarnChatUserWithBody(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).

		__Authorization:__

		Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	WarnChatUser(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolls request

	/*
		    Gets a list of polls that the broadcaster created.

		Polls are available for 90 days after theyre created.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
	*/
	GetPolls(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndPollWithBody request with any body

	/*
		    Ends an active poll. You have the option to end it or end it and archive it.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	EndPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Ends an active poll. You have the option to end it or end it and archive it.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	EndPoll(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePollWithBody request with any body

	/*
		    Creates a poll that viewers in the broadcasters channel can vote on.

		The poll begins as soon as its created. You may run only one poll at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	CreatePollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Creates a poll that viewers in the broadcasters channel can vote on.

		The poll begins as soon as its created. You may run only one poll at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	CreatePoll(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPredictions request

	/*
		    Gets a list of Channel Points Predictions that the broadcaster created.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:predictions** or **channel:manage:predictions** scope.
	*/
	GetPredictions(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndPredictionWithBody request with any body

	/*
		    Locks, resolves, or cancels a Channel Points Prediction.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	EndPredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Locks, resolves, or cancels a Channel Points Prediction.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	EndPrediction(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePredictionWithBody request with any body

	/*
		    Creates a Channel Points Prediction.

		With a Channel Points Prediction, the broadcaster poses a question and viewers try to predict the outcome. The prediction runs as soon as its created. The broadcaster may run only one prediction at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	CreatePredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Creates a Channel Points Prediction.

		With a Channel Points Prediction, the broadcaster poses a question and viewers try to predict the outcome. The prediction runs as soon as its created. The broadcaster may run only one prediction at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	CreatePrediction(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelARaid request

	/*
		    Cancel a pending raid.

		You can cancel a raid at any point up until the broadcaster clicks **Raid Now** in the Twitch UX or the 90-second countdown expires.

		**Rate Limit**: The limit is 10 requests within a 10-minute window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:raids** scope.
	*/
	CancelARaid(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartARaid request

	/*
		    Raid another channel by sending the broadcasters viewers to the targeted channel.

		When you call the API from a chat bot or extension, the Twitch UX pops up a window at the top of the chat room that identifies the number of viewers in the raid. The raid occurs when the broadcaster clicks **Raid Now** or after the 90-second countdown expires.

		To determine whether the raid successfully occurred, you must subscribe to the [Channel Raid](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelraid) event. For more information, see [Get notified when a raid begins](https://dev.twitch.tv/docs/api/raids#get-notified-when-a-raid-begins).

		To cancel a pending raid, use the [Cancel a raid](https://dev.twitch.tv/docs/api/reference#cancel-a-raid) endpoint.

		**Rate Limit**: The limit is 10 requests within a 10-minute window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:raids** scope.
	*/
	StartARaid(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelStreamSchedule request

	/*
		    Gets the broadcasters streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelStreamSchedule(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelIcalendar request

	/*
		    Gets the broadcasters streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).

		__Authorization:__

		The Client-Id and Authorization headers are not required.

		__Response Body:__

		The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).

		The Content-Type response header is set to `text/calendar`.
	*/
	GetChannelIcalendar(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChannelStreamScheduleSegment request

	/*
		    Removes a broadcast segment from the broadcasters streaming schedule.

		**NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	DeleteChannelStreamScheduleSegment(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelStreamScheduleSegmentWithBody request with any body

	/*
		    Updates a scheduled broadcast segment.

		For recurring segments, updating a segments title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	UpdateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates a scheduled broadcast segment.

		For recurring segments, updating a segments title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	UpdateChannelStreamScheduleSegment(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateChannelStreamScheduleSegmentWithBody request with any body

	/*
		    Adds a single or recurring broadcast to the broadcasters streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	CreateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Adds a single or recurring broadcast to the broadcasters streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	CreateChannelStreamScheduleSegment(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelStreamSchedule request

	/*
		    Updates the broadcasters schedule settings, such as scheduling a vacation.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	UpdateChannelStreamSchedule(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCategories request

	/*
		    Gets the games or categories that match the specified query.

		To match, the categorys name must contain all parts of the query string. For example, if the query string is 42, the response includes any category name that contains 42 in the title. If the query string is a phrase like _love computer_, the response includes any category name that contains the words love and computer anywhere in the name. The comparison is case insensitive.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	SearchCategories(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchChannels request

	/*
		    Gets the channels that match the specified query and have streamed content within the past 6 months.

		The fields that the API uses for comparison depends on the value that the _live\_only_ query parameter is set to. If _live\_only_ is **false**, the API matches on the broadcasters login name. However, if _live\_only_ is **true**, the API matches on the broadcasters name and category name.

		To match, the beginning of the broadcasters name or category must match the query string. The comparison is case insensitive. If the query string is angel\_of\_death, it matches all names that begin with angel\_of\_death. However, if the query string is a phrase like _angel of death_, it matches to names starting with angelofdeath or names starting with angel\_of\_death.

		By default, the results include both live and offline channels. To get only live channels set the _live\_only_ query parameter to **true**.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	SearchChannels(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSharedChatSession request

	/*
		    NEW Retrieves the active shared chat session for a channel.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	GetSharedChatSession(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreams request

	/*
		    Gets a list of all streams. The list is in descending order by the number of viewers watching the stream. Because viewers come and go during a stream, its possible to find duplicate or missing streams in the list as you page through the results.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFollowedStreams request

	/*
		    Gets the list of broadcasters that the user follows and that are streaming live.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:follows** scope.
	*/
	GetFollowedStreams(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamKey request

	/*
		    Gets the channels stream key.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:stream\_key** scope.
	*/
	GetStreamKey(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamMarkers request

	/*
		    Gets a list of markers from the users most recent stream or from the specified VOD/video. A marker is an arbitrary point in a live stream that the broadcaster or editor marked, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:broadcast** or **channel:manage:broadcast** scope.
	*/
	GetStreamMarkers(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStreamMarkerWithBody request with any body

	/*
		    Adds a marker to a live stream. A marker is an arbitrary point in a live stream that the broadcaster or editor wants to mark, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

		You may not add markers:

		* If the stream is not live
		* If the stream has not enabled video on demand (VOD)
		* If the stream is a premiere (a live, first-viewing event that combines uploaded videos with live chat)
		* If the stream is a rerun of a past broadcast, including past premieres.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.
	*/
	CreateStreamMarkerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Adds a marker to a live stream. A marker is an arbitrary point in a live stream that the broadcaster or editor wants to mark, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

		You may not add markers:

		* If the stream is not live
		* If the stream has not enabled video on demand (VOD)
		* If the stream is a premiere (a live, first-viewing event that combines uploaded videos with live chat)
		* If the stream is a rerun of a past broadcast, including past premieres.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.
	*/
	CreateStreamMarker(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamTags request

	/*
		    **IMPORTANT** Twitch is moving from Twitch-defined tags to channel-defined tags. **IMPORTANT** As of February 28, 2023, this endpoint returns an empty array. On July 13, 2023, it will return a 410 response. If you use this endpoint, please update your code to use [Get Channel Information](https://dev.twitch.tv/docs/api/reference#get-channel-information).

		Gets the list of stream tags that the broadcaster or Twitch added to their channel.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetStreamTags(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBroadcasterSubscriptions request

	/*
		    Gets a list of users that subscribe to the specified broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:subscriptions** scope.

		A Twitch extensions may use an app access token if the broadcaster has granted the **channel:read:subscriptions** scope from within the Twitch Extensions manager.
	*/
	GetBroadcasterSubscriptions(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUserSubscription request

	/*
		    Checks whether the user subscribes to the broadcasters channel.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:subscriptions** scope.

		A Twitch extensions may use an app access token if the broadcaster has granted the **user:read:subscriptions** scope from within the Twitch Extensions manager.
	*/
	CheckUserSubscription(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStreamTags request

	/*
		    **IMPORTANT** Twitch is moving from Twitch-defined tags to channel-defined tags. **IMPORTANT** As of February 28, 2023, this endpoint returns an empty array. On July 13, 2023, it will return a 410 response.

		Gets a list of all stream tags that Twitch defines. The broadcaster may apply any of these to their channel except automatic tags. For an online list of the possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetAllStreamTags(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request

	/*
		    Gets information about the specified Twitch team. [Read More](https://help.twitch.tv/s/article/twitch-teams)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTeams request

	/*
		    Gets the list of Twitch teams that the broadcaster is a member of.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelTeams(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request

	/*
		    Gets information about one or more users.

		You may look up users using their user ID, login name, or both but the sum total of the number of users you may look up is 100\. For example, you may specify 50 IDs and 50 names or 100 IDs or names, but you cannot specify 100 IDs and 100 names.

		If you dont specify IDs or login names, the request returns information about the user in the access token if you specify a user access token.

		To include the users verified email address in the response, you must use a user access token that includes the **user:read:email** scope.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request

	/*
		    Updates the specified users information. The user ID in the OAuth token identifies the user whose information you want to update.

		To include the users verified email address in the response, the user access token must also include the **user:read:email** scope.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit** scope.
	*/
	UpdateUser(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnblockUser request

	/*
		    Removes the user from the broadcasters list of blocked users. The user ID in the OAuth token identifies the broadcaster whos removing the block.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:blocked\_users** scope.
	*/
	UnblockUser(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserBlockList request

	/*
		    Gets the list of users that the broadcaster has blocked. [Read More](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:blocked\_users** scope.
	*/
	GetUserBlockList(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockUser request

	/*
		    Blocks the specified user from interacting with or having contact with the broadcaster. The user ID in the OAuth token identifies the broadcaster who is blocking the user.

		To learn more about blocking users, see [Block Other Users on Twitch](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:blocked\_users** scope.
	*/
	BlockUser(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserActiveExtensions request

	/*
		    Gets the active extensions that the broadcaster has installed for each configuration.

		NOTE: To include extensions that you have under development, you must specify a user access token that includes the **user:read:broadcast** or **user:edit:broadcast** scope.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetUserActiveExtensions(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserExtensionsWithBody request with any body

	/*
		    Updates an installed extensions information. You can update the extensions activation state, ID, and version number. The user ID in the access token identifies the broadcaster whose extensions youre updating.

		NOTE: If you try to activate an extension under multiple extension types, the last write wins (and there is no guarantee of write order).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit:broadcast** scope.
	*/
	UpdateUserExtensionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Updates an installed extensions information. You can update the extensions activation state, ID, and version number. The user ID in the access token identifies the broadcaster whose extensions youre updating.

		NOTE: If you try to activate an extension under multiple extension types, the last write wins (and there is no guarantee of write order).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit:broadcast** scope.
	*/
	UpdateUserExtensions(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserExtensions request

	/*
		    Gets a list of all extensions (both active and inactive) that the broadcaster has installed. The user ID in the access token identifies the broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:broadcast** or **user:edit:broadcast** scope. To include inactive extensions, you must include the **user:edit:broadcast** scope.
	*/
	GetUserExtensions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVideos request

	/*
		    Deletes one or more videos. You may delete past broadcasts, highlights, or uploads.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:videos** scope.
	*/
	DeleteVideos(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideos request

	/*
		    Gets information about one or more published videos. You may get videos by ID, by user, or by game/category.

		You may apply several filters to get a subset of the videos. The filters are applied as an AND operation to each video. For example, if _language_ is set to de and _game\_id_ is set to 21779, the response includes only videos that show playing League of Legends by users that stream in German. The filters apply only if you get videos by user ID or game ID.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetVideos(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendWhisperWithBody request with any body

	/*
		    Sends a whisper message to the specified user.

		NOTE: The user sending the whisper must have a verified phone number (see the **Phone Number** setting in your [Security and Privacy](https://www.twitch.tv/settings/security) settings).

		NOTE: The API may silently drop whispers that it suspects of violating Twitch policies. (The API does not indicate that it dropped the whisper; it returns a 204 status code as if it succeeded.)

		**Rate Limits**: You may whisper to a maximum of 40 unique recipients per day. Within the per day limit, you may whisper a maximum of 3 whispers per second and a maximum of 100 whispers per minute.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:whispers** scope.
	*/
	SendWhisperWithBody(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	/*
		    Sends a whisper message to the specified user.

		NOTE: The user sending the whisper must have a verified phone number (see the **Phone Number** setting in your [Security and Privacy](https://www.twitch.tv/settings/security) settings).

		NOTE: The API may silently drop whispers that it suspects of violating Twitch policies. (The API does not indicate that it dropped the whisper; it returns a 204 status code as if it succeeded.)

		**Rate Limits**: You may whisper to a maximum of 40 unique recipients per day. Within the per day limit, you may whisper a maximum of 3 whispers per second and a maximum of 100 whispers per minute.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:whispers** scope.
	*/
	SendWhisper(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetExtensionAnalytics(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGameAnalytics(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGameAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheermotes(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCheermotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionBitsProducts(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionBitsProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExtensionBitsProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExtensionBitsProductRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExtensionBitsProduct(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExtensionBitsProductRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBitsLeaderboard(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBitsLeaderboardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomReward(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomRewardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomReward(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomRewardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomRewardWithBody(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomRewardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomReward(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomRewardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomRewardsWithBody(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomRewardsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomRewards(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomRewardsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomRewardRedemption(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomRewardRedemptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRedemptionStatusWithBody(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRedemptionStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRedemptionStatus(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRedemptionStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelInformation(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelInformationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyChannelInformationWithBody(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyChannelInformationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyChannelInformation(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyChannelInformationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdSchedule(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnoozeNextAd(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnoozeNextAdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartCommercialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartCommercialRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartCommercial(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartCommercialRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelEditors(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelEditorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFollowedChannels(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFollowedChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelFollowers(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelFollowersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveChannelVip(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveChannelVipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVips(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelVip(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelVipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharityCampaign(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharityCampaignRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharityCampaignDonations(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharityCampaignDonationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatAnnouncementWithBody(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatAnnouncementRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatAnnouncement(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatAnnouncementRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelChatBadges(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelChatBadgesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalChatBadges(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalChatBadgesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChatters(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChattersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserChatColor(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserChatColorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserChatColor(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserChatColorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelEmotes(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelEmotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalEmotes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalEmotesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmoteSets(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmoteSetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEmotes(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEmotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatMessage(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChatSettings(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChatSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChatSettingsWithBody(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChatSettings(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendAShoutout(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendAShoutoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClips(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClip(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentClassificationLabels(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentClassificationLabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDropsEntitlements(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDropsEntitlementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDropsEntitlementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDropsEntitlementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDropsEntitlements(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDropsEntitlementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConduit(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConduitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConduits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConduitsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduits(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConduitsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConduits(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConduitsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConduitShards(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConduitShardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduitShardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitShardsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduitShards(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitShardsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEventsubSubscription(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEventsubSubscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsubSubscriptions(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsubSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventsubSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventsubSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventsubSubscription(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventsubSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensions(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionChatMessageWithBody(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionChatMessageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionChatMessage(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionChatMessageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionConfigurationSegment(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionConfigurationSegmentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionConfigurationSegmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionConfigurationSegmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionConfigurationSegment(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionConfigurationSegmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionSecretsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExtensionSecret(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExtensionSecretRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionLiveChannels(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionLiveChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionPubsubMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionPubsubMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionPubsubMessage(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionPubsubMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleasedExtensions(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasedExtensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionRequiredConfigurationWithBody(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionRequiredConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionRequiredConfiguration(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionRequiredConfigurationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionTransactions(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGames(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGamesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopGames(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopGamesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCreatorGoals(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCreatorGoalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelGuestStarSettings(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelGuestStarSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelGuestStarSettingsWithBody(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelGuestStarSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelGuestStarSettings(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelGuestStarSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGuestStarInvite(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGuestStarInviteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGuestStarInvites(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGuestStarInvitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendGuestStarInvite(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendGuestStarInviteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndGuestStarSession(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndGuestStarSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGuestStarSession(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGuestStarSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGuestStarSession(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGuestStarSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGuestStarSlot(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGuestStarSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGuestStarSlot(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGuestStarSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignGuestStarSlot(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignGuestStarSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGuestStarSlotSettings(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGuestStarSlotSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHypeTrainEvents(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHypeTrainEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHypeTrainStatus(ctx context.Context, params *GetHypeTrainStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHypeTrainStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageHeldAutomodMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageHeldAutomodMessagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageHeldAutomodMessages(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageHeldAutomodMessagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomodSettings(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomodSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomodSettingsWithBody(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomodSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomodSettings(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomodSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBannedUsers(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBannedUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnbanUser(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnbanUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanUserWithBody(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanUser(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBlockedTerm(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBlockedTermRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockedTerms(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockedTermsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBlockedTermWithBody(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBlockedTermRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBlockedTerm(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBlockedTermRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModeratedChannels(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModeratedChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChatMessages(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChatMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAutomodStatusWithBody(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAutomodStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAutomodStatus(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAutomodStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveChannelModerator(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveChannelModeratorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModerators(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModeratorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelModerator(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelModeratorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShieldModeStatus(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShieldModeStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShieldModeStatusWithBody(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShieldModeStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShieldModeStatus(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShieldModeStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnbanRequests(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnbanRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveUnbanRequests(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveUnbanRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WarnChatUserWithBody(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWarnChatUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WarnChatUser(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWarnChatUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolls(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPollsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPoll(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePoll(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPredictions(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPredictionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPredictionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPrediction(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPredictionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePredictionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrediction(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePredictionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelARaid(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelARaidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartARaid(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartARaidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelStreamSchedule(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelStreamScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelIcalendar(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelIcalendarRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChannelStreamScheduleSegment(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChannelStreamScheduleSegmentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelStreamScheduleSegmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelStreamScheduleSegment(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelStreamScheduleSegmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelStreamScheduleSegmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelStreamScheduleSegment(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelStreamScheduleSegmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelStreamSchedule(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelStreamScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCategories(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchChannels(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSharedChatSession(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSharedChatSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFollowedStreams(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFollowedStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamKey(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamMarkers(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamMarkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStreamMarkerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStreamMarkerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStreamMarker(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStreamMarkerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamTags(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBroadcasterSubscriptions(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBroadcasterSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUserSubscription(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUserSubscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStreamTags(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStreamTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTeams(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnblockUser(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnblockUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserBlockList(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserBlockListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockUser(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserActiveExtensions(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserActiveExtensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserExtensionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserExtensionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserExtensions(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserExtensionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserExtensions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserExtensionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVideos(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVideosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideos(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendWhisperWithBody(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendWhisperRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendWhisper(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendWhisperRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetExtensionAnalyticsRequest generates requests for GetExtensionAnalytics
func NewGetExtensionAnalyticsRequest(server string, params *GetExtensionAnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExtensionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, *params.ExtensionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ended_at", runtime.ParamLocationQuery, *params.EndedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGameAnalyticsRequest generates requests for GetGameAnalytics
func NewGetGameAnalyticsRequest(server string, params *GetGameAnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/games")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ended_at", runtime.ParamLocationQuery, *params.EndedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCheermotesRequest generates requests for GetCheermotes
func NewGetCheermotesRequest(server string, params *GetCheermotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/cheermotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExtensionBitsProductsRequest generates requests for GetExtensionBitsProducts
func NewGetExtensionBitsProductsRequest(server string, params *GetExtensionBitsProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShouldIncludeAll != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "should_include_all", runtime.ParamLocationQuery, *params.ShouldIncludeAll); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExtensionBitsProductRequest calls the generic UpdateExtensionBitsProduct builder with application/json body
func NewUpdateExtensionBitsProductRequest(server string, body UpdateExtensionBitsProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExtensionBitsProductRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateExtensionBitsProductRequestWithBody generates requests for UpdateExtensionBitsProduct with any type of body
func NewUpdateExtensionBitsProductRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBitsLeaderboardRequest generates requests for GetBitsLeaderboard
func NewGetBitsLeaderboardRequest(server string, params *GetBitsLeaderboardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/leaderboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Period != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, *params.Period); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomRewardRequest generates requests for DeleteCustomReward
func NewDeleteCustomRewardRequest(server string, params *DeleteCustomRewardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomRewardRequest generates requests for GetCustomReward
func NewGetCustomRewardRequest(server string, params *GetCustomRewardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyManageableRewards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_manageable_rewards", runtime.ParamLocationQuery, *params.OnlyManageableRewards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomRewardRequest calls the generic UpdateCustomReward builder with application/json body
func NewUpdateCustomRewardRequest(server string, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomRewardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateCustomRewardRequestWithBody generates requests for UpdateCustomReward with any type of body
func NewUpdateCustomRewardRequestWithBody(server string, params *UpdateCustomRewardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCustomRewardsRequest calls the generic CreateCustomRewards builder with application/json body
func NewCreateCustomRewardsRequest(server string, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomRewardsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCustomRewardsRequestWithBody generates requests for CreateCustomRewards with any type of body
func NewCreateCustomRewardsRequestWithBody(server string, params *CreateCustomRewardsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomRewardRedemptionRequest generates requests for GetCustomRewardRedemption
func NewGetCustomRewardRedemptionRequest(server string, params *GetCustomRewardRedemptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards/redemptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_id", runtime.ParamLocationQuery, params.RewardId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRedemptionStatusRequest calls the generic UpdateRedemptionStatus builder with application/json body
func NewUpdateRedemptionStatusRequest(server string, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRedemptionStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRedemptionStatusRequestWithBody generates requests for UpdateRedemptionStatus with any type of body
func NewUpdateRedemptionStatusRequestWithBody(server string, params *UpdateRedemptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards/redemptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_id", runtime.ParamLocationQuery, params.RewardId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelInformationRequest generates requests for GetChannelInformation
func NewGetChannelInformationRequest(server string, params *GetChannelInformationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyChannelInformationRequest calls the generic ModifyChannelInformation builder with application/json body
func NewModifyChannelInformationRequest(server string, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyChannelInformationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewModifyChannelInformationRequestWithBody generates requests for ModifyChannelInformation with any type of body
func NewModifyChannelInformationRequestWithBody(server string, params *ModifyChannelInformationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAdScheduleRequest generates requests for GetAdSchedule
func NewGetAdScheduleRequest(server string, params *GetAdScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/ads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnoozeNextAdRequest generates requests for SnoozeNextAd
func NewSnoozeNextAdRequest(server string, params *SnoozeNextAdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/ads/schedule/snooze")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartCommercialRequest calls the generic StartCommercial builder with application/json body
func NewStartCommercialRequest(server string, body StartCommercialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartCommercialRequestWithBody(server, "application/json", bodyReader)
}

// NewStartCommercialRequestWithBody generates requests for StartCommercial with any type of body
func NewStartCommercialRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/commercial")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelEditorsRequest generates requests for GetChannelEditors
func NewGetChannelEditorsRequest(server string, params *GetChannelEditorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/editors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFollowedChannelsRequest generates requests for GetFollowedChannels
func NewGetFollowedChannelsRequest(server string, params *GetFollowedChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/followed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelFollowersRequest generates requests for GetChannelFollowers
func NewGetChannelFollowersRequest(server string, params *GetChannelFollowersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/followers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveChannelVipRequest generates requests for RemoveChannelVip
func NewRemoveChannelVipRequest(server string, params *RemoveChannelVipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/vips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVipsRequest generates requests for GetVips
func NewGetVipsRequest(server string, params *GetVipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/vips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddChannelVipRequest generates requests for AddChannelVip
func NewAddChannelVipRequest(server string, params *AddChannelVipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/vips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharityCampaignRequest generates requests for GetCharityCampaign
func NewGetCharityCampaignRequest(server string, params *GetCharityCampaignParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charity/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharityCampaignDonationsRequest generates requests for GetCharityCampaignDonations
func NewGetCharityCampaignDonationsRequest(server string, params *GetCharityCampaignDonationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charity/donations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendChatAnnouncementRequest calls the generic SendChatAnnouncement builder with application/json body
func NewSendChatAnnouncementRequest(server string, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendChatAnnouncementRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendChatAnnouncementRequestWithBody generates requests for SendChatAnnouncement with any type of body
func NewSendChatAnnouncementRequestWithBody(server string, params *SendChatAnnouncementParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/announcements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelChatBadgesRequest generates requests for GetChannelChatBadges
func NewGetChannelChatBadgesRequest(server string, params *GetChannelChatBadgesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/badges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalChatBadgesRequest generates requests for GetGlobalChatBadges
func NewGetGlobalChatBadgesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/badges/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChattersRequest generates requests for GetChatters
func NewGetChattersRequest(server string, params *GetChattersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/chatters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserChatColorRequest generates requests for GetUserChatColor
func NewGetUserChatColorRequest(server string, params *GetUserChatColorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/color")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserChatColorRequest generates requests for UpdateUserChatColor
func NewUpdateUserChatColorRequest(server string, params *UpdateUserChatColorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/color")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "color", runtime.ParamLocationQuery, params.Color); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelEmotesRequest generates requests for GetChannelEmotes
func NewGetChannelEmotesRequest(server string, params *GetChannelEmotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalEmotesRequest generates requests for GetGlobalEmotes
func NewGetGlobalEmotesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmoteSetsRequest generates requests for GetEmoteSets
func NewGetEmoteSetsRequest(server string, params *GetEmoteSetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes/set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emote_set_id", runtime.ParamLocationQuery, params.EmoteSetId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserEmotesRequest generates requests for GetUserEmotes
func NewGetUserEmotesRequest(server string, params *GetUserEmotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendChatMessageRequest calls the generic SendChatMessage builder with application/json body
func NewSendChatMessageRequest(server string, body SendChatMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendChatMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendChatMessageRequestWithBody generates requests for SendChatMessage with any type of body
func NewSendChatMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChatSettingsRequest generates requests for GetChatSettings
func NewGetChatSettingsRequest(server string, params *GetChatSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ModeratorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, *params.ModeratorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChatSettingsRequest calls the generic UpdateChatSettings builder with application/json body
func NewUpdateChatSettingsRequest(server string, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChatSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateChatSettingsRequestWithBody generates requests for UpdateChatSettings with any type of body
func NewUpdateChatSettingsRequestWithBody(server string, params *UpdateChatSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendAShoutoutRequest generates requests for SendAShoutout
func NewSendAShoutoutRequest(server string, params *SendAShoutoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/shoutouts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_broadcaster_id", runtime.ParamLocationQuery, params.FromBroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_broadcaster_id", runtime.ParamLocationQuery, params.ToBroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClipsRequest generates requests for GetClips
func NewGetClipsRequest(server string, params *GetClipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ended_at", runtime.ParamLocationQuery, *params.EndedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFeatured != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_featured", runtime.ParamLocationQuery, *params.IsFeatured); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClipRequest generates requests for CreateClip
func NewCreateClipRequest(server string, params *CreateClipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.HasDelay != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_delay", runtime.ParamLocationQuery, *params.HasDelay); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentClassificationLabelsRequest generates requests for GetContentClassificationLabels
func NewGetContentClassificationLabelsRequest(server string, params *GetContentClassificationLabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content_classification_labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDropsEntitlementsRequest generates requests for GetDropsEntitlements
func NewGetDropsEntitlementsRequest(server string, params *GetDropsEntitlementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entitlements/drops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FulfillmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fulfillment_status", runtime.ParamLocationQuery, *params.FulfillmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDropsEntitlementsRequest calls the generic UpdateDropsEntitlements builder with application/json body
func NewUpdateDropsEntitlementsRequest(server string, body UpdateDropsEntitlementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDropsEntitlementsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateDropsEntitlementsRequestWithBody generates requests for UpdateDropsEntitlements with any type of body
func NewUpdateDropsEntitlementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entitlements/drops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConduitRequest generates requests for DeleteConduit
func NewDeleteConduitRequest(server string, params *DeleteConduitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConduitsRequest generates requests for GetConduits
func NewGetConduitsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConduitsRequest calls the generic UpdateConduits builder with application/json body
func NewUpdateConduitsRequest(server string, body UpdateConduitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConduitsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConduitsRequestWithBody generates requests for UpdateConduits with any type of body
func NewUpdateConduitsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateConduitsRequest calls the generic CreateConduits builder with application/json body
func NewCreateConduitsRequest(server string, body CreateConduitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConduitsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConduitsRequestWithBody generates requests for CreateConduits with any type of body
func NewCreateConduitsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConduitShardsRequest generates requests for GetConduitShards
func NewGetConduitShardsRequest(server string, params *GetConduitShardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits/shards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "conduit_id", runtime.ParamLocationQuery, params.ConduitId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConduitShardsRequest calls the generic UpdateConduitShards builder with application/json body
func NewUpdateConduitShardsRequest(server string, body UpdateConduitShardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConduitShardsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConduitShardsRequestWithBody generates requests for UpdateConduitShards with any type of body
func NewUpdateConduitShardsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits/shards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEventsubSubscriptionRequest generates requests for DeleteEventsubSubscription
func NewDeleteEventsubSubscriptionRequest(server string, params *DeleteEventsubSubscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsubSubscriptionsRequest generates requests for GetEventsubSubscriptions
func NewGetEventsubSubscriptionsRequest(server string, params *GetEventsubSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubscriptionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subscription_id", runtime.ParamLocationQuery, *params.SubscriptionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEventsubSubscriptionRequest calls the generic CreateEventsubSubscription builder with application/json body
func NewCreateEventsubSubscriptionRequest(server string, body CreateEventsubSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEventsubSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEventsubSubscriptionRequestWithBody generates requests for CreateEventsubSubscription with any type of body
func NewCreateEventsubSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionsRequest generates requests for GetExtensions
func NewGetExtensionsRequest(server string, params *GetExtensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ExtensionVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_version", runtime.ParamLocationQuery, *params.ExtensionVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendExtensionChatMessageRequest calls the generic SendExtensionChatMessage builder with application/json body
func NewSendExtensionChatMessageRequest(server string, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendExtensionChatMessageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendExtensionChatMessageRequestWithBody generates requests for SendExtensionChatMessage with any type of body
func NewSendExtensionChatMessageRequestWithBody(server string, params *SendExtensionChatMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/chat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionConfigurationSegmentRequest generates requests for GetExtensionConfigurationSegment
func NewGetExtensionConfigurationSegmentRequest(server string, params *GetExtensionConfigurationSegmentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segment", runtime.ParamLocationQuery, params.Segment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetExtensionConfigurationSegmentRequest calls the generic SetExtensionConfigurationSegment builder with application/json body
func NewSetExtensionConfigurationSegmentRequest(server string, body SetExtensionConfigurationSegmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetExtensionConfigurationSegmentRequestWithBody(server, "application/json", bodyReader)
}

// NewSetExtensionConfigurationSegmentRequestWithBody generates requests for SetExtensionConfigurationSegment with any type of body
func NewSetExtensionConfigurationSegmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionSecretsRequest generates requests for GetExtensionSecrets
func NewGetExtensionSecretsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/jwt/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExtensionSecretRequest generates requests for CreateExtensionSecret
func NewCreateExtensionSecretRequest(server string, params *CreateExtensionSecretParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/jwt/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Delay != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delay", runtime.ParamLocationQuery, *params.Delay); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExtensionLiveChannelsRequest generates requests for GetExtensionLiveChannels
func NewGetExtensionLiveChannelsRequest(server string, params *GetExtensionLiveChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendExtensionPubsubMessageRequest calls the generic SendExtensionPubsubMessage builder with application/json body
func NewSendExtensionPubsubMessageRequest(server string, body SendExtensionPubsubMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendExtensionPubsubMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendExtensionPubsubMessageRequestWithBody generates requests for SendExtensionPubsubMessage with any type of body
func NewSendExtensionPubsubMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/pubsub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReleasedExtensionsRequest generates requests for GetReleasedExtensions
func NewGetReleasedExtensionsRequest(server string, params *GetReleasedExtensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/released")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ExtensionVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_version", runtime.ParamLocationQuery, *params.ExtensionVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetExtensionRequiredConfigurationRequest calls the generic SetExtensionRequiredConfiguration builder with application/json body
func NewSetExtensionRequiredConfigurationRequest(server string, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetExtensionRequiredConfigurationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetExtensionRequiredConfigurationRequestWithBody generates requests for SetExtensionRequiredConfiguration with any type of body
func NewSetExtensionRequiredConfigurationRequestWithBody(server string, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/required_configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionTransactionsRequest generates requests for GetExtensionTransactions
func NewGetExtensionTransactionsRequest(server string, params *GetExtensionTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGamesRequest generates requests for GetGames
func NewGetGamesRequest(server string, params *GetGamesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/games")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "igdb_id", runtime.ParamLocationQuery, *params.IgdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopGamesRequest generates requests for GetTopGames
func NewGetTopGamesRequest(server string, params *GetTopGamesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/games/top")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCreatorGoalsRequest generates requests for GetCreatorGoals
func NewGetCreatorGoalsRequest(server string, params *GetCreatorGoalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelGuestStarSettingsRequest generates requests for GetChannelGuestStarSettings
func NewGetChannelGuestStarSettingsRequest(server string, params *GetChannelGuestStarSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/channel_settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelGuestStarSettingsRequest calls the generic UpdateChannelGuestStarSettings builder with application/json body
func NewUpdateChannelGuestStarSettingsRequest(server string, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelGuestStarSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateChannelGuestStarSettingsRequestWithBody generates requests for UpdateChannelGuestStarSettings with any type of body
func NewUpdateChannelGuestStarSettingsRequestWithBody(server string, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/channel_settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGuestStarInviteRequest generates requests for DeleteGuestStarInvite
func NewDeleteGuestStarInviteRequest(server string, params *DeleteGuestStarInviteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGuestStarInvitesRequest generates requests for GetGuestStarInvites
func NewGetGuestStarInvitesRequest(server string, params *GetGuestStarInvitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendGuestStarInviteRequest generates requests for SendGuestStarInvite
func NewSendGuestStarInviteRequest(server string, params *SendGuestStarInviteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndGuestStarSessionRequest generates requests for EndGuestStarSession
func NewEndGuestStarSessionRequest(server string, params *EndGuestStarSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGuestStarSessionRequest generates requests for GetGuestStarSession
func NewGetGuestStarSessionRequest(server string, params *GetGuestStarSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGuestStarSessionRequest generates requests for CreateGuestStarSession
func NewCreateGuestStarSessionRequest(server string, params *CreateGuestStarSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGuestStarSlotRequest generates requests for DeleteGuestStarSlot
func NewDeleteGuestStarSlotRequest(server string, params *DeleteGuestStarSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slot_id", runtime.ParamLocationQuery, params.SlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ShouldReinviteGuest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "should_reinvite_guest", runtime.ParamLocationQuery, *params.ShouldReinviteGuest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGuestStarSlotRequest generates requests for UpdateGuestStarSlot
func NewUpdateGuestStarSlotRequest(server string, params *UpdateGuestStarSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_slot_id", runtime.ParamLocationQuery, params.SourceSlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DestinationSlotId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destination_slot_id", runtime.ParamLocationQuery, *params.DestinationSlotId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignGuestStarSlotRequest generates requests for AssignGuestStarSlot
func NewAssignGuestStarSlotRequest(server string, params *AssignGuestStarSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slot_id", runtime.ParamLocationQuery, params.SlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGuestStarSlotSettingsRequest generates requests for UpdateGuestStarSlotSettings
func NewUpdateGuestStarSlotSettingsRequest(server string, params *UpdateGuestStarSlotSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot_settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slot_id", runtime.ParamLocationQuery, params.SlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsAudioEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_audio_enabled", runtime.ParamLocationQuery, *params.IsAudioEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsVideoEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_video_enabled", runtime.ParamLocationQuery, *params.IsVideoEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_live", runtime.ParamLocationQuery, *params.IsLive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Volume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volume", runtime.ParamLocationQuery, *params.Volume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHypeTrainEventsRequest generates requests for GetHypeTrainEvents
func NewGetHypeTrainEventsRequest(server string, params *GetHypeTrainEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hypetrain/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHypeTrainStatusRequest generates requests for GetHypeTrainStatus
func NewGetHypeTrainStatusRequest(server string, params *GetHypeTrainStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hypetrain/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManageHeldAutomodMessagesRequest calls the generic ManageHeldAutomodMessages builder with application/json body
func NewManageHeldAutomodMessagesRequest(server string, body ManageHeldAutomodMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManageHeldAutomodMessagesRequestWithBody(server, "application/json", bodyReader)
}

// NewManageHeldAutomodMessagesRequestWithBody generates requests for ManageHeldAutomodMessages with any type of body
func NewManageHeldAutomodMessagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/automod/message")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAutomodSettingsRequest generates requests for GetAutomodSettings
func NewGetAutomodSettingsRequest(server string, params *GetAutomodSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/automod/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAutomodSettingsRequest calls the generic UpdateAutomodSettings builder with application/json body
func NewUpdateAutomodSettingsRequest(server string, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomodSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateAutomodSettingsRequestWithBody generates requests for UpdateAutomodSettings with any type of body
func NewUpdateAutomodSettingsRequestWithBody(server string, params *UpdateAutomodSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/automod/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBannedUsersRequest generates requests for GetBannedUsers
func NewGetBannedUsersRequest(server string, params *GetBannedUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/banned")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnbanUserRequest generates requests for UnbanUser
func NewUnbanUserRequest(server string, params *UnbanUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/bans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBanUserRequest calls the generic BanUser builder with application/json body
func NewBanUserRequest(server string, params *BanUserParams, body BanUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBanUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBanUserRequestWithBody generates requests for BanUser with any type of body
func NewBanUserRequestWithBody(server string, params *BanUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/bans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveBlockedTermRequest generates requests for RemoveBlockedTerm
func NewRemoveBlockedTermRequest(server string, params *RemoveBlockedTermParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/blocked_terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockedTermsRequest generates requests for GetBlockedTerms
func NewGetBlockedTermsRequest(server string, params *GetBlockedTermsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/blocked_terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddBlockedTermRequest calls the generic AddBlockedTerm builder with application/json body
func NewAddBlockedTermRequest(server string, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBlockedTermRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddBlockedTermRequestWithBody generates requests for AddBlockedTerm with any type of body
func NewAddBlockedTermRequestWithBody(server string, params *AddBlockedTermParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/blocked_terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetModeratedChannelsRequest generates requests for GetModeratedChannels
func NewGetModeratedChannelsRequest(server string, params *GetModeratedChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteChatMessagesRequest generates requests for DeleteChatMessages
func NewDeleteChatMessagesRequest(server string, params *DeleteChatMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/chat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MessageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_id", runtime.ParamLocationQuery, *params.MessageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckAutomodStatusRequest calls the generic CheckAutomodStatus builder with application/json body
func NewCheckAutomodStatusRequest(server string, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckAutomodStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCheckAutomodStatusRequestWithBody generates requests for CheckAutomodStatus with any type of body
func NewCheckAutomodStatusRequestWithBody(server string, params *CheckAutomodStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/enforcements/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveChannelModeratorRequest generates requests for RemoveChannelModerator
func NewRemoveChannelModeratorRequest(server string, params *RemoveChannelModeratorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/moderators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModeratorsRequest generates requests for GetModerators
func NewGetModeratorsRequest(server string, params *GetModeratorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/moderators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddChannelModeratorRequest generates requests for AddChannelModerator
func NewAddChannelModeratorRequest(server string, params *AddChannelModeratorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/moderators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShieldModeStatusRequest generates requests for GetShieldModeStatus
func NewGetShieldModeStatusRequest(server string, params *GetShieldModeStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/shield_mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShieldModeStatusRequest calls the generic UpdateShieldModeStatus builder with application/json body
func NewUpdateShieldModeStatusRequest(server string, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShieldModeStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateShieldModeStatusRequestWithBody generates requests for UpdateShieldModeStatus with any type of body
func NewUpdateShieldModeStatusRequestWithBody(server string, params *UpdateShieldModeStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/shield_mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUnbanRequestsRequest generates requests for GetUnbanRequests
func NewGetUnbanRequestsRequest(server string, params *GetUnbanRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/unban_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveUnbanRequestsRequest generates requests for ResolveUnbanRequests
func NewResolveUnbanRequestsRequest(server string, params *ResolveUnbanRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/unban_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unban_request_id", runtime.ParamLocationQuery, params.UnbanRequestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResolutionText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution_text", runtime.ParamLocationQuery, *params.ResolutionText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWarnChatUserRequest calls the generic WarnChatUser builder with application/json body
func NewWarnChatUserRequest(server string, params *WarnChatUserParams, body WarnChatUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWarnChatUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewWarnChatUserRequestWithBody generates requests for WarnChatUser with any type of body
func NewWarnChatUserRequestWithBody(server string, params *WarnChatUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/warnings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPollsRequest generates requests for GetPolls
func NewGetPollsRequest(server string, params *GetPollsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndPollRequest calls the generic EndPoll builder with application/json body
func NewEndPollRequest(server string, body EndPollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndPollRequestWithBody(server, "application/json", bodyReader)
}

// NewEndPollRequestWithBody generates requests for EndPoll with any type of body
func NewEndPollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePollRequest calls the generic CreatePoll builder with application/json body
func NewCreatePollRequest(server string, body CreatePollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePollRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePollRequestWithBody generates requests for CreatePoll with any type of body
func NewCreatePollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPredictionsRequest generates requests for GetPredictions
func NewGetPredictionsRequest(server string, params *GetPredictionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndPredictionRequest calls the generic EndPrediction builder with application/json body
func NewEndPredictionRequest(server string, body EndPredictionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndPredictionRequestWithBody(server, "application/json", bodyReader)
}

// NewEndPredictionRequestWithBody generates requests for EndPrediction with any type of body
func NewEndPredictionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePredictionRequest calls the generic CreatePrediction builder with application/json body
func NewCreatePredictionRequest(server string, body CreatePredictionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePredictionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePredictionRequestWithBody generates requests for CreatePrediction with any type of body
func NewCreatePredictionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelARaidRequest generates requests for CancelARaid
func NewCancelARaidRequest(server string, params *CancelARaidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/raids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartARaidRequest generates requests for StartARaid
func NewStartARaidRequest(server string, params *StartARaidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/raids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromBroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_broadcaster_id", runtime.ParamLocationQuery, *params.FromBroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToBroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_broadcaster_id", runtime.ParamLocationQuery, *params.ToBroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelStreamScheduleRequest generates requests for GetChannelStreamSchedule
func NewGetChannelStreamScheduleRequest(server string, params *GetChannelStreamScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UtcOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "utc_offset", runtime.ParamLocationQuery, *params.UtcOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelIcalendarRequest generates requests for GetChannelIcalendar
func NewGetChannelIcalendarRequest(server string, params *GetChannelIcalendarParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/icalendar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteChannelStreamScheduleSegmentRequest generates requests for DeleteChannelStreamScheduleSegment
func NewDeleteChannelStreamScheduleSegmentRequest(server string, params *DeleteChannelStreamScheduleSegmentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/segment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelStreamScheduleSegmentRequest calls the generic UpdateChannelStreamScheduleSegment builder with application/json body
func NewUpdateChannelStreamScheduleSegmentRequest(server string, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelStreamScheduleSegmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateChannelStreamScheduleSegmentRequestWithBody generates requests for UpdateChannelStreamScheduleSegment with any type of body
func NewUpdateChannelStreamScheduleSegmentRequestWithBody(server string, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/segment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateChannelStreamScheduleSegmentRequest calls the generic CreateChannelStreamScheduleSegment builder with application/json body
func NewCreateChannelStreamScheduleSegmentRequest(server string, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChannelStreamScheduleSegmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateChannelStreamScheduleSegmentRequestWithBody generates requests for CreateChannelStreamScheduleSegment with any type of body
func NewCreateChannelStreamScheduleSegmentRequestWithBody(server string, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/segment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateChannelStreamScheduleRequest generates requests for UpdateChannelStreamSchedule
func NewUpdateChannelStreamScheduleRequest(server string, params *UpdateChannelStreamScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsVacationEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_vacation_enabled", runtime.ParamLocationQuery, *params.IsVacationEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VacationStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vacation_start_time", runtime.ParamLocationQuery, *params.VacationStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VacationEndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vacation_end_time", runtime.ParamLocationQuery, *params.VacationEndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timezone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCategoriesRequest generates requests for SearchCategories
func NewSearchCategoriesRequest(server string, params *SearchCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchChannelsRequest generates requests for SearchChannels
func NewSearchChannelsRequest(server string, params *SearchChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LiveOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "live_only", runtime.ParamLocationQuery, *params.LiveOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSharedChatSessionRequest generates requests for GetSharedChatSession
func NewGetSharedChatSessionRequest(server string, params *GetSharedChatSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared_chat/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRequest generates requests for GetStreams
func NewGetStreamsRequest(server string, params *GetStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserLogin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_login", runtime.ParamLocationQuery, *params.UserLogin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFollowedStreamsRequest generates requests for GetFollowedStreams
func NewGetFollowedStreamsRequest(server string, params *GetFollowedStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/followed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamKeyRequest generates requests for GetStreamKey
func NewGetStreamKeyRequest(server string, params *GetStreamKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamMarkersRequest generates requests for GetStreamMarkers
func NewGetStreamMarkersRequest(server string, params *GetStreamMarkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/markers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "video_id", runtime.ParamLocationQuery, *params.VideoId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStreamMarkerRequest calls the generic CreateStreamMarker builder with application/json body
func NewCreateStreamMarkerRequest(server string, body CreateStreamMarkerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStreamMarkerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStreamMarkerRequestWithBody generates requests for CreateStreamMarker with any type of body
func NewCreateStreamMarkerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/markers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStreamTagsRequest generates requests for GetStreamTags
func NewGetStreamTagsRequest(server string, params *GetStreamTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBroadcasterSubscriptionsRequest generates requests for GetBroadcasterSubscriptions
func NewGetBroadcasterSubscriptionsRequest(server string, params *GetBroadcasterSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckUserSubscriptionRequest generates requests for CheckUserSubscription
func NewCheckUserSubscriptionRequest(server string, params *CheckUserSubscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllStreamTagsRequest generates requests for GetAllStreamTags
func NewGetAllStreamTagsRequest(server string, params *GetAllStreamTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TagId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag_id", runtime.ParamLocationQuery, *params.TagId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelTeamsRequest generates requests for GetChannelTeams
func NewGetChannelTeamsRequest(server string, params *GetChannelTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/channel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Login != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login", runtime.ParamLocationQuery, *params.Login); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest generates requests for UpdateUser
func NewUpdateUserRequest(server string, params *UpdateUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnblockUserRequest generates requests for UnblockUser
func NewUnblockUserRequest(server string, params *UnblockUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_user_id", runtime.ParamLocationQuery, params.TargetUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserBlockListRequest generates requests for GetUserBlockList
func NewGetUserBlockListRequest(server string, params *GetUserBlockListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockUserRequest generates requests for BlockUser
func NewBlockUserRequest(server string, params *BlockUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_user_id", runtime.ParamLocationQuery, params.TargetUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SourceContext != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_context", runtime.ParamLocationQuery, *params.SourceContext); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserActiveExtensionsRequest generates requests for GetUserActiveExtensions
func NewGetUserActiveExtensionsRequest(server string, params *GetUserActiveExtensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserExtensionsRequest calls the generic UpdateUserExtensions builder with application/json body
func NewUpdateUserExtensionsRequest(server string, body UpdateUserExtensionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserExtensionsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserExtensionsRequestWithBody generates requests for UpdateUserExtensions with any type of body
func NewUpdateUserExtensionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserExtensionsRequest generates requests for GetUserExtensions
func NewGetUserExtensionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/extensions/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVideosRequest generates requests for DeleteVideos
func NewDeleteVideosRequest(server string, params *DeleteVideosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosRequest generates requests for GetVideos
func NewGetVideosRequest(server string, params *GetVideosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Period != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, *params.Period); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendWhisperRequest calls the generic SendWhisper builder with application/json body
func NewSendWhisperRequest(server string, params *SendWhisperParams, body SendWhisperJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendWhisperRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendWhisperRequestWithBody generates requests for SendWhisper with any type of body
func NewSendWhisperRequestWithBody(server string, params *SendWhisperParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whispers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_user_id", runtime.ParamLocationQuery, params.FromUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_user_id", runtime.ParamLocationQuery, params.ToUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// Generated with client-with-responses.tmpl
// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
	OkOnNon200 bool
	Tracer     trace.Tracer
}

// StatusFailureError is the error returned if the response was a non-success code.
type StatusFailureError struct {
	Resp *http.Response
	Err  error
}

func (s StatusFailureError) Error() string {
	if s.Err != nil {
		return s.Err.Error()
	}
	return fmt.Sprintf("got non success response code: %d", s.Resp.StatusCode)
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling.
// When OkOnNon200 is false, all requests that return a non 200 status code will generate and return a StatusFailureError wrapping the response.
// This is useful when treating the library as a RPC client and no errors are acceptable. If the error states are important however,
// setting OKOnNon200 to true will result in all requests that do not trigger a standard HTTP request error (such as an encoding error)
// to return with no error. This means that the error must be parsed from the response state.
func NewClientWithResponses(server string, OkOnNon200 bool, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{
		ClientInterface: client,
		OkOnNon200:      OkOnNon200,
	}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetExtensionAnalyticsWithResponse request

	/*
		    Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
	*/
	GetExtensionAnalyticsWithResponse(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (*GetExtensionAnalyticsHTTPResponse, error)

	// GetGameAnalyticsWithResponse request

	/*
		    Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
	*/
	GetGameAnalyticsWithResponse(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (*GetGameAnalyticsHTTPResponse, error)

	// GetCheermotesWithResponse request

	/*
		    Gets a list of Cheermotes that users can use to cheer Bits in any Bits-enabled channels chat room. Cheermotes are animated emotes that viewers can assign Bits to.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetCheermotesWithResponse(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (*GetCheermotesHTTPResponse, error)

	// GetExtensionBitsProductsWithResponse request

	/*
		    Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extensions client ID.
	*/
	GetExtensionBitsProductsWithResponse(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (*GetExtensionBitsProductsHTTPResponse, error)

	// UpdateExtensionBitsProductWithBodyWithResponse request with any body

	/*
		    Adds or updates a Bits product that the extension created. If the SKU doesnt exist, the product is added. You may update all fields except the `sku` field.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extensions client ID.
	*/
	UpdateExtensionBitsProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExtensionBitsProductHTTPResponse, error)

	/*
		            Adds or updates a Bits product that the extension created. If the SKU doesnt exist, the product is added. You may update all fields except the `sku` field.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extensions client ID.
	*/
	UpdateExtensionBitsProductWithResponse(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExtensionBitsProductHTTPResponse, error)

	// GetBitsLeaderboardWithResponse request

	/*
		    Gets the Bits leaderboard for the authenticated broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **bits:read** scope.
	*/
	GetBitsLeaderboardWithResponse(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (*GetBitsLeaderboardHTTPResponse, error)

	// DeleteCustomRewardWithResponse request

	/*
		    Deletes a custom reward that the broadcaster created.

		The app used to create the reward is the only app that may delete it. If the rewards redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	DeleteCustomRewardWithResponse(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (*DeleteCustomRewardHTTPResponse, error)

	// GetCustomRewardWithResponse request

	/*
		    Gets a list of custom rewards that the specified broadcaster created.

		**NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
	*/
	GetCustomRewardWithResponse(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (*GetCustomRewardHTTPResponse, error)

	// UpdateCustomRewardWithBodyWithResponse request with any body

	/*
		    Updates a custom reward. The app used to create the reward is the only app that may update the reward.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.

		__Request Body:__

		The body of the request should contain only the fields youre updating.
	*/
	UpdateCustomRewardWithBodyWithResponse(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomRewardHTTPResponse, error)

	/*
		            Updates a custom reward. The app used to create the reward is the only app that may update the reward.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.

		__Request Body:__

		The body of the request should contain only the fields youre updating.
	*/
	UpdateCustomRewardWithResponse(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomRewardHTTPResponse, error)

	// CreateCustomRewardsWithBodyWithResponse request with any body

	/*
		    Creates a Custom Reward in the broadcasters channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	CreateCustomRewardsWithBodyWithResponse(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomRewardsHTTPResponse, error)

	/*
		            Creates a Custom Reward in the broadcasters channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	CreateCustomRewardsWithResponse(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomRewardsHTTPResponse, error)

	// GetCustomRewardRedemptionWithResponse request

	/*
		    Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
	*/
	GetCustomRewardRedemptionWithResponse(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (*GetCustomRewardRedemptionHTTPResponse, error)

	// UpdateRedemptionStatusWithBodyWithResponse request with any body

	/*
		    Updates a redemptions status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	UpdateRedemptionStatusWithBodyWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRedemptionStatusHTTPResponse, error)

	/*
		            Updates a redemptions status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
	*/
	UpdateRedemptionStatusWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRedemptionStatusHTTPResponse, error)

	// GetChannelInformationWithResponse request

	/*
		    Gets information about one or more channels.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelInformationWithResponse(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (*GetChannelInformationHTTPResponse, error)

	// ModifyChannelInformationWithBodyWithResponse request with any body

	/*
		    Updates a channels properties.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.

		__Request Body:__

		All fields are optional, but you must specify at least one field.
	*/
	ModifyChannelInformationWithBodyWithResponse(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyChannelInformationHTTPResponse, error)

	/*
		            Updates a channels properties.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.

		__Request Body:__

		All fields are optional, but you must specify at least one field.
	*/
	ModifyChannelInformationWithResponse(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyChannelInformationHTTPResponse, error)

	// GetAdScheduleWithResponse request

	/*
		    This endpoint returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time. Note that a new ad cannot be run until 8 minutes after running a previous ad.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:ads** scope. The `user_id` in the user access token must match the `broadcaster_id`.
	*/
	GetAdScheduleWithResponse(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (*GetAdScheduleHTTPResponse, error)

	// SnoozeNextAdWithResponse request

	/*
		    If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes. This endpoint duplicates the snooze functionality in the creator dashboards Ads Manager.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:ads** scope. The `user_id` in the user access token must match the `broadcaster_id`.
	*/
	SnoozeNextAdWithResponse(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (*SnoozeNextAdHTTPResponse, error)

	// StartCommercialWithBodyWithResponse request with any body

	/*
		    Starts a commercial on the specified channel.

		**NOTE**: Only partners and affiliates may run commercials and they must be streaming live at the time.

		**NOTE**: Only the broadcaster may start a commercial; the broadcasters editors and moderators may not start commercials on behalf of the broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:edit:commercial** scope.
	*/
	StartCommercialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartCommercialHTTPResponse, error)

	/*
		            Starts a commercial on the specified channel.

		**NOTE**: Only partners and affiliates may run commercials and they must be streaming live at the time.

		**NOTE**: Only the broadcaster may start a commercial; the broadcasters editors and moderators may not start commercials on behalf of the broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:edit:commercial** scope.
	*/
	StartCommercialWithResponse(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (*StartCommercialHTTPResponse, error)

	// GetChannelEditorsWithResponse request

	/*
		    Gets the broadcasters list editors.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:editors** scope.
	*/
	GetChannelEditorsWithResponse(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (*GetChannelEditorsHTTPResponse, error)

	// GetFollowedChannelsWithResponse request

	/*
		    Gets a list of broadcasters that the specified user follows. You can also use this endpoint to see whether a user follows a specific broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:follows** scope.
	*/
	GetFollowedChannelsWithResponse(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (*GetFollowedChannelsHTTPResponse, error)

	// GetChannelFollowersWithResponse request

	/*
		    Gets a list of users that follow the specified broadcaster. You can also use this endpoint to see whether a specific user follows the broadcaster.

		__Authorization:__

		* Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:followers** scope.
		* The ID in the broadcaster\_id query parameter must match the user ID in the access token or the user ID in the access token must be a moderator for the specified broadcaster.

		This endpoint will return specific follower information only if both of the above are true. If a scope is not provided or the user isnt the broadcaster or a moderator for the specified channel, only the total follower count will be included in the response.
	*/
	GetChannelFollowersWithResponse(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (*GetChannelFollowersHTTPResponse, error)

	// RemoveChannelVipWithResponse request

	/*
		    Removes the specified user as a VIP in the broadcasters channel.

		If the broadcaster is removing the users VIP status, the ID in the _broadcaster\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\_id_ query parameter must match the user ID in the access token.

		**Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
	*/
	RemoveChannelVipWithResponse(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (*RemoveChannelVipHTTPResponse, error)

	// GetVipsWithResponse request

	/*
		    Gets a list of the broadcasters VIPs.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
	*/
	GetVipsWithResponse(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (*GetVipsHTTPResponse, error)

	// AddChannelVipWithResponse request

	/*
		    Adds the specified user as a VIP in the broadcasters channel.

		**Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
	*/
	AddChannelVipWithResponse(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (*AddChannelVipHTTPResponse, error)

	// GetCharityCampaignWithResponse request

	/*
		    Gets information about the charity campaign that a broadcaster is running. For example, the campaigns fundraising goal and the current amount of donations.

		To receive events when progress is made towards the campaigns goal or the broadcaster changes the fundraising goal, subscribe to the [channel.charity\_campaign.progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelcharity%5Fcampaignprogress) subscription type.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:charity** scope.
	*/
	GetCharityCampaignWithResponse(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (*GetCharityCampaignHTTPResponse, error)

	// GetCharityCampaignDonationsWithResponse request

	/*
		    Gets the list of donations that users have made to the broadcasters active charity campaign.

		To receive events as donations occur, subscribe to the [channel.charity\_campaign.donate](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelcharity%5Fcampaigndonate) subscription type.

		__Authorization:__

		Requires a user access token that includes the **channel:read:charity** scope.
	*/
	GetCharityCampaignDonationsWithResponse(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (*GetCharityCampaignDonationsHTTPResponse, error)

	// SendChatAnnouncementWithBodyWithResponse request with any body

	/*
		    Sends an announcement to the broadcasters chat room.

		**Rate Limits**: One announcement may be sent every 2 seconds.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
	*/
	SendChatAnnouncementWithBodyWithResponse(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendChatAnnouncementHTTPResponse, error)

	/*
		            Sends an announcement to the broadcasters chat room.

		**Rate Limits**: One announcement may be sent every 2 seconds.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
	*/
	SendChatAnnouncementWithResponse(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (*SendChatAnnouncementHTTPResponse, error)

	// GetChannelChatBadgesWithResponse request

	/*
		    Gets the broadcasters list of custom chat badges. The list is empty if the broadcaster hasnt created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelChatBadgesWithResponse(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (*GetChannelChatBadgesHTTPResponse, error)

	// GetGlobalChatBadgesWithResponse request

	/*
		    Gets Twitchs list of chat badges, which users may use in any channels chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

		__Request Query Parameters:__

		None
	*/
	GetGlobalChatBadgesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalChatBadgesHTTPResponse, error)

	// GetChattersWithResponse request

	/*
		    Gets the list of users that are connected to the broadcasters chat session.

		**NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.

		To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
	*/
	GetChattersWithResponse(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (*GetChattersHTTPResponse, error)

	// GetUserChatColorWithResponse request

	/*
		    Gets the color used for the users name in chat.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetUserChatColorWithResponse(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (*GetUserChatColorHTTPResponse, error)

	// UpdateUserChatColorWithResponse request

	/*
		    Updates the color used for the users name in chat.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\_color** scope.
	*/
	UpdateUserChatColorWithResponse(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (*UpdateUserChatColorHTTPResponse, error)

	// GetChannelEmotesWithResponse request

	/*
		    Gets the broadcasters list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channels chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)

		For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language=bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).

		**NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelEmotesWithResponse(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (*GetChannelEmotesHTTPResponse, error)

	// GetGlobalEmotesWithResponse request

	/*
		    Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.

		[Learn More](https://dev.twitch.tv/docs/irc/emotes)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

		__Request Query Parameters:__

		None
	*/
	GetGlobalEmotesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalEmotesHTTPResponse, error)

	// GetEmoteSetsWithResponse request

	/*
		    Gets emotes for one or more specified emote sets.

		An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.

		[Learn More](https://dev.twitch.tv/docs/irc/emotes)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetEmoteSetsWithResponse(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (*GetEmoteSetsHTTPResponse, error)

	// GetUserEmotesWithResponse request

	/*
		    NEW Retrieves emotes available to the user across all channels.

		__Authorization:__

		* Requires a user access token that includes the **user:read:emotes** scope.
		* Query parameter `user_id` must match the `user_id` in the user access token.
	*/
	GetUserEmotesWithResponse(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (*GetUserEmotesHTTPResponse, error)

	// SendChatMessageWithBodyWithResponse request with any body

	/*
		    NEW Sends a message to the broadcasters chat room.

		**NOTE:** When sending messages to a Shared Chat session, behaviors differ depending on your authentication token type:

		* When using an _App Access Token_, messages will only be sent to the source channel (defined by the `broadcaster_id` parameter) by default starting on May 19, 2025\. Messages can be sent to all channels by using the `for_source_only` parameter and setting it to `false`.
		* When using a _User Access Token_, messages will be sent to all channels in the shared chat session, including the source channel. This behavior cannot be changed with this token type.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the `user:write:chat` scope. If app access token used, then additionally requires `user:bot` scope from chatting user, and either `channel:bot` scope from broadcaster or moderator status.
	*/
	SendChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendChatMessageHTTPResponse, error)

	/*
		            NEW Sends a message to the broadcasters chat room.

		**NOTE:** When sending messages to a Shared Chat session, behaviors differ depending on your authentication token type:

		* When using an _App Access Token_, messages will only be sent to the source channel (defined by the `broadcaster_id` parameter) by default starting on May 19, 2025\. Messages can be sent to all channels by using the `for_source_only` parameter and setting it to `false`.
		* When using a _User Access Token_, messages will be sent to all channels in the shared chat session, including the source channel. This behavior cannot be changed with this token type.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the `user:write:chat` scope. If app access token used, then additionally requires `user:bot` scope from chatting user, and either `channel:bot` scope from broadcaster or moderator status.
	*/
	SendChatMessageWithResponse(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendChatMessageHTTPResponse, error)

	// GetChatSettingsWithResponse request

	/*
		    Gets the broadcasters chat settings.

		For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChatSettingsWithResponse(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (*GetChatSettingsHTTPResponse, error)

	// UpdateChatSettingsWithBodyWithResponse request with any body

	/*
		    Updates the broadcasters chat settings.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_settings** scope.

		__Request Body:__

		All fields are optional. Specify only those fields that you want to update.

		To set the `slow_mode_wait_time` or `follower_mode_duration` field to its default value, set the corresponding `slow_mode` or `follower_mode` field to **true** (and dont include the `slow_mode_wait_time` or `follower_mode_duration` field).

		To set the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, you must set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **true**.

		To remove the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **false** (and dont include the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
	*/
	UpdateChatSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChatSettingsHTTPResponse, error)

	/*
		            Updates the broadcasters chat settings.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_settings** scope.

		__Request Body:__

		All fields are optional. Specify only those fields that you want to update.

		To set the `slow_mode_wait_time` or `follower_mode_duration` field to its default value, set the corresponding `slow_mode` or `follower_mode` field to **true** (and dont include the `slow_mode_wait_time` or `follower_mode_duration` field).

		To set the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, you must set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **true**.

		To remove the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **false** (and dont include the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
	*/
	UpdateChatSettingsWithResponse(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChatSettingsHTTPResponse, error)

	// SendAShoutoutWithResponse request

	/*
		    Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.

		Twitchs Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)

		**Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.

		To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoints rate limit.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
	*/
	SendAShoutoutWithResponse(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (*SendAShoutoutHTTPResponse, error)

	// GetClipsWithResponse request

	/*
		    Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).

		When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\. If additional results are necessary, paginate over different query parameters such as multiple `started_at` and `ended_at` timeframes to refine the search.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

		__Request Query Parameters:__

		The _id_, _game\_id_, and _broadcaster\_id_ query parameters are mutually exclusive.
	*/
	GetClipsWithResponse(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (*GetClipsHTTPResponse, error)

	// CreateClipWithResponse request

	/*
		    Creates a clip from the broadcasters stream.

		This API captures up to 90 seconds of the broadcasters stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.

		By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window thats used for the clip, use the URL in the responses `edit_url` field. You can specify a clip thats from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.

		Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasnt returned the clip, assume it failed.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
	*/
	CreateClipWithResponse(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (*CreateClipHTTPResponse, error)

	// GetContentClassificationLabelsWithResponse request

	/*
		    Gets information about Twitch content classification labels.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetContentClassificationLabelsWithResponse(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (*GetContentClassificationLabelsHTTPResponse, error)

	// GetDropsEntitlementsWithResponse request

	/*
		    Gets an organizations list of entitlements that have been granted to a game, a user, or both.

		**NOTE:** Entitlements returned in the response body data are not guaranteed to be sorted by any field returned by the API. To retrieve **CLAIMED** or **FULFILLED** entitlements, use the `fulfillment_status` query parameter to filter results. To retrieve entitlements for a specific game, use the `game_id` query parameter to filter results.

		The following table identifies the request parameters that you may specify based on the type of access token used.

		| Access token type | Parameter | Description |
		| - | - | - |
		| App | None | If you dont specify request parameters, the request returns all entitlements that your organization owns. |
		| App | user_id | The request returns all entitlements for any game that the organization granted to the specified user. |
		| App | user_id, game_id | The request returns all entitlements that the specified game granted to the specified user. |
		| App | game_id | The request returns all entitlements that the specified game granted to all entitled users. |
		| User | None | If you dont specify request parameters, the request returns all entitlements for any game that the organization granted to the user identified in the access token. |
		| User | user_id | Invalid. |
		| User | user_id, game_id | Invalid. |
		| User | game_id | The request returns all entitlements that the specified game granted to the user identified in the access token. |


		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
	*/
	GetDropsEntitlementsWithResponse(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (*GetDropsEntitlementsHTTPResponse, error)

	// UpdateDropsEntitlementsWithBodyWithResponse request with any body

	/*
		    Updates the Drop entitlements fulfillment status.

		The following table identifies which entitlements are updated based on the type of access token used.

		| Access token type | Data thats updated |
		| - | - |
		| App | Updates all entitlements with benefits owned by the organization in the access token. |
		| User | Updates all entitlements owned by the user in the access token and where the benefits are owned by the organization in the access token. |


		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
	*/
	UpdateDropsEntitlementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDropsEntitlementsHTTPResponse, error)

	/*
		            Updates the Drop entitlements fulfillment status.

		The following table identifies which entitlements are updated based on the type of access token used.

		| Access token type | Data thats updated |
		| - | - |
		| App | Updates all entitlements with benefits owned by the organization in the access token. |
		| User | Updates all entitlements owned by the user in the access token and where the benefits are owned by the organization in the access token. |


		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
	*/
	UpdateDropsEntitlementsWithResponse(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDropsEntitlementsHTTPResponse, error)

	// DeleteConduitWithResponse request

	/*
		    NEW Deletes a specified [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/). Note that it may take some time for Eventsub subscriptions on a deleted [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to show as disabled when calling [Get Eventsub Subscriptions](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	DeleteConduitWithResponse(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (*DeleteConduitHTTPResponse, error)

	// GetConduitsWithResponse request

	/*
		    NEW Gets the [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) for a client ID.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	GetConduitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConduitsHTTPResponse, error)

	// UpdateConduitsWithBodyWithResponse request with any body

	/*
		    NEW Updates a [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) shard count. To delete shards, update the count to a lower number, and the shards above the count will be deleted. For example, if the existing shard count is 100, by resetting shard count to 50, shards 50-99 are disabled.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConduitsHTTPResponse, error)

	/*
		            NEW Updates a [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) shard count. To delete shards, update the count to a lower number, and the shards above the count will be deleted. For example, if the existing shard count is 100, by resetting shard count to 50, shards 50-99 are disabled.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitsWithResponse(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConduitsHTTPResponse, error)

	// CreateConduitsWithBodyWithResponse request with any body

	/*
		    NEW Creates a new [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	CreateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConduitsHTTPResponse, error)

	/*
		            NEW Creates a new [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	CreateConduitsWithResponse(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConduitsHTTPResponse, error)

	// GetConduitShardsWithResponse request

	/*
		    NEW Gets a lists of all shards for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	GetConduitShardsWithResponse(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (*GetConduitShardsHTTPResponse, error)

	// UpdateConduitShardsWithBodyWithResponse request with any body

	/*
		    NEW Updates shard(s) for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		**NOTE:** Shard IDs are indexed starting at 0, so a conduit with a `shard_count` of 5 will have shards with IDs 0 through 4.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitShardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConduitShardsHTTPResponse, error)

	/*
		            NEW Updates shard(s) for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

		**NOTE:** Shard IDs are indexed starting at 0, so a conduit with a `shard_count` of 5 will have shards with IDs 0 through 4.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	UpdateConduitShardsWithResponse(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConduitShardsHTTPResponse, error)

	// DeleteEventsubSubscriptionWithResponse request

	/*
		    Deletes an EventSub subscription.

		__Authorization:__

		If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
	*/
	DeleteEventsubSubscriptionWithResponse(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteEventsubSubscriptionHTTPResponse, error)

	// GetEventsubSubscriptionsWithResponse request

	/*
		    Gets a list of EventSub subscriptions that the client in the access token created.

		__Authorization:__

		If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.

		__Request Query Parameters:__

		Use the _status_, _type_, _user\_id_, and _subscription\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
	*/
	GetEventsubSubscriptionsWithResponse(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetEventsubSubscriptionsHTTPResponse, error)

	// CreateEventsubSubscriptionWithBodyWithResponse request with any body

	/*
		    Creates an EventSub subscription.

		__Authorization:__

		If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the `channel:read:subscriptions` scope, which adds the required permission to your app access tokens client ID.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesnt include user authorization, the token may include any scopes or no scopes.

		If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
	*/
	CreateEventsubSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventsubSubscriptionHTTPResponse, error)

	/*
		            Creates an EventSub subscription.

		__Authorization:__

		If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the `channel:read:subscriptions` scope, which adds the required permission to your app access tokens client ID.

		If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesnt include user authorization, the token may include any scopes or no scopes.

		If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
	*/
	CreateEventsubSubscriptionWithResponse(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventsubSubscriptionHTTPResponse, error)

	// GetExtensionsWithResponse request

	/*
		    Gets information about an extension.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the `role` field must be set to _external_.
	*/
	GetExtensionsWithResponse(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*GetExtensionsHTTPResponse, error)

	// SendExtensionChatMessageWithBodyWithResponse request with any body

	/*
		    Sends a message to the specified broadcasters chat room. The extensions name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extensions **Capabilities** tab).

		**Rate Limits**: You may send a maximum of 12 messages per minute per channel.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` and `user_id` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SendExtensionChatMessageWithBodyWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendExtensionChatMessageHTTPResponse, error)

	/*
		            Sends a message to the specified broadcasters chat room. The extensions name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extensions **Capabilities** tab).

		**Rate Limits**: You may send a maximum of 12 messages per minute per channel.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` and `user_id` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SendExtensionChatMessageWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendExtensionChatMessageHTTPResponse, error)

	// GetExtensionConfigurationSegmentWithResponse request

	/*
		    Gets the specified configuration segment from the specified extension.

		**Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	GetExtensionConfigurationSegmentWithResponse(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (*GetExtensionConfigurationSegmentHTTPResponse, error)

	// SetExtensionConfigurationSegmentWithBodyWithResponse request with any body

	/*
		    Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.

		**Rate Limits**: You may update the configuration a maximum of 20 times per minute.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SetExtensionConfigurationSegmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetExtensionConfigurationSegmentHTTPResponse, error)

	/*
		            Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.

		**Rate Limits**: You may update the configuration a maximum of 20 times per minute.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	SetExtensionConfigurationSegmentWithResponse(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*SetExtensionConfigurationSegmentHTTPResponse, error)

	// GetExtensionSecretsWithResponse request

	/*
		    Gets an extensions list of shared secrets.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	GetExtensionSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExtensionSecretsHTTPResponse, error)

	// CreateExtensionSecretWithResponse request

	/*
		    Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
	*/
	CreateExtensionSecretWithResponse(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (*CreateExtensionSecretHTTPResponse, error)

	// GetExtensionLiveChannelsWithResponse request

	/*
		    Gets a list of broadcasters that are streaming live and have installed or activated the extension.

		It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetExtensionLiveChannelsWithResponse(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (*GetExtensionLiveChannelsHTTPResponse, error)

	// SendExtensionPubsubMessageWithBodyWithResponse request with any body

	/*
		    Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.

		**Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the `channel_id` and `pubsub_perms` fields. The `role` field must be set to _external_.

		To send the message to a specific channel, set the `channel_id` field in the JWT to the channels ID and set the `pubsub_perms.send` array to _broadcast_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "27419011",
		  "pubsub_perms": {
		    "send":[
		      "broadcast"
		    ]
		  }
		}

		```

		To send the message to all channels on which your extension is active, set the `channel_id` field to _all_ and set the `pubsub_perms.send` array to _global_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "all",
		  "pubsub_perms": {
		    "send":[
		      "global"
		    ]
		  }
		}

		```
	*/
	SendExtensionPubsubMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendExtensionPubsubMessageHTTPResponse, error)

	/*
		            Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.

		**Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the `channel_id` and `pubsub_perms` fields. The `role` field must be set to _external_.

		To send the message to a specific channel, set the `channel_id` field in the JWT to the channels ID and set the `pubsub_perms.send` array to _broadcast_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "27419011",
		  "pubsub_perms": {
		    "send":[
		      "broadcast"
		    ]
		  }
		}

		```

		To send the message to all channels on which your extension is active, set the `channel_id` field to _all_ and set the `pubsub_perms.send` array to _global_.

		```
		{
		  "exp": 1503343947,
		  "user_id": "27419011",
		  "role": "external",
		  "channel_id": "all",
		  "pubsub_perms": {
		    "send":[
		      "global"
		    ]
		  }
		}

		```
	*/
	SendExtensionPubsubMessageWithResponse(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendExtensionPubsubMessageHTTPResponse, error)

	// GetReleasedExtensionsWithResponse request

	/*
		    Gets information about a released extension. Returns the extension if its `state` is Released.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetReleasedExtensionsWithResponse(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (*GetReleasedExtensionsHTTPResponse, error)

	// SetExtensionRequiredConfigurationWithBodyWithResponse request with any body

	/*
		    Updates the extensions required\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the `role` field to _external_ and the `user_id` field to the ID of the user that owns the extension.
	*/
	SetExtensionRequiredConfigurationWithBodyWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetExtensionRequiredConfigurationHTTPResponse, error)

	/*
		            Updates the extensions required\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).

		__Authorization:__

		Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the `role` field to _external_ and the `user_id` field to the ID of the user that owns the extension.
	*/
	SetExtensionRequiredConfigurationWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetExtensionRequiredConfigurationHTTPResponse, error)

	// GetExtensionTransactionsWithResponse request

	/*
		    Gets an extensions list of transactions. A transaction records the exchange of a currency (for example, Bits) for a digital product.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
	*/
	GetExtensionTransactionsWithResponse(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (*GetExtensionTransactionsHTTPResponse, error)

	// GetGamesWithResponse request

	/*
		    Gets information about specified categories or games.

		You may get up to 100 categories or games by specifying their ID or name. You may specify all IDs, all names, or a combination of IDs and names. If you specify a combination of IDs and names, the total number of IDs and names must not exceed 100.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetGamesWithResponse(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (*GetGamesHTTPResponse, error)

	// GetTopGamesWithResponse request

	/*
		    Gets information about all broadcasts on Twitch.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetTopGamesWithResponse(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (*GetTopGamesHTTPResponse, error)

	// GetCreatorGoalsWithResponse request

	/*
		    Gets the broadcasters list of active goals. Use this endpoint to get the current progress of each goal.

		Instead of polling for the progress of a goal, consider [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to receive notifications when a goal makes progress using the [channel.goal.progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelgoalprogress) subscription type. [Read More](https://dev.twitch.tv/docs/api/goals#requesting-event-notifications)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:goals** scope.
	*/
	GetCreatorGoalsWithResponse(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (*GetCreatorGoalsHTTPResponse, error)

	// GetChannelGuestStarSettingsWithResponse request

	/*
		    BETA Gets the channel settings for configuration of the Guest Star feature for a particular host.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
	*/
	GetChannelGuestStarSettingsWithResponse(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (*GetChannelGuestStarSettingsHTTPResponse, error)

	// UpdateChannelGuestStarSettingsWithBodyWithResponse request with any body

	/*
		    BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	UpdateChannelGuestStarSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelGuestStarSettingsHTTPResponse, error)

	/*
		            BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	UpdateChannelGuestStarSettingsWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelGuestStarSettingsHTTPResponse, error)

	// DeleteGuestStarInviteWithResponse request

	/*
		    BETA Revokes a previously sent invite for a Guest Star session.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	DeleteGuestStarInviteWithResponse(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (*DeleteGuestStarInviteHTTPResponse, error)

	// GetGuestStarInvitesWithResponse request

	/*
		    BETA Provides the caller with a list of pending invites to a Guest Star session, including the invitees ready status while joining the waiting room.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
	*/
	GetGuestStarInvitesWithResponse(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (*GetGuestStarInvitesHTTPResponse, error)

	// SendGuestStarInviteWithResponse request

	/*
		    BETA Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	SendGuestStarInviteWithResponse(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (*SendGuestStarInviteHTTPResponse, error)

	// EndGuestStarSessionWithResponse request

	/*
		    BETA Programmatically ends a Guest Star session on behalf of the broadcaster. Performs the same action as if the host clicked the End Call button in the Guest Star UI.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	EndGuestStarSessionWithResponse(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (*EndGuestStarSessionHTTPResponse, error)

	// GetGuestStarSessionWithResponse request

	/*
		    BETA Gets information about an ongoing Guest Star session for a particular channel.

		__Authorization:__

		* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
		* Guests must be either invited or assigned a slot within the session
	*/
	GetGuestStarSessionWithResponse(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (*GetGuestStarSessionHTTPResponse, error)

	// CreateGuestStarSessionWithResponse request

	/*
		    BETA Programmatically creates a Guest Star session on behalf of the broadcaster. Requires the broadcaster to be present in the call interface, or the call will be ended automatically.

		__Authorization:__

		* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star`
	*/
	CreateGuestStarSessionWithResponse(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (*CreateGuestStarSessionHTTPResponse, error)

	// DeleteGuestStarSlotWithResponse request

	/*
		    BETA Allows a caller to remove a slot assignment from a user participating in an active Guest Star session. This revokes their access to the session immediately and disables their access to publish or subscribe to media within the session.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	DeleteGuestStarSlotWithResponse(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (*DeleteGuestStarSlotHTTPResponse, error)

	// UpdateGuestStarSlotWithResponse request

	/*
		    BETA Allows a user to update the assigned slot for a particular user within the active Guest Star session.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	UpdateGuestStarSlotWithResponse(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (*UpdateGuestStarSlotHTTPResponse, error)

	// AssignGuestStarSlotWithResponse request

	/*
		    BETA Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	AssignGuestStarSlotWithResponse(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (*AssignGuestStarSlotHTTPResponse, error)

	// UpdateGuestStarSlotSettingsWithResponse request

	/*
		    BETA Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host. These settings will be broadcasted to all subscribers which control their view of the guest in that slot. One or more of the optional parameters to this API can be specified at any time.

		__Authorization:__

		* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
	*/
	UpdateGuestStarSlotSettingsWithResponse(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (*UpdateGuestStarSlotSettingsHTTPResponse, error)

	// GetHypeTrainEventsWithResponse request

	/*
		    DEPRECATED Scheduled for removal on December 4, 2025\. Use Get Hype Train Status instead. See [announcement](https://discuss.dev.twitch.com/t/legacy-get-hype-train-events-api-and-eventsub-hype-train-v1-subscription-types-deprecation-and-withdrawal-timeline/64299).

		Gets information about the broadcasters current or most recent Hype Train event.

		Instead of polling for events, consider [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to Hype Train events ([Begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainbegin), [Progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainprogress), [End](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainend)).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:hype\_train** scope.
	*/
	GetHypeTrainEventsWithResponse(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (*GetHypeTrainEventsHTTPResponse, error)

	// GetHypeTrainStatusWithResponse request

	/*
		    NEW Get the status of a Hype Train for the specified broadcaster.

		__Authorization:__

		* Requires an [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
		* Requires OAuth Scope: `channel:read:hype_train`.
		* Requires that `broadcaster_id` and `user_id` match in the User-Access token.
	*/
	GetHypeTrainStatusWithResponse(ctx context.Context, params *GetHypeTrainStatusParams, reqEditors ...RequestEditorFn) (*GetHypeTrainStatusHTTPResponse, error)

	// ManageHeldAutomodMessagesWithBodyWithResponse request with any body

	/*
		    Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		To get messages that AutoMod is holding for review, subscribe to the **automod-queue.<moderator\_id>.<channel\_id>** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
	*/
	ManageHeldAutomodMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManageHeldAutomodMessagesHTTPResponse, error)

	/*
		            Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		To get messages that AutoMod is holding for review, subscribe to the **automod-queue.<moderator\_id>.<channel\_id>** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
	*/
	ManageHeldAutomodMessagesWithResponse(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*ManageHeldAutomodMessagesHTTPResponse, error)

	// GetAutomodSettingsWithResponse request

	/*
		    Gets the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\_settings** scope.
	*/
	GetAutomodSettingsWithResponse(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (*GetAutomodSettingsHTTPResponse, error)

	// UpdateAutomodSettingsWithBodyWithResponse request with any body

	/*
		    Updates the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\_settings** scope.

		__Request Body:__

		Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, youll send a GET request, update the fields you want to change, and pass that object in the PUT request.

		You may set either `overall_level` or the individual settings like `aggression`, but not both.

		Setting `overall_level` applies default values to the individual settings. However, setting `overall_level` to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set `overall_level` to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).

		If `overall_level` is currently set and you update `swearing` to 3, `overall_level` will be set to **null** and all settings other than `swearing` will be set to 0\. The same is true if individual settings are set and you update `overall_level` to 3  all the individual settings are updated to reflect the default level.

		Note that if you set all the individual settings to values that match what `overall_level` would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.

		Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
	*/
	UpdateAutomodSettingsWithBodyWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomodSettingsHTTPResponse, error)

	/*
		            Updates the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\_settings** scope.

		__Request Body:__

		Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, youll send a GET request, update the fields you want to change, and pass that object in the PUT request.

		You may set either `overall_level` or the individual settings like `aggression`, but not both.

		Setting `overall_level` applies default values to the individual settings. However, setting `overall_level` to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set `overall_level` to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).

		If `overall_level` is currently set and you update `swearing` to 3, `overall_level` will be set to **null** and all settings other than `swearing` will be set to 0\. The same is true if individual settings are set and you update `overall_level` to 3  all the individual settings are updated to reflect the default level.

		Note that if you set all the individual settings to values that match what `overall_level` would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.

		Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
	*/
	UpdateAutomodSettingsWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomodSettingsHTTPResponse, error)

	// GetBannedUsersWithResponse request

	/*
		    Gets all users that the broadcaster banned or put in a timeout.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\_users** scope.
	*/
	GetBannedUsersWithResponse(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (*GetBannedUsersHTTPResponse, error)

	// UnbanUserWithResponse request

	/*
		    Removes the ban or timeout that was placed on the specified user.

		To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
	*/
	UnbanUserWithResponse(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (*UnbanUserHTTPResponse, error)

	// BanUserWithBodyWithResponse request with any body

	/*
		    Bans a user from participating in the specified broadcasters chat room or puts them in a timeout.

		For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).

		If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.

		To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
	*/
	BanUserWithBodyWithResponse(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BanUserHTTPResponse, error)

	/*
		            Bans a user from participating in the specified broadcasters chat room or puts them in a timeout.

		For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).

		If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.

		To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
	*/
	BanUserWithResponse(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*BanUserHTTPResponse, error)

	// RemoveBlockedTermWithResponse request

	/*
		    Removes the word or phrase from the broadcasters list of blocked terms.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
	*/
	RemoveBlockedTermWithResponse(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (*RemoveBlockedTermHTTPResponse, error)

	// GetBlockedTermsWithResponse request

	/*
		    Gets the broadcasters list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\_terms** or **moderator:manage:blocked\_terms** scope.
	*/
	GetBlockedTermsWithResponse(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (*GetBlockedTermsHTTPResponse, error)

	// AddBlockedTermWithBodyWithResponse request with any body

	/*
		    Adds a word or phrase to the broadcasters list of blocked terms. These are the terms that the broadcaster doesnt want used in their chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
	*/
	AddBlockedTermWithBodyWithResponse(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBlockedTermHTTPResponse, error)

	/*
		            Adds a word or phrase to the broadcasters list of blocked terms. These are the terms that the broadcaster doesnt want used in their chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
	*/
	AddBlockedTermWithResponse(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBlockedTermHTTPResponse, error)

	// GetModeratedChannelsWithResponse request

	/*
		    Gets a list of channels that the specified user has moderator privileges in.

		__Authorization:__

		* Query parameter `user_id` must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
		* Requires OAuth Scope: `user:read:moderated_channels`
	*/
	GetModeratedChannelsWithResponse(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (*GetModeratedChannelsHTTPResponse, error)

	// DeleteChatMessagesWithResponse request

	/*
		    Removes a single chat message or all chat messages from the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_messages** scope.
	*/
	DeleteChatMessagesWithResponse(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (*DeleteChatMessagesHTTPResponse, error)

	// CheckAutomodStatusWithBodyWithResponse request with any body

	/*
		    Checks whether AutoMod would flag the specified message for review.

		AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		**Rate Limits**: Rates are limited per channel based on the account type rather than per access token.

		| Account type | Limit per minute | Limit per hour |
		| - | - | - |
		| Normal | 5 | 50 |
		| Affiliate | 10 | 100 |
		| Partner | 30 | 300 |


		The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
	*/
	CheckAutomodStatusWithBodyWithResponse(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckAutomodStatusHTTPResponse, error)

	/*
		            Checks whether AutoMod would flag the specified message for review.

		AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

		**Rate Limits**: Rates are limited per channel based on the account type rather than per access token.

		| Account type | Limit per minute | Limit per hour |
		| - | - | - |
		| Normal | 5 | 50 |
		| Affiliate | 10 | 100 |
		| Partner | 30 | 300 |


		The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
	*/
	CheckAutomodStatusWithResponse(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckAutomodStatusHTTPResponse, error)

	// RemoveChannelModeratorWithResponse request

	/*
		    Removes a moderator from the broadcasters chat room.

		**Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
	*/
	RemoveChannelModeratorWithResponse(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (*RemoveChannelModeratorHTTPResponse, error)

	// GetModeratorsWithResponse request

	/*
		    Gets all users allowed to moderate the broadcasters chat room.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
	*/
	GetModeratorsWithResponse(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (*GetModeratorsHTTPResponse, error)

	// AddChannelModeratorWithResponse request

	/*
		    Adds a moderator to the broadcasters chat room.

		**Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
	*/
	AddChannelModeratorWithResponse(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (*AddChannelModeratorHTTPResponse, error)

	// GetShieldModeStatusWithResponse request

	/*
		    Gets the broadcasters Shield Mode activation status.

		To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\_mode** or **moderator:manage:shield\_mode** scope.
	*/
	GetShieldModeStatusWithResponse(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (*GetShieldModeStatusHTTPResponse, error)

	// UpdateShieldModeStatusWithBodyWithResponse request with any body

	/*
		    Activates or deactivates the broadcasters Shield Mode.

		Twitchs Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasnt configured Shield Mode, it applies default overrides.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\_mode** scope.
	*/
	UpdateShieldModeStatusWithBodyWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShieldModeStatusHTTPResponse, error)

	/*
		            Activates or deactivates the broadcasters Shield Mode.

		Twitchs Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasnt configured Shield Mode, it applies default overrides.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\_mode** scope.
	*/
	UpdateShieldModeStatusWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShieldModeStatusHTTPResponse, error)

	// GetUnbanRequestsWithResponse request

	/*
		    NEW Gets a list of unban requests for a broadcasters channel.

		__Authorization:__

		* Requires a user access token that includes the **moderator:read:unban\_requests** or **moderator:manage:unban\_requests** scope.
		* Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	GetUnbanRequestsWithResponse(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (*GetUnbanRequestsHTTPResponse, error)

	// ResolveUnbanRequestsWithResponse request

	/*
		    NEW Resolves an unban request by approving or denying it.

		__Authorization:__

		* Requires a user access token that includes the **moderator:manage:unban\_requests** scope.
		* Query parameter `moderator_id` must match the `user_id` in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	ResolveUnbanRequestsWithResponse(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (*ResolveUnbanRequestsHTTPResponse, error)

	// WarnChatUserWithBodyWithResponse request with any body

	/*
		    NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).

		__Authorization:__

		Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	WarnChatUserWithBodyWithResponse(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WarnChatUserHTTPResponse, error)

	/*
		            NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).

		__Authorization:__

		Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	WarnChatUserWithResponse(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (*WarnChatUserHTTPResponse, error)

	// GetPollsWithResponse request

	/*
		    Gets a list of polls that the broadcaster created.

		Polls are available for 90 days after theyre created.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
	*/
	GetPollsWithResponse(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (*GetPollsHTTPResponse, error)

	// EndPollWithBodyWithResponse request with any body

	/*
		    Ends an active poll. You have the option to end it or end it and archive it.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	EndPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndPollHTTPResponse, error)

	/*
		            Ends an active poll. You have the option to end it or end it and archive it.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	EndPollWithResponse(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (*EndPollHTTPResponse, error)

	// CreatePollWithBodyWithResponse request with any body

	/*
		    Creates a poll that viewers in the broadcasters channel can vote on.

		The poll begins as soon as its created. You may run only one poll at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	CreatePollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePollHTTPResponse, error)

	/*
		            Creates a poll that viewers in the broadcasters channel can vote on.

		The poll begins as soon as its created. You may run only one poll at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
	*/
	CreatePollWithResponse(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePollHTTPResponse, error)

	// GetPredictionsWithResponse request

	/*
		    Gets a list of Channel Points Predictions that the broadcaster created.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:predictions** or **channel:manage:predictions** scope.
	*/
	GetPredictionsWithResponse(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (*GetPredictionsHTTPResponse, error)

	// EndPredictionWithBodyWithResponse request with any body

	/*
		    Locks, resolves, or cancels a Channel Points Prediction.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	EndPredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndPredictionHTTPResponse, error)

	/*
		            Locks, resolves, or cancels a Channel Points Prediction.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	EndPredictionWithResponse(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*EndPredictionHTTPResponse, error)

	// CreatePredictionWithBodyWithResponse request with any body

	/*
		    Creates a Channel Points Prediction.

		With a Channel Points Prediction, the broadcaster poses a question and viewers try to predict the outcome. The prediction runs as soon as its created. The broadcaster may run only one prediction at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	CreatePredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePredictionHTTPResponse, error)

	/*
		            Creates a Channel Points Prediction.

		With a Channel Points Prediction, the broadcaster poses a question and viewers try to predict the outcome. The prediction runs as soon as its created. The broadcaster may run only one prediction at a time.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
	*/
	CreatePredictionWithResponse(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePredictionHTTPResponse, error)

	// CancelARaidWithResponse request

	/*
		    Cancel a pending raid.

		You can cancel a raid at any point up until the broadcaster clicks **Raid Now** in the Twitch UX or the 90-second countdown expires.

		**Rate Limit**: The limit is 10 requests within a 10-minute window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:raids** scope.
	*/
	CancelARaidWithResponse(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (*CancelARaidHTTPResponse, error)

	// StartARaidWithResponse request

	/*
		    Raid another channel by sending the broadcasters viewers to the targeted channel.

		When you call the API from a chat bot or extension, the Twitch UX pops up a window at the top of the chat room that identifies the number of viewers in the raid. The raid occurs when the broadcaster clicks **Raid Now** or after the 90-second countdown expires.

		To determine whether the raid successfully occurred, you must subscribe to the [Channel Raid](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelraid) event. For more information, see [Get notified when a raid begins](https://dev.twitch.tv/docs/api/raids#get-notified-when-a-raid-begins).

		To cancel a pending raid, use the [Cancel a raid](https://dev.twitch.tv/docs/api/reference#cancel-a-raid) endpoint.

		**Rate Limit**: The limit is 10 requests within a 10-minute window.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:raids** scope.
	*/
	StartARaidWithResponse(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (*StartARaidHTTPResponse, error)

	// GetChannelStreamScheduleWithResponse request

	/*
		    Gets the broadcasters streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelStreamScheduleWithResponse(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*GetChannelStreamScheduleHTTPResponse, error)

	// GetChannelIcalendarWithResponse request

	/*
		    Gets the broadcasters streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).

		__Authorization:__

		The Client-Id and Authorization headers are not required.

		__Response Body:__

		The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).

		The Content-Type response header is set to `text/calendar`.
	*/
	GetChannelIcalendarWithResponse(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (*GetChannelIcalendarHTTPResponse, error)

	// DeleteChannelStreamScheduleSegmentWithResponse request

	/*
		    Removes a broadcast segment from the broadcasters streaming schedule.

		**NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	DeleteChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (*DeleteChannelStreamScheduleSegmentHTTPResponse, error)

	// UpdateChannelStreamScheduleSegmentWithBodyWithResponse request with any body

	/*
		    Updates a scheduled broadcast segment.

		For recurring segments, updating a segments title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	UpdateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelStreamScheduleSegmentHTTPResponse, error)

	/*
		            Updates a scheduled broadcast segment.

		For recurring segments, updating a segments title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	UpdateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelStreamScheduleSegmentHTTPResponse, error)

	// CreateChannelStreamScheduleSegmentWithBodyWithResponse request with any body

	/*
		    Adds a single or recurring broadcast to the broadcasters streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	CreateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChannelStreamScheduleSegmentHTTPResponse, error)

	/*
		            Adds a single or recurring broadcast to the broadcasters streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	CreateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChannelStreamScheduleSegmentHTTPResponse, error)

	// UpdateChannelStreamScheduleWithResponse request

	/*
		    Updates the broadcasters schedule settings, such as scheduling a vacation.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
	*/
	UpdateChannelStreamScheduleWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*UpdateChannelStreamScheduleHTTPResponse, error)

	// SearchCategoriesWithResponse request

	/*
		    Gets the games or categories that match the specified query.

		To match, the categorys name must contain all parts of the query string. For example, if the query string is 42, the response includes any category name that contains 42 in the title. If the query string is a phrase like _love computer_, the response includes any category name that contains the words love and computer anywhere in the name. The comparison is case insensitive.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	SearchCategoriesWithResponse(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (*SearchCategoriesHTTPResponse, error)

	// SearchChannelsWithResponse request

	/*
		    Gets the channels that match the specified query and have streamed content within the past 6 months.

		The fields that the API uses for comparison depends on the value that the _live\_only_ query parameter is set to. If _live\_only_ is **false**, the API matches on the broadcasters login name. However, if _live\_only_ is **true**, the API matches on the broadcasters name and category name.

		To match, the beginning of the broadcasters name or category must match the query string. The comparison is case insensitive. If the query string is angel\_of\_death, it matches all names that begin with angel\_of\_death. However, if the query string is a phrase like _angel of death_, it matches to names starting with angelofdeath or names starting with angel\_of\_death.

		By default, the results include both live and offline channels. To get only live channels set the _live\_only_ query parameter to **true**.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	SearchChannelsWithResponse(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (*SearchChannelsHTTPResponse, error)

	// GetSharedChatSessionWithResponse request

	/*
		    NEW Retrieves the active shared chat session for a channel.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
	*/
	GetSharedChatSessionWithResponse(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (*GetSharedChatSessionHTTPResponse, error)

	// GetStreamsWithResponse request

	/*
		    Gets a list of all streams. The list is in descending order by the number of viewers watching the stream. Because viewers come and go during a stream, its possible to find duplicate or missing streams in the list as you page through the results.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsHTTPResponse, error)

	// GetFollowedStreamsWithResponse request

	/*
		    Gets the list of broadcasters that the user follows and that are streaming live.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:follows** scope.
	*/
	GetFollowedStreamsWithResponse(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (*GetFollowedStreamsHTTPResponse, error)

	// GetStreamKeyWithResponse request

	/*
		    Gets the channels stream key.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:stream\_key** scope.
	*/
	GetStreamKeyWithResponse(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (*GetStreamKeyHTTPResponse, error)

	// GetStreamMarkersWithResponse request

	/*
		    Gets a list of markers from the users most recent stream or from the specified VOD/video. A marker is an arbitrary point in a live stream that the broadcaster or editor marked, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:broadcast** or **channel:manage:broadcast** scope.
	*/
	GetStreamMarkersWithResponse(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (*GetStreamMarkersHTTPResponse, error)

	// CreateStreamMarkerWithBodyWithResponse request with any body

	/*
		    Adds a marker to a live stream. A marker is an arbitrary point in a live stream that the broadcaster or editor wants to mark, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

		You may not add markers:

		* If the stream is not live
		* If the stream has not enabled video on demand (VOD)
		* If the stream is a premiere (a live, first-viewing event that combines uploaded videos with live chat)
		* If the stream is a rerun of a past broadcast, including past premieres.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.
	*/
	CreateStreamMarkerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStreamMarkerHTTPResponse, error)

	/*
		            Adds a marker to a live stream. A marker is an arbitrary point in a live stream that the broadcaster or editor wants to mark, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

		You may not add markers:

		* If the stream is not live
		* If the stream has not enabled video on demand (VOD)
		* If the stream is a premiere (a live, first-viewing event that combines uploaded videos with live chat)
		* If the stream is a rerun of a past broadcast, including past premieres.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.
	*/
	CreateStreamMarkerWithResponse(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStreamMarkerHTTPResponse, error)

	// GetStreamTagsWithResponse request

	/*
		    **IMPORTANT** Twitch is moving from Twitch-defined tags to channel-defined tags. **IMPORTANT** As of February 28, 2023, this endpoint returns an empty array. On July 13, 2023, it will return a 410 response. If you use this endpoint, please update your code to use [Get Channel Information](https://dev.twitch.tv/docs/api/reference#get-channel-information).

		Gets the list of stream tags that the broadcaster or Twitch added to their channel.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetStreamTagsWithResponse(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (*GetStreamTagsHTTPResponse, error)

	// GetBroadcasterSubscriptionsWithResponse request

	/*
		    Gets a list of users that subscribe to the specified broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:subscriptions** scope.

		A Twitch extensions may use an app access token if the broadcaster has granted the **channel:read:subscriptions** scope from within the Twitch Extensions manager.
	*/
	GetBroadcasterSubscriptionsWithResponse(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetBroadcasterSubscriptionsHTTPResponse, error)

	// CheckUserSubscriptionWithResponse request

	/*
		    Checks whether the user subscribes to the broadcasters channel.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:subscriptions** scope.

		A Twitch extensions may use an app access token if the broadcaster has granted the **user:read:subscriptions** scope from within the Twitch Extensions manager.
	*/
	CheckUserSubscriptionWithResponse(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (*CheckUserSubscriptionHTTPResponse, error)

	// GetAllStreamTagsWithResponse request

	/*
		    **IMPORTANT** Twitch is moving from Twitch-defined tags to channel-defined tags. **IMPORTANT** As of February 28, 2023, this endpoint returns an empty array. On July 13, 2023, it will return a 410 response.

		Gets a list of all stream tags that Twitch defines. The broadcaster may apply any of these to their channel except automatic tags. For an online list of the possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags).

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetAllStreamTagsWithResponse(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (*GetAllStreamTagsHTTPResponse, error)

	// GetTeamsWithResponse request

	/*
		    Gets information about the specified Twitch team. [Read More](https://help.twitch.tv/s/article/twitch-teams)

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsHTTPResponse, error)

	// GetChannelTeamsWithResponse request

	/*
		    Gets the list of Twitch teams that the broadcaster is a member of.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetChannelTeamsWithResponse(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (*GetChannelTeamsHTTPResponse, error)

	// GetUsersWithResponse request

	/*
		    Gets information about one or more users.

		You may look up users using their user ID, login name, or both but the sum total of the number of users you may look up is 100\. For example, you may specify 50 IDs and 50 names or 100 IDs or names, but you cannot specify 100 IDs and 100 names.

		If you dont specify IDs or login names, the request returns information about the user in the access token if you specify a user access token.

		To include the users verified email address in the response, you must use a user access token that includes the **user:read:email** scope.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersHTTPResponse, error)

	// UpdateUserWithResponse request

	/*
		    Updates the specified users information. The user ID in the OAuth token identifies the user whose information you want to update.

		To include the users verified email address in the response, the user access token must also include the **user:read:email** scope.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit** scope.
	*/
	UpdateUserWithResponse(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (*UpdateUserHTTPResponse, error)

	// UnblockUserWithResponse request

	/*
		    Removes the user from the broadcasters list of blocked users. The user ID in the OAuth token identifies the broadcaster whos removing the block.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:blocked\_users** scope.
	*/
	UnblockUserWithResponse(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (*UnblockUserHTTPResponse, error)

	// GetUserBlockListWithResponse request

	/*
		    Gets the list of users that the broadcaster has blocked. [Read More](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers)

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:blocked\_users** scope.
	*/
	GetUserBlockListWithResponse(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (*GetUserBlockListHTTPResponse, error)

	// BlockUserWithResponse request

	/*
		    Blocks the specified user from interacting with or having contact with the broadcaster. The user ID in the OAuth token identifies the broadcaster who is blocking the user.

		To learn more about blocking users, see [Block Other Users on Twitch](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:blocked\_users** scope.
	*/
	BlockUserWithResponse(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (*BlockUserHTTPResponse, error)

	// GetUserActiveExtensionsWithResponse request

	/*
		    Gets the active extensions that the broadcaster has installed for each configuration.

		NOTE: To include extensions that you have under development, you must specify a user access token that includes the **user:read:broadcast** or **user:edit:broadcast** scope.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetUserActiveExtensionsWithResponse(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (*GetUserActiveExtensionsHTTPResponse, error)

	// UpdateUserExtensionsWithBodyWithResponse request with any body

	/*
		    Updates an installed extensions information. You can update the extensions activation state, ID, and version number. The user ID in the access token identifies the broadcaster whose extensions youre updating.

		NOTE: If you try to activate an extension under multiple extension types, the last write wins (and there is no guarantee of write order).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit:broadcast** scope.
	*/
	UpdateUserExtensionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserExtensionsHTTPResponse, error)

	/*
		            Updates an installed extensions information. You can update the extensions activation state, ID, and version number. The user ID in the access token identifies the broadcaster whose extensions youre updating.

		NOTE: If you try to activate an extension under multiple extension types, the last write wins (and there is no guarantee of write order).

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit:broadcast** scope.
	*/
	UpdateUserExtensionsWithResponse(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserExtensionsHTTPResponse, error)

	// GetUserExtensionsWithResponse request

	/*
		    Gets a list of all extensions (both active and inactive) that the broadcaster has installed. The user ID in the access token identifies the broadcaster.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:broadcast** or **user:edit:broadcast** scope. To include inactive extensions, you must include the **user:edit:broadcast** scope.
	*/
	GetUserExtensionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserExtensionsHTTPResponse, error)

	// DeleteVideosWithResponse request

	/*
		    Deletes one or more videos. You may delete past broadcasts, highlights, or uploads.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:videos** scope.
	*/
	DeleteVideosWithResponse(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (*DeleteVideosHTTPResponse, error)

	// GetVideosWithResponse request

	/*
		    Gets information about one or more published videos. You may get videos by ID, by user, or by game/category.

		You may apply several filters to get a subset of the videos. The filters are applied as an AND operation to each video. For example, if _language_ is set to de and _game\_id_ is set to 21779, the response includes only videos that show playing League of Legends by users that stream in German. The filters apply only if you get videos by user ID or game ID.

		__Authorization:__

		Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
	*/
	GetVideosWithResponse(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (*GetVideosHTTPResponse, error)

	// SendWhisperWithBodyWithResponse request with any body

	/*
		    Sends a whisper message to the specified user.

		NOTE: The user sending the whisper must have a verified phone number (see the **Phone Number** setting in your [Security and Privacy](https://www.twitch.tv/settings/security) settings).

		NOTE: The API may silently drop whispers that it suspects of violating Twitch policies. (The API does not indicate that it dropped the whisper; it returns a 204 status code as if it succeeded.)

		**Rate Limits**: You may whisper to a maximum of 40 unique recipients per day. Within the per day limit, you may whisper a maximum of 3 whispers per second and a maximum of 100 whispers per minute.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:whispers** scope.
	*/
	SendWhisperWithBodyWithResponse(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendWhisperHTTPResponse, error)

	/*
		            Sends a whisper message to the specified user.

		NOTE: The user sending the whisper must have a verified phone number (see the **Phone Number** setting in your [Security and Privacy](https://www.twitch.tv/settings/security) settings).

		NOTE: The API may silently drop whispers that it suspects of violating Twitch policies. (The API does not indicate that it dropped the whisper; it returns a 204 status code as if it succeeded.)

		**Rate Limits**: You may whisper to a maximum of 40 unique recipients per day. Within the per day limit, you may whisper a maximum of 3 whispers per second and a maximum of 100 whispers per minute.

		__Authorization:__

		Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:whispers** scope.
	*/
	SendWhisperWithResponse(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (*SendWhisperHTTPResponse, error)
}

type GetExtensionAnalyticsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionAnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionAnalyticsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionAnalyticsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGameAnalyticsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGameAnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetGameAnalyticsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGameAnalyticsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheermotesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCheermotesResponse
}

// Status returns HTTPResponse.Status
func (r GetCheermotesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheermotesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionBitsProductsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionBitsProductsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionBitsProductsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionBitsProductsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExtensionBitsProductHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateExtensionBitsProductResponse
}

// Status returns HTTPResponse.Status
func (r UpdateExtensionBitsProductHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExtensionBitsProductHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBitsLeaderboardHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBitsLeaderboardResponse
}

// Status returns HTTPResponse.Status
func (r GetBitsLeaderboardHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBitsLeaderboardHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomRewardHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomRewardHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomRewardHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomRewardHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCustomRewardResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomRewardHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomRewardHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomRewardHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateCustomRewardResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCustomRewardHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomRewardHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomRewardsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCustomRewardsResponse
}

// Status returns HTTPResponse.Status
func (r CreateCustomRewardsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomRewardsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomRewardRedemptionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCustomRewardRedemptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomRewardRedemptionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomRewardRedemptionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRedemptionStatusHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateRedemptionStatusResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRedemptionStatusHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRedemptionStatusHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelInformationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelInformationResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelInformationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelInformationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyChannelInformationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyChannelInformationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyChannelInformationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAdScheduleResponse
}

// Status returns HTTPResponse.Status
func (r GetAdScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnoozeNextAdHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnoozeNextAdResponse
}

// Status returns HTTPResponse.Status
func (r SnoozeNextAdHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnoozeNextAdHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartCommercialHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartCommercialResponse
}

// Status returns HTTPResponse.Status
func (r StartCommercialHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartCommercialHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelEditorsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelEditorsResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelEditorsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelEditorsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFollowedChannelsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFollowedChannelsResponse
}

// Status returns HTTPResponse.Status
func (r GetFollowedChannelsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFollowedChannelsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelFollowersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelFollowersResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelFollowersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelFollowersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveChannelVipHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveChannelVipHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveChannelVipHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVipsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetVIPsResponse
}

// Status returns HTTPResponse.Status
func (r GetVipsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVipsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelVipHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddChannelVipHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelVipHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharityCampaignHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCharityCampaignResponse
}

// Status returns HTTPResponse.Status
func (r GetCharityCampaignHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharityCampaignHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharityCampaignDonationsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCharityCampaignDonationsResponse
}

// Status returns HTTPResponse.Status
func (r GetCharityCampaignDonationsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharityCampaignDonationsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendChatAnnouncementHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendChatAnnouncementHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendChatAnnouncementHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelChatBadgesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelChatBadgesResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelChatBadgesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelChatBadgesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalChatBadgesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGlobalChatBadgesResponse
}

// Status returns HTTPResponse.Status
func (r GetGlobalChatBadgesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalChatBadgesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChattersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChattersResponse
}

// Status returns HTTPResponse.Status
func (r GetChattersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChattersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserChatColorHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserChatColorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserChatColorHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserChatColorHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserChatColorHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateUserChatColorHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserChatColorHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelEmotesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelEmotesResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelEmotesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelEmotesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalEmotesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGlobalEmotesResponse
}

// Status returns HTTPResponse.Status
func (r GetGlobalEmotesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalEmotesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmoteSetsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEmoteSetsResponse
}

// Status returns HTTPResponse.Status
func (r GetEmoteSetsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmoteSetsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEmotesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserEmotesResponse
}

// Status returns HTTPResponse.Status
func (r GetUserEmotesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEmotesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendChatMessageHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendChatMessageResponse
}

// Status returns HTTPResponse.Status
func (r SendChatMessageHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendChatMessageHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChatSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChatSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetChatSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChatSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChatSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateChatSettingsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateChatSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChatSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendAShoutoutHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendAShoutoutHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendAShoutoutHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClipsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClipsResponse
}

// Status returns HTTPResponse.Status
func (r GetClipsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClipsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClipHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateClipResponse
}

// Status returns HTTPResponse.Status
func (r CreateClipHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClipHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentClassificationLabelsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetContentClassificationLabelsResponse
}

// Status returns HTTPResponse.Status
func (r GetContentClassificationLabelsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentClassificationLabelsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDropsEntitlementsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDropsEntitlementsResponse
}

// Status returns HTTPResponse.Status
func (r GetDropsEntitlementsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDropsEntitlementsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDropsEntitlementsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateDropsEntitlementsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateDropsEntitlementsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDropsEntitlementsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConduitHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConduitHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConduitHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConduitsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConduitsResponse
}

// Status returns HTTPResponse.Status
func (r GetConduitsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConduitsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConduitsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateConduitsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConduitsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConduitsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConduitsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateConduitsResponse
}

// Status returns HTTPResponse.Status
func (r CreateConduitsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConduitsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConduitShardsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConduitShardsResponse
}

// Status returns HTTPResponse.Status
func (r GetConduitShardsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConduitShardsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConduitShardsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateConduitShardsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConduitShardsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConduitShardsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEventsubSubscriptionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEventsubSubscriptionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEventsubSubscriptionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsubSubscriptionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEventSubSubscriptionsResponse
}

// Status returns HTTPResponse.Status
func (r GetEventsubSubscriptionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsubSubscriptionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEventsubSubscriptionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateEventSubSubscriptionResponse
}

// Status returns HTTPResponse.Status
func (r CreateEventsubSubscriptionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEventsubSubscriptionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendExtensionChatMessageHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendExtensionChatMessageHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendExtensionChatMessageHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionConfigurationSegmentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionConfigurationSegmentResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionConfigurationSegmentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionConfigurationSegmentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetExtensionConfigurationSegmentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetExtensionConfigurationSegmentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetExtensionConfigurationSegmentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionSecretsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionSecretsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionSecretsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionSecretsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExtensionSecretHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateExtensionSecretResponse
}

// Status returns HTTPResponse.Status
func (r CreateExtensionSecretHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExtensionSecretHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionLiveChannelsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionLiveChannelsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionLiveChannelsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionLiveChannelsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendExtensionPubsubMessageHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendExtensionPubsubMessageHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendExtensionPubsubMessageHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleasedExtensionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetReleasedExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetReleasedExtensionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasedExtensionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetExtensionRequiredConfigurationHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetExtensionRequiredConfigurationHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetExtensionRequiredConfigurationHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionTransactionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionTransactionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionTransactionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGamesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGamesResponse
}

// Status returns HTTPResponse.Status
func (r GetGamesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGamesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopGamesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTopGamesResponse
}

// Status returns HTTPResponse.Status
func (r GetTopGamesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopGamesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCreatorGoalsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCreatorGoalsResponse
}

// Status returns HTTPResponse.Status
func (r GetCreatorGoalsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCreatorGoalsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelGuestStarSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelGuestStarSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelGuestStarSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelGuestStarSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelGuestStarSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateChannelGuestStarSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelGuestStarSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGuestStarInviteHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGuestStarInviteHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGuestStarInviteHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGuestStarInvitesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGuestStarInvitesResponse
}

// Status returns HTTPResponse.Status
func (r GetGuestStarInvitesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGuestStarInvitesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendGuestStarInviteHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendGuestStarInviteHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendGuestStarInviteHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndGuestStarSessionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EndGuestStarSessionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndGuestStarSessionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGuestStarSessionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGuestStarSessionResponse
}

// Status returns HTTPResponse.Status
func (r GetGuestStarSessionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGuestStarSessionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGuestStarSessionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateGuestStarSessionResponse
}

// Status returns HTTPResponse.Status
func (r CreateGuestStarSessionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGuestStarSessionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGuestStarSlotHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGuestStarSlotHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGuestStarSlotHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGuestStarSlotHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGuestStarSlotHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGuestStarSlotHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignGuestStarSlotHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AssignGuestStarSlotHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignGuestStarSlotHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGuestStarSlotSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGuestStarSlotSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGuestStarSlotSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHypeTrainEventsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetHypeTrainEventsResponse
}

// Status returns HTTPResponse.Status
func (r GetHypeTrainEventsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHypeTrainEventsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHypeTrainStatusHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetHypeTrainStatusResponse
}

// Status returns HTTPResponse.Status
func (r GetHypeTrainStatusHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHypeTrainStatusHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManageHeldAutomodMessagesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ManageHeldAutomodMessagesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManageHeldAutomodMessagesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomodSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAutoModSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetAutomodSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomodSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomodSettingsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateAutoModSettingsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAutomodSettingsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomodSettingsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBannedUsersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBannedUsersResponse
}

// Status returns HTTPResponse.Status
func (r GetBannedUsersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBannedUsersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnbanUserHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnbanUserHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnbanUserHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BanUserHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BanUserResponse
}

// Status returns HTTPResponse.Status
func (r BanUserHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BanUserHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveBlockedTermHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveBlockedTermHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveBlockedTermHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockedTermsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBlockedTermsResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockedTermsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockedTermsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBlockedTermHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddBlockedTermResponse
}

// Status returns HTTPResponse.Status
func (r AddBlockedTermHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBlockedTermHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModeratedChannelsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModeratedChannelsResponse
}

// Status returns HTTPResponse.Status
func (r GetModeratedChannelsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModeratedChannelsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChatMessagesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteChatMessagesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChatMessagesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAutomodStatusHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckAutoModStatusResponse
}

// Status returns HTTPResponse.Status
func (r CheckAutomodStatusHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAutomodStatusHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveChannelModeratorHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveChannelModeratorHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveChannelModeratorHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModeratorsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModeratorsResponse
}

// Status returns HTTPResponse.Status
func (r GetModeratorsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModeratorsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelModeratorHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddChannelModeratorHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelModeratorHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShieldModeStatusHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShieldModeStatusResponse
}

// Status returns HTTPResponse.Status
func (r GetShieldModeStatusHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShieldModeStatusHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShieldModeStatusHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateShieldModeStatusResponse
}

// Status returns HTTPResponse.Status
func (r UpdateShieldModeStatusHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShieldModeStatusHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnbanRequestsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUnbanRequestsResponse
}

// Status returns HTTPResponse.Status
func (r GetUnbanRequestsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnbanRequestsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveUnbanRequestsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResolveUnbanRequestsResponse
}

// Status returns HTTPResponse.Status
func (r ResolveUnbanRequestsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveUnbanRequestsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WarnChatUserHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarnChatUserResponse
}

// Status returns HTTPResponse.Status
func (r WarnChatUserHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WarnChatUserHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPollsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPollsResponse
}

// Status returns HTTPResponse.Status
func (r GetPollsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPollsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndPollHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndPollResponse
}

// Status returns HTTPResponse.Status
func (r EndPollHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndPollHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePollHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePollResponse
}

// Status returns HTTPResponse.Status
func (r CreatePollHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePollHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPredictionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPredictionsResponse
}

// Status returns HTTPResponse.Status
func (r GetPredictionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPredictionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndPredictionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndPredictionResponse
}

// Status returns HTTPResponse.Status
func (r EndPredictionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndPredictionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePredictionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePredictionResponse
}

// Status returns HTTPResponse.Status
func (r CreatePredictionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePredictionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelARaidHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelARaidHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelARaidHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartARaidHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartRaidResponse
}

// Status returns HTTPResponse.Status
func (r StartARaidHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartARaidHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelStreamScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelStreamScheduleResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelStreamScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelStreamScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelIcalendarHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetChannelIcalendarHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelIcalendarHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChannelStreamScheduleSegmentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteChannelStreamScheduleSegmentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelStreamScheduleSegmentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelStreamScheduleSegmentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateChannelStreamScheduleSegmentResponse
}

// Status returns HTTPResponse.Status
func (r UpdateChannelStreamScheduleSegmentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelStreamScheduleSegmentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateChannelStreamScheduleSegmentHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateChannelStreamScheduleSegmentResponse
}

// Status returns HTTPResponse.Status
func (r CreateChannelStreamScheduleSegmentHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChannelStreamScheduleSegmentHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelStreamScheduleHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateChannelStreamScheduleHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelStreamScheduleHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCategoriesHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchCategoriesResponse
}

// Status returns HTTPResponse.Status
func (r SearchCategoriesHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCategoriesHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchChannelsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchChannelsResponse
}

// Status returns HTTPResponse.Status
func (r SearchChannelsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchChannelsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSharedChatSessionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSharedChatSessionResponse
}

// Status returns HTTPResponse.Status
func (r GetSharedChatSessionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSharedChatSessionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamsResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFollowedStreamsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFollowedStreamsResponse
}

// Status returns HTTPResponse.Status
func (r GetFollowedStreamsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFollowedStreamsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamKeyHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamKeyResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamKeyHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamKeyHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamMarkersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamMarkersResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamMarkersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamMarkersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStreamMarkerHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateStreamMarkerResponse
}

// Status returns HTTPResponse.Status
func (r CreateStreamMarkerHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStreamMarkerHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamTagsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamTagsResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamTagsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamTagsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBroadcasterSubscriptionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBroadcasterSubscriptionsResponse
}

// Status returns HTTPResponse.Status
func (r GetBroadcasterSubscriptionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBroadcasterSubscriptionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUserSubscriptionHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckUserSubscriptionResponse
}

// Status returns HTTPResponse.Status
func (r CheckUserSubscriptionHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUserSubscriptionHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStreamTagsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllStreamTagsResponse
}

// Status returns HTTPResponse.Status
func (r GetAllStreamTagsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStreamTagsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTeamsResponse
}

// Status returns HTTPResponse.Status
func (r GetTeamsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTeamsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelTeamsResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelTeamsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTeamsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUsersResponse
}

// Status returns HTTPResponse.Status
func (r GetUsersHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserResponse
}

// Status returns HTTPResponse.Status
func (r UpdateUserHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnblockUserHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnblockUserHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnblockUserHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserBlockListHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserBlockListResponse
}

// Status returns HTTPResponse.Status
func (r GetUserBlockListHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserBlockListHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockUserHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BlockUserHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockUserHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserActiveExtensionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserActiveExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetUserActiveExtensionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserActiveExtensionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserExtensionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateUserExtensionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserExtensionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserExtensionsHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetUserExtensionsHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserExtensionsHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVideosHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteVideosResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVideosHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVideosHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetVideosResponse
}

// Status returns HTTPResponse.Status
func (r GetVideosHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendWhisperHTTPResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendWhisperHTTPResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendWhisperHTTPResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetExtensionAnalyticsWithResponse request returning *GetExtensionAnalyticsHTTPResponse

/*
	Gets an analytics report for one or more extensions. The response contains the URLs used to download the reports (CSV files). [Learn More](https://dev.twitch.tv/docs/insights)

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:extensions** scope.
*/
func (c *ClientWithResponses) GetExtensionAnalyticsWithResponse(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (r *GetExtensionAnalyticsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionAnalyticsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionAnalytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionAnalyticsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGameAnalyticsWithResponse request returning *GetGameAnalyticsHTTPResponse

/*
	Gets an analytics report for one or more games. The response contains the URLs used to download the reports (CSV files). [Learn more](https://dev.twitch.tv/docs/insights)

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **analytics:read:games** scope.
*/
func (c *ClientWithResponses) GetGameAnalyticsWithResponse(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (r *GetGameAnalyticsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGameAnalyticsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGameAnalytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGameAnalyticsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCheermotesWithResponse request returning *GetCheermotesHTTPResponse

/*
	Gets a list of Cheermotes that users can use to cheer Bits in any Bits-enabled channels chat room. Cheermotes are animated emotes that viewers can assign Bits to.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetCheermotesWithResponse(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (r *GetCheermotesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCheermotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCheermotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCheermotesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionBitsProductsWithResponse request returning *GetExtensionBitsProductsHTTPResponse

/*
	Gets the list of Bits products that belongs to the extension. The client ID in the app access token identifies the extension.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must be the extensions client ID.
*/
func (c *ClientWithResponses) GetExtensionBitsProductsWithResponse(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (r *GetExtensionBitsProductsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionBitsProductsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionBitsProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionBitsProductsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateExtensionBitsProductWithBodyWithResponse request with arbitrary body returning *UpdateExtensionBitsProductHTTPResponse

/*
	Adds or updates a Bits product that the extension created. If the SKU doesnt exist, the product is added. You may update all fields except the `sku` field.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extensions client ID.
*/
func (c *ClientWithResponses) UpdateExtensionBitsProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateExtensionBitsProductHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateExtensionBitsProductWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateExtensionBitsProductWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateExtensionBitsProductHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Adds or updates a Bits product that the extension created. If the SKU doesnt exist, the product is added. You may update all fields except the `sku` field.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens). The client ID in the app access token must match the extensions client ID.
*/
func (c *ClientWithResponses) UpdateExtensionBitsProductWithResponse(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateExtensionBitsProductHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateExtensionBitsProductWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateExtensionBitsProduct(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateExtensionBitsProductHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBitsLeaderboardWithResponse request returning *GetBitsLeaderboardHTTPResponse

/*
	Gets the Bits leaderboard for the authenticated broadcaster.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **bits:read** scope.
*/
func (c *ClientWithResponses) GetBitsLeaderboardWithResponse(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (r *GetBitsLeaderboardHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBitsLeaderboardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBitsLeaderboard(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBitsLeaderboardHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteCustomRewardWithResponse request returning *DeleteCustomRewardHTTPResponse

/*
	Deletes a custom reward that the broadcaster created.

The app used to create the reward is the only app that may delete it. If the rewards redemption status is UNFULFILLED at the time the reward is deleted, its redemption status is marked as FULFILLED.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) DeleteCustomRewardWithResponse(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (r *DeleteCustomRewardHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteCustomRewardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteCustomReward(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteCustomRewardHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCustomRewardWithResponse request returning *GetCustomRewardHTTPResponse

/*
	Gets a list of custom rewards that the specified broadcaster created.

**NOTE**: A channel may offer a maximum of 50 rewards, which includes both enabled and disabled rewards.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) GetCustomRewardWithResponse(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (r *GetCustomRewardHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCustomRewardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCustomReward(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCustomRewardHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateCustomRewardWithBodyWithResponse request with arbitrary body returning *UpdateCustomRewardHTTPResponse

/*
	Updates a custom reward. The app used to create the reward is the only app that may update the reward.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.

__Request Body:__

The body of the request should contain only the fields youre updating.
*/
func (c *ClientWithResponses) UpdateCustomRewardWithBodyWithResponse(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateCustomRewardHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateCustomRewardWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateCustomRewardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateCustomRewardHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates a custom reward. The app used to create the reward is the only app that may update the reward.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/api/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.

__Request Body:__

The body of the request should contain only the fields youre updating.
*/
func (c *ClientWithResponses) UpdateCustomRewardWithResponse(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateCustomRewardHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateCustomRewardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateCustomReward(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateCustomRewardHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateCustomRewardsWithBodyWithResponse request with arbitrary body returning *CreateCustomRewardsHTTPResponse

/*
	Creates a Custom Reward in the broadcasters channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) CreateCustomRewardsWithBodyWithResponse(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateCustomRewardsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateCustomRewardsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateCustomRewardsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateCustomRewardsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Creates a Custom Reward in the broadcasters channel. The maximum number of custom rewards per channel is 50, which includes both enabled and disabled rewards.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) CreateCustomRewardsWithResponse(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateCustomRewardsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateCustomRewardsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateCustomRewards(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateCustomRewardsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCustomRewardRedemptionWithResponse request returning *GetCustomRewardRedemptionHTTPResponse

/*
	Gets a list of redemptions for the specified custom reward. The app used to create the reward is the only app that may get the redemptions.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:redemptions** or **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) GetCustomRewardRedemptionWithResponse(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (r *GetCustomRewardRedemptionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCustomRewardRedemptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCustomRewardRedemption(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCustomRewardRedemptionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateRedemptionStatusWithBodyWithResponse request with arbitrary body returning *UpdateRedemptionStatusHTTPResponse

/*
	Updates a redemptions status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) UpdateRedemptionStatusWithBodyWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateRedemptionStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateRedemptionStatusWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateRedemptionStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateRedemptionStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates a redemptions status. You may update a redemption only if its status is UNFULFILLED. The app used to create the reward is the only app that may update the redemption.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:redemptions** scope.
*/
func (c *ClientWithResponses) UpdateRedemptionStatusWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateRedemptionStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateRedemptionStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateRedemptionStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateRedemptionStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelInformationWithResponse request returning *GetChannelInformationHTTPResponse

/*
	Gets information about one or more channels.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetChannelInformationWithResponse(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (r *GetChannelInformationHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelInformationWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelInformation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelInformationHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ModifyChannelInformationWithBodyWithResponse request with arbitrary body returning *ModifyChannelInformationHTTPResponse

/*
	Updates a channels properties.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.

__Request Body:__

All fields are optional, but you must specify at least one field.
*/
func (c *ClientWithResponses) ModifyChannelInformationWithBodyWithResponse(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *ModifyChannelInformationHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ModifyChannelInformationWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ModifyChannelInformationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseModifyChannelInformationHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates a channels properties.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.

__Request Body:__

All fields are optional, but you must specify at least one field.
*/
func (c *ClientWithResponses) ModifyChannelInformationWithResponse(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (r *ModifyChannelInformationHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ModifyChannelInformationWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ModifyChannelInformation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseModifyChannelInformationHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetAdScheduleWithResponse request returning *GetAdScheduleHTTPResponse

/*
	This endpoint returns ad schedule related information, including snooze, when the last ad was run, when the next ad is scheduled, and if the channel is currently in pre-roll free time. Note that a new ad cannot be run until 8 minutes after running a previous ad.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:ads** scope. The `user_id` in the user access token must match the `broadcaster_id`.
*/
func (c *ClientWithResponses) GetAdScheduleWithResponse(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (r *GetAdScheduleHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetAdScheduleWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetAdSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetAdScheduleHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SnoozeNextAdWithResponse request returning *SnoozeNextAdHTTPResponse

/*
	If available, pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes. This endpoint duplicates the snooze functionality in the creator dashboards Ads Manager.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:ads** scope. The `user_id` in the user access token must match the `broadcaster_id`.
*/
func (c *ClientWithResponses) SnoozeNextAdWithResponse(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (r *SnoozeNextAdHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SnoozeNextAdWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SnoozeNextAd(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSnoozeNextAdHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// StartCommercialWithBodyWithResponse request with arbitrary body returning *StartCommercialHTTPResponse

/*
	Starts a commercial on the specified channel.

**NOTE**: Only partners and affiliates may run commercials and they must be streaming live at the time.

**NOTE**: Only the broadcaster may start a commercial; the broadcasters editors and moderators may not start commercials on behalf of the broadcaster.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:edit:commercial** scope.
*/
func (c *ClientWithResponses) StartCommercialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *StartCommercialHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "StartCommercialWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.StartCommercialWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseStartCommercialHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Starts a commercial on the specified channel.

**NOTE**: Only partners and affiliates may run commercials and they must be streaming live at the time.

**NOTE**: Only the broadcaster may start a commercial; the broadcasters editors and moderators may not start commercials on behalf of the broadcaster.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:edit:commercial** scope.
*/
func (c *ClientWithResponses) StartCommercialWithResponse(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (r *StartCommercialHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "StartCommercialWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.StartCommercial(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseStartCommercialHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelEditorsWithResponse request returning *GetChannelEditorsHTTPResponse

/*
	Gets the broadcasters list editors.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:editors** scope.
*/
func (c *ClientWithResponses) GetChannelEditorsWithResponse(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (r *GetChannelEditorsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelEditorsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelEditors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelEditorsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetFollowedChannelsWithResponse request returning *GetFollowedChannelsHTTPResponse

/*
	Gets a list of broadcasters that the specified user follows. You can also use this endpoint to see whether a user follows a specific broadcaster.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:follows** scope.
*/
func (c *ClientWithResponses) GetFollowedChannelsWithResponse(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (r *GetFollowedChannelsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetFollowedChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetFollowedChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetFollowedChannelsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelFollowersWithResponse request returning *GetChannelFollowersHTTPResponse

/*
	Gets a list of users that follow the specified broadcaster. You can also use this endpoint to see whether a specific user follows the broadcaster.

__Authorization:__

* Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:followers** scope.
* The ID in the broadcaster\_id query parameter must match the user ID in the access token or the user ID in the access token must be a moderator for the specified broadcaster.

This endpoint will return specific follower information only if both of the above are true. If a scope is not provided or the user isnt the broadcaster or a moderator for the specified channel, only the total follower count will be included in the response.
*/
func (c *ClientWithResponses) GetChannelFollowersWithResponse(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (r *GetChannelFollowersHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelFollowersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelFollowers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelFollowersHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// RemoveChannelVipWithResponse request returning *RemoveChannelVipHTTPResponse

/*
	Removes the specified user as a VIP in the broadcasters channel.

If the broadcaster is removing the users VIP status, the ID in the _broadcaster\_id_ query parameter must match the user ID in the access token; otherwise, if the user is removing their VIP status themselves, the ID in the _user\_id_ query parameter must match the user ID in the access token.

**Rate Limits**: The broadcaster may remove a maximum of 10 VIPs within a 10-second window.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
*/
func (c *ClientWithResponses) RemoveChannelVipWithResponse(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (r *RemoveChannelVipHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "RemoveChannelVipWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.RemoveChannelVip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseRemoveChannelVipHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetVipsWithResponse request returning *GetVipsHTTPResponse

/*
	Gets a list of the broadcasters VIPs.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:vips** scope. If your app also adds and removes VIP status, you can use the **channel:manage:vips** scope instead.
*/
func (c *ClientWithResponses) GetVipsWithResponse(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (r *GetVipsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetVipsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetVips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetVipsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AddChannelVipWithResponse request returning *AddChannelVipHTTPResponse

/*
	Adds the specified user as a VIP in the broadcasters channel.

**Rate Limits**: The broadcaster may add a maximum of 10 VIPs within a 10-second window.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:vips** scope.
*/
func (c *ClientWithResponses) AddChannelVipWithResponse(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (r *AddChannelVipHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddChannelVipWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddChannelVip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddChannelVipHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCharityCampaignWithResponse request returning *GetCharityCampaignHTTPResponse

/*
	Gets information about the charity campaign that a broadcaster is running. For example, the campaigns fundraising goal and the current amount of donations.

To receive events when progress is made towards the campaigns goal or the broadcaster changes the fundraising goal, subscribe to the [channel.charity\_campaign.progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelcharity%5Fcampaignprogress) subscription type.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:charity** scope.
*/
func (c *ClientWithResponses) GetCharityCampaignWithResponse(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (r *GetCharityCampaignHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCharityCampaignWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCharityCampaign(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCharityCampaignHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCharityCampaignDonationsWithResponse request returning *GetCharityCampaignDonationsHTTPResponse

/*
	Gets the list of donations that users have made to the broadcasters active charity campaign.

To receive events as donations occur, subscribe to the [channel.charity\_campaign.donate](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelcharity%5Fcampaigndonate) subscription type.

__Authorization:__

Requires a user access token that includes the **channel:read:charity** scope.
*/
func (c *ClientWithResponses) GetCharityCampaignDonationsWithResponse(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (r *GetCharityCampaignDonationsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCharityCampaignDonationsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCharityCampaignDonations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCharityCampaignDonationsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendChatAnnouncementWithBodyWithResponse request with arbitrary body returning *SendChatAnnouncementHTTPResponse

/*
	Sends an announcement to the broadcasters chat room.

**Rate Limits**: One announcement may be sent every 2 seconds.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
*/
func (c *ClientWithResponses) SendChatAnnouncementWithBodyWithResponse(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendChatAnnouncementHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatAnnouncementWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatAnnouncementWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatAnnouncementHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Sends an announcement to the broadcasters chat room.

**Rate Limits**: One announcement may be sent every 2 seconds.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:announcements** scope.
*/
func (c *ClientWithResponses) SendChatAnnouncementWithResponse(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendChatAnnouncementHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatAnnouncementWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatAnnouncement(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatAnnouncementHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelChatBadgesWithResponse request returning *GetChannelChatBadgesHTTPResponse

/*
	Gets the broadcasters list of custom chat badges. The list is empty if the broadcaster hasnt created custom chat badges. For information about custom badges, see [subscriber badges](https://help.twitch.tv/s/article/subscriber-badge-guide) and [Bits badges](https://help.twitch.tv/s/article/custom-bit-badges-guide).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetChannelChatBadgesWithResponse(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (r *GetChannelChatBadgesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelChatBadgesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelChatBadges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelChatBadgesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGlobalChatBadgesWithResponse request returning *GetGlobalChatBadgesHTTPResponse

/*
	Gets Twitchs list of chat badges, which users may use in any channels chat room. For information about chat badges, see [Twitch Chat Badges Guide](https://help.twitch.tv/s/article/twitch-chat-badges-guide).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

__Request Query Parameters:__

None
*/
func (c *ClientWithResponses) GetGlobalChatBadgesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetGlobalChatBadgesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGlobalChatBadgesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGlobalChatBadges(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGlobalChatBadgesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChattersWithResponse request returning *GetChattersHTTPResponse

/*
	Gets the list of users that are connected to the broadcasters chat session.

**NOTE**: There is a delay between when users join and leave a chat and when the list is updated accordingly.

To determine whether a user is a moderator or VIP, use the [Get Moderators](https://dev.twitch.tv/docs/api/reference#get-moderators) and [Get VIPs](https://dev.twitch.tv/docs/api/reference#get-vips) endpoints. You can check the roles of up to 100 users.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:chatters** scope.
*/
func (c *ClientWithResponses) GetChattersWithResponse(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (r *GetChattersHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChattersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChatters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChattersHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserChatColorWithResponse request returning *GetUserChatColorHTTPResponse

/*
	Gets the color used for the users name in chat.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetUserChatColorWithResponse(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (r *GetUserChatColorHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserChatColorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserChatColor(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserChatColorHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateUserChatColorWithResponse request returning *UpdateUserChatColorHTTPResponse

/*
	Updates the color used for the users name in chat.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:chat\_color** scope.
*/
func (c *ClientWithResponses) UpdateUserChatColorWithResponse(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (r *UpdateUserChatColorHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserChatColorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUserChatColor(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserChatColorHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelEmotesWithResponse request returning *GetChannelEmotesHTTPResponse

/*
	Gets the broadcasters list of custom emotes. Broadcasters create these custom emotes for users who subscribe to or follow the channel or cheer Bits in the channels chat window. [Learn More](https://dev.twitch.tv/docs/irc/emotes)

For information about the custom emotes, see [subscriber emotes](https://help.twitch.tv/s/article/subscriber-emote-guide), [Bits tier emotes](https://help.twitch.tv/s/article/custom-bit-badges-guide?language=bg#slots), and [follower emotes](https://blog.twitch.tv/en/2021/06/04/kicking-off-10-years-with-our-biggest-emote-update-ever/).

**NOTE:** With the exception of custom follower emotes, users may use custom emotes in any Twitch chat.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetChannelEmotesWithResponse(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (r *GetChannelEmotesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelEmotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelEmotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelEmotesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGlobalEmotesWithResponse request returning *GetGlobalEmotesHTTPResponse

/*
	Gets the list of [global emotes](https://www.twitch.tv/creatorcamp/en/learn-the-basics/emotes/). Global emotes are Twitch-created emotes that users can use in any Twitch chat.

[Learn More](https://dev.twitch.tv/docs/irc/emotes)

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

__Request Query Parameters:__

None
*/
func (c *ClientWithResponses) GetGlobalEmotesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetGlobalEmotesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGlobalEmotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGlobalEmotes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGlobalEmotesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetEmoteSetsWithResponse request returning *GetEmoteSetsHTTPResponse

/*
	Gets emotes for one or more specified emote sets.

An emote set groups emotes that have a similar context. For example, Twitch places all the subscriber emotes that a broadcaster uploads for their channel in the same emote set.

[Learn More](https://dev.twitch.tv/docs/irc/emotes)

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetEmoteSetsWithResponse(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (r *GetEmoteSetsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetEmoteSetsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetEmoteSets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetEmoteSetsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserEmotesWithResponse request returning *GetUserEmotesHTTPResponse

/*
	NEW Retrieves emotes available to the user across all channels.

__Authorization:__

* Requires a user access token that includes the **user:read:emotes** scope.
* Query parameter `user_id` must match the `user_id` in the user access token.
*/
func (c *ClientWithResponses) GetUserEmotesWithResponse(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (r *GetUserEmotesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserEmotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserEmotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserEmotesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendChatMessageWithBodyWithResponse request with arbitrary body returning *SendChatMessageHTTPResponse

/*
	NEW Sends a message to the broadcasters chat room.

**NOTE:** When sending messages to a Shared Chat session, behaviors differ depending on your authentication token type:

* When using an _App Access Token_, messages will only be sent to the source channel (defined by the `broadcaster_id` parameter) by default starting on May 19, 2025\. Messages can be sent to all channels by using the `for_source_only` parameter and setting it to `false`.
* When using a _User Access Token_, messages will be sent to all channels in the shared chat session, including the source channel. This behavior cannot be changed with this token type.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the `user:write:chat` scope. If app access token used, then additionally requires `user:bot` scope from chatting user, and either `channel:bot` scope from broadcaster or moderator status.
*/
func (c *ClientWithResponses) SendChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendChatMessageHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatMessageWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatMessageHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	NEW Sends a message to the broadcasters chat room.

**NOTE:** When sending messages to a Shared Chat session, behaviors differ depending on your authentication token type:

* When using an _App Access Token_, messages will only be sent to the source channel (defined by the `broadcaster_id` parameter) by default starting on May 19, 2025\. Messages can be sent to all channels by using the `for_source_only` parameter and setting it to `false`.
* When using a _User Access Token_, messages will be sent to all channels in the shared chat session, including the source channel. This behavior cannot be changed with this token type.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the `user:write:chat` scope. If app access token used, then additionally requires `user:bot` scope from chatting user, and either `channel:bot` scope from broadcaster or moderator status.
*/
func (c *ClientWithResponses) SendChatMessageWithResponse(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendChatMessageHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatMessageWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatMessageHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChatSettingsWithResponse request returning *GetChatSettingsHTTPResponse

/*
	Gets the broadcasters chat settings.

For an overview of chat settings, see [Chat Commands for Broadcasters and Moderators](https://help.twitch.tv/s/article/chat-commands#AllMods) and [Moderator Preferences](https://help.twitch.tv/s/article/setting-up-moderation-for-your-twitch-channel#modpreferences).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetChatSettingsWithResponse(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (r *GetChatSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChatSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChatSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChatSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChatSettingsWithBodyWithResponse request with arbitrary body returning *UpdateChatSettingsHTTPResponse

/*
	Updates the broadcasters chat settings.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_settings** scope.

__Request Body:__

All fields are optional. Specify only those fields that you want to update.

To set the `slow_mode_wait_time` or `follower_mode_duration` field to its default value, set the corresponding `slow_mode` or `follower_mode` field to **true** (and dont include the `slow_mode_wait_time` or `follower_mode_duration` field).

To set the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, you must set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **true**.

To remove the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **false** (and dont include the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
*/
func (c *ClientWithResponses) UpdateChatSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateChatSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChatSettingsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChatSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChatSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates the broadcasters chat settings.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_settings** scope.

__Request Body:__

All fields are optional. Specify only those fields that you want to update.

To set the `slow_mode_wait_time` or `follower_mode_duration` field to its default value, set the corresponding `slow_mode` or `follower_mode` field to **true** (and dont include the `slow_mode_wait_time` or `follower_mode_duration` field).

To set the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, you must set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **true**.

To remove the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` fields value, set the corresponding `slow_mode`, `follower_mode`, or `non_moderator_chat_delay` field to **false** (and dont include the `slow_mode_wait_time`, `follower_mode_duration`, or `non_moderator_chat_delay_duration` field).
*/
func (c *ClientWithResponses) UpdateChatSettingsWithResponse(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateChatSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChatSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChatSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChatSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendAShoutoutWithResponse request returning *SendAShoutoutHTTPResponse

/*
	Sends a Shoutout to the specified broadcaster. Typically, you send Shoutouts when you or one of your moderators notice another broadcaster in your chat, the other broadcaster is coming up in conversation, or after they raid your broadcast.

Twitchs Shoutout feature is a great way for you to show support for other broadcasters and help them grow. Viewers who do not follow the other broadcaster will see a pop-up Follow button in your chat that they can click to follow the other broadcaster. [Learn More](https://help.twitch.tv/s/article/shoutouts)

**Rate Limits**: The broadcaster may send a Shoutout once every 2 minutes. They may send the same broadcaster a Shoutout once every 60 minutes.

To receive notifications when a Shoutout is sent or received, subscribe to the [channel.shoutout.create](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutcreate) and [channel.shoutout.receive](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshoutoutreceive) subscription types. The **channel.shoutout.create** event includes cooldown periods that indicate when the broadcaster may send another Shoutout without exceeding the endpoints rate limit.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shoutouts** scope.
*/
func (c *ClientWithResponses) SendAShoutoutWithResponse(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (r *SendAShoutoutHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendAShoutoutWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendAShoutout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendAShoutoutHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetClipsWithResponse request returning *GetClipsHTTPResponse

/*
	Gets one or more video clips that were captured from streams. For information about clips, see [How to use clips](https://help.twitch.tv/s/article/how-to-use-clips).

When using pagination for clips, note that the maximum number of results returned over multiple requests will be approximately 1,000\. If additional results are necessary, paginate over different query parameters such as multiple `started_at` and `ended_at` timeframes to refine the search.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).

__Request Query Parameters:__

The _id_, _game\_id_, and _broadcaster\_id_ query parameters are mutually exclusive.
*/
func (c *ClientWithResponses) GetClipsWithResponse(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (r *GetClipsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetClipsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetClips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetClipsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateClipWithResponse request returning *CreateClipHTTPResponse

/*
	Creates a clip from the broadcasters stream.

This API captures up to 90 seconds of the broadcasters stream. The 90 seconds spans the point in the stream from when you called the API. For example, if you call the API at the 4:00 minute mark, the API captures from approximately the 3:35 mark to approximately the 4:05 minute mark. Twitch tries its best to capture 90 seconds of the stream, but the actual length may be less. This may occur if you begin capturing the clip near the beginning or end of the stream.

By default, Twitch publishes up to the last 30 seconds of the 90 seconds window and provides a default title for the clip. To specify the title and the portion of the 90 seconds window thats used for the clip, use the URL in the responses `edit_url` field. You can specify a clip thats from 5 seconds to 60 seconds in length. The URL is valid for up to 24 hours or until the clip is published, whichever comes first.

Creating a clip is an asynchronous process that can take a short amount of time to complete. To determine whether the clip was successfully created, call [Get Clips](https://dev.twitch.tv/docs/api/reference#get-clips) using the clip ID that this request returned. If Get Clips returns the clip, the clip was successfully created. If after 15 seconds Get Clips hasnt returned the clip, assume it failed.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **clips:edit** scope.
*/
func (c *ClientWithResponses) CreateClipWithResponse(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (r *CreateClipHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateClipWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateClip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateClipHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetContentClassificationLabelsWithResponse request returning *GetContentClassificationLabelsHTTPResponse

/*
	Gets information about Twitch content classification labels.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetContentClassificationLabelsWithResponse(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (r *GetContentClassificationLabelsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetContentClassificationLabelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetContentClassificationLabels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetContentClassificationLabelsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetDropsEntitlementsWithResponse request returning *GetDropsEntitlementsHTTPResponse

/*
	Gets an organizations list of entitlements that have been granted to a game, a user, or both.

**NOTE:** Entitlements returned in the response body data are not guaranteed to be sorted by any field returned by the API. To retrieve **CLAIMED** or **FULFILLED** entitlements, use the `fulfillment_status` query parameter to filter results. To retrieve entitlements for a specific game, use the `game_id` query parameter to filter results.

The following table identifies the request parameters that you may specify based on the type of access token used.

| Access token type | Parameter | Description |
| - | - | - |
| App | None | If you dont specify request parameters, the request returns all entitlements that your organization owns. |
| App | user_id | The request returns all entitlements for any game that the organization granted to the specified user. |
| App | user_id, game_id | The request returns all entitlements that the specified game granted to the specified user. |
| App | game_id | The request returns all entitlements that the specified game granted to all entitled users. |
| User | None | If you dont specify request parameters, the request returns all entitlements for any game that the organization granted to the user identified in the access token. |
| User | user_id | Invalid. |
| User | user_id, game_id | Invalid. |
| User | game_id | The request returns all entitlements that the specified game granted to the user identified in the access token. |

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
*/
func (c *ClientWithResponses) GetDropsEntitlementsWithResponse(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (r *GetDropsEntitlementsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetDropsEntitlementsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetDropsEntitlements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetDropsEntitlementsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateDropsEntitlementsWithBodyWithResponse request with arbitrary body returning *UpdateDropsEntitlementsHTTPResponse

/*
	Updates the Drop entitlements fulfillment status.

The following table identifies which entitlements are updated based on the type of access token used.

| Access token type | Data thats updated |
| - | - |
| App | Updates all entitlements with benefits owned by the organization in the access token. |
| User | Updates all entitlements owned by the user in the access token and where the benefits are owned by the organization in the access token. |

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
*/
func (c *ClientWithResponses) UpdateDropsEntitlementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateDropsEntitlementsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateDropsEntitlementsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateDropsEntitlementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateDropsEntitlementsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates the Drop entitlements fulfillment status.

The following table identifies which entitlements are updated based on the type of access token used.

| Access token type | Data thats updated |
| - | - |
| App | Updates all entitlements with benefits owned by the organization in the access token. |
| User | Updates all entitlements owned by the user in the access token and where the benefits are owned by the organization in the access token. |

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens). The Client ID associated with the access token must be owned by a user who is a member of the [organization](https://dev.twitch.tv/docs/docs/companies/) that holds ownership of the game.
*/
func (c *ClientWithResponses) UpdateDropsEntitlementsWithResponse(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateDropsEntitlementsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateDropsEntitlementsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateDropsEntitlements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateDropsEntitlementsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteConduitWithResponse request returning *DeleteConduitHTTPResponse

/*
	NEW Deletes a specified [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/). Note that it may take some time for Eventsub subscriptions on a deleted [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to show as disabled when calling [Get Eventsub Subscriptions](https://dev.twitch.tv/docs/api/reference/#get-eventsub-subscriptions).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) DeleteConduitWithResponse(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (r *DeleteConduitHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteConduitWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteConduit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteConduitHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetConduitsWithResponse request returning *GetConduitsHTTPResponse

/*
	NEW Gets the [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) for a client ID.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) GetConduitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetConduitsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetConduitsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetConduits(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetConduitsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateConduitsWithBodyWithResponse request with arbitrary body returning *UpdateConduitsHTTPResponse

/*
	NEW Updates a [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) shard count. To delete shards, update the count to a lower number, and the shards above the count will be deleted. For example, if the existing shard count is 100, by resetting shard count to 50, shards 50-99 are disabled.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) UpdateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateConduitsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduitsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	NEW Updates a [conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) shard count. To delete shards, update the count to a lower number, and the shards above the count will be deleted. For example, if the existing shard count is 100, by resetting shard count to 50, shards 50-99 are disabled.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) UpdateConduitsWithResponse(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateConduitsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateConduitsWithBodyWithResponse request with arbitrary body returning *CreateConduitsHTTPResponse

/*
	NEW Creates a new [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) CreateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateConduitsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateConduitsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateConduitsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateConduitsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	NEW Creates a new [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) CreateConduitsWithResponse(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateConduitsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateConduitsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateConduits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateConduitsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetConduitShardsWithResponse request returning *GetConduitShardsHTTPResponse

/*
	NEW Gets a lists of all shards for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) GetConduitShardsWithResponse(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (r *GetConduitShardsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetConduitShardsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetConduitShards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetConduitShardsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateConduitShardsWithBodyWithResponse request with arbitrary body returning *UpdateConduitShardsHTTPResponse

/*
	NEW Updates shard(s) for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

**NOTE:** Shard IDs are indexed starting at 0, so a conduit with a `shard_count` of 5 will have shards with IDs 0 through 4.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) UpdateConduitShardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateConduitShardsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitShardsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduitShardsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitShardsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	NEW Updates shard(s) for a [conduit](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/).

**NOTE:** Shard IDs are indexed starting at 0, so a conduit with a `shard_count` of 5 will have shards with IDs 0 through 4.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) UpdateConduitShardsWithResponse(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateConduitShardsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitShardsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduitShards(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitShardsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteEventsubSubscriptionWithResponse request returning *DeleteEventsubSubscriptionHTTPResponse

/*
	Deletes an EventSub subscription.

__Authorization:__

If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token.

If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.
*/
func (c *ClientWithResponses) DeleteEventsubSubscriptionWithResponse(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (r *DeleteEventsubSubscriptionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteEventsubSubscriptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteEventsubSubscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteEventsubSubscriptionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetEventsubSubscriptionsWithResponse request returning *GetEventsubSubscriptionsHTTPResponse

/*
	Gets a list of EventSub subscriptions that the client in the access token created.

__Authorization:__

If you use [Webhooks](https://dev.twitch.tv/docs/eventsub/handling-webhook-events) or [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.

If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. The token may include any scopes.

__Request Query Parameters:__

Use the _status_, _type_, _user\_id_, and _subscription\_id_ query parameters to filter the list of subscriptions that are returned. The filters are mutually exclusive; the request fails if you specify more than one filter.
*/
func (c *ClientWithResponses) GetEventsubSubscriptionsWithResponse(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (r *GetEventsubSubscriptionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetEventsubSubscriptionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetEventsubSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetEventsubSubscriptionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateEventsubSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateEventsubSubscriptionHTTPResponse

/*
	Creates an EventSub subscription.

__Authorization:__

If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the `channel:read:subscriptions` scope, which adds the required permission to your app access tokens client ID.

If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesnt include user authorization, the token may include any scopes or no scopes.

If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
*/
func (c *ClientWithResponses) CreateEventsubSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateEventsubSubscriptionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateEventsubSubscriptionWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateEventsubSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateEventsubSubscriptionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Creates an EventSub subscription.

__Authorization:__

If you use [webhooks to receive events](https://dev.twitch.tv/docs/eventsub/handling-webhook-events), the request must specify an app access token. The request will fail if you use a user access token. If the subscription type requires user authorization, the user must have granted your app (client ID) permissions to receive those events before you subscribe to them. For example, to subscribe to [channel.subscribe](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types/#channelsubscribe) events, your app must get a user access token that includes the `channel:read:subscriptions` scope, which adds the required permission to your app access tokens client ID.

If you use [WebSockets to receive events](https://dev.twitch.tv/docs/eventsub/handling-websocket-events), the request must specify a user access token. The request will fail if you use an app access token. If the subscription type requires user authorization, the token must include the required scope. However, if the subscription type doesnt include user authorization, the token may include any scopes or no scopes.

If you use [Conduits](https://dev.twitch.tv/docs/eventsub/handling-conduit-events/) to receive events, the request must specify an app access token. The request will fail if you use a user access token.
*/
func (c *ClientWithResponses) CreateEventsubSubscriptionWithResponse(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateEventsubSubscriptionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateEventsubSubscriptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateEventsubSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateEventsubSubscriptionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionsWithResponse request returning *GetExtensionsHTTPResponse

/*
	Gets information about an extension.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` field (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)), and the `role` field must be set to _external_.
*/
func (c *ClientWithResponses) GetExtensionsWithResponse(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (r *GetExtensionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendExtensionChatMessageWithBodyWithResponse request with arbitrary body returning *SendExtensionChatMessageHTTPResponse

/*
	Sends a message to the specified broadcasters chat room. The extensions name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extensions **Capabilities** tab).

**Rate Limits**: You may send a maximum of 12 messages per minute per channel.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` and `user_id` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) SendExtensionChatMessageWithBodyWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendExtensionChatMessageHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionChatMessageWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionChatMessageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionChatMessageHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Sends a message to the specified broadcasters chat room. The extensions name is used as the username for the message in the chat room. To send a chat message, your extension must enable **Chat Capabilities** (under your extensions **Capabilities** tab).

**Rate Limits**: You may send a maximum of 12 messages per minute per channel.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role` and `user_id` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) SendExtensionChatMessageWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendExtensionChatMessageHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionChatMessageWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionChatMessage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionChatMessageHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionConfigurationSegmentWithResponse request returning *GetExtensionConfigurationSegmentHTTPResponse

/*
	Gets the specified configuration segment from the specified extension.

**Rate Limits**: You may retrieve each segment a maximum of 20 times per minute.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) GetExtensionConfigurationSegmentWithResponse(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (r *GetExtensionConfigurationSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionConfigurationSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionConfigurationSegment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionConfigurationSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SetExtensionConfigurationSegmentWithBodyWithResponse request with arbitrary body returning *SetExtensionConfigurationSegmentHTTPResponse

/*
	Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.

**Rate Limits**: You may update the configuration a maximum of 20 times per minute.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) SetExtensionConfigurationSegmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SetExtensionConfigurationSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionConfigurationSegmentWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionConfigurationSegmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionConfigurationSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates a configuration segment. The segment is limited to 5 KB. Extensions that are active on a channel do not receive the updated configuration.

**Rate Limits**: You may update the configuration a maximum of 20 times per minute.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) SetExtensionConfigurationSegmentWithResponse(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (r *SetExtensionConfigurationSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionConfigurationSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionConfigurationSegment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionConfigurationSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionSecretsWithResponse request returning *GetExtensionSecretsHTTPResponse

/*
	Gets an extensions list of shared secrets.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) GetExtensionSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetExtensionSecretsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionSecretsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionSecrets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionSecretsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateExtensionSecretWithResponse request returning *CreateExtensionSecretHTTPResponse

/*
	Creates a shared secret used to sign and verify JWT tokens. Creating a new secret removes the current secrets from service. Use this function only when you are ready to use the new secret it returns.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). The `role` field must be set to _external_.
*/
func (c *ClientWithResponses) CreateExtensionSecretWithResponse(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (r *CreateExtensionSecretHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateExtensionSecretWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateExtensionSecret(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateExtensionSecretHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionLiveChannelsWithResponse request returning *GetExtensionLiveChannelsHTTPResponse

/*
	Gets a list of broadcasters that are streaming live and have installed or activated the extension.

It may take a few minutes for the list to include or remove broadcasters that have recently gone live or stopped broadcasting.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetExtensionLiveChannelsWithResponse(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (r *GetExtensionLiveChannelsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionLiveChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionLiveChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionLiveChannelsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendExtensionPubsubMessageWithBodyWithResponse request with arbitrary body returning *SendExtensionPubsubMessageHTTPResponse

/*
	Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.

**Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the `channel_id` and `pubsub_perms` fields. The `role` field must be set to _external_.

To send the message to a specific channel, set the `channel_id` field in the JWT to the channels ID and set the `pubsub_perms.send` array to _broadcast_.

```

	{
	  "exp": 1503343947,
	  "user_id": "27419011",
	  "role": "external",
	  "channel_id": "27419011",
	  "pubsub_perms": {
	    "send":[
	      "broadcast"
	    ]
	  }
	}

```

To send the message to all channels on which your extension is active, set the `channel_id` field to _all_ and set the `pubsub_perms.send` array to _global_.

```

	{
	  "exp": 1503343947,
	  "user_id": "27419011",
	  "role": "external",
	  "channel_id": "all",
	  "pubsub_perms": {
	    "send":[
	      "global"
	    ]
	  }
	}

```
*/
func (c *ClientWithResponses) SendExtensionPubsubMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendExtensionPubsubMessageHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionPubsubMessageWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionPubsubMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionPubsubMessageHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Sends a message to one or more viewers. You can send messages to a specific channel or to all channels where your extension is active. This endpoint uses the same mechanism as the [send](https://dev.twitch.tv/docs/extensions/reference#send) JavaScript helper function used to send messages.

**Rate Limits**: You may send a maximum of 100 messages per minute per combination of extension client ID and broadcaster ID.

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an Extension Backend Service (EBS). For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)) along with the `channel_id` and `pubsub_perms` fields. The `role` field must be set to _external_.

To send the message to a specific channel, set the `channel_id` field in the JWT to the channels ID and set the `pubsub_perms.send` array to _broadcast_.

```

	{
	  "exp": 1503343947,
	  "user_id": "27419011",
	  "role": "external",
	  "channel_id": "27419011",
	  "pubsub_perms": {
	    "send":[
	      "broadcast"
	    ]
	  }
	}

```

To send the message to all channels on which your extension is active, set the `channel_id` field to _all_ and set the `pubsub_perms.send` array to _global_.

```

	{
	  "exp": 1503343947,
	  "user_id": "27419011",
	  "role": "external",
	  "channel_id": "all",
	  "pubsub_perms": {
	    "send":[
	      "global"
	    ]
	  }
	}

```
*/
func (c *ClientWithResponses) SendExtensionPubsubMessageWithResponse(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendExtensionPubsubMessageHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionPubsubMessageWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionPubsubMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionPubsubMessageHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetReleasedExtensionsWithResponse request returning *GetReleasedExtensionsHTTPResponse

/*
	Gets information about a released extension. Returns the extension if its `state` is Released.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetReleasedExtensionsWithResponse(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (r *GetReleasedExtensionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetReleasedExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetReleasedExtensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetReleasedExtensionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SetExtensionRequiredConfigurationWithBodyWithResponse request with arbitrary body returning *SetExtensionRequiredConfigurationHTTPResponse

/*
	Updates the extensions required\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the `role` field to _external_ and the `user_id` field to the ID of the user that owns the extension.
*/
func (c *ClientWithResponses) SetExtensionRequiredConfigurationWithBodyWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SetExtensionRequiredConfigurationHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionRequiredConfigurationWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionRequiredConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionRequiredConfigurationHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates the extensions required\_configuration string. Use this endpoint if your extension requires the broadcaster to configure the extension before activating it (to require configuration, you must select **Custom/My Own Service** in Extension [Capabilities](https://dev.twitch.tv/docs/extensions/life-cycle/#capabilities)). For more information, see [Required Configurations](https://dev.twitch.tv/docs/extensions/building#required-configurations) and [Setting Required Configuration](https://dev.twitch.tv/docs/extensions/building#setting-required-configuration-with-the-configuration-service-optional).

__Authorization:__

Requires a signed JSON Web Token (JWT) created by an EBS. For signing requirements, see [Signing the JWT](https://dev.twitch.tv/docs/extensions/building/#signing-the-jwt). The signed JWT must include the `role`, `user_id`, and `exp` fields (see [JWT Schema](https://dev.twitch.tv/docs/extensions/reference/#jwt-schema)). Set the `role` field to _external_ and the `user_id` field to the ID of the user that owns the extension.
*/
func (c *ClientWithResponses) SetExtensionRequiredConfigurationWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (r *SetExtensionRequiredConfigurationHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionRequiredConfigurationWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionRequiredConfiguration(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionRequiredConfigurationHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionTransactionsWithResponse request returning *GetExtensionTransactionsHTTPResponse

/*
	Gets an extensions list of transactions. A transaction records the exchange of a currency (for example, Bits) for a digital product.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens).
*/
func (c *ClientWithResponses) GetExtensionTransactionsWithResponse(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (r *GetExtensionTransactionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionTransactionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionTransactionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGamesWithResponse request returning *GetGamesHTTPResponse

/*
	Gets information about specified categories or games.

You may get up to 100 categories or games by specifying their ID or name. You may specify all IDs, all names, or a combination of IDs and names. If you specify a combination of IDs and names, the total number of IDs and names must not exceed 100.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetGamesWithResponse(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (r *GetGamesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGamesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGames(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGamesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetTopGamesWithResponse request returning *GetTopGamesHTTPResponse

/*
	Gets information about all broadcasts on Twitch.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetTopGamesWithResponse(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (r *GetTopGamesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetTopGamesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetTopGames(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetTopGamesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCreatorGoalsWithResponse request returning *GetCreatorGoalsHTTPResponse

/*
	Gets the broadcasters list of active goals. Use this endpoint to get the current progress of each goal.

Instead of polling for the progress of a goal, consider [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to receive notifications when a goal makes progress using the [channel.goal.progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelgoalprogress) subscription type. [Read More](https://dev.twitch.tv/docs/api/goals#requesting-event-notifications)

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:goals** scope.
*/
func (c *ClientWithResponses) GetCreatorGoalsWithResponse(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (r *GetCreatorGoalsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCreatorGoalsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCreatorGoals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCreatorGoalsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelGuestStarSettingsWithResponse request returning *GetChannelGuestStarSettingsHTTPResponse

/*
	BETA Gets the channel settings for configuration of the Guest Star feature for a particular host.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) GetChannelGuestStarSettingsWithResponse(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (r *GetChannelGuestStarSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelGuestStarSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelGuestStarSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelGuestStarSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChannelGuestStarSettingsWithBodyWithResponse request with arbitrary body returning *UpdateChannelGuestStarSettingsHTTPResponse

/*
	BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.

__Authorization:__

* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star`
*/
func (c *ClientWithResponses) UpdateChannelGuestStarSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateChannelGuestStarSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelGuestStarSettingsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelGuestStarSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelGuestStarSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.

__Authorization:__

* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star`
*/
func (c *ClientWithResponses) UpdateChannelGuestStarSettingsWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateChannelGuestStarSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelGuestStarSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelGuestStarSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelGuestStarSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteGuestStarInviteWithResponse request returning *DeleteGuestStarInviteHTTPResponse

/*
	BETA Revokes a previously sent invite for a Guest Star session.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) DeleteGuestStarInviteWithResponse(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (r *DeleteGuestStarInviteHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteGuestStarInviteWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteGuestStarInvite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteGuestStarInviteHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGuestStarInvitesWithResponse request returning *GetGuestStarInvitesHTTPResponse

/*
	BETA Provides the caller with a list of pending invites to a Guest Star session, including the invitees ready status while joining the waiting room.

__Authorization:__

* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) GetGuestStarInvitesWithResponse(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (r *GetGuestStarInvitesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGuestStarInvitesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGuestStarInvites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGuestStarInvitesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendGuestStarInviteWithResponse request returning *SendGuestStarInviteHTTPResponse

/*
	BETA Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) SendGuestStarInviteWithResponse(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (r *SendGuestStarInviteHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendGuestStarInviteWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendGuestStarInvite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendGuestStarInviteHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// EndGuestStarSessionWithResponse request returning *EndGuestStarSessionHTTPResponse

/*
	BETA Programmatically ends a Guest Star session on behalf of the broadcaster. Performs the same action as if the host clicked the End Call button in the Guest Star UI.

__Authorization:__

* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star`
*/
func (c *ClientWithResponses) EndGuestStarSessionWithResponse(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (r *EndGuestStarSessionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndGuestStarSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndGuestStarSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndGuestStarSessionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGuestStarSessionWithResponse request returning *GetGuestStarSessionHTTPResponse

/*
	BETA Gets information about an ongoing Guest Star session for a particular channel.

__Authorization:__

* Requires OAuth Scope: `channel:read:guest_star`, `channel:manage:guest_star`, `moderator:read:guest_star` or `moderator:manage:guest_star`
* Guests must be either invited or assigned a slot within the session
*/
func (c *ClientWithResponses) GetGuestStarSessionWithResponse(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (r *GetGuestStarSessionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGuestStarSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGuestStarSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGuestStarSessionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateGuestStarSessionWithResponse request returning *CreateGuestStarSessionHTTPResponse

/*
	BETA Programmatically creates a Guest Star session on behalf of the broadcaster. Requires the broadcaster to be present in the call interface, or the call will be ended automatically.

__Authorization:__

* Query parameter `broadcaster_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star`
*/
func (c *ClientWithResponses) CreateGuestStarSessionWithResponse(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (r *CreateGuestStarSessionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateGuestStarSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateGuestStarSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateGuestStarSessionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteGuestStarSlotWithResponse request returning *DeleteGuestStarSlotHTTPResponse

/*
	BETA Allows a caller to remove a slot assignment from a user participating in an active Guest Star session. This revokes their access to the session immediately and disables their access to publish or subscribe to media within the session.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) DeleteGuestStarSlotWithResponse(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (r *DeleteGuestStarSlotHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteGuestStarSlotWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteGuestStarSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteGuestStarSlotHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateGuestStarSlotWithResponse request returning *UpdateGuestStarSlotHTTPResponse

/*
	BETA Allows a user to update the assigned slot for a particular user within the active Guest Star session.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) UpdateGuestStarSlotWithResponse(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (r *UpdateGuestStarSlotHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateGuestStarSlotWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateGuestStarSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateGuestStarSlotHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AssignGuestStarSlotWithResponse request returning *AssignGuestStarSlotHTTPResponse

/*
	BETA Allows a previously invited user to be assigned a slot within the active Guest Star session, once that guest has indicated they are ready to join.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) AssignGuestStarSlotWithResponse(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (r *AssignGuestStarSlotHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AssignGuestStarSlotWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AssignGuestStarSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAssignGuestStarSlotHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateGuestStarSlotSettingsWithResponse request returning *UpdateGuestStarSlotSettingsHTTPResponse

/*
	BETA Allows a user to update slot settings for a particular guest within a Guest Star session, such as allowing the user to share audio or video within the call as a host. These settings will be broadcasted to all subscribers which control their view of the guest in that slot. One or more of the optional parameters to this API can be specified at any time.

__Authorization:__

* Query parameter `moderator_id` must match the `user_id` in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `channel:manage:guest_star` or `moderator:manage:guest_star`
*/
func (c *ClientWithResponses) UpdateGuestStarSlotSettingsWithResponse(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (r *UpdateGuestStarSlotSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateGuestStarSlotSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateGuestStarSlotSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateGuestStarSlotSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetHypeTrainEventsWithResponse request returning *GetHypeTrainEventsHTTPResponse

/*
	DEPRECATED Scheduled for removal on December 4, 2025\. Use Get Hype Train Status instead. See [announcement](https://discuss.dev.twitch.com/t/legacy-get-hype-train-events-api-and-eventsub-hype-train-v1-subscription-types-deprecation-and-withdrawal-timeline/64299).

Gets information about the broadcasters current or most recent Hype Train event.

Instead of polling for events, consider [subscribing](https://dev.twitch.tv/docs/eventsub/manage-subscriptions) to Hype Train events ([Begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainbegin), [Progress](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainprogress), [End](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelhype%5Ftrainend)).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:hype\_train** scope.
*/
func (c *ClientWithResponses) GetHypeTrainEventsWithResponse(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (r *GetHypeTrainEventsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetHypeTrainEventsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetHypeTrainEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetHypeTrainEventsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetHypeTrainStatusWithResponse request returning *GetHypeTrainStatusHTTPResponse

/*
	NEW Get the status of a Hype Train for the specified broadcaster.

__Authorization:__

* Requires an [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
* Requires OAuth Scope: `channel:read:hype_train`.
* Requires that `broadcaster_id` and `user_id` match in the User-Access token.
*/
func (c *ClientWithResponses) GetHypeTrainStatusWithResponse(ctx context.Context, params *GetHypeTrainStatusParams, reqEditors ...RequestEditorFn) (r *GetHypeTrainStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetHypeTrainStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetHypeTrainStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetHypeTrainStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ManageHeldAutomodMessagesWithBodyWithResponse request with arbitrary body returning *ManageHeldAutomodMessagesHTTPResponse

/*
	Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

To get messages that AutoMod is holding for review, subscribe to the **automod-queue.<moderator\_id>.<channel\_id>** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
*/
func (c *ClientWithResponses) ManageHeldAutomodMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *ManageHeldAutomodMessagesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ManageHeldAutomodMessagesWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ManageHeldAutomodMessagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseManageHeldAutomodMessagesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Allow or deny the message that AutoMod flagged for review. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

To get messages that AutoMod is holding for review, subscribe to the **automod-queue.<moderator\_id>.<channel\_id>** [topic](https://dev.twitch.tv/docs/pubsub#topics) using [PubSub](https://dev.twitch.tv/docs/pubsub). PubSub sends a notification to your app when AutoMod holds a message for review.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod** scope.
*/
func (c *ClientWithResponses) ManageHeldAutomodMessagesWithResponse(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (r *ManageHeldAutomodMessagesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ManageHeldAutomodMessagesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ManageHeldAutomodMessages(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseManageHeldAutomodMessagesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetAutomodSettingsWithResponse request returning *GetAutomodSettingsHTTPResponse

/*
	Gets the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:automod\_settings** scope.
*/
func (c *ClientWithResponses) GetAutomodSettingsWithResponse(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (r *GetAutomodSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetAutomodSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetAutomodSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetAutomodSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateAutomodSettingsWithBodyWithResponse request with arbitrary body returning *UpdateAutomodSettingsHTTPResponse

/*
	Updates the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\_settings** scope.

__Request Body:__

Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, youll send a GET request, update the fields you want to change, and pass that object in the PUT request.

You may set either `overall_level` or the individual settings like `aggression`, but not both.

Setting `overall_level` applies default values to the individual settings. However, setting `overall_level` to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set `overall_level` to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).

If `overall_level` is currently set and you update `swearing` to 3, `overall_level` will be set to **null** and all settings other than `swearing` will be set to 0\. The same is true if individual settings are set and you update `overall_level` to 3  all the individual settings are updated to reflect the default level.

Note that if you set all the individual settings to values that match what `overall_level` would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.

Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
*/
func (c *ClientWithResponses) UpdateAutomodSettingsWithBodyWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateAutomodSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateAutomodSettingsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateAutomodSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateAutomodSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates the broadcasters AutoMod settings. The settings are used to automatically block inappropriate or harassing messages from appearing in the broadcasters chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:automod\_settings** scope.

__Request Body:__

Because PUT is an overwrite operation, you must include all the fields that you want set after the operation completes. Typically, youll send a GET request, update the fields you want to change, and pass that object in the PUT request.

You may set either `overall_level` or the individual settings like `aggression`, but not both.

Setting `overall_level` applies default values to the individual settings. However, setting `overall_level` to 4 does not necessarily mean that it applies 4 to all the individual settings. Instead, it applies a set of recommended defaults to the rest of the settings. For example, if you set `overall_level` to 2, Twitch provides some filtering on discrimination and sexual content, but more filtering on hostility (see the first example response).

If `overall_level` is currently set and you update `swearing` to 3, `overall_level` will be set to **null** and all settings other than `swearing` will be set to 0\. The same is true if individual settings are set and you update `overall_level` to 3  all the individual settings are updated to reflect the default level.

Note that if you set all the individual settings to values that match what `overall_level` would have set them to, Twitch changes AutoMod to use the default AutoMod level instead of using the individual settings.

Valid values for all levels are from 0 (no filtering) through 4 (most aggressive filtering). These levels affect how aggressively AutoMod holds back messages for moderators to review before they appear in chat or are denied (not shown).
*/
func (c *ClientWithResponses) UpdateAutomodSettingsWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateAutomodSettingsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateAutomodSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateAutomodSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateAutomodSettingsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBannedUsersWithResponse request returning *GetBannedUsersHTTPResponse

/*
	Gets all users that the broadcaster banned or put in a timeout.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** or **moderator:manage:banned\_users** scope.
*/
func (c *ClientWithResponses) GetBannedUsersWithResponse(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (r *GetBannedUsersHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBannedUsersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBannedUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBannedUsersHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UnbanUserWithResponse request returning *UnbanUserHTTPResponse

/*
	Removes the ban or timeout that was placed on the specified user.

To ban a user, see [Ban user](https://dev.twitch.tv/docs/api/reference#ban-user).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
*/
func (c *ClientWithResponses) UnbanUserWithResponse(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (r *UnbanUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UnbanUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UnbanUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUnbanUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// BanUserWithBodyWithResponse request with arbitrary body returning *BanUserHTTPResponse

/*
	Bans a user from participating in the specified broadcasters chat room or puts them in a timeout.

For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).

If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.

To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
*/
func (c *ClientWithResponses) BanUserWithBodyWithResponse(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *BanUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "BanUserWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.BanUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseBanUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Bans a user from participating in the specified broadcasters chat room or puts them in a timeout.

For information about banning or putting users in a timeout, see [Ban a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheBanFeature) and [Timeout a User](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat#TheTimeoutFeature).

If the user is currently in a timeout, you can call this endpoint to change the duration of the timeout or ban them altogether. If the user is currently banned, you cannot call this method to put them in a timeout instead.

To remove a ban or end a timeout, see [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:banned\_users** scope.
*/
func (c *ClientWithResponses) BanUserWithResponse(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (r *BanUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "BanUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.BanUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseBanUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// RemoveBlockedTermWithResponse request returning *RemoveBlockedTermHTTPResponse

/*
	Removes the word or phrase from the broadcasters list of blocked terms.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
*/
func (c *ClientWithResponses) RemoveBlockedTermWithResponse(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (r *RemoveBlockedTermHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "RemoveBlockedTermWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.RemoveBlockedTerm(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseRemoveBlockedTermHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBlockedTermsWithResponse request returning *GetBlockedTermsHTTPResponse

/*
	Gets the broadcasters list of non-private, blocked words or phrases. These are the terms that the broadcaster or moderator added manually or that were denied by AutoMod.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:blocked\_terms** or **moderator:manage:blocked\_terms** scope.
*/
func (c *ClientWithResponses) GetBlockedTermsWithResponse(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (r *GetBlockedTermsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBlockedTermsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBlockedTerms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBlockedTermsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AddBlockedTermWithBodyWithResponse request with arbitrary body returning *AddBlockedTermHTTPResponse

/*
	Adds a word or phrase to the broadcasters list of blocked terms. These are the terms that the broadcaster doesnt want used in their chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
*/
func (c *ClientWithResponses) AddBlockedTermWithBodyWithResponse(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *AddBlockedTermHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddBlockedTermWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddBlockedTermWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddBlockedTermHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Adds a word or phrase to the broadcasters list of blocked terms. These are the terms that the broadcaster doesnt want used in their chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:blocked\_terms** scope.
*/
func (c *ClientWithResponses) AddBlockedTermWithResponse(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (r *AddBlockedTermHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddBlockedTermWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddBlockedTerm(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddBlockedTermHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetModeratedChannelsWithResponse request returning *GetModeratedChannelsHTTPResponse

/*
	Gets a list of channels that the specified user has moderator privileges in.

__Authorization:__

* Query parameter `user_id` must match the user ID in the [User-Access token](https://dev.twitch.tv/docs/authentication#user-access-tokens)
* Requires OAuth Scope: `user:read:moderated_channels`
*/
func (c *ClientWithResponses) GetModeratedChannelsWithResponse(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (r *GetModeratedChannelsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetModeratedChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetModeratedChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetModeratedChannelsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteChatMessagesWithResponse request returning *DeleteChatMessagesHTTPResponse

/*
	Removes a single chat message or all chat messages from the broadcasters chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:chat\_messages** scope.
*/
func (c *ClientWithResponses) DeleteChatMessagesWithResponse(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (r *DeleteChatMessagesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteChatMessagesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteChatMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteChatMessagesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CheckAutomodStatusWithBodyWithResponse request with arbitrary body returning *CheckAutomodStatusHTTPResponse

/*
	Checks whether AutoMod would flag the specified message for review.

AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

**Rate Limits**: Rates are limited per channel based on the account type rather than per access token.

| Account type | Limit per minute | Limit per hour |
| - | - | - |
| Normal | 5 | 50 |
| Affiliate | 10 | 100 |
| Partner | 30 | 300 |

The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
*/
func (c *ClientWithResponses) CheckAutomodStatusWithBodyWithResponse(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CheckAutomodStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CheckAutomodStatusWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CheckAutomodStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCheckAutomodStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Checks whether AutoMod would flag the specified message for review.

AutoMod is a moderation tool that holds inappropriate or harassing chat messages for moderators to review. Moderators approve or deny the messages that AutoMod flags; only approved messages are released to chat. AutoMod detects misspellings and evasive language automatically. For information about AutoMod, see [How to Use AutoMod](https://help.twitch.tv/s/article/how-to-use-automod).

**Rate Limits**: Rates are limited per channel based on the account type rather than per access token.

| Account type | Limit per minute | Limit per hour |
| - | - | - |
| Normal | 5 | 50 |
| Affiliate | 10 | 100 |
| Partner | 30 | 300 |

The above limits are in addition to the standard [Twitch API rate limits](https://dev.twitch.tv/docs/api/guide#twitch-rate-limits). The rate limit headers in the response represent the Twitch rate limits and not the above limits.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope.
*/
func (c *ClientWithResponses) CheckAutomodStatusWithResponse(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (r *CheckAutomodStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CheckAutomodStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CheckAutomodStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCheckAutomodStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// RemoveChannelModeratorWithResponse request returning *RemoveChannelModeratorHTTPResponse

/*
	Removes a moderator from the broadcasters chat room.

**Rate Limits**: The broadcaster may remove a maximum of 10 moderators within a 10-second window.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
*/
func (c *ClientWithResponses) RemoveChannelModeratorWithResponse(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (r *RemoveChannelModeratorHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "RemoveChannelModeratorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.RemoveChannelModerator(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseRemoveChannelModeratorHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetModeratorsWithResponse request returning *GetModeratorsHTTPResponse

/*
	Gets all users allowed to moderate the broadcasters chat room.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderation:read** scope. If your app also adds and removes moderators, you can use the **channel:manage:moderators** scope instead.
*/
func (c *ClientWithResponses) GetModeratorsWithResponse(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (r *GetModeratorsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetModeratorsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetModerators(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetModeratorsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AddChannelModeratorWithResponse request returning *AddChannelModeratorHTTPResponse

/*
	Adds a moderator to the broadcasters chat room.

**Rate Limits**: The broadcaster may add a maximum of 10 moderators within a 10-second window.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:moderators** scope.
*/
func (c *ClientWithResponses) AddChannelModeratorWithResponse(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (r *AddChannelModeratorHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddChannelModeratorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddChannelModerator(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddChannelModeratorHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetShieldModeStatusWithResponse request returning *GetShieldModeStatusHTTPResponse

/*
	Gets the broadcasters Shield Mode activation status.

To receive notification when the broadcaster activates and deactivates Shield Mode, subscribe to the [channel.shield\_mode.begin](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodebegin) and [channel.shield\_mode.end](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelshield%5Fmodeend) subscription types.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:read:shield\_mode** or **moderator:manage:shield\_mode** scope.
*/
func (c *ClientWithResponses) GetShieldModeStatusWithResponse(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (r *GetShieldModeStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetShieldModeStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetShieldModeStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetShieldModeStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateShieldModeStatusWithBodyWithResponse request with arbitrary body returning *UpdateShieldModeStatusHTTPResponse

/*
	Activates or deactivates the broadcasters Shield Mode.

Twitchs Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasnt configured Shield Mode, it applies default overrides.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\_mode** scope.
*/
func (c *ClientWithResponses) UpdateShieldModeStatusWithBodyWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateShieldModeStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateShieldModeStatusWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateShieldModeStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateShieldModeStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Activates or deactivates the broadcasters Shield Mode.

Twitchs Shield Mode feature is like a panic button that broadcasters can push to protect themselves from chat abuse coming from one or more accounts. When activated, Shield Mode applies the overrides that the broadcaster configured in the Twitch UX. If the broadcaster hasnt configured Shield Mode, it applies default overrides.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **moderator:manage:shield\_mode** scope.
*/
func (c *ClientWithResponses) UpdateShieldModeStatusWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateShieldModeStatusHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateShieldModeStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateShieldModeStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateShieldModeStatusHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUnbanRequestsWithResponse request returning *GetUnbanRequestsHTTPResponse

/*
	NEW Gets a list of unban requests for a broadcasters channel.

__Authorization:__

* Requires a user access token that includes the **moderator:read:unban\_requests** or **moderator:manage:unban\_requests** scope.
* Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
*/
func (c *ClientWithResponses) GetUnbanRequestsWithResponse(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (r *GetUnbanRequestsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUnbanRequestsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUnbanRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUnbanRequestsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ResolveUnbanRequestsWithResponse request returning *ResolveUnbanRequestsHTTPResponse

/*
	NEW Resolves an unban request by approving or denying it.

__Authorization:__

* Requires a user access token that includes the **moderator:manage:unban\_requests** scope.
* Query parameter `moderator_id` must match the `user_id` in the[user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
*/
func (c *ClientWithResponses) ResolveUnbanRequestsWithResponse(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (r *ResolveUnbanRequestsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ResolveUnbanRequestsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ResolveUnbanRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseResolveUnbanRequestsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// WarnChatUserWithBodyWithResponse request with arbitrary body returning *WarnChatUserHTTPResponse

/*
	NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).

__Authorization:__

Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
*/
func (c *ClientWithResponses) WarnChatUserWithBodyWithResponse(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *WarnChatUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "WarnChatUserWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.WarnChatUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseWarnChatUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged. New warnings can be issued to a user when they already have a warning in the channel (new warning will replace old warning).

__Authorization:__

Requires a user access token that includes the **moderator:manage:warnings** scope. Query parameter `moderator_id` must match the `user_id` in the [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
*/
func (c *ClientWithResponses) WarnChatUserWithResponse(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (r *WarnChatUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "WarnChatUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.WarnChatUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseWarnChatUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetPollsWithResponse request returning *GetPollsHTTPResponse

/*
	Gets a list of polls that the broadcaster created.

Polls are available for 90 days after theyre created.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:polls** or **channel:manage:polls** scope.
*/
func (c *ClientWithResponses) GetPollsWithResponse(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (r *GetPollsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetPollsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetPolls(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetPollsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// EndPollWithBodyWithResponse request with arbitrary body returning *EndPollHTTPResponse

/*
	Ends an active poll. You have the option to end it or end it and archive it.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
*/
func (c *ClientWithResponses) EndPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *EndPollHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPollWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPollHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Ends an active poll. You have the option to end it or end it and archive it.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
*/
func (c *ClientWithResponses) EndPollWithResponse(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (r *EndPollHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPollWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPollHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreatePollWithBodyWithResponse request with arbitrary body returning *CreatePollHTTPResponse

/*
	Creates a poll that viewers in the broadcasters channel can vote on.

The poll begins as soon as its created. You may run only one poll at a time.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
*/
func (c *ClientWithResponses) CreatePollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreatePollHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePollWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePollHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Creates a poll that viewers in the broadcasters channel can vote on.

The poll begins as soon as its created. You may run only one poll at a time.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:polls** scope.
*/
func (c *ClientWithResponses) CreatePollWithResponse(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreatePollHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePollWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePollHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetPredictionsWithResponse request returning *GetPredictionsHTTPResponse

/*
	Gets a list of Channel Points Predictions that the broadcaster created.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:predictions** or **channel:manage:predictions** scope.
*/
func (c *ClientWithResponses) GetPredictionsWithResponse(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (r *GetPredictionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetPredictionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetPredictions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetPredictionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// EndPredictionWithBodyWithResponse request with arbitrary body returning *EndPredictionHTTPResponse

/*
	Locks, resolves, or cancels a Channel Points Prediction.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
*/
func (c *ClientWithResponses) EndPredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *EndPredictionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPredictionWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPredictionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPredictionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Locks, resolves, or cancels a Channel Points Prediction.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
*/
func (c *ClientWithResponses) EndPredictionWithResponse(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (r *EndPredictionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPredictionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPrediction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPredictionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreatePredictionWithBodyWithResponse request with arbitrary body returning *CreatePredictionHTTPResponse

/*
	Creates a Channel Points Prediction.

With a Channel Points Prediction, the broadcaster poses a question and viewers try to predict the outcome. The prediction runs as soon as its created. The broadcaster may run only one prediction at a time.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
*/
func (c *ClientWithResponses) CreatePredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreatePredictionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePredictionWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePredictionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePredictionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Creates a Channel Points Prediction.

With a Channel Points Prediction, the broadcaster poses a question and viewers try to predict the outcome. The prediction runs as soon as its created. The broadcaster may run only one prediction at a time.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:predictions** scope.
*/
func (c *ClientWithResponses) CreatePredictionWithResponse(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreatePredictionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePredictionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePrediction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePredictionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CancelARaidWithResponse request returning *CancelARaidHTTPResponse

/*
	Cancel a pending raid.

You can cancel a raid at any point up until the broadcaster clicks **Raid Now** in the Twitch UX or the 90-second countdown expires.

**Rate Limit**: The limit is 10 requests within a 10-minute window.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:raids** scope.
*/
func (c *ClientWithResponses) CancelARaidWithResponse(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (r *CancelARaidHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CancelARaidWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CancelARaid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCancelARaidHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// StartARaidWithResponse request returning *StartARaidHTTPResponse

/*
	Raid another channel by sending the broadcasters viewers to the targeted channel.

When you call the API from a chat bot or extension, the Twitch UX pops up a window at the top of the chat room that identifies the number of viewers in the raid. The raid occurs when the broadcaster clicks **Raid Now** or after the 90-second countdown expires.

To determine whether the raid successfully occurred, you must subscribe to the [Channel Raid](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#channelraid) event. For more information, see [Get notified when a raid begins](https://dev.twitch.tv/docs/api/raids#get-notified-when-a-raid-begins).

To cancel a pending raid, use the [Cancel a raid](https://dev.twitch.tv/docs/api/reference#cancel-a-raid) endpoint.

**Rate Limit**: The limit is 10 requests within a 10-minute window.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:raids** scope.
*/
func (c *ClientWithResponses) StartARaidWithResponse(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (r *StartARaidHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "StartARaidWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.StartARaid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseStartARaidHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelStreamScheduleWithResponse request returning *GetChannelStreamScheduleHTTPResponse

/*
	Gets the broadcasters streaming schedule. You can get the entire schedule or specific segments of the schedule. [Learn More](https://help.twitch.tv/s/article/channel-page-setup#Schedule)

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetChannelStreamScheduleWithResponse(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (r *GetChannelStreamScheduleHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelStreamScheduleWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelStreamSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelStreamScheduleHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelIcalendarWithResponse request returning *GetChannelIcalendarHTTPResponse

/*
	Gets the broadcasters streaming schedule as an [iCalendar](https://datatracker.ietf.org/doc/html/rfc5545).

__Authorization:__

The Client-Id and Authorization headers are not required.

__Response Body:__

The response body contains the iCalendar data (see [RFC5545](https://datatracker.ietf.org/doc/html/rfc5545)).

The Content-Type response header is set to `text/calendar`.
*/
func (c *ClientWithResponses) GetChannelIcalendarWithResponse(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (r *GetChannelIcalendarHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelIcalendarWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelIcalendar(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelIcalendarHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteChannelStreamScheduleSegmentWithResponse request returning *DeleteChannelStreamScheduleSegmentHTTPResponse

/*
	Removes a broadcast segment from the broadcasters streaming schedule.

**NOTE**: For recurring segments, removing a segment removes all segments in the recurring schedule.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
*/
func (c *ClientWithResponses) DeleteChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (r *DeleteChannelStreamScheduleSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteChannelStreamScheduleSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteChannelStreamScheduleSegment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteChannelStreamScheduleSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChannelStreamScheduleSegmentWithBodyWithResponse request with arbitrary body returning *UpdateChannelStreamScheduleSegmentHTTPResponse

/*
	Updates a scheduled broadcast segment.

For recurring segments, updating a segments title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
*/
func (c *ClientWithResponses) UpdateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateChannelStreamScheduleSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelStreamScheduleSegmentWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelStreamScheduleSegmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelStreamScheduleSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates a scheduled broadcast segment.

For recurring segments, updating a segments title, category, duration, and timezone, changes all segments in the recurring schedule, not just the specified segment.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
*/
func (c *ClientWithResponses) UpdateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateChannelStreamScheduleSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelStreamScheduleSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelStreamScheduleSegment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelStreamScheduleSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateChannelStreamScheduleSegmentWithBodyWithResponse request with arbitrary body returning *CreateChannelStreamScheduleSegmentHTTPResponse

/*
	Adds a single or recurring broadcast to the broadcasters streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
*/
func (c *ClientWithResponses) CreateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateChannelStreamScheduleSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateChannelStreamScheduleSegmentWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateChannelStreamScheduleSegmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateChannelStreamScheduleSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Adds a single or recurring broadcast to the broadcasters streaming schedule. For information about scheduling broadcasts, see [Stream Schedule](https://help.twitch.tv/s/article/channel-page-setup#Schedule).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
*/
func (c *ClientWithResponses) CreateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateChannelStreamScheduleSegmentHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateChannelStreamScheduleSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateChannelStreamScheduleSegment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateChannelStreamScheduleSegmentHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChannelStreamScheduleWithResponse request returning *UpdateChannelStreamScheduleHTTPResponse

/*
	Updates the broadcasters schedule settings, such as scheduling a vacation.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:schedule** scope.
*/
func (c *ClientWithResponses) UpdateChannelStreamScheduleWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (r *UpdateChannelStreamScheduleHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelStreamScheduleWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelStreamSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelStreamScheduleHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SearchCategoriesWithResponse request returning *SearchCategoriesHTTPResponse

/*
	Gets the games or categories that match the specified query.

To match, the categorys name must contain all parts of the query string. For example, if the query string is 42, the response includes any category name that contains 42 in the title. If the query string is a phrase like _love computer_, the response includes any category name that contains the words love and computer anywhere in the name. The comparison is case insensitive.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) SearchCategoriesWithResponse(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (r *SearchCategoriesHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SearchCategoriesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SearchCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSearchCategoriesHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SearchChannelsWithResponse request returning *SearchChannelsHTTPResponse

/*
	Gets the channels that match the specified query and have streamed content within the past 6 months.

The fields that the API uses for comparison depends on the value that the _live\_only_ query parameter is set to. If _live\_only_ is **false**, the API matches on the broadcasters login name. However, if _live\_only_ is **true**, the API matches on the broadcasters name and category name.

To match, the beginning of the broadcasters name or category must match the query string. The comparison is case insensitive. If the query string is angel\_of\_death, it matches all names that begin with angel\_of\_death. However, if the query string is a phrase like _angel of death_, it matches to names starting with angelofdeath or names starting with angel\_of\_death.

By default, the results include both live and offline channels. To get only live channels set the _live\_only_ query parameter to **true**.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) SearchChannelsWithResponse(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (r *SearchChannelsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SearchChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SearchChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSearchChannelsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetSharedChatSessionWithResponse request returning *GetSharedChatSessionHTTPResponse

/*
	NEW Retrieves the active shared chat session for a channel.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/cli/token-command/#app-access-token) or [user access token](https://dev.twitch.tv/docs/authentication/#user-access-tokens).
*/
func (c *ClientWithResponses) GetSharedChatSessionWithResponse(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (r *GetSharedChatSessionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetSharedChatSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetSharedChatSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetSharedChatSessionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamsWithResponse request returning *GetStreamsHTTPResponse

/*
	Gets a list of all streams. The list is in descending order by the number of viewers watching the stream. Because viewers come and go during a stream, its possible to find duplicate or missing streams in the list as you page through the results.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (r *GetStreamsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetFollowedStreamsWithResponse request returning *GetFollowedStreamsHTTPResponse

/*
	Gets the list of broadcasters that the user follows and that are streaming live.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:follows** scope.
*/
func (c *ClientWithResponses) GetFollowedStreamsWithResponse(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (r *GetFollowedStreamsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetFollowedStreamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetFollowedStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetFollowedStreamsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamKeyWithResponse request returning *GetStreamKeyHTTPResponse

/*
	Gets the channels stream key.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:stream\_key** scope.
*/
func (c *ClientWithResponses) GetStreamKeyWithResponse(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (r *GetStreamKeyHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamKeyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreamKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamKeyHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamMarkersWithResponse request returning *GetStreamMarkersHTTPResponse

/*
	Gets a list of markers from the users most recent stream or from the specified VOD/video. A marker is an arbitrary point in a live stream that the broadcaster or editor marked, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:broadcast** or **channel:manage:broadcast** scope.
*/
func (c *ClientWithResponses) GetStreamMarkersWithResponse(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (r *GetStreamMarkersHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamMarkersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreamMarkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamMarkersHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateStreamMarkerWithBodyWithResponse request with arbitrary body returning *CreateStreamMarkerHTTPResponse

/*
	Adds a marker to a live stream. A marker is an arbitrary point in a live stream that the broadcaster or editor wants to mark, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

You may not add markers:

* If the stream is not live
* If the stream has not enabled video on demand (VOD)
* If the stream is a premiere (a live, first-viewing event that combines uploaded videos with live chat)
* If the stream is a rerun of a past broadcast, including past premieres.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.
*/
func (c *ClientWithResponses) CreateStreamMarkerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateStreamMarkerHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateStreamMarkerWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateStreamMarkerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateStreamMarkerHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Adds a marker to a live stream. A marker is an arbitrary point in a live stream that the broadcaster or editor wants to mark, so they can return to that spot later to create video highlights (see Video Producer, Highlights in the Twitch UX).

You may not add markers:

* If the stream is not live
* If the stream has not enabled video on demand (VOD)
* If the stream is a premiere (a live, first-viewing event that combines uploaded videos with live chat)
* If the stream is a rerun of a past broadcast, including past premieres.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:broadcast** scope.
*/
func (c *ClientWithResponses) CreateStreamMarkerWithResponse(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateStreamMarkerHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateStreamMarkerWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateStreamMarker(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateStreamMarkerHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamTagsWithResponse request returning *GetStreamTagsHTTPResponse

/*
	**IMPORTANT** Twitch is moving from Twitch-defined tags to channel-defined tags. **IMPORTANT** As of February 28, 2023, this endpoint returns an empty array. On July 13, 2023, it will return a 410 response. If you use this endpoint, please update your code to use [Get Channel Information](https://dev.twitch.tv/docs/api/reference#get-channel-information).

Gets the list of stream tags that the broadcaster or Twitch added to their channel.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetStreamTagsWithResponse(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (r *GetStreamTagsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamTagsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreamTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamTagsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBroadcasterSubscriptionsWithResponse request returning *GetBroadcasterSubscriptionsHTTPResponse

/*
	Gets a list of users that subscribe to the specified broadcaster.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:read:subscriptions** scope.

A Twitch extensions may use an app access token if the broadcaster has granted the **channel:read:subscriptions** scope from within the Twitch Extensions manager.
*/
func (c *ClientWithResponses) GetBroadcasterSubscriptionsWithResponse(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (r *GetBroadcasterSubscriptionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBroadcasterSubscriptionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBroadcasterSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBroadcasterSubscriptionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CheckUserSubscriptionWithResponse request returning *CheckUserSubscriptionHTTPResponse

/*
	Checks whether the user subscribes to the broadcasters channel.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:subscriptions** scope.

A Twitch extensions may use an app access token if the broadcaster has granted the **user:read:subscriptions** scope from within the Twitch Extensions manager.
*/
func (c *ClientWithResponses) CheckUserSubscriptionWithResponse(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (r *CheckUserSubscriptionHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CheckUserSubscriptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CheckUserSubscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCheckUserSubscriptionHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetAllStreamTagsWithResponse request returning *GetAllStreamTagsHTTPResponse

/*
	**IMPORTANT** Twitch is moving from Twitch-defined tags to channel-defined tags. **IMPORTANT** As of February 28, 2023, this endpoint returns an empty array. On July 13, 2023, it will return a 410 response.

Gets a list of all stream tags that Twitch defines. The broadcaster may apply any of these to their channel except automatic tags. For an online list of the possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags).

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetAllStreamTagsWithResponse(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (r *GetAllStreamTagsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetAllStreamTagsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetAllStreamTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetAllStreamTagsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetTeamsWithResponse request returning *GetTeamsHTTPResponse

/*
	Gets information about the specified Twitch team. [Read More](https://help.twitch.tv/s/article/twitch-teams)

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (r *GetTeamsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetTeamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetTeamsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelTeamsWithResponse request returning *GetChannelTeamsHTTPResponse

/*
	Gets the list of Twitch teams that the broadcaster is a member of.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetChannelTeamsWithResponse(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (r *GetChannelTeamsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelTeamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelTeamsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUsersWithResponse request returning *GetUsersHTTPResponse

/*
	Gets information about one or more users.

You may look up users using their user ID, login name, or both but the sum total of the number of users you may look up is 100\. For example, you may specify 50 IDs and 50 names or 100 IDs or names, but you cannot specify 100 IDs and 100 names.

If you dont specify IDs or login names, the request returns information about the user in the access token if you specify a user access token.

To include the users verified email address in the response, you must use a user access token that includes the **user:read:email** scope.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (r *GetUsersHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUsersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUsersHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateUserWithResponse request returning *UpdateUserHTTPResponse

/*
	Updates the specified users information. The user ID in the OAuth token identifies the user whose information you want to update.

To include the users verified email address in the response, the user access token must also include the **user:read:email** scope.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit** scope.
*/
func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (r *UpdateUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UnblockUserWithResponse request returning *UnblockUserHTTPResponse

/*
	Removes the user from the broadcasters list of blocked users. The user ID in the OAuth token identifies the broadcaster whos removing the block.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:blocked\_users** scope.
*/
func (c *ClientWithResponses) UnblockUserWithResponse(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (r *UnblockUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UnblockUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UnblockUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUnblockUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserBlockListWithResponse request returning *GetUserBlockListHTTPResponse

/*
	Gets the list of users that the broadcaster has blocked. [Read More](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers)

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:blocked\_users** scope.
*/
func (c *ClientWithResponses) GetUserBlockListWithResponse(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (r *GetUserBlockListHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserBlockListWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserBlockList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserBlockListHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// BlockUserWithResponse request returning *BlockUserHTTPResponse

/*
	Blocks the specified user from interacting with or having contact with the broadcaster. The user ID in the OAuth token identifies the broadcaster who is blocking the user.

To learn more about blocking users, see [Block Other Users on Twitch](https://help.twitch.tv/s/article/how-to-manage-harassment-in-chat?language=en%5FUS#BlockWhispersandMessagesfromStrangers).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:blocked\_users** scope.
*/
func (c *ClientWithResponses) BlockUserWithResponse(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (r *BlockUserHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "BlockUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.BlockUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseBlockUserHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserActiveExtensionsWithResponse request returning *GetUserActiveExtensionsHTTPResponse

/*
	Gets the active extensions that the broadcaster has installed for each configuration.

NOTE: To include extensions that you have under development, you must specify a user access token that includes the **user:read:broadcast** or **user:edit:broadcast** scope.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetUserActiveExtensionsWithResponse(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (r *GetUserActiveExtensionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserActiveExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserActiveExtensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserActiveExtensionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateUserExtensionsWithBodyWithResponse request with arbitrary body returning *UpdateUserExtensionsHTTPResponse

/*
	Updates an installed extensions information. You can update the extensions activation state, ID, and version number. The user ID in the access token identifies the broadcaster whose extensions youre updating.

NOTE: If you try to activate an extension under multiple extension types, the last write wins (and there is no guarantee of write order).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit:broadcast** scope.
*/
func (c *ClientWithResponses) UpdateUserExtensionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateUserExtensionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserExtensionsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUserExtensionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserExtensionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Updates an installed extensions information. You can update the extensions activation state, ID, and version number. The user ID in the access token identifies the broadcaster whose extensions youre updating.

NOTE: If you try to activate an extension under multiple extension types, the last write wins (and there is no guarantee of write order).

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:edit:broadcast** scope.
*/
func (c *ClientWithResponses) UpdateUserExtensionsWithResponse(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateUserExtensionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUserExtensions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserExtensionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserExtensionsWithResponse request returning *GetUserExtensionsHTTPResponse

/*
	Gets a list of all extensions (both active and inactive) that the broadcaster has installed. The user ID in the access token identifies the broadcaster.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:read:broadcast** or **user:edit:broadcast** scope. To include inactive extensions, you must include the **user:edit:broadcast** scope.
*/
func (c *ClientWithResponses) GetUserExtensionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetUserExtensionsHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserExtensions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserExtensionsHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteVideosWithResponse request returning *DeleteVideosHTTPResponse

/*
	Deletes one or more videos. You may delete past broadcasts, highlights, or uploads.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **channel:manage:videos** scope.
*/
func (c *ClientWithResponses) DeleteVideosWithResponse(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (r *DeleteVideosHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteVideosWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteVideos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteVideosHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetVideosWithResponse request returning *GetVideosHTTPResponse

/*
	Gets information about one or more published videos. You may get videos by ID, by user, or by game/category.

You may apply several filters to get a subset of the videos. The filters are applied as an AND operation to each video. For example, if _language_ is set to de and _game\_id_ is set to 21779, the response includes only videos that show playing League of Legends by users that stream in German. The filters apply only if you get videos by user ID or game ID.

__Authorization:__

Requires an [app access token](https://dev.twitch.tv/docs/authentication#app-access-tokens) or [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens).
*/
func (c *ClientWithResponses) GetVideosWithResponse(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (r *GetVideosHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetVideosWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetVideos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetVideosHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendWhisperWithBodyWithResponse request with arbitrary body returning *SendWhisperHTTPResponse

/*
	Sends a whisper message to the specified user.

NOTE: The user sending the whisper must have a verified phone number (see the **Phone Number** setting in your [Security and Privacy](https://www.twitch.tv/settings/security) settings).

NOTE: The API may silently drop whispers that it suspects of violating Twitch policies. (The API does not indicate that it dropped the whisper; it returns a 204 status code as if it succeeded.)

**Rate Limits**: You may whisper to a maximum of 40 unique recipients per day. Within the per day limit, you may whisper a maximum of 3 whispers per second and a maximum of 100 whispers per minute.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:whispers** scope.
*/
func (c *ClientWithResponses) SendWhisperWithBodyWithResponse(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendWhisperHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendWhisperWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendWhisperWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendWhisperHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

/*
	Sends a whisper message to the specified user.

NOTE: The user sending the whisper must have a verified phone number (see the **Phone Number** setting in your [Security and Privacy](https://www.twitch.tv/settings/security) settings).

NOTE: The API may silently drop whispers that it suspects of violating Twitch policies. (The API does not indicate that it dropped the whisper; it returns a 204 status code as if it succeeded.)

**Rate Limits**: You may whisper to a maximum of 40 unique recipients per day. Within the per day limit, you may whisper a maximum of 3 whispers per second and a maximum of 100 whispers per minute.

__Authorization:__

Requires a [user access token](https://dev.twitch.tv/docs/authentication#user-access-tokens) that includes the **user:manage:whispers** scope.
*/
func (c *ClientWithResponses) SendWhisperWithResponse(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendWhisperHTTPResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendWhisperWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendWhisper(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendWhisperHTTPResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ParseGetExtensionAnalyticsHTTPResponse parses an HTTP response from a GetExtensionAnalyticsWithResponse call
func ParseGetExtensionAnalyticsHTTPResponse(rsp *http.Response) (*GetExtensionAnalyticsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionAnalyticsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionAnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGameAnalyticsHTTPResponse parses an HTTP response from a GetGameAnalyticsWithResponse call
func ParseGetGameAnalyticsHTTPResponse(rsp *http.Response) (*GetGameAnalyticsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGameAnalyticsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGameAnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCheermotesHTTPResponse parses an HTTP response from a GetCheermotesWithResponse call
func ParseGetCheermotesHTTPResponse(rsp *http.Response) (*GetCheermotesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCheermotesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCheermotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExtensionBitsProductsHTTPResponse parses an HTTP response from a GetExtensionBitsProductsWithResponse call
func ParseGetExtensionBitsProductsHTTPResponse(rsp *http.Response) (*GetExtensionBitsProductsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionBitsProductsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionBitsProductsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateExtensionBitsProductHTTPResponse parses an HTTP response from a UpdateExtensionBitsProductWithResponse call
func ParseUpdateExtensionBitsProductHTTPResponse(rsp *http.Response) (*UpdateExtensionBitsProductHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateExtensionBitsProductHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateExtensionBitsProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBitsLeaderboardHTTPResponse parses an HTTP response from a GetBitsLeaderboardWithResponse call
func ParseGetBitsLeaderboardHTTPResponse(rsp *http.Response) (*GetBitsLeaderboardHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBitsLeaderboardHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBitsLeaderboardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomRewardHTTPResponse parses an HTTP response from a DeleteCustomRewardWithResponse call
func ParseDeleteCustomRewardHTTPResponse(rsp *http.Response) (*DeleteCustomRewardHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteCustomRewardHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomRewardHTTPResponse parses an HTTP response from a GetCustomRewardWithResponse call
func ParseGetCustomRewardHTTPResponse(rsp *http.Response) (*GetCustomRewardHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCustomRewardHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCustomRewardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomRewardHTTPResponse parses an HTTP response from a UpdateCustomRewardWithResponse call
func ParseUpdateCustomRewardHTTPResponse(rsp *http.Response) (*UpdateCustomRewardHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateCustomRewardHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateCustomRewardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomRewardsHTTPResponse parses an HTTP response from a CreateCustomRewardsWithResponse call
func ParseCreateCustomRewardsHTTPResponse(rsp *http.Response) (*CreateCustomRewardsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateCustomRewardsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCustomRewardsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomRewardRedemptionHTTPResponse parses an HTTP response from a GetCustomRewardRedemptionWithResponse call
func ParseGetCustomRewardRedemptionHTTPResponse(rsp *http.Response) (*GetCustomRewardRedemptionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCustomRewardRedemptionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCustomRewardRedemptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRedemptionStatusHTTPResponse parses an HTTP response from a UpdateRedemptionStatusWithResponse call
func ParseUpdateRedemptionStatusHTTPResponse(rsp *http.Response) (*UpdateRedemptionStatusHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateRedemptionStatusHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRedemptionStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelInformationHTTPResponse parses an HTTP response from a GetChannelInformationWithResponse call
func ParseGetChannelInformationHTTPResponse(rsp *http.Response) (*GetChannelInformationHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelInformationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelInformationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyChannelInformationHTTPResponse parses an HTTP response from a ModifyChannelInformationWithResponse call
func ParseModifyChannelInformationHTTPResponse(rsp *http.Response) (*ModifyChannelInformationHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &ModifyChannelInformationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAdScheduleHTTPResponse parses an HTTP response from a GetAdScheduleWithResponse call
func ParseGetAdScheduleHTTPResponse(rsp *http.Response) (*GetAdScheduleHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetAdScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAdScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSnoozeNextAdHTTPResponse parses an HTTP response from a SnoozeNextAdWithResponse call
func ParseSnoozeNextAdHTTPResponse(rsp *http.Response) (*SnoozeNextAdHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SnoozeNextAdHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnoozeNextAdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartCommercialHTTPResponse parses an HTTP response from a StartCommercialWithResponse call
func ParseStartCommercialHTTPResponse(rsp *http.Response) (*StartCommercialHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &StartCommercialHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartCommercialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelEditorsHTTPResponse parses an HTTP response from a GetChannelEditorsWithResponse call
func ParseGetChannelEditorsHTTPResponse(rsp *http.Response) (*GetChannelEditorsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelEditorsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelEditorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFollowedChannelsHTTPResponse parses an HTTP response from a GetFollowedChannelsWithResponse call
func ParseGetFollowedChannelsHTTPResponse(rsp *http.Response) (*GetFollowedChannelsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetFollowedChannelsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFollowedChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelFollowersHTTPResponse parses an HTTP response from a GetChannelFollowersWithResponse call
func ParseGetChannelFollowersHTTPResponse(rsp *http.Response) (*GetChannelFollowersHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelFollowersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelFollowersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveChannelVipHTTPResponse parses an HTTP response from a RemoveChannelVipWithResponse call
func ParseRemoveChannelVipHTTPResponse(rsp *http.Response) (*RemoveChannelVipHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &RemoveChannelVipHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVipsHTTPResponse parses an HTTP response from a GetVipsWithResponse call
func ParseGetVipsHTTPResponse(rsp *http.Response) (*GetVipsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetVipsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetVIPsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddChannelVipHTTPResponse parses an HTTP response from a AddChannelVipWithResponse call
func ParseAddChannelVipHTTPResponse(rsp *http.Response) (*AddChannelVipHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AddChannelVipHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCharityCampaignHTTPResponse parses an HTTP response from a GetCharityCampaignWithResponse call
func ParseGetCharityCampaignHTTPResponse(rsp *http.Response) (*GetCharityCampaignHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCharityCampaignHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCharityCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharityCampaignDonationsHTTPResponse parses an HTTP response from a GetCharityCampaignDonationsWithResponse call
func ParseGetCharityCampaignDonationsHTTPResponse(rsp *http.Response) (*GetCharityCampaignDonationsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCharityCampaignDonationsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCharityCampaignDonationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendChatAnnouncementHTTPResponse parses an HTTP response from a SendChatAnnouncementWithResponse call
func ParseSendChatAnnouncementHTTPResponse(rsp *http.Response) (*SendChatAnnouncementHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendChatAnnouncementHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetChannelChatBadgesHTTPResponse parses an HTTP response from a GetChannelChatBadgesWithResponse call
func ParseGetChannelChatBadgesHTTPResponse(rsp *http.Response) (*GetChannelChatBadgesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelChatBadgesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelChatBadgesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalChatBadgesHTTPResponse parses an HTTP response from a GetGlobalChatBadgesWithResponse call
func ParseGetGlobalChatBadgesHTTPResponse(rsp *http.Response) (*GetGlobalChatBadgesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGlobalChatBadgesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGlobalChatBadgesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChattersHTTPResponse parses an HTTP response from a GetChattersWithResponse call
func ParseGetChattersHTTPResponse(rsp *http.Response) (*GetChattersHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChattersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChattersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserChatColorHTTPResponse parses an HTTP response from a GetUserChatColorWithResponse call
func ParseGetUserChatColorHTTPResponse(rsp *http.Response) (*GetUserChatColorHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserChatColorHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserChatColorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserChatColorHTTPResponse parses an HTTP response from a UpdateUserChatColorWithResponse call
func ParseUpdateUserChatColorHTTPResponse(rsp *http.Response) (*UpdateUserChatColorHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateUserChatColorHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetChannelEmotesHTTPResponse parses an HTTP response from a GetChannelEmotesWithResponse call
func ParseGetChannelEmotesHTTPResponse(rsp *http.Response) (*GetChannelEmotesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelEmotesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelEmotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalEmotesHTTPResponse parses an HTTP response from a GetGlobalEmotesWithResponse call
func ParseGetGlobalEmotesHTTPResponse(rsp *http.Response) (*GetGlobalEmotesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGlobalEmotesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGlobalEmotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmoteSetsHTTPResponse parses an HTTP response from a GetEmoteSetsWithResponse call
func ParseGetEmoteSetsHTTPResponse(rsp *http.Response) (*GetEmoteSetsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetEmoteSetsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEmoteSetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserEmotesHTTPResponse parses an HTTP response from a GetUserEmotesWithResponse call
func ParseGetUserEmotesHTTPResponse(rsp *http.Response) (*GetUserEmotesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserEmotesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserEmotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendChatMessageHTTPResponse parses an HTTP response from a SendChatMessageWithResponse call
func ParseSendChatMessageHTTPResponse(rsp *http.Response) (*SendChatMessageHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendChatMessageHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendChatMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChatSettingsHTTPResponse parses an HTTP response from a GetChatSettingsWithResponse call
func ParseGetChatSettingsHTTPResponse(rsp *http.Response) (*GetChatSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChatSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChatSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateChatSettingsHTTPResponse parses an HTTP response from a UpdateChatSettingsWithResponse call
func ParseUpdateChatSettingsHTTPResponse(rsp *http.Response) (*UpdateChatSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChatSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateChatSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendAShoutoutHTTPResponse parses an HTTP response from a SendAShoutoutWithResponse call
func ParseSendAShoutoutHTTPResponse(rsp *http.Response) (*SendAShoutoutHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendAShoutoutHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetClipsHTTPResponse parses an HTTP response from a GetClipsWithResponse call
func ParseGetClipsHTTPResponse(rsp *http.Response) (*GetClipsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetClipsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClipsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateClipHTTPResponse parses an HTTP response from a CreateClipWithResponse call
func ParseCreateClipHTTPResponse(rsp *http.Response) (*CreateClipHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateClipHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateClipResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseGetContentClassificationLabelsHTTPResponse parses an HTTP response from a GetContentClassificationLabelsWithResponse call
func ParseGetContentClassificationLabelsHTTPResponse(rsp *http.Response) (*GetContentClassificationLabelsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetContentClassificationLabelsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetContentClassificationLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDropsEntitlementsHTTPResponse parses an HTTP response from a GetDropsEntitlementsWithResponse call
func ParseGetDropsEntitlementsHTTPResponse(rsp *http.Response) (*GetDropsEntitlementsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetDropsEntitlementsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDropsEntitlementsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDropsEntitlementsHTTPResponse parses an HTTP response from a UpdateDropsEntitlementsWithResponse call
func ParseUpdateDropsEntitlementsHTTPResponse(rsp *http.Response) (*UpdateDropsEntitlementsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateDropsEntitlementsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateDropsEntitlementsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConduitHTTPResponse parses an HTTP response from a DeleteConduitWithResponse call
func ParseDeleteConduitHTTPResponse(rsp *http.Response) (*DeleteConduitHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteConduitHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConduitsHTTPResponse parses an HTTP response from a GetConduitsWithResponse call
func ParseGetConduitsHTTPResponse(rsp *http.Response) (*GetConduitsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetConduitsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConduitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConduitsHTTPResponse parses an HTTP response from a UpdateConduitsWithResponse call
func ParseUpdateConduitsHTTPResponse(rsp *http.Response) (*UpdateConduitsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateConduitsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateConduitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateConduitsHTTPResponse parses an HTTP response from a CreateConduitsWithResponse call
func ParseCreateConduitsHTTPResponse(rsp *http.Response) (*CreateConduitsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateConduitsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateConduitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConduitShardsHTTPResponse parses an HTTP response from a GetConduitShardsWithResponse call
func ParseGetConduitShardsHTTPResponse(rsp *http.Response) (*GetConduitShardsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetConduitShardsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConduitShardsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConduitShardsHTTPResponse parses an HTTP response from a UpdateConduitShardsWithResponse call
func ParseUpdateConduitShardsHTTPResponse(rsp *http.Response) (*UpdateConduitShardsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateConduitShardsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateConduitShardsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseDeleteEventsubSubscriptionHTTPResponse parses an HTTP response from a DeleteEventsubSubscriptionWithResponse call
func ParseDeleteEventsubSubscriptionHTTPResponse(rsp *http.Response) (*DeleteEventsubSubscriptionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteEventsubSubscriptionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventsubSubscriptionsHTTPResponse parses an HTTP response from a GetEventsubSubscriptionsWithResponse call
func ParseGetEventsubSubscriptionsHTTPResponse(rsp *http.Response) (*GetEventsubSubscriptionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetEventsubSubscriptionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEventSubSubscriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEventsubSubscriptionHTTPResponse parses an HTTP response from a CreateEventsubSubscriptionWithResponse call
func ParseCreateEventsubSubscriptionHTTPResponse(rsp *http.Response) (*CreateEventsubSubscriptionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateEventsubSubscriptionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateEventSubSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseGetExtensionsHTTPResponse parses an HTTP response from a GetExtensionsWithResponse call
func ParseGetExtensionsHTTPResponse(rsp *http.Response) (*GetExtensionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendExtensionChatMessageHTTPResponse parses an HTTP response from a SendExtensionChatMessageWithResponse call
func ParseSendExtensionChatMessageHTTPResponse(rsp *http.Response) (*SendExtensionChatMessageHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendExtensionChatMessageHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExtensionConfigurationSegmentHTTPResponse parses an HTTP response from a GetExtensionConfigurationSegmentWithResponse call
func ParseGetExtensionConfigurationSegmentHTTPResponse(rsp *http.Response) (*GetExtensionConfigurationSegmentHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionConfigurationSegmentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionConfigurationSegmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetExtensionConfigurationSegmentHTTPResponse parses an HTTP response from a SetExtensionConfigurationSegmentWithResponse call
func ParseSetExtensionConfigurationSegmentHTTPResponse(rsp *http.Response) (*SetExtensionConfigurationSegmentHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SetExtensionConfigurationSegmentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExtensionSecretsHTTPResponse parses an HTTP response from a GetExtensionSecretsWithResponse call
func ParseGetExtensionSecretsHTTPResponse(rsp *http.Response) (*GetExtensionSecretsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionSecretsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionSecretsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExtensionSecretHTTPResponse parses an HTTP response from a CreateExtensionSecretWithResponse call
func ParseCreateExtensionSecretHTTPResponse(rsp *http.Response) (*CreateExtensionSecretHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateExtensionSecretHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateExtensionSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExtensionLiveChannelsHTTPResponse parses an HTTP response from a GetExtensionLiveChannelsWithResponse call
func ParseGetExtensionLiveChannelsHTTPResponse(rsp *http.Response) (*GetExtensionLiveChannelsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionLiveChannelsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionLiveChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendExtensionPubsubMessageHTTPResponse parses an HTTP response from a SendExtensionPubsubMessageWithResponse call
func ParseSendExtensionPubsubMessageHTTPResponse(rsp *http.Response) (*SendExtensionPubsubMessageHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendExtensionPubsubMessageHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReleasedExtensionsHTTPResponse parses an HTTP response from a GetReleasedExtensionsWithResponse call
func ParseGetReleasedExtensionsHTTPResponse(rsp *http.Response) (*GetReleasedExtensionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetReleasedExtensionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetReleasedExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetExtensionRequiredConfigurationHTTPResponse parses an HTTP response from a SetExtensionRequiredConfigurationWithResponse call
func ParseSetExtensionRequiredConfigurationHTTPResponse(rsp *http.Response) (*SetExtensionRequiredConfigurationHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SetExtensionRequiredConfigurationHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExtensionTransactionsHTTPResponse parses an HTTP response from a GetExtensionTransactionsWithResponse call
func ParseGetExtensionTransactionsHTTPResponse(rsp *http.Response) (*GetExtensionTransactionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionTransactionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGamesHTTPResponse parses an HTTP response from a GetGamesWithResponse call
func ParseGetGamesHTTPResponse(rsp *http.Response) (*GetGamesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGamesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGamesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopGamesHTTPResponse parses an HTTP response from a GetTopGamesWithResponse call
func ParseGetTopGamesHTTPResponse(rsp *http.Response) (*GetTopGamesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetTopGamesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTopGamesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCreatorGoalsHTTPResponse parses an HTTP response from a GetCreatorGoalsWithResponse call
func ParseGetCreatorGoalsHTTPResponse(rsp *http.Response) (*GetCreatorGoalsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCreatorGoalsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCreatorGoalsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelGuestStarSettingsHTTPResponse parses an HTTP response from a GetChannelGuestStarSettingsWithResponse call
func ParseGetChannelGuestStarSettingsHTTPResponse(rsp *http.Response) (*GetChannelGuestStarSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelGuestStarSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelGuestStarSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateChannelGuestStarSettingsHTTPResponse parses an HTTP response from a UpdateChannelGuestStarSettingsWithResponse call
func ParseUpdateChannelGuestStarSettingsHTTPResponse(rsp *http.Response) (*UpdateChannelGuestStarSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChannelGuestStarSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGuestStarInviteHTTPResponse parses an HTTP response from a DeleteGuestStarInviteWithResponse call
func ParseDeleteGuestStarInviteHTTPResponse(rsp *http.Response) (*DeleteGuestStarInviteHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteGuestStarInviteHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGuestStarInvitesHTTPResponse parses an HTTP response from a GetGuestStarInvitesWithResponse call
func ParseGetGuestStarInvitesHTTPResponse(rsp *http.Response) (*GetGuestStarInvitesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGuestStarInvitesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGuestStarInvitesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendGuestStarInviteHTTPResponse parses an HTTP response from a SendGuestStarInviteWithResponse call
func ParseSendGuestStarInviteHTTPResponse(rsp *http.Response) (*SendGuestStarInviteHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendGuestStarInviteHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEndGuestStarSessionHTTPResponse parses an HTTP response from a EndGuestStarSessionWithResponse call
func ParseEndGuestStarSessionHTTPResponse(rsp *http.Response) (*EndGuestStarSessionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &EndGuestStarSessionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGuestStarSessionHTTPResponse parses an HTTP response from a GetGuestStarSessionWithResponse call
func ParseGetGuestStarSessionHTTPResponse(rsp *http.Response) (*GetGuestStarSessionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGuestStarSessionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGuestStarSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGuestStarSessionHTTPResponse parses an HTTP response from a CreateGuestStarSessionWithResponse call
func ParseCreateGuestStarSessionHTTPResponse(rsp *http.Response) (*CreateGuestStarSessionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateGuestStarSessionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateGuestStarSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGuestStarSlotHTTPResponse parses an HTTP response from a DeleteGuestStarSlotWithResponse call
func ParseDeleteGuestStarSlotHTTPResponse(rsp *http.Response) (*DeleteGuestStarSlotHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteGuestStarSlotHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGuestStarSlotHTTPResponse parses an HTTP response from a UpdateGuestStarSlotWithResponse call
func ParseUpdateGuestStarSlotHTTPResponse(rsp *http.Response) (*UpdateGuestStarSlotHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateGuestStarSlotHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAssignGuestStarSlotHTTPResponse parses an HTTP response from a AssignGuestStarSlotWithResponse call
func ParseAssignGuestStarSlotHTTPResponse(rsp *http.Response) (*AssignGuestStarSlotHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AssignGuestStarSlotHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGuestStarSlotSettingsHTTPResponse parses an HTTP response from a UpdateGuestStarSlotSettingsWithResponse call
func ParseUpdateGuestStarSlotSettingsHTTPResponse(rsp *http.Response) (*UpdateGuestStarSlotSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateGuestStarSlotSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHypeTrainEventsHTTPResponse parses an HTTP response from a GetHypeTrainEventsWithResponse call
func ParseGetHypeTrainEventsHTTPResponse(rsp *http.Response) (*GetHypeTrainEventsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetHypeTrainEventsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetHypeTrainEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetHypeTrainStatusHTTPResponse parses an HTTP response from a GetHypeTrainStatusWithResponse call
func ParseGetHypeTrainStatusHTTPResponse(rsp *http.Response) (*GetHypeTrainStatusHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetHypeTrainStatusHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetHypeTrainStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseManageHeldAutomodMessagesHTTPResponse parses an HTTP response from a ManageHeldAutomodMessagesWithResponse call
func ParseManageHeldAutomodMessagesHTTPResponse(rsp *http.Response) (*ManageHeldAutomodMessagesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &ManageHeldAutomodMessagesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAutomodSettingsHTTPResponse parses an HTTP response from a GetAutomodSettingsWithResponse call
func ParseGetAutomodSettingsHTTPResponse(rsp *http.Response) (*GetAutomodSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetAutomodSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAutoModSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAutomodSettingsHTTPResponse parses an HTTP response from a UpdateAutomodSettingsWithResponse call
func ParseUpdateAutomodSettingsHTTPResponse(rsp *http.Response) (*UpdateAutomodSettingsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateAutomodSettingsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateAutoModSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBannedUsersHTTPResponse parses an HTTP response from a GetBannedUsersWithResponse call
func ParseGetBannedUsersHTTPResponse(rsp *http.Response) (*GetBannedUsersHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBannedUsersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBannedUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnbanUserHTTPResponse parses an HTTP response from a UnbanUserWithResponse call
func ParseUnbanUserHTTPResponse(rsp *http.Response) (*UnbanUserHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UnbanUserHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBanUserHTTPResponse parses an HTTP response from a BanUserWithResponse call
func ParseBanUserHTTPResponse(rsp *http.Response) (*BanUserHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &BanUserHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BanUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveBlockedTermHTTPResponse parses an HTTP response from a RemoveBlockedTermWithResponse call
func ParseRemoveBlockedTermHTTPResponse(rsp *http.Response) (*RemoveBlockedTermHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &RemoveBlockedTermHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBlockedTermsHTTPResponse parses an HTTP response from a GetBlockedTermsWithResponse call
func ParseGetBlockedTermsHTTPResponse(rsp *http.Response) (*GetBlockedTermsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBlockedTermsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBlockedTermsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddBlockedTermHTTPResponse parses an HTTP response from a AddBlockedTermWithResponse call
func ParseAddBlockedTermHTTPResponse(rsp *http.Response) (*AddBlockedTermHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AddBlockedTermHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddBlockedTermResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModeratedChannelsHTTPResponse parses an HTTP response from a GetModeratedChannelsWithResponse call
func ParseGetModeratedChannelsHTTPResponse(rsp *http.Response) (*GetModeratedChannelsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetModeratedChannelsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModeratedChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteChatMessagesHTTPResponse parses an HTTP response from a DeleteChatMessagesWithResponse call
func ParseDeleteChatMessagesHTTPResponse(rsp *http.Response) (*DeleteChatMessagesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteChatMessagesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCheckAutomodStatusHTTPResponse parses an HTTP response from a CheckAutomodStatusWithResponse call
func ParseCheckAutomodStatusHTTPResponse(rsp *http.Response) (*CheckAutomodStatusHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CheckAutomodStatusHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckAutoModStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveChannelModeratorHTTPResponse parses an HTTP response from a RemoveChannelModeratorWithResponse call
func ParseRemoveChannelModeratorHTTPResponse(rsp *http.Response) (*RemoveChannelModeratorHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &RemoveChannelModeratorHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetModeratorsHTTPResponse parses an HTTP response from a GetModeratorsWithResponse call
func ParseGetModeratorsHTTPResponse(rsp *http.Response) (*GetModeratorsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetModeratorsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModeratorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddChannelModeratorHTTPResponse parses an HTTP response from a AddChannelModeratorWithResponse call
func ParseAddChannelModeratorHTTPResponse(rsp *http.Response) (*AddChannelModeratorHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AddChannelModeratorHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetShieldModeStatusHTTPResponse parses an HTTP response from a GetShieldModeStatusWithResponse call
func ParseGetShieldModeStatusHTTPResponse(rsp *http.Response) (*GetShieldModeStatusHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetShieldModeStatusHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShieldModeStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateShieldModeStatusHTTPResponse parses an HTTP response from a UpdateShieldModeStatusWithResponse call
func ParseUpdateShieldModeStatusHTTPResponse(rsp *http.Response) (*UpdateShieldModeStatusHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateShieldModeStatusHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateShieldModeStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUnbanRequestsHTTPResponse parses an HTTP response from a GetUnbanRequestsWithResponse call
func ParseGetUnbanRequestsHTTPResponse(rsp *http.Response) (*GetUnbanRequestsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUnbanRequestsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUnbanRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResolveUnbanRequestsHTTPResponse parses an HTTP response from a ResolveUnbanRequestsWithResponse call
func ParseResolveUnbanRequestsHTTPResponse(rsp *http.Response) (*ResolveUnbanRequestsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &ResolveUnbanRequestsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResolveUnbanRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWarnChatUserHTTPResponse parses an HTTP response from a WarnChatUserWithResponse call
func ParseWarnChatUserHTTPResponse(rsp *http.Response) (*WarnChatUserHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &WarnChatUserHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarnChatUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPollsHTTPResponse parses an HTTP response from a GetPollsWithResponse call
func ParseGetPollsHTTPResponse(rsp *http.Response) (*GetPollsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetPollsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPollsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndPollHTTPResponse parses an HTTP response from a EndPollWithResponse call
func ParseEndPollHTTPResponse(rsp *http.Response) (*EndPollHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &EndPollHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndPollResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePollHTTPResponse parses an HTTP response from a CreatePollWithResponse call
func ParseCreatePollHTTPResponse(rsp *http.Response) (*CreatePollHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreatePollHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePollResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPredictionsHTTPResponse parses an HTTP response from a GetPredictionsWithResponse call
func ParseGetPredictionsHTTPResponse(rsp *http.Response) (*GetPredictionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetPredictionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPredictionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndPredictionHTTPResponse parses an HTTP response from a EndPredictionWithResponse call
func ParseEndPredictionHTTPResponse(rsp *http.Response) (*EndPredictionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &EndPredictionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndPredictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePredictionHTTPResponse parses an HTTP response from a CreatePredictionWithResponse call
func ParseCreatePredictionHTTPResponse(rsp *http.Response) (*CreatePredictionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreatePredictionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePredictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelARaidHTTPResponse parses an HTTP response from a CancelARaidWithResponse call
func ParseCancelARaidHTTPResponse(rsp *http.Response) (*CancelARaidHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CancelARaidHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStartARaidHTTPResponse parses an HTTP response from a StartARaidWithResponse call
func ParseStartARaidHTTPResponse(rsp *http.Response) (*StartARaidHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &StartARaidHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartRaidResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelStreamScheduleHTTPResponse parses an HTTP response from a GetChannelStreamScheduleWithResponse call
func ParseGetChannelStreamScheduleHTTPResponse(rsp *http.Response) (*GetChannelStreamScheduleHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelStreamScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelStreamScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelIcalendarHTTPResponse parses an HTTP response from a GetChannelIcalendarWithResponse call
func ParseGetChannelIcalendarHTTPResponse(rsp *http.Response) (*GetChannelIcalendarHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelIcalendarHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteChannelStreamScheduleSegmentHTTPResponse parses an HTTP response from a DeleteChannelStreamScheduleSegmentWithResponse call
func ParseDeleteChannelStreamScheduleSegmentHTTPResponse(rsp *http.Response) (*DeleteChannelStreamScheduleSegmentHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteChannelStreamScheduleSegmentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateChannelStreamScheduleSegmentHTTPResponse parses an HTTP response from a UpdateChannelStreamScheduleSegmentWithResponse call
func ParseUpdateChannelStreamScheduleSegmentHTTPResponse(rsp *http.Response) (*UpdateChannelStreamScheduleSegmentHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChannelStreamScheduleSegmentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateChannelStreamScheduleSegmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateChannelStreamScheduleSegmentHTTPResponse parses an HTTP response from a CreateChannelStreamScheduleSegmentWithResponse call
func ParseCreateChannelStreamScheduleSegmentHTTPResponse(rsp *http.Response) (*CreateChannelStreamScheduleSegmentHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateChannelStreamScheduleSegmentHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateChannelStreamScheduleSegmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateChannelStreamScheduleHTTPResponse parses an HTTP response from a UpdateChannelStreamScheduleWithResponse call
func ParseUpdateChannelStreamScheduleHTTPResponse(rsp *http.Response) (*UpdateChannelStreamScheduleHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChannelStreamScheduleHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchCategoriesHTTPResponse parses an HTTP response from a SearchCategoriesWithResponse call
func ParseSearchCategoriesHTTPResponse(rsp *http.Response) (*SearchCategoriesHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SearchCategoriesHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchChannelsHTTPResponse parses an HTTP response from a SearchChannelsWithResponse call
func ParseSearchChannelsHTTPResponse(rsp *http.Response) (*SearchChannelsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SearchChannelsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSharedChatSessionHTTPResponse parses an HTTP response from a GetSharedChatSessionWithResponse call
func ParseGetSharedChatSessionHTTPResponse(rsp *http.Response) (*GetSharedChatSessionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetSharedChatSessionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSharedChatSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamsHTTPResponse parses an HTTP response from a GetStreamsWithResponse call
func ParseGetStreamsHTTPResponse(rsp *http.Response) (*GetStreamsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFollowedStreamsHTTPResponse parses an HTTP response from a GetFollowedStreamsWithResponse call
func ParseGetFollowedStreamsHTTPResponse(rsp *http.Response) (*GetFollowedStreamsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetFollowedStreamsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFollowedStreamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamKeyHTTPResponse parses an HTTP response from a GetStreamKeyWithResponse call
func ParseGetStreamKeyHTTPResponse(rsp *http.Response) (*GetStreamKeyHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamKeyHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamMarkersHTTPResponse parses an HTTP response from a GetStreamMarkersWithResponse call
func ParseGetStreamMarkersHTTPResponse(rsp *http.Response) (*GetStreamMarkersHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamMarkersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamMarkersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateStreamMarkerHTTPResponse parses an HTTP response from a CreateStreamMarkerWithResponse call
func ParseCreateStreamMarkerHTTPResponse(rsp *http.Response) (*CreateStreamMarkerHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateStreamMarkerHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateStreamMarkerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamTagsHTTPResponse parses an HTTP response from a GetStreamTagsWithResponse call
func ParseGetStreamTagsHTTPResponse(rsp *http.Response) (*GetStreamTagsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamTagsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamTagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBroadcasterSubscriptionsHTTPResponse parses an HTTP response from a GetBroadcasterSubscriptionsWithResponse call
func ParseGetBroadcasterSubscriptionsHTTPResponse(rsp *http.Response) (*GetBroadcasterSubscriptionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBroadcasterSubscriptionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBroadcasterSubscriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckUserSubscriptionHTTPResponse parses an HTTP response from a CheckUserSubscriptionWithResponse call
func ParseCheckUserSubscriptionHTTPResponse(rsp *http.Response) (*CheckUserSubscriptionHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CheckUserSubscriptionHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckUserSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllStreamTagsHTTPResponse parses an HTTP response from a GetAllStreamTagsWithResponse call
func ParseGetAllStreamTagsHTTPResponse(rsp *http.Response) (*GetAllStreamTagsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetAllStreamTagsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllStreamTagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTeamsHTTPResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsHTTPResponse(rsp *http.Response) (*GetTeamsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetTeamsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTeamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTeamsHTTPResponse parses an HTTP response from a GetChannelTeamsWithResponse call
func ParseGetChannelTeamsHTTPResponse(rsp *http.Response) (*GetChannelTeamsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelTeamsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelTeamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersHTTPResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersHTTPResponse(rsp *http.Response) (*GetUsersHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUsersHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserHTTPResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserHTTPResponse(rsp *http.Response) (*UpdateUserHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateUserHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnblockUserHTTPResponse parses an HTTP response from a UnblockUserWithResponse call
func ParseUnblockUserHTTPResponse(rsp *http.Response) (*UnblockUserHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UnblockUserHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserBlockListHTTPResponse parses an HTTP response from a GetUserBlockListWithResponse call
func ParseGetUserBlockListHTTPResponse(rsp *http.Response) (*GetUserBlockListHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserBlockListHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserBlockListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockUserHTTPResponse parses an HTTP response from a BlockUserWithResponse call
func ParseBlockUserHTTPResponse(rsp *http.Response) (*BlockUserHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &BlockUserHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserActiveExtensionsHTTPResponse parses an HTTP response from a GetUserActiveExtensionsWithResponse call
func ParseGetUserActiveExtensionsHTTPResponse(rsp *http.Response) (*GetUserActiveExtensionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserActiveExtensionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserActiveExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserExtensionsHTTPResponse parses an HTTP response from a UpdateUserExtensionsWithResponse call
func ParseUpdateUserExtensionsHTTPResponse(rsp *http.Response) (*UpdateUserExtensionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateUserExtensionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserExtensionsHTTPResponse parses an HTTP response from a GetUserExtensionsWithResponse call
func ParseGetUserExtensionsHTTPResponse(rsp *http.Response) (*GetUserExtensionsHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserExtensionsHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVideosHTTPResponse parses an HTTP response from a DeleteVideosWithResponse call
func ParseDeleteVideosHTTPResponse(rsp *http.Response) (*DeleteVideosHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteVideosHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteVideosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVideosHTTPResponse parses an HTTP response from a GetVideosWithResponse call
func ParseGetVideosHTTPResponse(rsp *http.Response) (*GetVideosHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetVideosHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetVideosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendWhisperHTTPResponse parses an HTTP response from a SendWhisperWithResponse call
func ParseSendWhisperHTTPResponse(rsp *http.Response) (*SendWhisperHTTPResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendWhisperHTTPResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
