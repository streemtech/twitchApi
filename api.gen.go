// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.1.0 DO NOT EDIT.

//Generated with imports.tmpl

package api

import (
	"bytes"
	"compress/gzip"
	"context"
	sql "database/sql"
	"encoding/base64"
	"fmt"
	"io"
	"log/slog"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	json "github.com/go-json-experiment/json"
	"github.com/go-playground/validator/v10"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
	"github.com/streemtech/libraries/tlog"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"gorm.io/gorm"
)

// Generated with constants.tmpl
const (
	Twitch_authScopes = "twitch_auth.Scopes"
)

//Generated with constants.tmpl

// Defines values for BroadcasterSubscriptionTier.
const (
	BroadcasterSubscriptionTierN1000 BroadcasterSubscriptionTier = "1000"

	BroadcasterSubscriptionTierN2000 BroadcasterSubscriptionTier = "2000"

	BroadcasterSubscriptionTierN3000 BroadcasterSubscriptionTier = "3000"
)

// IsBroadcasterSubscriptionTier returns true if the user passes in a value that is contained in the
// list of enums of BroadcasterSubscriptionTier.
func IsBroadcasterSubscriptionTier(val BroadcasterSubscriptionTier) bool {
	switch val {
	case BroadcasterSubscriptionTierN1000:
		return true
	case BroadcasterSubscriptionTierN2000:
		return true
	case BroadcasterSubscriptionTierN3000:
		return true
	default:
		return false
	}
}

// BroadcasterSubscriptionTierEnumMap returns a map of all of the enum values
var BroadcasterSubscriptionTierEnumMap = map[BroadcasterSubscriptionTier]BroadcasterSubscriptionTier{
	BroadcasterSubscriptionTierN1000: BroadcasterSubscriptionTierN1000,
	BroadcasterSubscriptionTierN2000: BroadcasterSubscriptionTierN2000,
	BroadcasterSubscriptionTierN3000: BroadcasterSubscriptionTierN3000,
}

// Defines values for ChannelEmoteEmoteType.
const (
	ChannelEmoteEmoteTypeBitstier ChannelEmoteEmoteType = "bitstier"

	ChannelEmoteEmoteTypeFollower ChannelEmoteEmoteType = "follower"

	ChannelEmoteEmoteTypeSubscriptions ChannelEmoteEmoteType = "subscriptions"
)

// IsChannelEmoteEmoteType returns true if the user passes in a value that is contained in the
// list of enums of ChannelEmoteEmoteType.
func IsChannelEmoteEmoteType(val ChannelEmoteEmoteType) bool {
	switch val {
	case ChannelEmoteEmoteTypeBitstier:
		return true
	case ChannelEmoteEmoteTypeFollower:
		return true
	case ChannelEmoteEmoteTypeSubscriptions:
		return true
	default:
		return false
	}
}

// ChannelEmoteEmoteTypeEnumMap returns a map of all of the enum values
var ChannelEmoteEmoteTypeEnumMap = map[ChannelEmoteEmoteType]ChannelEmoteEmoteType{
	ChannelEmoteEmoteTypeBitstier:      ChannelEmoteEmoteTypeBitstier,
	ChannelEmoteEmoteTypeFollower:      ChannelEmoteEmoteTypeFollower,
	ChannelEmoteEmoteTypeSubscriptions: ChannelEmoteEmoteTypeSubscriptions,
}

// Defines values for ChannelEmoteFormat.
const (
	ChannelEmoteFormatAnimated ChannelEmoteFormat = "animated"

	ChannelEmoteFormatStatic ChannelEmoteFormat = "static"
)

// IsChannelEmoteFormat returns true if the user passes in a value that is contained in the
// list of enums of ChannelEmoteFormat.
func IsChannelEmoteFormat(val ChannelEmoteFormat) bool {
	switch val {
	case ChannelEmoteFormatAnimated:
		return true
	case ChannelEmoteFormatStatic:
		return true
	default:
		return false
	}
}

// ChannelEmoteFormatEnumMap returns a map of all of the enum values
var ChannelEmoteFormatEnumMap = map[ChannelEmoteFormat]ChannelEmoteFormat{
	ChannelEmoteFormatAnimated: ChannelEmoteFormatAnimated,
	ChannelEmoteFormatStatic:   ChannelEmoteFormatStatic,
}

// Defines values for ChannelEmoteScale.
const (
	ChannelEmoteScaleN10 ChannelEmoteScale = "1.0"

	ChannelEmoteScaleN20 ChannelEmoteScale = "2.0"

	ChannelEmoteScaleN30 ChannelEmoteScale = "3.0"
)

// IsChannelEmoteScale returns true if the user passes in a value that is contained in the
// list of enums of ChannelEmoteScale.
func IsChannelEmoteScale(val ChannelEmoteScale) bool {
	switch val {
	case ChannelEmoteScaleN10:
		return true
	case ChannelEmoteScaleN20:
		return true
	case ChannelEmoteScaleN30:
		return true
	default:
		return false
	}
}

// ChannelEmoteScaleEnumMap returns a map of all of the enum values
var ChannelEmoteScaleEnumMap = map[ChannelEmoteScale]ChannelEmoteScale{
	ChannelEmoteScaleN10: ChannelEmoteScaleN10,
	ChannelEmoteScaleN20: ChannelEmoteScaleN20,
	ChannelEmoteScaleN30: ChannelEmoteScaleN30,
}

// Defines values for ChannelEmoteThemeMode.
const (
	ChannelEmoteThemeModeDark ChannelEmoteThemeMode = "dark"

	ChannelEmoteThemeModeLight ChannelEmoteThemeMode = "light"
)

// IsChannelEmoteThemeMode returns true if the user passes in a value that is contained in the
// list of enums of ChannelEmoteThemeMode.
func IsChannelEmoteThemeMode(val ChannelEmoteThemeMode) bool {
	switch val {
	case ChannelEmoteThemeModeDark:
		return true
	case ChannelEmoteThemeModeLight:
		return true
	default:
		return false
	}
}

// ChannelEmoteThemeModeEnumMap returns a map of all of the enum values
var ChannelEmoteThemeModeEnumMap = map[ChannelEmoteThemeMode]ChannelEmoteThemeMode{
	ChannelEmoteThemeModeDark:  ChannelEmoteThemeModeDark,
	ChannelEmoteThemeModeLight: ChannelEmoteThemeModeLight,
}

// Defines values for CheermoteTiersId.
const (
	CheermoteTiersIdN1 CheermoteTiersId = "1"

	CheermoteTiersIdN100 CheermoteTiersId = "100"

	CheermoteTiersIdN1000 CheermoteTiersId = "1000"

	CheermoteTiersIdN10000 CheermoteTiersId = "10000"

	CheermoteTiersIdN100000 CheermoteTiersId = "100000"

	CheermoteTiersIdN500 CheermoteTiersId = "500"

	CheermoteTiersIdN5000 CheermoteTiersId = "5000"
)

// IsCheermoteTiersId returns true if the user passes in a value that is contained in the
// list of enums of CheermoteTiersId.
func IsCheermoteTiersId(val CheermoteTiersId) bool {
	switch val {
	case CheermoteTiersIdN1:
		return true
	case CheermoteTiersIdN100:
		return true
	case CheermoteTiersIdN1000:
		return true
	case CheermoteTiersIdN10000:
		return true
	case CheermoteTiersIdN100000:
		return true
	case CheermoteTiersIdN500:
		return true
	case CheermoteTiersIdN5000:
		return true
	default:
		return false
	}
}

// CheermoteTiersIdEnumMap returns a map of all of the enum values
var CheermoteTiersIdEnumMap = map[CheermoteTiersId]CheermoteTiersId{
	CheermoteTiersIdN1:      CheermoteTiersIdN1,
	CheermoteTiersIdN100:    CheermoteTiersIdN100,
	CheermoteTiersIdN1000:   CheermoteTiersIdN1000,
	CheermoteTiersIdN10000:  CheermoteTiersIdN10000,
	CheermoteTiersIdN100000: CheermoteTiersIdN100000,
	CheermoteTiersIdN500:    CheermoteTiersIdN500,
	CheermoteTiersIdN5000:   CheermoteTiersIdN5000,
}

// Defines values for CheermoteType.
const (
	ChannelCustom CheermoteType = "channel_custom"

	DisplayOnly CheermoteType = "display_only"

	GlobalFirstParty CheermoteType = "global_first_party"

	GlobalThirdParty CheermoteType = "global_third_party"

	Sponsored CheermoteType = "sponsored"
)

// IsCheermoteType returns true if the user passes in a value that is contained in the
// list of enums of CheermoteType.
func IsCheermoteType(val CheermoteType) bool {
	switch val {
	case ChannelCustom:
		return true
	case DisplayOnly:
		return true
	case GlobalFirstParty:
		return true
	case GlobalThirdParty:
		return true
	case Sponsored:
		return true
	default:
		return false
	}
}

// CheermoteTypeEnumMap returns a map of all of the enum values
var CheermoteTypeEnumMap = map[CheermoteType]CheermoteType{
	ChannelCustom:    ChannelCustom,
	DisplayOnly:      DisplayOnly,
	GlobalFirstParty: GlobalFirstParty,
	GlobalThirdParty: GlobalThirdParty,
	Sponsored:        Sponsored,
}

// Defines values for CreateEventSubSubscriptionBodyTransportMethod.
const (
	CreateEventSubSubscriptionBodyTransportMethodConduit CreateEventSubSubscriptionBodyTransportMethod = "conduit"

	CreateEventSubSubscriptionBodyTransportMethodWebhook CreateEventSubSubscriptionBodyTransportMethod = "webhook"

	CreateEventSubSubscriptionBodyTransportMethodWebsocket CreateEventSubSubscriptionBodyTransportMethod = "websocket"
)

// IsCreateEventSubSubscriptionBodyTransportMethod returns true if the user passes in a value that is contained in the
// list of enums of CreateEventSubSubscriptionBodyTransportMethod.
func IsCreateEventSubSubscriptionBodyTransportMethod(val CreateEventSubSubscriptionBodyTransportMethod) bool {
	switch val {
	case CreateEventSubSubscriptionBodyTransportMethodConduit:
		return true
	case CreateEventSubSubscriptionBodyTransportMethodWebhook:
		return true
	case CreateEventSubSubscriptionBodyTransportMethodWebsocket:
		return true
	default:
		return false
	}
}

// CreateEventSubSubscriptionBodyTransportMethodEnumMap returns a map of all of the enum values
var CreateEventSubSubscriptionBodyTransportMethodEnumMap = map[CreateEventSubSubscriptionBodyTransportMethod]CreateEventSubSubscriptionBodyTransportMethod{
	CreateEventSubSubscriptionBodyTransportMethodConduit:   CreateEventSubSubscriptionBodyTransportMethodConduit,
	CreateEventSubSubscriptionBodyTransportMethodWebhook:   CreateEventSubSubscriptionBodyTransportMethodWebhook,
	CreateEventSubSubscriptionBodyTransportMethodWebsocket: CreateEventSubSubscriptionBodyTransportMethodWebsocket,
}

// Defines values for CreateEventSubSubscriptionBodyType.
const (
	CreateEventSubSubscriptionBodyTypeAutomodMessageHold CreateEventSubSubscriptionBodyType = "automod.message.hold"

	CreateEventSubSubscriptionBodyTypeAutomodMessageUpdate CreateEventSubSubscriptionBodyType = "automod.message.update"

	CreateEventSubSubscriptionBodyTypeAutomodSettingsUpdate CreateEventSubSubscriptionBodyType = "automod.settings.update"

	CreateEventSubSubscriptionBodyTypeAutomodTermsUpdate CreateEventSubSubscriptionBodyType = "automod.terms.update"

	CreateEventSubSubscriptionBodyTypeChannelAdBreakBegin CreateEventSubSubscriptionBodyType = "channel.ad_break.begin"

	CreateEventSubSubscriptionBodyTypeChannelBan CreateEventSubSubscriptionBodyType = "channel.ban"

	CreateEventSubSubscriptionBodyTypeChannelChannelPointsAutomaticRewardRedemptionAdd CreateEventSubSubscriptionBodyType = "channel.channel_points_automatic_reward_redemption.add"

	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardAdd CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward.add"

	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionAdd CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward_redemption.add"

	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionUpdate CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward_redemption.update"

	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRemove CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward.remove"

	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardUpdate CreateEventSubSubscriptionBodyType = "channel.channel_points_custom_reward.update"

	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignDonate CreateEventSubSubscriptionBodyType = "channel.charity_campaign.donate"

	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignProgress CreateEventSubSubscriptionBodyType = "channel.charity_campaign.progress"

	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStart CreateEventSubSubscriptionBodyType = "channel.charity_campaign.start"

	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStop CreateEventSubSubscriptionBodyType = "channel.charity_campaign.stop"

	CreateEventSubSubscriptionBodyTypeChannelChatClear CreateEventSubSubscriptionBodyType = "channel.chat.clear"

	CreateEventSubSubscriptionBodyTypeChannelChatClearUserMessages CreateEventSubSubscriptionBodyType = "channel.chat.clear_user_messages"

	CreateEventSubSubscriptionBodyTypeChannelChatMessage CreateEventSubSubscriptionBodyType = "channel.chat.message"

	CreateEventSubSubscriptionBodyTypeChannelChatMessageDelete CreateEventSubSubscriptionBodyType = "channel.chat.message_delete"

	CreateEventSubSubscriptionBodyTypeChannelChatNotification CreateEventSubSubscriptionBodyType = "channel.chat.notification"

	CreateEventSubSubscriptionBodyTypeChannelChatSettingsUpdate CreateEventSubSubscriptionBodyType = "channel.chat_settings.update"

	CreateEventSubSubscriptionBodyTypeChannelChatUserMessageHold CreateEventSubSubscriptionBodyType = "channel.chat.user_message_hold"

	CreateEventSubSubscriptionBodyTypeChannelChatUserMessageUpdate CreateEventSubSubscriptionBodyType = "channel.chat.user_message_update"

	CreateEventSubSubscriptionBodyTypeChannelCheer CreateEventSubSubscriptionBodyType = "channel.cheer"

	CreateEventSubSubscriptionBodyTypeChannelFollow CreateEventSubSubscriptionBodyType = "channel.follow"

	CreateEventSubSubscriptionBodyTypeChannelGoalBegin CreateEventSubSubscriptionBodyType = "channel.goal.begin"

	CreateEventSubSubscriptionBodyTypeChannelGoalEnd CreateEventSubSubscriptionBodyType = "channel.goal.end"

	CreateEventSubSubscriptionBodyTypeChannelGoalProgress CreateEventSubSubscriptionBodyType = "channel.goal.progress"

	CreateEventSubSubscriptionBodyTypeChannelGuestStarGuestUpdate CreateEventSubSubscriptionBodyType = "channel.guest_star_guest.update"

	CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionBegin CreateEventSubSubscriptionBodyType = "channel.guest_star_session.begin"

	CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionEnd CreateEventSubSubscriptionBodyType = "channel.guest_star_session.end"

	CreateEventSubSubscriptionBodyTypeChannelGuestStarSettingsUpdate CreateEventSubSubscriptionBodyType = "channel.guest_star_settings.update"

	CreateEventSubSubscriptionBodyTypeChannelHypeTrainBegin CreateEventSubSubscriptionBodyType = "channel.hype_train.begin"

	CreateEventSubSubscriptionBodyTypeChannelHypeTrainEnd CreateEventSubSubscriptionBodyType = "channel.hype_train.end"

	CreateEventSubSubscriptionBodyTypeChannelHypeTrainProgress CreateEventSubSubscriptionBodyType = "channel.hype_train.progress"

	CreateEventSubSubscriptionBodyTypeChannelModerate CreateEventSubSubscriptionBodyType = "channel.moderate"

	CreateEventSubSubscriptionBodyTypeChannelModeratorAdd CreateEventSubSubscriptionBodyType = "channel.moderator.add"

	CreateEventSubSubscriptionBodyTypeChannelModeratorRemove CreateEventSubSubscriptionBodyType = "channel.moderator.remove"

	CreateEventSubSubscriptionBodyTypeChannelPollBegin CreateEventSubSubscriptionBodyType = "channel.poll.begin"

	CreateEventSubSubscriptionBodyTypeChannelPollEnd CreateEventSubSubscriptionBodyType = "channel.poll.end"

	CreateEventSubSubscriptionBodyTypeChannelPollProgress CreateEventSubSubscriptionBodyType = "channel.poll.progress"

	CreateEventSubSubscriptionBodyTypeChannelPredictionBegin CreateEventSubSubscriptionBodyType = "channel.prediction.begin"

	CreateEventSubSubscriptionBodyTypeChannelPredictionEnd CreateEventSubSubscriptionBodyType = "channel.prediction.end"

	CreateEventSubSubscriptionBodyTypeChannelPredictionLock CreateEventSubSubscriptionBodyType = "channel.prediction.lock"

	CreateEventSubSubscriptionBodyTypeChannelPredictionProgress CreateEventSubSubscriptionBodyType = "channel.prediction.progress"

	CreateEventSubSubscriptionBodyTypeChannelRaid CreateEventSubSubscriptionBodyType = "channel.raid"

	CreateEventSubSubscriptionBodyTypeChannelSharedChatBegin CreateEventSubSubscriptionBodyType = "channel.shared_chat.begin"

	CreateEventSubSubscriptionBodyTypeChannelSharedChatEnd CreateEventSubSubscriptionBodyType = "channel.shared_chat.end"

	CreateEventSubSubscriptionBodyTypeChannelSharedChatUpdate CreateEventSubSubscriptionBodyType = "channel.shared_chat.update"

	CreateEventSubSubscriptionBodyTypeChannelShieldModeBegin CreateEventSubSubscriptionBodyType = "channel.shield_mode.begin"

	CreateEventSubSubscriptionBodyTypeChannelShieldModeEnd CreateEventSubSubscriptionBodyType = "channel.shield_mode.end"

	CreateEventSubSubscriptionBodyTypeChannelShoutoutCreate CreateEventSubSubscriptionBodyType = "channel.shoutout.create"

	CreateEventSubSubscriptionBodyTypeChannelShoutoutReceive CreateEventSubSubscriptionBodyType = "channel.shoutout.receive"

	CreateEventSubSubscriptionBodyTypeChannelSubscribe CreateEventSubSubscriptionBodyType = "channel.subscribe"

	CreateEventSubSubscriptionBodyTypeChannelSubscriptionEnd CreateEventSubSubscriptionBodyType = "channel.subscription.end"

	CreateEventSubSubscriptionBodyTypeChannelSubscriptionGift CreateEventSubSubscriptionBodyType = "channel.subscription.gift"

	CreateEventSubSubscriptionBodyTypeChannelSubscriptionMessage CreateEventSubSubscriptionBodyType = "channel.subscription.message"

	CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserMessage CreateEventSubSubscriptionBodyType = "channel.suspicious_user.message"

	CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserUpdate CreateEventSubSubscriptionBodyType = "channel.suspicious_user.update"

	CreateEventSubSubscriptionBodyTypeChannelUnban CreateEventSubSubscriptionBodyType = "channel.unban"

	CreateEventSubSubscriptionBodyTypeChannelUnbanRequestCreate CreateEventSubSubscriptionBodyType = "channel.unban_request.create"

	CreateEventSubSubscriptionBodyTypeChannelUnbanRequestResolve CreateEventSubSubscriptionBodyType = "channel.unban_request.resolve"

	CreateEventSubSubscriptionBodyTypeChannelUpdate CreateEventSubSubscriptionBodyType = "channel.update"

	CreateEventSubSubscriptionBodyTypeChannelVipAdd CreateEventSubSubscriptionBodyType = "channel.vip.add"

	CreateEventSubSubscriptionBodyTypeChannelVipRemove CreateEventSubSubscriptionBodyType = "channel.vip.remove"

	CreateEventSubSubscriptionBodyTypeChannelWarningAcknowledge CreateEventSubSubscriptionBodyType = "channel.warning.acknowledge"

	CreateEventSubSubscriptionBodyTypeChannelWarningSend CreateEventSubSubscriptionBodyType = "channel.warning.send"

	CreateEventSubSubscriptionBodyTypeConduitShardDisabled CreateEventSubSubscriptionBodyType = "conduit.shard.disabled"

	CreateEventSubSubscriptionBodyTypeDropEntitlementGrant CreateEventSubSubscriptionBodyType = "drop.entitlement.grant"

	CreateEventSubSubscriptionBodyTypeExtensionBitsTransactionCreate CreateEventSubSubscriptionBodyType = "extension.bits_transaction.create"

	CreateEventSubSubscriptionBodyTypeStreamOffline CreateEventSubSubscriptionBodyType = "stream.offline"

	CreateEventSubSubscriptionBodyTypeStreamOnline CreateEventSubSubscriptionBodyType = "stream.online"

	CreateEventSubSubscriptionBodyTypeUserAuthorizationGrant CreateEventSubSubscriptionBodyType = "user.authorization.grant"

	CreateEventSubSubscriptionBodyTypeUserAuthorizationRevoke CreateEventSubSubscriptionBodyType = "user.authorization.revoke"

	CreateEventSubSubscriptionBodyTypeUserUpdate CreateEventSubSubscriptionBodyType = "user.update"

	CreateEventSubSubscriptionBodyTypeUserWhisperMessage CreateEventSubSubscriptionBodyType = "user.whisper.message"
)

// IsCreateEventSubSubscriptionBodyType returns true if the user passes in a value that is contained in the
// list of enums of CreateEventSubSubscriptionBodyType.
func IsCreateEventSubSubscriptionBodyType(val CreateEventSubSubscriptionBodyType) bool {
	switch val {
	case CreateEventSubSubscriptionBodyTypeAutomodMessageHold:
		return true
	case CreateEventSubSubscriptionBodyTypeAutomodMessageUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeAutomodSettingsUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeAutomodTermsUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelAdBreakBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelBan:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChannelPointsAutomaticRewardRedemptionAdd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardAdd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionAdd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRemove:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelCharityCampaignDonate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelCharityCampaignProgress:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStart:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStop:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatClear:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatClearUserMessages:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatMessage:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatMessageDelete:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatNotification:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatSettingsUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatUserMessageHold:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelChatUserMessageUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelCheer:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelFollow:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGoalBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGoalEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGoalProgress:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGuestStarGuestUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelGuestStarSettingsUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelHypeTrainBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelHypeTrainEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelHypeTrainProgress:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelModerate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelModeratorAdd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelModeratorRemove:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPollBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPollEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPollProgress:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPredictionBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPredictionEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPredictionLock:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelPredictionProgress:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelRaid:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSharedChatBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSharedChatEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSharedChatUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelShieldModeBegin:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelShieldModeEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelShoutoutCreate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelShoutoutReceive:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSubscribe:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSubscriptionEnd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSubscriptionGift:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSubscriptionMessage:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserMessage:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelUnban:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelUnbanRequestCreate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelUnbanRequestResolve:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelVipAdd:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelVipRemove:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelWarningAcknowledge:
		return true
	case CreateEventSubSubscriptionBodyTypeChannelWarningSend:
		return true
	case CreateEventSubSubscriptionBodyTypeConduitShardDisabled:
		return true
	case CreateEventSubSubscriptionBodyTypeDropEntitlementGrant:
		return true
	case CreateEventSubSubscriptionBodyTypeExtensionBitsTransactionCreate:
		return true
	case CreateEventSubSubscriptionBodyTypeStreamOffline:
		return true
	case CreateEventSubSubscriptionBodyTypeStreamOnline:
		return true
	case CreateEventSubSubscriptionBodyTypeUserAuthorizationGrant:
		return true
	case CreateEventSubSubscriptionBodyTypeUserAuthorizationRevoke:
		return true
	case CreateEventSubSubscriptionBodyTypeUserUpdate:
		return true
	case CreateEventSubSubscriptionBodyTypeUserWhisperMessage:
		return true
	default:
		return false
	}
}

// CreateEventSubSubscriptionBodyTypeEnumMap returns a map of all of the enum values
var CreateEventSubSubscriptionBodyTypeEnumMap = map[CreateEventSubSubscriptionBodyType]CreateEventSubSubscriptionBodyType{
	CreateEventSubSubscriptionBodyTypeAutomodMessageHold:                               CreateEventSubSubscriptionBodyTypeAutomodMessageHold,
	CreateEventSubSubscriptionBodyTypeAutomodMessageUpdate:                             CreateEventSubSubscriptionBodyTypeAutomodMessageUpdate,
	CreateEventSubSubscriptionBodyTypeAutomodSettingsUpdate:                            CreateEventSubSubscriptionBodyTypeAutomodSettingsUpdate,
	CreateEventSubSubscriptionBodyTypeAutomodTermsUpdate:                               CreateEventSubSubscriptionBodyTypeAutomodTermsUpdate,
	CreateEventSubSubscriptionBodyTypeChannelAdBreakBegin:                              CreateEventSubSubscriptionBodyTypeChannelAdBreakBegin,
	CreateEventSubSubscriptionBodyTypeChannelBan:                                       CreateEventSubSubscriptionBodyTypeChannelBan,
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsAutomaticRewardRedemptionAdd: CreateEventSubSubscriptionBodyTypeChannelChannelPointsAutomaticRewardRedemptionAdd,
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardAdd:              CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardAdd,
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionAdd:    CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionAdd,
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionUpdate: CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRedemptionUpdate,
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRemove:           CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardRemove,
	CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardUpdate:           CreateEventSubSubscriptionBodyTypeChannelChannelPointsCustomRewardUpdate,
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignDonate:                     CreateEventSubSubscriptionBodyTypeChannelCharityCampaignDonate,
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignProgress:                   CreateEventSubSubscriptionBodyTypeChannelCharityCampaignProgress,
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStart:                      CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStart,
	CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStop:                       CreateEventSubSubscriptionBodyTypeChannelCharityCampaignStop,
	CreateEventSubSubscriptionBodyTypeChannelChatClear:                                 CreateEventSubSubscriptionBodyTypeChannelChatClear,
	CreateEventSubSubscriptionBodyTypeChannelChatClearUserMessages:                     CreateEventSubSubscriptionBodyTypeChannelChatClearUserMessages,
	CreateEventSubSubscriptionBodyTypeChannelChatMessage:                               CreateEventSubSubscriptionBodyTypeChannelChatMessage,
	CreateEventSubSubscriptionBodyTypeChannelChatMessageDelete:                         CreateEventSubSubscriptionBodyTypeChannelChatMessageDelete,
	CreateEventSubSubscriptionBodyTypeChannelChatNotification:                          CreateEventSubSubscriptionBodyTypeChannelChatNotification,
	CreateEventSubSubscriptionBodyTypeChannelChatSettingsUpdate:                        CreateEventSubSubscriptionBodyTypeChannelChatSettingsUpdate,
	CreateEventSubSubscriptionBodyTypeChannelChatUserMessageHold:                       CreateEventSubSubscriptionBodyTypeChannelChatUserMessageHold,
	CreateEventSubSubscriptionBodyTypeChannelChatUserMessageUpdate:                     CreateEventSubSubscriptionBodyTypeChannelChatUserMessageUpdate,
	CreateEventSubSubscriptionBodyTypeChannelCheer:                                     CreateEventSubSubscriptionBodyTypeChannelCheer,
	CreateEventSubSubscriptionBodyTypeChannelFollow:                                    CreateEventSubSubscriptionBodyTypeChannelFollow,
	CreateEventSubSubscriptionBodyTypeChannelGoalBegin:                                 CreateEventSubSubscriptionBodyTypeChannelGoalBegin,
	CreateEventSubSubscriptionBodyTypeChannelGoalEnd:                                   CreateEventSubSubscriptionBodyTypeChannelGoalEnd,
	CreateEventSubSubscriptionBodyTypeChannelGoalProgress:                              CreateEventSubSubscriptionBodyTypeChannelGoalProgress,
	CreateEventSubSubscriptionBodyTypeChannelGuestStarGuestUpdate:                      CreateEventSubSubscriptionBodyTypeChannelGuestStarGuestUpdate,
	CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionBegin:                     CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionBegin,
	CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionEnd:                       CreateEventSubSubscriptionBodyTypeChannelGuestStarSessionEnd,
	CreateEventSubSubscriptionBodyTypeChannelGuestStarSettingsUpdate:                   CreateEventSubSubscriptionBodyTypeChannelGuestStarSettingsUpdate,
	CreateEventSubSubscriptionBodyTypeChannelHypeTrainBegin:                            CreateEventSubSubscriptionBodyTypeChannelHypeTrainBegin,
	CreateEventSubSubscriptionBodyTypeChannelHypeTrainEnd:                              CreateEventSubSubscriptionBodyTypeChannelHypeTrainEnd,
	CreateEventSubSubscriptionBodyTypeChannelHypeTrainProgress:                         CreateEventSubSubscriptionBodyTypeChannelHypeTrainProgress,
	CreateEventSubSubscriptionBodyTypeChannelModerate:                                  CreateEventSubSubscriptionBodyTypeChannelModerate,
	CreateEventSubSubscriptionBodyTypeChannelModeratorAdd:                              CreateEventSubSubscriptionBodyTypeChannelModeratorAdd,
	CreateEventSubSubscriptionBodyTypeChannelModeratorRemove:                           CreateEventSubSubscriptionBodyTypeChannelModeratorRemove,
	CreateEventSubSubscriptionBodyTypeChannelPollBegin:                                 CreateEventSubSubscriptionBodyTypeChannelPollBegin,
	CreateEventSubSubscriptionBodyTypeChannelPollEnd:                                   CreateEventSubSubscriptionBodyTypeChannelPollEnd,
	CreateEventSubSubscriptionBodyTypeChannelPollProgress:                              CreateEventSubSubscriptionBodyTypeChannelPollProgress,
	CreateEventSubSubscriptionBodyTypeChannelPredictionBegin:                           CreateEventSubSubscriptionBodyTypeChannelPredictionBegin,
	CreateEventSubSubscriptionBodyTypeChannelPredictionEnd:                             CreateEventSubSubscriptionBodyTypeChannelPredictionEnd,
	CreateEventSubSubscriptionBodyTypeChannelPredictionLock:                            CreateEventSubSubscriptionBodyTypeChannelPredictionLock,
	CreateEventSubSubscriptionBodyTypeChannelPredictionProgress:                        CreateEventSubSubscriptionBodyTypeChannelPredictionProgress,
	CreateEventSubSubscriptionBodyTypeChannelRaid:                                      CreateEventSubSubscriptionBodyTypeChannelRaid,
	CreateEventSubSubscriptionBodyTypeChannelSharedChatBegin:                           CreateEventSubSubscriptionBodyTypeChannelSharedChatBegin,
	CreateEventSubSubscriptionBodyTypeChannelSharedChatEnd:                             CreateEventSubSubscriptionBodyTypeChannelSharedChatEnd,
	CreateEventSubSubscriptionBodyTypeChannelSharedChatUpdate:                          CreateEventSubSubscriptionBodyTypeChannelSharedChatUpdate,
	CreateEventSubSubscriptionBodyTypeChannelShieldModeBegin:                           CreateEventSubSubscriptionBodyTypeChannelShieldModeBegin,
	CreateEventSubSubscriptionBodyTypeChannelShieldModeEnd:                             CreateEventSubSubscriptionBodyTypeChannelShieldModeEnd,
	CreateEventSubSubscriptionBodyTypeChannelShoutoutCreate:                            CreateEventSubSubscriptionBodyTypeChannelShoutoutCreate,
	CreateEventSubSubscriptionBodyTypeChannelShoutoutReceive:                           CreateEventSubSubscriptionBodyTypeChannelShoutoutReceive,
	CreateEventSubSubscriptionBodyTypeChannelSubscribe:                                 CreateEventSubSubscriptionBodyTypeChannelSubscribe,
	CreateEventSubSubscriptionBodyTypeChannelSubscriptionEnd:                           CreateEventSubSubscriptionBodyTypeChannelSubscriptionEnd,
	CreateEventSubSubscriptionBodyTypeChannelSubscriptionGift:                          CreateEventSubSubscriptionBodyTypeChannelSubscriptionGift,
	CreateEventSubSubscriptionBodyTypeChannelSubscriptionMessage:                       CreateEventSubSubscriptionBodyTypeChannelSubscriptionMessage,
	CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserMessage:                     CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserMessage,
	CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserUpdate:                      CreateEventSubSubscriptionBodyTypeChannelSuspiciousUserUpdate,
	CreateEventSubSubscriptionBodyTypeChannelUnban:                                     CreateEventSubSubscriptionBodyTypeChannelUnban,
	CreateEventSubSubscriptionBodyTypeChannelUnbanRequestCreate:                        CreateEventSubSubscriptionBodyTypeChannelUnbanRequestCreate,
	CreateEventSubSubscriptionBodyTypeChannelUnbanRequestResolve:                       CreateEventSubSubscriptionBodyTypeChannelUnbanRequestResolve,
	CreateEventSubSubscriptionBodyTypeChannelUpdate:                                    CreateEventSubSubscriptionBodyTypeChannelUpdate,
	CreateEventSubSubscriptionBodyTypeChannelVipAdd:                                    CreateEventSubSubscriptionBodyTypeChannelVipAdd,
	CreateEventSubSubscriptionBodyTypeChannelVipRemove:                                 CreateEventSubSubscriptionBodyTypeChannelVipRemove,
	CreateEventSubSubscriptionBodyTypeChannelWarningAcknowledge:                        CreateEventSubSubscriptionBodyTypeChannelWarningAcknowledge,
	CreateEventSubSubscriptionBodyTypeChannelWarningSend:                               CreateEventSubSubscriptionBodyTypeChannelWarningSend,
	CreateEventSubSubscriptionBodyTypeConduitShardDisabled:                             CreateEventSubSubscriptionBodyTypeConduitShardDisabled,
	CreateEventSubSubscriptionBodyTypeDropEntitlementGrant:                             CreateEventSubSubscriptionBodyTypeDropEntitlementGrant,
	CreateEventSubSubscriptionBodyTypeExtensionBitsTransactionCreate:                   CreateEventSubSubscriptionBodyTypeExtensionBitsTransactionCreate,
	CreateEventSubSubscriptionBodyTypeStreamOffline:                                    CreateEventSubSubscriptionBodyTypeStreamOffline,
	CreateEventSubSubscriptionBodyTypeStreamOnline:                                     CreateEventSubSubscriptionBodyTypeStreamOnline,
	CreateEventSubSubscriptionBodyTypeUserAuthorizationGrant:                           CreateEventSubSubscriptionBodyTypeUserAuthorizationGrant,
	CreateEventSubSubscriptionBodyTypeUserAuthorizationRevoke:                          CreateEventSubSubscriptionBodyTypeUserAuthorizationRevoke,
	CreateEventSubSubscriptionBodyTypeUserUpdate:                                       CreateEventSubSubscriptionBodyTypeUserUpdate,
	CreateEventSubSubscriptionBodyTypeUserWhisperMessage:                               CreateEventSubSubscriptionBodyTypeUserWhisperMessage,
}

// Defines values for CreatorGoalType.
const (
	CreatorGoalTypeFollower CreatorGoalType = "follower"

	CreatorGoalTypeNewSubscription CreatorGoalType = "new_subscription"

	CreatorGoalTypeNewSubscriptionCount CreatorGoalType = "new_subscription_count"

	CreatorGoalTypeSubscription CreatorGoalType = "subscription"

	CreatorGoalTypeSubscriptionCount CreatorGoalType = "subscription_count"
)

// IsCreatorGoalType returns true if the user passes in a value that is contained in the
// list of enums of CreatorGoalType.
func IsCreatorGoalType(val CreatorGoalType) bool {
	switch val {
	case CreatorGoalTypeFollower:
		return true
	case CreatorGoalTypeNewSubscription:
		return true
	case CreatorGoalTypeNewSubscriptionCount:
		return true
	case CreatorGoalTypeSubscription:
		return true
	case CreatorGoalTypeSubscriptionCount:
		return true
	default:
		return false
	}
}

// CreatorGoalTypeEnumMap returns a map of all of the enum values
var CreatorGoalTypeEnumMap = map[CreatorGoalType]CreatorGoalType{
	CreatorGoalTypeFollower:             CreatorGoalTypeFollower,
	CreatorGoalTypeNewSubscription:      CreatorGoalTypeNewSubscription,
	CreatorGoalTypeNewSubscriptionCount: CreatorGoalTypeNewSubscriptionCount,
	CreatorGoalTypeSubscription:         CreatorGoalTypeSubscription,
	CreatorGoalTypeSubscriptionCount:    CreatorGoalTypeSubscriptionCount,
}

// Defines values for CustomRewardRedemptionStatus.
const (
	CustomRewardRedemptionStatusCANCELED CustomRewardRedemptionStatus = "CANCELED"

	CustomRewardRedemptionStatusFULFILLED CustomRewardRedemptionStatus = "FULFILLED"

	CustomRewardRedemptionStatusUNFULFILLED CustomRewardRedemptionStatus = "UNFULFILLED"
)

// IsCustomRewardRedemptionStatus returns true if the user passes in a value that is contained in the
// list of enums of CustomRewardRedemptionStatus.
func IsCustomRewardRedemptionStatus(val CustomRewardRedemptionStatus) bool {
	switch val {
	case CustomRewardRedemptionStatusCANCELED:
		return true
	case CustomRewardRedemptionStatusFULFILLED:
		return true
	case CustomRewardRedemptionStatusUNFULFILLED:
		return true
	default:
		return false
	}
}

// CustomRewardRedemptionStatusEnumMap returns a map of all of the enum values
var CustomRewardRedemptionStatusEnumMap = map[CustomRewardRedemptionStatus]CustomRewardRedemptionStatus{
	CustomRewardRedemptionStatusCANCELED:    CustomRewardRedemptionStatusCANCELED,
	CustomRewardRedemptionStatusFULFILLED:   CustomRewardRedemptionStatusFULFILLED,
	CustomRewardRedemptionStatusUNFULFILLED: CustomRewardRedemptionStatusUNFULFILLED,
}

// Defines values for DropsEntitlementFulfillmentStatus.
const (
	DropsEntitlementFulfillmentStatusCLAIMED DropsEntitlementFulfillmentStatus = "CLAIMED"

	DropsEntitlementFulfillmentStatusFULFILLED DropsEntitlementFulfillmentStatus = "FULFILLED"
)

// IsDropsEntitlementFulfillmentStatus returns true if the user passes in a value that is contained in the
// list of enums of DropsEntitlementFulfillmentStatus.
func IsDropsEntitlementFulfillmentStatus(val DropsEntitlementFulfillmentStatus) bool {
	switch val {
	case DropsEntitlementFulfillmentStatusCLAIMED:
		return true
	case DropsEntitlementFulfillmentStatusFULFILLED:
		return true
	default:
		return false
	}
}

// DropsEntitlementFulfillmentStatusEnumMap returns a map of all of the enum values
var DropsEntitlementFulfillmentStatusEnumMap = map[DropsEntitlementFulfillmentStatus]DropsEntitlementFulfillmentStatus{
	DropsEntitlementFulfillmentStatusCLAIMED:   DropsEntitlementFulfillmentStatusCLAIMED,
	DropsEntitlementFulfillmentStatusFULFILLED: DropsEntitlementFulfillmentStatusFULFILLED,
}

// Defines values for DropsEntitlementUpdatedStatus.
const (
	INVALIDID DropsEntitlementUpdatedStatus = "INVALID_ID"

	NOTFOUND DropsEntitlementUpdatedStatus = "NOT_FOUND"

	SUCCESS DropsEntitlementUpdatedStatus = "SUCCESS"

	UNAUTHORIZED DropsEntitlementUpdatedStatus = "UNAUTHORIZED"

	UPDATEFAILED DropsEntitlementUpdatedStatus = "UPDATE_FAILED"
)

// IsDropsEntitlementUpdatedStatus returns true if the user passes in a value that is contained in the
// list of enums of DropsEntitlementUpdatedStatus.
func IsDropsEntitlementUpdatedStatus(val DropsEntitlementUpdatedStatus) bool {
	switch val {
	case INVALIDID:
		return true
	case NOTFOUND:
		return true
	case SUCCESS:
		return true
	case UNAUTHORIZED:
		return true
	case UPDATEFAILED:
		return true
	default:
		return false
	}
}

// DropsEntitlementUpdatedStatusEnumMap returns a map of all of the enum values
var DropsEntitlementUpdatedStatusEnumMap = map[DropsEntitlementUpdatedStatus]DropsEntitlementUpdatedStatus{
	INVALIDID:    INVALIDID,
	NOTFOUND:     NOTFOUND,
	SUCCESS:      SUCCESS,
	UNAUTHORIZED: UNAUTHORIZED,
	UPDATEFAILED: UPDATEFAILED,
}

// Defines values for EmoteEmoteType.
const (
	EmoteEmoteTypeBitstier EmoteEmoteType = "bitstier"

	EmoteEmoteTypeFollower EmoteEmoteType = "follower"

	EmoteEmoteTypeSubscriptions EmoteEmoteType = "subscriptions"
)

// IsEmoteEmoteType returns true if the user passes in a value that is contained in the
// list of enums of EmoteEmoteType.
func IsEmoteEmoteType(val EmoteEmoteType) bool {
	switch val {
	case EmoteEmoteTypeBitstier:
		return true
	case EmoteEmoteTypeFollower:
		return true
	case EmoteEmoteTypeSubscriptions:
		return true
	default:
		return false
	}
}

// EmoteEmoteTypeEnumMap returns a map of all of the enum values
var EmoteEmoteTypeEnumMap = map[EmoteEmoteType]EmoteEmoteType{
	EmoteEmoteTypeBitstier:      EmoteEmoteTypeBitstier,
	EmoteEmoteTypeFollower:      EmoteEmoteTypeFollower,
	EmoteEmoteTypeSubscriptions: EmoteEmoteTypeSubscriptions,
}

// Defines values for EmoteFormat.
const (
	EmoteFormatAnimated EmoteFormat = "animated"

	EmoteFormatStatic EmoteFormat = "static"
)

// IsEmoteFormat returns true if the user passes in a value that is contained in the
// list of enums of EmoteFormat.
func IsEmoteFormat(val EmoteFormat) bool {
	switch val {
	case EmoteFormatAnimated:
		return true
	case EmoteFormatStatic:
		return true
	default:
		return false
	}
}

// EmoteFormatEnumMap returns a map of all of the enum values
var EmoteFormatEnumMap = map[EmoteFormat]EmoteFormat{
	EmoteFormatAnimated: EmoteFormatAnimated,
	EmoteFormatStatic:   EmoteFormatStatic,
}

// Defines values for EmoteScale.
const (
	EmoteScaleN10 EmoteScale = "1.0"

	EmoteScaleN20 EmoteScale = "2.0"

	EmoteScaleN30 EmoteScale = "3.0"
)

// IsEmoteScale returns true if the user passes in a value that is contained in the
// list of enums of EmoteScale.
func IsEmoteScale(val EmoteScale) bool {
	switch val {
	case EmoteScaleN10:
		return true
	case EmoteScaleN20:
		return true
	case EmoteScaleN30:
		return true
	default:
		return false
	}
}

// EmoteScaleEnumMap returns a map of all of the enum values
var EmoteScaleEnumMap = map[EmoteScale]EmoteScale{
	EmoteScaleN10: EmoteScaleN10,
	EmoteScaleN20: EmoteScaleN20,
	EmoteScaleN30: EmoteScaleN30,
}

// Defines values for EmoteThemeMode.
const (
	EmoteThemeModeDark EmoteThemeMode = "dark"

	EmoteThemeModeLight EmoteThemeMode = "light"
)

// IsEmoteThemeMode returns true if the user passes in a value that is contained in the
// list of enums of EmoteThemeMode.
func IsEmoteThemeMode(val EmoteThemeMode) bool {
	switch val {
	case EmoteThemeModeDark:
		return true
	case EmoteThemeModeLight:
		return true
	default:
		return false
	}
}

// EmoteThemeModeEnumMap returns a map of all of the enum values
var EmoteThemeModeEnumMap = map[EmoteThemeMode]EmoteThemeMode{
	EmoteThemeModeDark:  EmoteThemeModeDark,
	EmoteThemeModeLight: EmoteThemeModeLight,
}

// Defines values for EndPollBodyStatus.
const (
	EndPollBodyStatusARCHIVED EndPollBodyStatus = "ARCHIVED"

	EndPollBodyStatusTERMINATED EndPollBodyStatus = "TERMINATED"
)

// IsEndPollBodyStatus returns true if the user passes in a value that is contained in the
// list of enums of EndPollBodyStatus.
func IsEndPollBodyStatus(val EndPollBodyStatus) bool {
	switch val {
	case EndPollBodyStatusARCHIVED:
		return true
	case EndPollBodyStatusTERMINATED:
		return true
	default:
		return false
	}
}

// EndPollBodyStatusEnumMap returns a map of all of the enum values
var EndPollBodyStatusEnumMap = map[EndPollBodyStatus]EndPollBodyStatus{
	EndPollBodyStatusARCHIVED:   EndPollBodyStatusARCHIVED,
	EndPollBodyStatusTERMINATED: EndPollBodyStatusTERMINATED,
}

// Defines values for EndPredictionBodyStatus.
const (
	EndPredictionBodyStatusCANCELED EndPredictionBodyStatus = "CANCELED"

	EndPredictionBodyStatusLOCKED EndPredictionBodyStatus = "LOCKED"

	EndPredictionBodyStatusRESOLVED EndPredictionBodyStatus = "RESOLVED"
)

// IsEndPredictionBodyStatus returns true if the user passes in a value that is contained in the
// list of enums of EndPredictionBodyStatus.
func IsEndPredictionBodyStatus(val EndPredictionBodyStatus) bool {
	switch val {
	case EndPredictionBodyStatusCANCELED:
		return true
	case EndPredictionBodyStatusLOCKED:
		return true
	case EndPredictionBodyStatusRESOLVED:
		return true
	default:
		return false
	}
}

// EndPredictionBodyStatusEnumMap returns a map of all of the enum values
var EndPredictionBodyStatusEnumMap = map[EndPredictionBodyStatus]EndPredictionBodyStatus{
	EndPredictionBodyStatusCANCELED: EndPredictionBodyStatusCANCELED,
	EndPredictionBodyStatusLOCKED:   EndPredictionBodyStatusLOCKED,
	EndPredictionBodyStatusRESOLVED: EndPredictionBodyStatusRESOLVED,
}

// Defines values for EventSubSubscriptionStatus.
const (
	EventSubSubscriptionStatusAuthorizationRevoked EventSubSubscriptionStatus = "authorization_revoked"

	EventSubSubscriptionStatusBetaMaintenance EventSubSubscriptionStatus = "beta_maintenance"

	EventSubSubscriptionStatusEnabled EventSubSubscriptionStatus = "enabled"

	EventSubSubscriptionStatusModeratorRemoved EventSubSubscriptionStatus = "moderator_removed"

	EventSubSubscriptionStatusNotificationFailuresExceeded EventSubSubscriptionStatus = "notification_failures_exceeded"

	EventSubSubscriptionStatusUserRemoved EventSubSubscriptionStatus = "user_removed"

	EventSubSubscriptionStatusVersionRemoved EventSubSubscriptionStatus = "version_removed"

	EventSubSubscriptionStatusWebhookCallbackVerificationFailed EventSubSubscriptionStatus = "webhook_callback_verification_failed"

	EventSubSubscriptionStatusWebhookCallbackVerificationPending EventSubSubscriptionStatus = "webhook_callback_verification_pending"

	EventSubSubscriptionStatusWebsocketConnectionUnused EventSubSubscriptionStatus = "websocket_connection_unused"

	EventSubSubscriptionStatusWebsocketDisconnected EventSubSubscriptionStatus = "websocket_disconnected"

	EventSubSubscriptionStatusWebsocketFailedPingPong EventSubSubscriptionStatus = "websocket_failed_ping_pong"

	EventSubSubscriptionStatusWebsocketInternalError EventSubSubscriptionStatus = "websocket_internal_error"

	EventSubSubscriptionStatusWebsocketNetworkError EventSubSubscriptionStatus = "websocket_network_error"

	EventSubSubscriptionStatusWebsocketNetworkTimeout EventSubSubscriptionStatus = "websocket_network_timeout"

	EventSubSubscriptionStatusWebsocketReceivedInboundTraffic EventSubSubscriptionStatus = "websocket_received_inbound_traffic"
)

// IsEventSubSubscriptionStatus returns true if the user passes in a value that is contained in the
// list of enums of EventSubSubscriptionStatus.
func IsEventSubSubscriptionStatus(val EventSubSubscriptionStatus) bool {
	switch val {
	case EventSubSubscriptionStatusAuthorizationRevoked:
		return true
	case EventSubSubscriptionStatusBetaMaintenance:
		return true
	case EventSubSubscriptionStatusEnabled:
		return true
	case EventSubSubscriptionStatusModeratorRemoved:
		return true
	case EventSubSubscriptionStatusNotificationFailuresExceeded:
		return true
	case EventSubSubscriptionStatusUserRemoved:
		return true
	case EventSubSubscriptionStatusVersionRemoved:
		return true
	case EventSubSubscriptionStatusWebhookCallbackVerificationFailed:
		return true
	case EventSubSubscriptionStatusWebhookCallbackVerificationPending:
		return true
	case EventSubSubscriptionStatusWebsocketConnectionUnused:
		return true
	case EventSubSubscriptionStatusWebsocketDisconnected:
		return true
	case EventSubSubscriptionStatusWebsocketFailedPingPong:
		return true
	case EventSubSubscriptionStatusWebsocketInternalError:
		return true
	case EventSubSubscriptionStatusWebsocketNetworkError:
		return true
	case EventSubSubscriptionStatusWebsocketNetworkTimeout:
		return true
	case EventSubSubscriptionStatusWebsocketReceivedInboundTraffic:
		return true
	default:
		return false
	}
}

// EventSubSubscriptionStatusEnumMap returns a map of all of the enum values
var EventSubSubscriptionStatusEnumMap = map[EventSubSubscriptionStatus]EventSubSubscriptionStatus{
	EventSubSubscriptionStatusAuthorizationRevoked:               EventSubSubscriptionStatusAuthorizationRevoked,
	EventSubSubscriptionStatusBetaMaintenance:                    EventSubSubscriptionStatusBetaMaintenance,
	EventSubSubscriptionStatusEnabled:                            EventSubSubscriptionStatusEnabled,
	EventSubSubscriptionStatusModeratorRemoved:                   EventSubSubscriptionStatusModeratorRemoved,
	EventSubSubscriptionStatusNotificationFailuresExceeded:       EventSubSubscriptionStatusNotificationFailuresExceeded,
	EventSubSubscriptionStatusUserRemoved:                        EventSubSubscriptionStatusUserRemoved,
	EventSubSubscriptionStatusVersionRemoved:                     EventSubSubscriptionStatusVersionRemoved,
	EventSubSubscriptionStatusWebhookCallbackVerificationFailed:  EventSubSubscriptionStatusWebhookCallbackVerificationFailed,
	EventSubSubscriptionStatusWebhookCallbackVerificationPending: EventSubSubscriptionStatusWebhookCallbackVerificationPending,
	EventSubSubscriptionStatusWebsocketConnectionUnused:          EventSubSubscriptionStatusWebsocketConnectionUnused,
	EventSubSubscriptionStatusWebsocketDisconnected:              EventSubSubscriptionStatusWebsocketDisconnected,
	EventSubSubscriptionStatusWebsocketFailedPingPong:            EventSubSubscriptionStatusWebsocketFailedPingPong,
	EventSubSubscriptionStatusWebsocketInternalError:             EventSubSubscriptionStatusWebsocketInternalError,
	EventSubSubscriptionStatusWebsocketNetworkError:              EventSubSubscriptionStatusWebsocketNetworkError,
	EventSubSubscriptionStatusWebsocketNetworkTimeout:            EventSubSubscriptionStatusWebsocketNetworkTimeout,
	EventSubSubscriptionStatusWebsocketReceivedInboundTraffic:    EventSubSubscriptionStatusWebsocketReceivedInboundTraffic,
}

// Defines values for EventSubSubscriptionTransportMethod.
const (
	EventSubSubscriptionTransportMethodWebhook EventSubSubscriptionTransportMethod = "webhook"

	EventSubSubscriptionTransportMethodWebsocket EventSubSubscriptionTransportMethod = "websocket"
)

// IsEventSubSubscriptionTransportMethod returns true if the user passes in a value that is contained in the
// list of enums of EventSubSubscriptionTransportMethod.
func IsEventSubSubscriptionTransportMethod(val EventSubSubscriptionTransportMethod) bool {
	switch val {
	case EventSubSubscriptionTransportMethodWebhook:
		return true
	case EventSubSubscriptionTransportMethodWebsocket:
		return true
	default:
		return false
	}
}

// EventSubSubscriptionTransportMethodEnumMap returns a map of all of the enum values
var EventSubSubscriptionTransportMethodEnumMap = map[EventSubSubscriptionTransportMethod]EventSubSubscriptionTransportMethod{
	EventSubSubscriptionTransportMethodWebhook:   EventSubSubscriptionTransportMethodWebhook,
	EventSubSubscriptionTransportMethodWebsocket: EventSubSubscriptionTransportMethodWebsocket,
}

// Defines values for EventSubSubscriptionType.
const (
	EventSubSubscriptionTypeAutomodMessageHold EventSubSubscriptionType = "automod.message.hold"

	EventSubSubscriptionTypeAutomodMessageUpdate EventSubSubscriptionType = "automod.message.update"

	EventSubSubscriptionTypeAutomodSettingsUpdate EventSubSubscriptionType = "automod.settings.update"

	EventSubSubscriptionTypeAutomodTermsUpdate EventSubSubscriptionType = "automod.terms.update"

	EventSubSubscriptionTypeChannelAdBreakBegin EventSubSubscriptionType = "channel.ad_break.begin"

	EventSubSubscriptionTypeChannelBan EventSubSubscriptionType = "channel.ban"

	EventSubSubscriptionTypeChannelChannelPointsAutomaticRewardRedemptionAdd EventSubSubscriptionType = "channel.channel_points_automatic_reward_redemption.add"

	EventSubSubscriptionTypeChannelChannelPointsCustomRewardAdd EventSubSubscriptionType = "channel.channel_points_custom_reward.add"

	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionAdd EventSubSubscriptionType = "channel.channel_points_custom_reward_redemption.add"

	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionUpdate EventSubSubscriptionType = "channel.channel_points_custom_reward_redemption.update"

	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRemove EventSubSubscriptionType = "channel.channel_points_custom_reward.remove"

	EventSubSubscriptionTypeChannelChannelPointsCustomRewardUpdate EventSubSubscriptionType = "channel.channel_points_custom_reward.update"

	EventSubSubscriptionTypeChannelCharityCampaignDonate EventSubSubscriptionType = "channel.charity_campaign.donate"

	EventSubSubscriptionTypeChannelCharityCampaignProgress EventSubSubscriptionType = "channel.charity_campaign.progress"

	EventSubSubscriptionTypeChannelCharityCampaignStart EventSubSubscriptionType = "channel.charity_campaign.start"

	EventSubSubscriptionTypeChannelCharityCampaignStop EventSubSubscriptionType = "channel.charity_campaign.stop"

	EventSubSubscriptionTypeChannelChatClear EventSubSubscriptionType = "channel.chat.clear"

	EventSubSubscriptionTypeChannelChatClearUserMessages EventSubSubscriptionType = "channel.chat.clear_user_messages"

	EventSubSubscriptionTypeChannelChatMessage EventSubSubscriptionType = "channel.chat.message"

	EventSubSubscriptionTypeChannelChatMessageDelete EventSubSubscriptionType = "channel.chat.message_delete"

	EventSubSubscriptionTypeChannelChatNotification EventSubSubscriptionType = "channel.chat.notification"

	EventSubSubscriptionTypeChannelChatSettingsUpdate EventSubSubscriptionType = "channel.chat_settings.update"

	EventSubSubscriptionTypeChannelChatUserMessageHold EventSubSubscriptionType = "channel.chat.user_message_hold"

	EventSubSubscriptionTypeChannelChatUserMessageUpdate EventSubSubscriptionType = "channel.chat.user_message_update"

	EventSubSubscriptionTypeChannelCheer EventSubSubscriptionType = "channel.cheer"

	EventSubSubscriptionTypeChannelFollow EventSubSubscriptionType = "channel.follow"

	EventSubSubscriptionTypeChannelGoalBegin EventSubSubscriptionType = "channel.goal.begin"

	EventSubSubscriptionTypeChannelGoalEnd EventSubSubscriptionType = "channel.goal.end"

	EventSubSubscriptionTypeChannelGoalProgress EventSubSubscriptionType = "channel.goal.progress"

	EventSubSubscriptionTypeChannelGuestStarGuestUpdate EventSubSubscriptionType = "channel.guest_star_guest.update"

	EventSubSubscriptionTypeChannelGuestStarSessionBegin EventSubSubscriptionType = "channel.guest_star_session.begin"

	EventSubSubscriptionTypeChannelGuestStarSessionEnd EventSubSubscriptionType = "channel.guest_star_session.end"

	EventSubSubscriptionTypeChannelGuestStarSettingsUpdate EventSubSubscriptionType = "channel.guest_star_settings.update"

	EventSubSubscriptionTypeChannelHypeTrainBegin EventSubSubscriptionType = "channel.hype_train.begin"

	EventSubSubscriptionTypeChannelHypeTrainEnd EventSubSubscriptionType = "channel.hype_train.end"

	EventSubSubscriptionTypeChannelHypeTrainProgress EventSubSubscriptionType = "channel.hype_train.progress"

	EventSubSubscriptionTypeChannelModerate EventSubSubscriptionType = "channel.moderate"

	EventSubSubscriptionTypeChannelModeratorAdd EventSubSubscriptionType = "channel.moderator.add"

	EventSubSubscriptionTypeChannelModeratorRemove EventSubSubscriptionType = "channel.moderator.remove"

	EventSubSubscriptionTypeChannelPollBegin EventSubSubscriptionType = "channel.poll.begin"

	EventSubSubscriptionTypeChannelPollEnd EventSubSubscriptionType = "channel.poll.end"

	EventSubSubscriptionTypeChannelPollProgress EventSubSubscriptionType = "channel.poll.progress"

	EventSubSubscriptionTypeChannelPredictionBegin EventSubSubscriptionType = "channel.prediction.begin"

	EventSubSubscriptionTypeChannelPredictionEnd EventSubSubscriptionType = "channel.prediction.end"

	EventSubSubscriptionTypeChannelPredictionLock EventSubSubscriptionType = "channel.prediction.lock"

	EventSubSubscriptionTypeChannelPredictionProgress EventSubSubscriptionType = "channel.prediction.progress"

	EventSubSubscriptionTypeChannelRaid EventSubSubscriptionType = "channel.raid"

	EventSubSubscriptionTypeChannelSharedChatBegin EventSubSubscriptionType = "channel.shared_chat.begin"

	EventSubSubscriptionTypeChannelSharedChatEnd EventSubSubscriptionType = "channel.shared_chat.end"

	EventSubSubscriptionTypeChannelSharedChatUpdate EventSubSubscriptionType = "channel.shared_chat.update"

	EventSubSubscriptionTypeChannelShieldModeBegin EventSubSubscriptionType = "channel.shield_mode.begin"

	EventSubSubscriptionTypeChannelShieldModeEnd EventSubSubscriptionType = "channel.shield_mode.end"

	EventSubSubscriptionTypeChannelShoutoutCreate EventSubSubscriptionType = "channel.shoutout.create"

	EventSubSubscriptionTypeChannelShoutoutReceive EventSubSubscriptionType = "channel.shoutout.receive"

	EventSubSubscriptionTypeChannelSubscribe EventSubSubscriptionType = "channel.subscribe"

	EventSubSubscriptionTypeChannelSubscriptionEnd EventSubSubscriptionType = "channel.subscription.end"

	EventSubSubscriptionTypeChannelSubscriptionGift EventSubSubscriptionType = "channel.subscription.gift"

	EventSubSubscriptionTypeChannelSubscriptionMessage EventSubSubscriptionType = "channel.subscription.message"

	EventSubSubscriptionTypeChannelSuspiciousUserMessage EventSubSubscriptionType = "channel.suspicious_user.message"

	EventSubSubscriptionTypeChannelSuspiciousUserUpdate EventSubSubscriptionType = "channel.suspicious_user.update"

	EventSubSubscriptionTypeChannelUnban EventSubSubscriptionType = "channel.unban"

	EventSubSubscriptionTypeChannelUnbanRequestCreate EventSubSubscriptionType = "channel.unban_request.create"

	EventSubSubscriptionTypeChannelUnbanRequestResolve EventSubSubscriptionType = "channel.unban_request.resolve"

	EventSubSubscriptionTypeChannelUpdate EventSubSubscriptionType = "channel.update"

	EventSubSubscriptionTypeChannelVipAdd EventSubSubscriptionType = "channel.vip.add"

	EventSubSubscriptionTypeChannelVipRemove EventSubSubscriptionType = "channel.vip.remove"

	EventSubSubscriptionTypeChannelWarningAcknowledge EventSubSubscriptionType = "channel.warning.acknowledge"

	EventSubSubscriptionTypeChannelWarningSend EventSubSubscriptionType = "channel.warning.send"

	EventSubSubscriptionTypeConduitShardDisabled EventSubSubscriptionType = "conduit.shard.disabled"

	EventSubSubscriptionTypeDropEntitlementGrant EventSubSubscriptionType = "drop.entitlement.grant"

	EventSubSubscriptionTypeExtensionBitsTransactionCreate EventSubSubscriptionType = "extension.bits_transaction.create"

	EventSubSubscriptionTypeStreamOffline EventSubSubscriptionType = "stream.offline"

	EventSubSubscriptionTypeStreamOnline EventSubSubscriptionType = "stream.online"

	EventSubSubscriptionTypeUserAuthorizationGrant EventSubSubscriptionType = "user.authorization.grant"

	EventSubSubscriptionTypeUserAuthorizationRevoke EventSubSubscriptionType = "user.authorization.revoke"

	EventSubSubscriptionTypeUserUpdate EventSubSubscriptionType = "user.update"

	EventSubSubscriptionTypeUserWhisperMessage EventSubSubscriptionType = "user.whisper.message"
)

// IsEventSubSubscriptionType returns true if the user passes in a value that is contained in the
// list of enums of EventSubSubscriptionType.
func IsEventSubSubscriptionType(val EventSubSubscriptionType) bool {
	switch val {
	case EventSubSubscriptionTypeAutomodMessageHold:
		return true
	case EventSubSubscriptionTypeAutomodMessageUpdate:
		return true
	case EventSubSubscriptionTypeAutomodSettingsUpdate:
		return true
	case EventSubSubscriptionTypeAutomodTermsUpdate:
		return true
	case EventSubSubscriptionTypeChannelAdBreakBegin:
		return true
	case EventSubSubscriptionTypeChannelBan:
		return true
	case EventSubSubscriptionTypeChannelChannelPointsAutomaticRewardRedemptionAdd:
		return true
	case EventSubSubscriptionTypeChannelChannelPointsCustomRewardAdd:
		return true
	case EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionAdd:
		return true
	case EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionUpdate:
		return true
	case EventSubSubscriptionTypeChannelChannelPointsCustomRewardRemove:
		return true
	case EventSubSubscriptionTypeChannelChannelPointsCustomRewardUpdate:
		return true
	case EventSubSubscriptionTypeChannelCharityCampaignDonate:
		return true
	case EventSubSubscriptionTypeChannelCharityCampaignProgress:
		return true
	case EventSubSubscriptionTypeChannelCharityCampaignStart:
		return true
	case EventSubSubscriptionTypeChannelCharityCampaignStop:
		return true
	case EventSubSubscriptionTypeChannelChatClear:
		return true
	case EventSubSubscriptionTypeChannelChatClearUserMessages:
		return true
	case EventSubSubscriptionTypeChannelChatMessage:
		return true
	case EventSubSubscriptionTypeChannelChatMessageDelete:
		return true
	case EventSubSubscriptionTypeChannelChatNotification:
		return true
	case EventSubSubscriptionTypeChannelChatSettingsUpdate:
		return true
	case EventSubSubscriptionTypeChannelChatUserMessageHold:
		return true
	case EventSubSubscriptionTypeChannelChatUserMessageUpdate:
		return true
	case EventSubSubscriptionTypeChannelCheer:
		return true
	case EventSubSubscriptionTypeChannelFollow:
		return true
	case EventSubSubscriptionTypeChannelGoalBegin:
		return true
	case EventSubSubscriptionTypeChannelGoalEnd:
		return true
	case EventSubSubscriptionTypeChannelGoalProgress:
		return true
	case EventSubSubscriptionTypeChannelGuestStarGuestUpdate:
		return true
	case EventSubSubscriptionTypeChannelGuestStarSessionBegin:
		return true
	case EventSubSubscriptionTypeChannelGuestStarSessionEnd:
		return true
	case EventSubSubscriptionTypeChannelGuestStarSettingsUpdate:
		return true
	case EventSubSubscriptionTypeChannelHypeTrainBegin:
		return true
	case EventSubSubscriptionTypeChannelHypeTrainEnd:
		return true
	case EventSubSubscriptionTypeChannelHypeTrainProgress:
		return true
	case EventSubSubscriptionTypeChannelModerate:
		return true
	case EventSubSubscriptionTypeChannelModeratorAdd:
		return true
	case EventSubSubscriptionTypeChannelModeratorRemove:
		return true
	case EventSubSubscriptionTypeChannelPollBegin:
		return true
	case EventSubSubscriptionTypeChannelPollEnd:
		return true
	case EventSubSubscriptionTypeChannelPollProgress:
		return true
	case EventSubSubscriptionTypeChannelPredictionBegin:
		return true
	case EventSubSubscriptionTypeChannelPredictionEnd:
		return true
	case EventSubSubscriptionTypeChannelPredictionLock:
		return true
	case EventSubSubscriptionTypeChannelPredictionProgress:
		return true
	case EventSubSubscriptionTypeChannelRaid:
		return true
	case EventSubSubscriptionTypeChannelSharedChatBegin:
		return true
	case EventSubSubscriptionTypeChannelSharedChatEnd:
		return true
	case EventSubSubscriptionTypeChannelSharedChatUpdate:
		return true
	case EventSubSubscriptionTypeChannelShieldModeBegin:
		return true
	case EventSubSubscriptionTypeChannelShieldModeEnd:
		return true
	case EventSubSubscriptionTypeChannelShoutoutCreate:
		return true
	case EventSubSubscriptionTypeChannelShoutoutReceive:
		return true
	case EventSubSubscriptionTypeChannelSubscribe:
		return true
	case EventSubSubscriptionTypeChannelSubscriptionEnd:
		return true
	case EventSubSubscriptionTypeChannelSubscriptionGift:
		return true
	case EventSubSubscriptionTypeChannelSubscriptionMessage:
		return true
	case EventSubSubscriptionTypeChannelSuspiciousUserMessage:
		return true
	case EventSubSubscriptionTypeChannelSuspiciousUserUpdate:
		return true
	case EventSubSubscriptionTypeChannelUnban:
		return true
	case EventSubSubscriptionTypeChannelUnbanRequestCreate:
		return true
	case EventSubSubscriptionTypeChannelUnbanRequestResolve:
		return true
	case EventSubSubscriptionTypeChannelUpdate:
		return true
	case EventSubSubscriptionTypeChannelVipAdd:
		return true
	case EventSubSubscriptionTypeChannelVipRemove:
		return true
	case EventSubSubscriptionTypeChannelWarningAcknowledge:
		return true
	case EventSubSubscriptionTypeChannelWarningSend:
		return true
	case EventSubSubscriptionTypeConduitShardDisabled:
		return true
	case EventSubSubscriptionTypeDropEntitlementGrant:
		return true
	case EventSubSubscriptionTypeExtensionBitsTransactionCreate:
		return true
	case EventSubSubscriptionTypeStreamOffline:
		return true
	case EventSubSubscriptionTypeStreamOnline:
		return true
	case EventSubSubscriptionTypeUserAuthorizationGrant:
		return true
	case EventSubSubscriptionTypeUserAuthorizationRevoke:
		return true
	case EventSubSubscriptionTypeUserUpdate:
		return true
	case EventSubSubscriptionTypeUserWhisperMessage:
		return true
	default:
		return false
	}
}

// EventSubSubscriptionTypeEnumMap returns a map of all of the enum values
var EventSubSubscriptionTypeEnumMap = map[EventSubSubscriptionType]EventSubSubscriptionType{
	EventSubSubscriptionTypeAutomodMessageHold:                               EventSubSubscriptionTypeAutomodMessageHold,
	EventSubSubscriptionTypeAutomodMessageUpdate:                             EventSubSubscriptionTypeAutomodMessageUpdate,
	EventSubSubscriptionTypeAutomodSettingsUpdate:                            EventSubSubscriptionTypeAutomodSettingsUpdate,
	EventSubSubscriptionTypeAutomodTermsUpdate:                               EventSubSubscriptionTypeAutomodTermsUpdate,
	EventSubSubscriptionTypeChannelAdBreakBegin:                              EventSubSubscriptionTypeChannelAdBreakBegin,
	EventSubSubscriptionTypeChannelBan:                                       EventSubSubscriptionTypeChannelBan,
	EventSubSubscriptionTypeChannelChannelPointsAutomaticRewardRedemptionAdd: EventSubSubscriptionTypeChannelChannelPointsAutomaticRewardRedemptionAdd,
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardAdd:              EventSubSubscriptionTypeChannelChannelPointsCustomRewardAdd,
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionAdd:    EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionAdd,
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionUpdate: EventSubSubscriptionTypeChannelChannelPointsCustomRewardRedemptionUpdate,
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardRemove:           EventSubSubscriptionTypeChannelChannelPointsCustomRewardRemove,
	EventSubSubscriptionTypeChannelChannelPointsCustomRewardUpdate:           EventSubSubscriptionTypeChannelChannelPointsCustomRewardUpdate,
	EventSubSubscriptionTypeChannelCharityCampaignDonate:                     EventSubSubscriptionTypeChannelCharityCampaignDonate,
	EventSubSubscriptionTypeChannelCharityCampaignProgress:                   EventSubSubscriptionTypeChannelCharityCampaignProgress,
	EventSubSubscriptionTypeChannelCharityCampaignStart:                      EventSubSubscriptionTypeChannelCharityCampaignStart,
	EventSubSubscriptionTypeChannelCharityCampaignStop:                       EventSubSubscriptionTypeChannelCharityCampaignStop,
	EventSubSubscriptionTypeChannelChatClear:                                 EventSubSubscriptionTypeChannelChatClear,
	EventSubSubscriptionTypeChannelChatClearUserMessages:                     EventSubSubscriptionTypeChannelChatClearUserMessages,
	EventSubSubscriptionTypeChannelChatMessage:                               EventSubSubscriptionTypeChannelChatMessage,
	EventSubSubscriptionTypeChannelChatMessageDelete:                         EventSubSubscriptionTypeChannelChatMessageDelete,
	EventSubSubscriptionTypeChannelChatNotification:                          EventSubSubscriptionTypeChannelChatNotification,
	EventSubSubscriptionTypeChannelChatSettingsUpdate:                        EventSubSubscriptionTypeChannelChatSettingsUpdate,
	EventSubSubscriptionTypeChannelChatUserMessageHold:                       EventSubSubscriptionTypeChannelChatUserMessageHold,
	EventSubSubscriptionTypeChannelChatUserMessageUpdate:                     EventSubSubscriptionTypeChannelChatUserMessageUpdate,
	EventSubSubscriptionTypeChannelCheer:                                     EventSubSubscriptionTypeChannelCheer,
	EventSubSubscriptionTypeChannelFollow:                                    EventSubSubscriptionTypeChannelFollow,
	EventSubSubscriptionTypeChannelGoalBegin:                                 EventSubSubscriptionTypeChannelGoalBegin,
	EventSubSubscriptionTypeChannelGoalEnd:                                   EventSubSubscriptionTypeChannelGoalEnd,
	EventSubSubscriptionTypeChannelGoalProgress:                              EventSubSubscriptionTypeChannelGoalProgress,
	EventSubSubscriptionTypeChannelGuestStarGuestUpdate:                      EventSubSubscriptionTypeChannelGuestStarGuestUpdate,
	EventSubSubscriptionTypeChannelGuestStarSessionBegin:                     EventSubSubscriptionTypeChannelGuestStarSessionBegin,
	EventSubSubscriptionTypeChannelGuestStarSessionEnd:                       EventSubSubscriptionTypeChannelGuestStarSessionEnd,
	EventSubSubscriptionTypeChannelGuestStarSettingsUpdate:                   EventSubSubscriptionTypeChannelGuestStarSettingsUpdate,
	EventSubSubscriptionTypeChannelHypeTrainBegin:                            EventSubSubscriptionTypeChannelHypeTrainBegin,
	EventSubSubscriptionTypeChannelHypeTrainEnd:                              EventSubSubscriptionTypeChannelHypeTrainEnd,
	EventSubSubscriptionTypeChannelHypeTrainProgress:                         EventSubSubscriptionTypeChannelHypeTrainProgress,
	EventSubSubscriptionTypeChannelModerate:                                  EventSubSubscriptionTypeChannelModerate,
	EventSubSubscriptionTypeChannelModeratorAdd:                              EventSubSubscriptionTypeChannelModeratorAdd,
	EventSubSubscriptionTypeChannelModeratorRemove:                           EventSubSubscriptionTypeChannelModeratorRemove,
	EventSubSubscriptionTypeChannelPollBegin:                                 EventSubSubscriptionTypeChannelPollBegin,
	EventSubSubscriptionTypeChannelPollEnd:                                   EventSubSubscriptionTypeChannelPollEnd,
	EventSubSubscriptionTypeChannelPollProgress:                              EventSubSubscriptionTypeChannelPollProgress,
	EventSubSubscriptionTypeChannelPredictionBegin:                           EventSubSubscriptionTypeChannelPredictionBegin,
	EventSubSubscriptionTypeChannelPredictionEnd:                             EventSubSubscriptionTypeChannelPredictionEnd,
	EventSubSubscriptionTypeChannelPredictionLock:                            EventSubSubscriptionTypeChannelPredictionLock,
	EventSubSubscriptionTypeChannelPredictionProgress:                        EventSubSubscriptionTypeChannelPredictionProgress,
	EventSubSubscriptionTypeChannelRaid:                                      EventSubSubscriptionTypeChannelRaid,
	EventSubSubscriptionTypeChannelSharedChatBegin:                           EventSubSubscriptionTypeChannelSharedChatBegin,
	EventSubSubscriptionTypeChannelSharedChatEnd:                             EventSubSubscriptionTypeChannelSharedChatEnd,
	EventSubSubscriptionTypeChannelSharedChatUpdate:                          EventSubSubscriptionTypeChannelSharedChatUpdate,
	EventSubSubscriptionTypeChannelShieldModeBegin:                           EventSubSubscriptionTypeChannelShieldModeBegin,
	EventSubSubscriptionTypeChannelShieldModeEnd:                             EventSubSubscriptionTypeChannelShieldModeEnd,
	EventSubSubscriptionTypeChannelShoutoutCreate:                            EventSubSubscriptionTypeChannelShoutoutCreate,
	EventSubSubscriptionTypeChannelShoutoutReceive:                           EventSubSubscriptionTypeChannelShoutoutReceive,
	EventSubSubscriptionTypeChannelSubscribe:                                 EventSubSubscriptionTypeChannelSubscribe,
	EventSubSubscriptionTypeChannelSubscriptionEnd:                           EventSubSubscriptionTypeChannelSubscriptionEnd,
	EventSubSubscriptionTypeChannelSubscriptionGift:                          EventSubSubscriptionTypeChannelSubscriptionGift,
	EventSubSubscriptionTypeChannelSubscriptionMessage:                       EventSubSubscriptionTypeChannelSubscriptionMessage,
	EventSubSubscriptionTypeChannelSuspiciousUserMessage:                     EventSubSubscriptionTypeChannelSuspiciousUserMessage,
	EventSubSubscriptionTypeChannelSuspiciousUserUpdate:                      EventSubSubscriptionTypeChannelSuspiciousUserUpdate,
	EventSubSubscriptionTypeChannelUnban:                                     EventSubSubscriptionTypeChannelUnban,
	EventSubSubscriptionTypeChannelUnbanRequestCreate:                        EventSubSubscriptionTypeChannelUnbanRequestCreate,
	EventSubSubscriptionTypeChannelUnbanRequestResolve:                       EventSubSubscriptionTypeChannelUnbanRequestResolve,
	EventSubSubscriptionTypeChannelUpdate:                                    EventSubSubscriptionTypeChannelUpdate,
	EventSubSubscriptionTypeChannelVipAdd:                                    EventSubSubscriptionTypeChannelVipAdd,
	EventSubSubscriptionTypeChannelVipRemove:                                 EventSubSubscriptionTypeChannelVipRemove,
	EventSubSubscriptionTypeChannelWarningAcknowledge:                        EventSubSubscriptionTypeChannelWarningAcknowledge,
	EventSubSubscriptionTypeChannelWarningSend:                               EventSubSubscriptionTypeChannelWarningSend,
	EventSubSubscriptionTypeConduitShardDisabled:                             EventSubSubscriptionTypeConduitShardDisabled,
	EventSubSubscriptionTypeDropEntitlementGrant:                             EventSubSubscriptionTypeDropEntitlementGrant,
	EventSubSubscriptionTypeExtensionBitsTransactionCreate:                   EventSubSubscriptionTypeExtensionBitsTransactionCreate,
	EventSubSubscriptionTypeStreamOffline:                                    EventSubSubscriptionTypeStreamOffline,
	EventSubSubscriptionTypeStreamOnline:                                     EventSubSubscriptionTypeStreamOnline,
	EventSubSubscriptionTypeUserAuthorizationGrant:                           EventSubSubscriptionTypeUserAuthorizationGrant,
	EventSubSubscriptionTypeUserAuthorizationRevoke:                          EventSubSubscriptionTypeUserAuthorizationRevoke,
	EventSubSubscriptionTypeUserUpdate:                                       EventSubSubscriptionTypeUserUpdate,
	EventSubSubscriptionTypeUserWhisperMessage:                               EventSubSubscriptionTypeUserWhisperMessage,
}

// Defines values for ExtensionConfigurationLocation.
const (
	ExtensionConfigurationLocationCustom ExtensionConfigurationLocation = "custom"

	ExtensionConfigurationLocationHosted ExtensionConfigurationLocation = "hosted"

	ExtensionConfigurationLocationNone ExtensionConfigurationLocation = "none"
)

// IsExtensionConfigurationLocation returns true if the user passes in a value that is contained in the
// list of enums of ExtensionConfigurationLocation.
func IsExtensionConfigurationLocation(val ExtensionConfigurationLocation) bool {
	switch val {
	case ExtensionConfigurationLocationCustom:
		return true
	case ExtensionConfigurationLocationHosted:
		return true
	case ExtensionConfigurationLocationNone:
		return true
	default:
		return false
	}
}

// ExtensionConfigurationLocationEnumMap returns a map of all of the enum values
var ExtensionConfigurationLocationEnumMap = map[ExtensionConfigurationLocation]ExtensionConfigurationLocation{
	ExtensionConfigurationLocationCustom: ExtensionConfigurationLocationCustom,
	ExtensionConfigurationLocationHosted: ExtensionConfigurationLocationHosted,
	ExtensionConfigurationLocationNone:   ExtensionConfigurationLocationNone,
}

// Defines values for ExtensionState.
const (
	Approved ExtensionState = "Approved"

	AssetsUploaded ExtensionState = "AssetsUploaded"

	Deleted ExtensionState = "Deleted"

	Deprecated ExtensionState = "Deprecated"

	InReview ExtensionState = "InReview"

	InTest ExtensionState = "InTest"

	PendingAction ExtensionState = "PendingAction"

	Rejected ExtensionState = "Rejected"

	Released ExtensionState = "Released"
)

// IsExtensionState returns true if the user passes in a value that is contained in the
// list of enums of ExtensionState.
func IsExtensionState(val ExtensionState) bool {
	switch val {
	case Approved:
		return true
	case AssetsUploaded:
		return true
	case Deleted:
		return true
	case Deprecated:
		return true
	case InReview:
		return true
	case InTest:
		return true
	case PendingAction:
		return true
	case Rejected:
		return true
	case Released:
		return true
	default:
		return false
	}
}

// ExtensionStateEnumMap returns a map of all of the enum values
var ExtensionStateEnumMap = map[ExtensionState]ExtensionState{
	Approved:       Approved,
	AssetsUploaded: AssetsUploaded,
	Deleted:        Deleted,
	Deprecated:     Deprecated,
	InReview:       InReview,
	InTest:         InTest,
	PendingAction:  PendingAction,
	Rejected:       Rejected,
	Released:       Released,
}

// Defines values for ExtensionSubscriptionsSupportLevel.
const (
	ExtensionSubscriptionsSupportLevelNone ExtensionSubscriptionsSupportLevel = "none"

	ExtensionSubscriptionsSupportLevelOptional ExtensionSubscriptionsSupportLevel = "optional"
)

// IsExtensionSubscriptionsSupportLevel returns true if the user passes in a value that is contained in the
// list of enums of ExtensionSubscriptionsSupportLevel.
func IsExtensionSubscriptionsSupportLevel(val ExtensionSubscriptionsSupportLevel) bool {
	switch val {
	case ExtensionSubscriptionsSupportLevelNone:
		return true
	case ExtensionSubscriptionsSupportLevelOptional:
		return true
	default:
		return false
	}
}

// ExtensionSubscriptionsSupportLevelEnumMap returns a map of all of the enum values
var ExtensionSubscriptionsSupportLevelEnumMap = map[ExtensionSubscriptionsSupportLevel]ExtensionSubscriptionsSupportLevel{
	ExtensionSubscriptionsSupportLevelNone:     ExtensionSubscriptionsSupportLevelNone,
	ExtensionSubscriptionsSupportLevelOptional: ExtensionSubscriptionsSupportLevelOptional,
}

// Defines values for ExtensionBitsProductCostType.
const (
	ExtensionBitsProductCostTypeBits ExtensionBitsProductCostType = "bits"
)

// IsExtensionBitsProductCostType returns true if the user passes in a value that is contained in the
// list of enums of ExtensionBitsProductCostType.
func IsExtensionBitsProductCostType(val ExtensionBitsProductCostType) bool {
	switch val {
	case ExtensionBitsProductCostTypeBits:
		return true
	default:
		return false
	}
}

// ExtensionBitsProductCostTypeEnumMap returns a map of all of the enum values
var ExtensionBitsProductCostTypeEnumMap = map[ExtensionBitsProductCostType]ExtensionBitsProductCostType{
	ExtensionBitsProductCostTypeBits: ExtensionBitsProductCostTypeBits,
}

// Defines values for ExtensionConfigurationSegmentSegment.
const (
	ExtensionConfigurationSegmentSegmentBroadcaster ExtensionConfigurationSegmentSegment = "broadcaster"

	ExtensionConfigurationSegmentSegmentDeveloper ExtensionConfigurationSegmentSegment = "developer"

	ExtensionConfigurationSegmentSegmentGlobal ExtensionConfigurationSegmentSegment = "global"
)

// IsExtensionConfigurationSegmentSegment returns true if the user passes in a value that is contained in the
// list of enums of ExtensionConfigurationSegmentSegment.
func IsExtensionConfigurationSegmentSegment(val ExtensionConfigurationSegmentSegment) bool {
	switch val {
	case ExtensionConfigurationSegmentSegmentBroadcaster:
		return true
	case ExtensionConfigurationSegmentSegmentDeveloper:
		return true
	case ExtensionConfigurationSegmentSegmentGlobal:
		return true
	default:
		return false
	}
}

// ExtensionConfigurationSegmentSegmentEnumMap returns a map of all of the enum values
var ExtensionConfigurationSegmentSegmentEnumMap = map[ExtensionConfigurationSegmentSegment]ExtensionConfigurationSegmentSegment{
	ExtensionConfigurationSegmentSegmentBroadcaster: ExtensionConfigurationSegmentSegmentBroadcaster,
	ExtensionConfigurationSegmentSegmentDeveloper:   ExtensionConfigurationSegmentSegmentDeveloper,
	ExtensionConfigurationSegmentSegmentGlobal:      ExtensionConfigurationSegmentSegmentGlobal,
}

// Defines values for ExtensionTransactionProductDataCostType.
const (
	ExtensionTransactionProductDataCostTypeBits ExtensionTransactionProductDataCostType = "bits"
)

// IsExtensionTransactionProductDataCostType returns true if the user passes in a value that is contained in the
// list of enums of ExtensionTransactionProductDataCostType.
func IsExtensionTransactionProductDataCostType(val ExtensionTransactionProductDataCostType) bool {
	switch val {
	case ExtensionTransactionProductDataCostTypeBits:
		return true
	default:
		return false
	}
}

// ExtensionTransactionProductDataCostTypeEnumMap returns a map of all of the enum values
var ExtensionTransactionProductDataCostTypeEnumMap = map[ExtensionTransactionProductDataCostType]ExtensionTransactionProductDataCostType{
	ExtensionTransactionProductDataCostTypeBits: ExtensionTransactionProductDataCostTypeBits,
}

// Defines values for ExtensionTransactionProductType.
const (
	BITSINEXTENSION ExtensionTransactionProductType = "BITS_IN_EXTENSION"
)

// IsExtensionTransactionProductType returns true if the user passes in a value that is contained in the
// list of enums of ExtensionTransactionProductType.
func IsExtensionTransactionProductType(val ExtensionTransactionProductType) bool {
	switch val {
	case BITSINEXTENSION:
		return true
	default:
		return false
	}
}

// ExtensionTransactionProductTypeEnumMap returns a map of all of the enum values
var ExtensionTransactionProductTypeEnumMap = map[ExtensionTransactionProductType]ExtensionTransactionProductType{
	BITSINEXTENSION: BITSINEXTENSION,
}

// Defines values for GetChannelGuestStarSettingsResponseGroupLayout.
const (
	GetChannelGuestStarSettingsResponseGroupLayoutSCREENSHARELAYOUT GetChannelGuestStarSettingsResponseGroupLayout = "SCREENSHARE_LAYOUT"

	GetChannelGuestStarSettingsResponseGroupLayoutTILEDLAYOUT GetChannelGuestStarSettingsResponseGroupLayout = "TILED_LAYOUT"
)

// IsGetChannelGuestStarSettingsResponseGroupLayout returns true if the user passes in a value that is contained in the
// list of enums of GetChannelGuestStarSettingsResponseGroupLayout.
func IsGetChannelGuestStarSettingsResponseGroupLayout(val GetChannelGuestStarSettingsResponseGroupLayout) bool {
	switch val {
	case GetChannelGuestStarSettingsResponseGroupLayoutSCREENSHARELAYOUT:
		return true
	case GetChannelGuestStarSettingsResponseGroupLayoutTILEDLAYOUT:
		return true
	default:
		return false
	}
}

// GetChannelGuestStarSettingsResponseGroupLayoutEnumMap returns a map of all of the enum values
var GetChannelGuestStarSettingsResponseGroupLayoutEnumMap = map[GetChannelGuestStarSettingsResponseGroupLayout]GetChannelGuestStarSettingsResponseGroupLayout{
	GetChannelGuestStarSettingsResponseGroupLayoutSCREENSHARELAYOUT: GetChannelGuestStarSettingsResponseGroupLayoutSCREENSHARELAYOUT,
	GetChannelGuestStarSettingsResponseGroupLayoutTILEDLAYOUT:       GetChannelGuestStarSettingsResponseGroupLayoutTILEDLAYOUT,
}

// Defines values for GetConduitShardsResponseDataStatus.
const (
	GetConduitShardsResponseDataStatusEnabled GetConduitShardsResponseDataStatus = "enabled"

	GetConduitShardsResponseDataStatusNotificationFailuresExceeded GetConduitShardsResponseDataStatus = "notification_failures_exceeded"

	GetConduitShardsResponseDataStatusWebhookCallbackVerificationFailed GetConduitShardsResponseDataStatus = "webhook_callback_verification_failed"

	GetConduitShardsResponseDataStatusWebhookCallbackVerificationPending GetConduitShardsResponseDataStatus = "webhook_callback_verification_pending"

	GetConduitShardsResponseDataStatusWebsocketDisconnected GetConduitShardsResponseDataStatus = "websocket_disconnected"

	GetConduitShardsResponseDataStatusWebsocketFailedPingPong GetConduitShardsResponseDataStatus = "websocket_failed_ping_pong"

	GetConduitShardsResponseDataStatusWebsocketFailedToReconnect GetConduitShardsResponseDataStatus = "websocket_failed_to_reconnect"

	GetConduitShardsResponseDataStatusWebsocketInternalError GetConduitShardsResponseDataStatus = "websocket_internal_error"

	GetConduitShardsResponseDataStatusWebsocketNetworkError GetConduitShardsResponseDataStatus = "websocket_network_error"

	GetConduitShardsResponseDataStatusWebsocketNetworkTimeout GetConduitShardsResponseDataStatus = "websocket_network_timeout"

	GetConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic GetConduitShardsResponseDataStatus = "websocket_received_inbound_traffic"
)

// IsGetConduitShardsResponseDataStatus returns true if the user passes in a value that is contained in the
// list of enums of GetConduitShardsResponseDataStatus.
func IsGetConduitShardsResponseDataStatus(val GetConduitShardsResponseDataStatus) bool {
	switch val {
	case GetConduitShardsResponseDataStatusEnabled:
		return true
	case GetConduitShardsResponseDataStatusNotificationFailuresExceeded:
		return true
	case GetConduitShardsResponseDataStatusWebhookCallbackVerificationFailed:
		return true
	case GetConduitShardsResponseDataStatusWebhookCallbackVerificationPending:
		return true
	case GetConduitShardsResponseDataStatusWebsocketDisconnected:
		return true
	case GetConduitShardsResponseDataStatusWebsocketFailedPingPong:
		return true
	case GetConduitShardsResponseDataStatusWebsocketFailedToReconnect:
		return true
	case GetConduitShardsResponseDataStatusWebsocketInternalError:
		return true
	case GetConduitShardsResponseDataStatusWebsocketNetworkError:
		return true
	case GetConduitShardsResponseDataStatusWebsocketNetworkTimeout:
		return true
	case GetConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic:
		return true
	default:
		return false
	}
}

// GetConduitShardsResponseDataStatusEnumMap returns a map of all of the enum values
var GetConduitShardsResponseDataStatusEnumMap = map[GetConduitShardsResponseDataStatus]GetConduitShardsResponseDataStatus{
	GetConduitShardsResponseDataStatusEnabled:                            GetConduitShardsResponseDataStatusEnabled,
	GetConduitShardsResponseDataStatusNotificationFailuresExceeded:       GetConduitShardsResponseDataStatusNotificationFailuresExceeded,
	GetConduitShardsResponseDataStatusWebhookCallbackVerificationFailed:  GetConduitShardsResponseDataStatusWebhookCallbackVerificationFailed,
	GetConduitShardsResponseDataStatusWebhookCallbackVerificationPending: GetConduitShardsResponseDataStatusWebhookCallbackVerificationPending,
	GetConduitShardsResponseDataStatusWebsocketDisconnected:              GetConduitShardsResponseDataStatusWebsocketDisconnected,
	GetConduitShardsResponseDataStatusWebsocketFailedPingPong:            GetConduitShardsResponseDataStatusWebsocketFailedPingPong,
	GetConduitShardsResponseDataStatusWebsocketFailedToReconnect:         GetConduitShardsResponseDataStatusWebsocketFailedToReconnect,
	GetConduitShardsResponseDataStatusWebsocketInternalError:             GetConduitShardsResponseDataStatusWebsocketInternalError,
	GetConduitShardsResponseDataStatusWebsocketNetworkError:              GetConduitShardsResponseDataStatusWebsocketNetworkError,
	GetConduitShardsResponseDataStatusWebsocketNetworkTimeout:            GetConduitShardsResponseDataStatusWebsocketNetworkTimeout,
	GetConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic:    GetConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic,
}

// Defines values for GetConduitShardsResponseDataTransportMethod.
const (
	GetConduitShardsResponseDataTransportMethodWebhook GetConduitShardsResponseDataTransportMethod = "webhook"

	GetConduitShardsResponseDataTransportMethodWebsocket GetConduitShardsResponseDataTransportMethod = "websocket"
)

// IsGetConduitShardsResponseDataTransportMethod returns true if the user passes in a value that is contained in the
// list of enums of GetConduitShardsResponseDataTransportMethod.
func IsGetConduitShardsResponseDataTransportMethod(val GetConduitShardsResponseDataTransportMethod) bool {
	switch val {
	case GetConduitShardsResponseDataTransportMethodWebhook:
		return true
	case GetConduitShardsResponseDataTransportMethodWebsocket:
		return true
	default:
		return false
	}
}

// GetConduitShardsResponseDataTransportMethodEnumMap returns a map of all of the enum values
var GetConduitShardsResponseDataTransportMethodEnumMap = map[GetConduitShardsResponseDataTransportMethod]GetConduitShardsResponseDataTransportMethod{
	GetConduitShardsResponseDataTransportMethodWebhook:   GetConduitShardsResponseDataTransportMethodWebhook,
	GetConduitShardsResponseDataTransportMethodWebsocket: GetConduitShardsResponseDataTransportMethodWebsocket,
}

// Defines values for GetUserEmotesResponseDataEmoteType.
const (
	GetUserEmotesResponseDataEmoteTypeBitstier GetUserEmotesResponseDataEmoteType = "bitstier"

	GetUserEmotesResponseDataEmoteTypeChannelpoints GetUserEmotesResponseDataEmoteType = "channelpoints"

	GetUserEmotesResponseDataEmoteTypeFollower GetUserEmotesResponseDataEmoteType = "follower"

	GetUserEmotesResponseDataEmoteTypeGlobals GetUserEmotesResponseDataEmoteType = "globals"

	GetUserEmotesResponseDataEmoteTypeHypetrain GetUserEmotesResponseDataEmoteType = "hypetrain"

	GetUserEmotesResponseDataEmoteTypeLimitedtime GetUserEmotesResponseDataEmoteType = "limitedtime"

	GetUserEmotesResponseDataEmoteTypeNone GetUserEmotesResponseDataEmoteType = "none"

	GetUserEmotesResponseDataEmoteTypeOwl2019 GetUserEmotesResponseDataEmoteType = "owl2019"

	GetUserEmotesResponseDataEmoteTypePrime GetUserEmotesResponseDataEmoteType = "prime"

	GetUserEmotesResponseDataEmoteTypeRewards GetUserEmotesResponseDataEmoteType = "rewards"

	GetUserEmotesResponseDataEmoteTypeSmilies GetUserEmotesResponseDataEmoteType = "smilies"

	GetUserEmotesResponseDataEmoteTypeSubscriptions GetUserEmotesResponseDataEmoteType = "subscriptions"

	GetUserEmotesResponseDataEmoteTypeTurbo GetUserEmotesResponseDataEmoteType = "turbo"

	GetUserEmotesResponseDataEmoteTypeTwofactor GetUserEmotesResponseDataEmoteType = "twofactor"
)

// IsGetUserEmotesResponseDataEmoteType returns true if the user passes in a value that is contained in the
// list of enums of GetUserEmotesResponseDataEmoteType.
func IsGetUserEmotesResponseDataEmoteType(val GetUserEmotesResponseDataEmoteType) bool {
	switch val {
	case GetUserEmotesResponseDataEmoteTypeBitstier:
		return true
	case GetUserEmotesResponseDataEmoteTypeChannelpoints:
		return true
	case GetUserEmotesResponseDataEmoteTypeFollower:
		return true
	case GetUserEmotesResponseDataEmoteTypeGlobals:
		return true
	case GetUserEmotesResponseDataEmoteTypeHypetrain:
		return true
	case GetUserEmotesResponseDataEmoteTypeLimitedtime:
		return true
	case GetUserEmotesResponseDataEmoteTypeNone:
		return true
	case GetUserEmotesResponseDataEmoteTypeOwl2019:
		return true
	case GetUserEmotesResponseDataEmoteTypePrime:
		return true
	case GetUserEmotesResponseDataEmoteTypeRewards:
		return true
	case GetUserEmotesResponseDataEmoteTypeSmilies:
		return true
	case GetUserEmotesResponseDataEmoteTypeSubscriptions:
		return true
	case GetUserEmotesResponseDataEmoteTypeTurbo:
		return true
	case GetUserEmotesResponseDataEmoteTypeTwofactor:
		return true
	default:
		return false
	}
}

// GetUserEmotesResponseDataEmoteTypeEnumMap returns a map of all of the enum values
var GetUserEmotesResponseDataEmoteTypeEnumMap = map[GetUserEmotesResponseDataEmoteType]GetUserEmotesResponseDataEmoteType{
	GetUserEmotesResponseDataEmoteTypeBitstier:      GetUserEmotesResponseDataEmoteTypeBitstier,
	GetUserEmotesResponseDataEmoteTypeChannelpoints: GetUserEmotesResponseDataEmoteTypeChannelpoints,
	GetUserEmotesResponseDataEmoteTypeFollower:      GetUserEmotesResponseDataEmoteTypeFollower,
	GetUserEmotesResponseDataEmoteTypeGlobals:       GetUserEmotesResponseDataEmoteTypeGlobals,
	GetUserEmotesResponseDataEmoteTypeHypetrain:     GetUserEmotesResponseDataEmoteTypeHypetrain,
	GetUserEmotesResponseDataEmoteTypeLimitedtime:   GetUserEmotesResponseDataEmoteTypeLimitedtime,
	GetUserEmotesResponseDataEmoteTypeNone:          GetUserEmotesResponseDataEmoteTypeNone,
	GetUserEmotesResponseDataEmoteTypeOwl2019:       GetUserEmotesResponseDataEmoteTypeOwl2019,
	GetUserEmotesResponseDataEmoteTypePrime:         GetUserEmotesResponseDataEmoteTypePrime,
	GetUserEmotesResponseDataEmoteTypeRewards:       GetUserEmotesResponseDataEmoteTypeRewards,
	GetUserEmotesResponseDataEmoteTypeSmilies:       GetUserEmotesResponseDataEmoteTypeSmilies,
	GetUserEmotesResponseDataEmoteTypeSubscriptions: GetUserEmotesResponseDataEmoteTypeSubscriptions,
	GetUserEmotesResponseDataEmoteTypeTurbo:         GetUserEmotesResponseDataEmoteTypeTurbo,
	GetUserEmotesResponseDataEmoteTypeTwofactor:     GetUserEmotesResponseDataEmoteTypeTwofactor,
}

// Defines values for GlobalEmoteFormat.
const (
	Animated GlobalEmoteFormat = "animated"

	Static GlobalEmoteFormat = "static"
)

// IsGlobalEmoteFormat returns true if the user passes in a value that is contained in the
// list of enums of GlobalEmoteFormat.
func IsGlobalEmoteFormat(val GlobalEmoteFormat) bool {
	switch val {
	case Animated:
		return true
	case Static:
		return true
	default:
		return false
	}
}

// GlobalEmoteFormatEnumMap returns a map of all of the enum values
var GlobalEmoteFormatEnumMap = map[GlobalEmoteFormat]GlobalEmoteFormat{
	Animated: Animated,
	Static:   Static,
}

// Defines values for GlobalEmoteScale.
const (
	N10 GlobalEmoteScale = "1.0"

	N20 GlobalEmoteScale = "2.0"

	N30 GlobalEmoteScale = "3.0"
)

// IsGlobalEmoteScale returns true if the user passes in a value that is contained in the
// list of enums of GlobalEmoteScale.
func IsGlobalEmoteScale(val GlobalEmoteScale) bool {
	switch val {
	case N10:
		return true
	case N20:
		return true
	case N30:
		return true
	default:
		return false
	}
}

// GlobalEmoteScaleEnumMap returns a map of all of the enum values
var GlobalEmoteScaleEnumMap = map[GlobalEmoteScale]GlobalEmoteScale{
	N10: N10,
	N20: N20,
	N30: N30,
}

// Defines values for GlobalEmoteThemeMode.
const (
	Dark GlobalEmoteThemeMode = "dark"

	Light GlobalEmoteThemeMode = "light"
)

// IsGlobalEmoteThemeMode returns true if the user passes in a value that is contained in the
// list of enums of GlobalEmoteThemeMode.
func IsGlobalEmoteThemeMode(val GlobalEmoteThemeMode) bool {
	switch val {
	case Dark:
		return true
	case Light:
		return true
	default:
		return false
	}
}

// GlobalEmoteThemeModeEnumMap returns a map of all of the enum values
var GlobalEmoteThemeModeEnumMap = map[GlobalEmoteThemeMode]GlobalEmoteThemeMode{
	Dark:  Dark,
	Light: Light,
}

// Defines values for HypeTrainEventEventDataLastContributionType.
const (
	HypeTrainEventEventDataLastContributionTypeBITS HypeTrainEventEventDataLastContributionType = "BITS"

	HypeTrainEventEventDataLastContributionTypeOTHER HypeTrainEventEventDataLastContributionType = "OTHER"

	HypeTrainEventEventDataLastContributionTypeSUBS HypeTrainEventEventDataLastContributionType = "SUBS"
)

// IsHypeTrainEventEventDataLastContributionType returns true if the user passes in a value that is contained in the
// list of enums of HypeTrainEventEventDataLastContributionType.
func IsHypeTrainEventEventDataLastContributionType(val HypeTrainEventEventDataLastContributionType) bool {
	switch val {
	case HypeTrainEventEventDataLastContributionTypeBITS:
		return true
	case HypeTrainEventEventDataLastContributionTypeOTHER:
		return true
	case HypeTrainEventEventDataLastContributionTypeSUBS:
		return true
	default:
		return false
	}
}

// HypeTrainEventEventDataLastContributionTypeEnumMap returns a map of all of the enum values
var HypeTrainEventEventDataLastContributionTypeEnumMap = map[HypeTrainEventEventDataLastContributionType]HypeTrainEventEventDataLastContributionType{
	HypeTrainEventEventDataLastContributionTypeBITS:  HypeTrainEventEventDataLastContributionTypeBITS,
	HypeTrainEventEventDataLastContributionTypeOTHER: HypeTrainEventEventDataLastContributionTypeOTHER,
	HypeTrainEventEventDataLastContributionTypeSUBS:  HypeTrainEventEventDataLastContributionTypeSUBS,
}

// Defines values for HypeTrainEventEventDataTopContributionsType.
const (
	HypeTrainEventEventDataTopContributionsTypeBITS HypeTrainEventEventDataTopContributionsType = "BITS"

	HypeTrainEventEventDataTopContributionsTypeOTHER HypeTrainEventEventDataTopContributionsType = "OTHER"

	HypeTrainEventEventDataTopContributionsTypeSUBS HypeTrainEventEventDataTopContributionsType = "SUBS"
)

// IsHypeTrainEventEventDataTopContributionsType returns true if the user passes in a value that is contained in the
// list of enums of HypeTrainEventEventDataTopContributionsType.
func IsHypeTrainEventEventDataTopContributionsType(val HypeTrainEventEventDataTopContributionsType) bool {
	switch val {
	case HypeTrainEventEventDataTopContributionsTypeBITS:
		return true
	case HypeTrainEventEventDataTopContributionsTypeOTHER:
		return true
	case HypeTrainEventEventDataTopContributionsTypeSUBS:
		return true
	default:
		return false
	}
}

// HypeTrainEventEventDataTopContributionsTypeEnumMap returns a map of all of the enum values
var HypeTrainEventEventDataTopContributionsTypeEnumMap = map[HypeTrainEventEventDataTopContributionsType]HypeTrainEventEventDataTopContributionsType{
	HypeTrainEventEventDataTopContributionsTypeBITS:  HypeTrainEventEventDataTopContributionsTypeBITS,
	HypeTrainEventEventDataTopContributionsTypeOTHER: HypeTrainEventEventDataTopContributionsTypeOTHER,
	HypeTrainEventEventDataTopContributionsTypeSUBS:  HypeTrainEventEventDataTopContributionsTypeSUBS,
}

// Defines values for ManageHeldAutoModMessagesBodyAction.
const (
	ALLOW ManageHeldAutoModMessagesBodyAction = "ALLOW"

	DENY ManageHeldAutoModMessagesBodyAction = "DENY"
)

// IsManageHeldAutoModMessagesBodyAction returns true if the user passes in a value that is contained in the
// list of enums of ManageHeldAutoModMessagesBodyAction.
func IsManageHeldAutoModMessagesBodyAction(val ManageHeldAutoModMessagesBodyAction) bool {
	switch val {
	case ALLOW:
		return true
	case DENY:
		return true
	default:
		return false
	}
}

// ManageHeldAutoModMessagesBodyActionEnumMap returns a map of all of the enum values
var ManageHeldAutoModMessagesBodyActionEnumMap = map[ManageHeldAutoModMessagesBodyAction]ManageHeldAutoModMessagesBodyAction{
	ALLOW: ALLOW,
	DENY:  DENY,
}

// Defines values for ModifyChannelInformationBodyContentClassificationLabelsId.
const (
	DrugsIntoxication ModifyChannelInformationBodyContentClassificationLabelsId = "DrugsIntoxication"

	Gambling ModifyChannelInformationBodyContentClassificationLabelsId = "Gambling"

	ProfanityVulgarity ModifyChannelInformationBodyContentClassificationLabelsId = "ProfanityVulgarity"

	SexualThemes ModifyChannelInformationBodyContentClassificationLabelsId = "SexualThemes"

	ViolentGraphic ModifyChannelInformationBodyContentClassificationLabelsId = "ViolentGraphic"
)

// IsModifyChannelInformationBodyContentClassificationLabelsId returns true if the user passes in a value that is contained in the
// list of enums of ModifyChannelInformationBodyContentClassificationLabelsId.
func IsModifyChannelInformationBodyContentClassificationLabelsId(val ModifyChannelInformationBodyContentClassificationLabelsId) bool {
	switch val {
	case DrugsIntoxication:
		return true
	case Gambling:
		return true
	case ProfanityVulgarity:
		return true
	case SexualThemes:
		return true
	case ViolentGraphic:
		return true
	default:
		return false
	}
}

// ModifyChannelInformationBodyContentClassificationLabelsIdEnumMap returns a map of all of the enum values
var ModifyChannelInformationBodyContentClassificationLabelsIdEnumMap = map[ModifyChannelInformationBodyContentClassificationLabelsId]ModifyChannelInformationBodyContentClassificationLabelsId{
	DrugsIntoxication:  DrugsIntoxication,
	Gambling:           Gambling,
	ProfanityVulgarity: ProfanityVulgarity,
	SexualThemes:       SexualThemes,
	ViolentGraphic:     ViolentGraphic,
}

// Defines values for PollStatus.
const (
	PollStatusACTIVE PollStatus = "ACTIVE"

	PollStatusARCHIVED PollStatus = "ARCHIVED"

	PollStatusCOMPLETED PollStatus = "COMPLETED"

	PollStatusINVALID PollStatus = "INVALID"

	PollStatusMODERATED PollStatus = "MODERATED"

	PollStatusTERMINATED PollStatus = "TERMINATED"
)

// IsPollStatus returns true if the user passes in a value that is contained in the
// list of enums of PollStatus.
func IsPollStatus(val PollStatus) bool {
	switch val {
	case PollStatusACTIVE:
		return true
	case PollStatusARCHIVED:
		return true
	case PollStatusCOMPLETED:
		return true
	case PollStatusINVALID:
		return true
	case PollStatusMODERATED:
		return true
	case PollStatusTERMINATED:
		return true
	default:
		return false
	}
}

// PollStatusEnumMap returns a map of all of the enum values
var PollStatusEnumMap = map[PollStatus]PollStatus{
	PollStatusACTIVE:     PollStatusACTIVE,
	PollStatusARCHIVED:   PollStatusARCHIVED,
	PollStatusCOMPLETED:  PollStatusCOMPLETED,
	PollStatusINVALID:    PollStatusINVALID,
	PollStatusMODERATED:  PollStatusMODERATED,
	PollStatusTERMINATED: PollStatusTERMINATED,
}

// Defines values for PredictionStatus.
const (
	PredictionStatusACTIVE PredictionStatus = "ACTIVE"

	PredictionStatusCANCELED PredictionStatus = "CANCELED"

	PredictionStatusLOCKED PredictionStatus = "LOCKED"

	PredictionStatusRESOLVED PredictionStatus = "RESOLVED"
)

// IsPredictionStatus returns true if the user passes in a value that is contained in the
// list of enums of PredictionStatus.
func IsPredictionStatus(val PredictionStatus) bool {
	switch val {
	case PredictionStatusACTIVE:
		return true
	case PredictionStatusCANCELED:
		return true
	case PredictionStatusLOCKED:
		return true
	case PredictionStatusRESOLVED:
		return true
	default:
		return false
	}
}

// PredictionStatusEnumMap returns a map of all of the enum values
var PredictionStatusEnumMap = map[PredictionStatus]PredictionStatus{
	PredictionStatusACTIVE:   PredictionStatusACTIVE,
	PredictionStatusCANCELED: PredictionStatusCANCELED,
	PredictionStatusLOCKED:   PredictionStatusLOCKED,
	PredictionStatusRESOLVED: PredictionStatusRESOLVED,
}

// Defines values for PredictionOutcomeColor.
const (
	BLUE PredictionOutcomeColor = "BLUE"

	PINK PredictionOutcomeColor = "PINK"
)

// IsPredictionOutcomeColor returns true if the user passes in a value that is contained in the
// list of enums of PredictionOutcomeColor.
func IsPredictionOutcomeColor(val PredictionOutcomeColor) bool {
	switch val {
	case BLUE:
		return true
	case PINK:
		return true
	default:
		return false
	}
}

// PredictionOutcomeColorEnumMap returns a map of all of the enum values
var PredictionOutcomeColorEnumMap = map[PredictionOutcomeColor]PredictionOutcomeColor{
	BLUE: BLUE,
	PINK: PINK,
}

// Defines values for SendChatAnnouncementBodyColor.
const (
	SendChatAnnouncementBodyColorBlue SendChatAnnouncementBodyColor = "blue"

	SendChatAnnouncementBodyColorGreen SendChatAnnouncementBodyColor = "green"

	SendChatAnnouncementBodyColorOrange SendChatAnnouncementBodyColor = "orange"

	SendChatAnnouncementBodyColorPrimaryDefault SendChatAnnouncementBodyColor = "primary (default)"

	SendChatAnnouncementBodyColorPurple SendChatAnnouncementBodyColor = "purple"
)

// IsSendChatAnnouncementBodyColor returns true if the user passes in a value that is contained in the
// list of enums of SendChatAnnouncementBodyColor.
func IsSendChatAnnouncementBodyColor(val SendChatAnnouncementBodyColor) bool {
	switch val {
	case SendChatAnnouncementBodyColorBlue:
		return true
	case SendChatAnnouncementBodyColorGreen:
		return true
	case SendChatAnnouncementBodyColorOrange:
		return true
	case SendChatAnnouncementBodyColorPrimaryDefault:
		return true
	case SendChatAnnouncementBodyColorPurple:
		return true
	default:
		return false
	}
}

// SendChatAnnouncementBodyColorEnumMap returns a map of all of the enum values
var SendChatAnnouncementBodyColorEnumMap = map[SendChatAnnouncementBodyColor]SendChatAnnouncementBodyColor{
	SendChatAnnouncementBodyColorBlue:           SendChatAnnouncementBodyColorBlue,
	SendChatAnnouncementBodyColorGreen:          SendChatAnnouncementBodyColorGreen,
	SendChatAnnouncementBodyColorOrange:         SendChatAnnouncementBodyColorOrange,
	SendChatAnnouncementBodyColorPrimaryDefault: SendChatAnnouncementBodyColorPrimaryDefault,
	SendChatAnnouncementBodyColorPurple:         SendChatAnnouncementBodyColorPurple,
}

// Defines values for SendExtensionPubSubMessageBodyTarget.
const (
	SendExtensionPubSubMessageBodyTargetBroadcast SendExtensionPubSubMessageBodyTarget = "broadcast"

	SendExtensionPubSubMessageBodyTargetGlobal SendExtensionPubSubMessageBodyTarget = "global"

	SendExtensionPubSubMessageBodyTargetWhisperuserId SendExtensionPubSubMessageBodyTarget = "whisper-<user-id>"
)

// IsSendExtensionPubSubMessageBodyTarget returns true if the user passes in a value that is contained in the
// list of enums of SendExtensionPubSubMessageBodyTarget.
func IsSendExtensionPubSubMessageBodyTarget(val SendExtensionPubSubMessageBodyTarget) bool {
	switch val {
	case SendExtensionPubSubMessageBodyTargetBroadcast:
		return true
	case SendExtensionPubSubMessageBodyTargetGlobal:
		return true
	case SendExtensionPubSubMessageBodyTargetWhisperuserId:
		return true
	default:
		return false
	}
}

// SendExtensionPubSubMessageBodyTargetEnumMap returns a map of all of the enum values
var SendExtensionPubSubMessageBodyTargetEnumMap = map[SendExtensionPubSubMessageBodyTarget]SendExtensionPubSubMessageBodyTarget{
	SendExtensionPubSubMessageBodyTargetBroadcast:     SendExtensionPubSubMessageBodyTargetBroadcast,
	SendExtensionPubSubMessageBodyTargetGlobal:        SendExtensionPubSubMessageBodyTargetGlobal,
	SendExtensionPubSubMessageBodyTargetWhisperuserId: SendExtensionPubSubMessageBodyTargetWhisperuserId,
}

// Defines values for SetExtensionConfigurationSegmentBodySegment.
const (
	SetExtensionConfigurationSegmentBodySegmentBroadcaster SetExtensionConfigurationSegmentBodySegment = "broadcaster"

	SetExtensionConfigurationSegmentBodySegmentDeveloper SetExtensionConfigurationSegmentBodySegment = "developer"

	SetExtensionConfigurationSegmentBodySegmentGlobal SetExtensionConfigurationSegmentBodySegment = "global"
)

// IsSetExtensionConfigurationSegmentBodySegment returns true if the user passes in a value that is contained in the
// list of enums of SetExtensionConfigurationSegmentBodySegment.
func IsSetExtensionConfigurationSegmentBodySegment(val SetExtensionConfigurationSegmentBodySegment) bool {
	switch val {
	case SetExtensionConfigurationSegmentBodySegmentBroadcaster:
		return true
	case SetExtensionConfigurationSegmentBodySegmentDeveloper:
		return true
	case SetExtensionConfigurationSegmentBodySegmentGlobal:
		return true
	default:
		return false
	}
}

// SetExtensionConfigurationSegmentBodySegmentEnumMap returns a map of all of the enum values
var SetExtensionConfigurationSegmentBodySegmentEnumMap = map[SetExtensionConfigurationSegmentBodySegment]SetExtensionConfigurationSegmentBodySegment{
	SetExtensionConfigurationSegmentBodySegmentBroadcaster: SetExtensionConfigurationSegmentBodySegmentBroadcaster,
	SetExtensionConfigurationSegmentBodySegmentDeveloper:   SetExtensionConfigurationSegmentBodySegmentDeveloper,
	SetExtensionConfigurationSegmentBodySegmentGlobal:      SetExtensionConfigurationSegmentBodySegmentGlobal,
}

// Defines values for StreamType.
const (
	StreamTypeLive StreamType = "live"
)

// IsStreamType returns true if the user passes in a value that is contained in the
// list of enums of StreamType.
func IsStreamType(val StreamType) bool {
	switch val {
	case StreamTypeLive:
		return true
	default:
		return false
	}
}

// StreamTypeEnumMap returns a map of all of the enum values
var StreamTypeEnumMap = map[StreamType]StreamType{
	StreamTypeLive: StreamTypeLive,
}

// Defines values for UpdateChannelGuestStarSettingsBodyGroupLayout.
const (
	UpdateChannelGuestStarSettingsBodyGroupLayoutHORIZONTALLAYOUT UpdateChannelGuestStarSettingsBodyGroupLayout = "HORIZONTAL_LAYOUT"

	UpdateChannelGuestStarSettingsBodyGroupLayoutSCREENSHARELAYOUT UpdateChannelGuestStarSettingsBodyGroupLayout = "SCREENSHARE_LAYOUT"

	UpdateChannelGuestStarSettingsBodyGroupLayoutTILEDLAYOUT UpdateChannelGuestStarSettingsBodyGroupLayout = "TILED_LAYOUT"

	UpdateChannelGuestStarSettingsBodyGroupLayoutVERTICALLAYOUT UpdateChannelGuestStarSettingsBodyGroupLayout = "VERTICAL_LAYOUT"
)

// IsUpdateChannelGuestStarSettingsBodyGroupLayout returns true if the user passes in a value that is contained in the
// list of enums of UpdateChannelGuestStarSettingsBodyGroupLayout.
func IsUpdateChannelGuestStarSettingsBodyGroupLayout(val UpdateChannelGuestStarSettingsBodyGroupLayout) bool {
	switch val {
	case UpdateChannelGuestStarSettingsBodyGroupLayoutHORIZONTALLAYOUT:
		return true
	case UpdateChannelGuestStarSettingsBodyGroupLayoutSCREENSHARELAYOUT:
		return true
	case UpdateChannelGuestStarSettingsBodyGroupLayoutTILEDLAYOUT:
		return true
	case UpdateChannelGuestStarSettingsBodyGroupLayoutVERTICALLAYOUT:
		return true
	default:
		return false
	}
}

// UpdateChannelGuestStarSettingsBodyGroupLayoutEnumMap returns a map of all of the enum values
var UpdateChannelGuestStarSettingsBodyGroupLayoutEnumMap = map[UpdateChannelGuestStarSettingsBodyGroupLayout]UpdateChannelGuestStarSettingsBodyGroupLayout{
	UpdateChannelGuestStarSettingsBodyGroupLayoutHORIZONTALLAYOUT:  UpdateChannelGuestStarSettingsBodyGroupLayoutHORIZONTALLAYOUT,
	UpdateChannelGuestStarSettingsBodyGroupLayoutSCREENSHARELAYOUT: UpdateChannelGuestStarSettingsBodyGroupLayoutSCREENSHARELAYOUT,
	UpdateChannelGuestStarSettingsBodyGroupLayoutTILEDLAYOUT:       UpdateChannelGuestStarSettingsBodyGroupLayoutTILEDLAYOUT,
	UpdateChannelGuestStarSettingsBodyGroupLayoutVERTICALLAYOUT:    UpdateChannelGuestStarSettingsBodyGroupLayoutVERTICALLAYOUT,
}

// Defines values for UpdateChatSettingsBodyNonModeratorChatDelayDuration.
const (
	N2 UpdateChatSettingsBodyNonModeratorChatDelayDuration = 2

	N4 UpdateChatSettingsBodyNonModeratorChatDelayDuration = 4

	N6 UpdateChatSettingsBodyNonModeratorChatDelayDuration = 6
)

// IsUpdateChatSettingsBodyNonModeratorChatDelayDuration returns true if the user passes in a value that is contained in the
// list of enums of UpdateChatSettingsBodyNonModeratorChatDelayDuration.
func IsUpdateChatSettingsBodyNonModeratorChatDelayDuration(val UpdateChatSettingsBodyNonModeratorChatDelayDuration) bool {
	switch val {
	case N2:
		return true
	case N4:
		return true
	case N6:
		return true
	default:
		return false
	}
}

// UpdateChatSettingsBodyNonModeratorChatDelayDurationEnumMap returns a map of all of the enum values
var UpdateChatSettingsBodyNonModeratorChatDelayDurationEnumMap = map[UpdateChatSettingsBodyNonModeratorChatDelayDuration]UpdateChatSettingsBodyNonModeratorChatDelayDuration{
	N2: N2,
	N4: N4,
	N6: N6,
}

// Defines values for UpdateConduitShardsBodyShardsTransportMethod.
const (
	UpdateConduitShardsBodyShardsTransportMethodWebhook UpdateConduitShardsBodyShardsTransportMethod = "webhook"

	UpdateConduitShardsBodyShardsTransportMethodWebsocket UpdateConduitShardsBodyShardsTransportMethod = "websocket"
)

// IsUpdateConduitShardsBodyShardsTransportMethod returns true if the user passes in a value that is contained in the
// list of enums of UpdateConduitShardsBodyShardsTransportMethod.
func IsUpdateConduitShardsBodyShardsTransportMethod(val UpdateConduitShardsBodyShardsTransportMethod) bool {
	switch val {
	case UpdateConduitShardsBodyShardsTransportMethodWebhook:
		return true
	case UpdateConduitShardsBodyShardsTransportMethodWebsocket:
		return true
	default:
		return false
	}
}

// UpdateConduitShardsBodyShardsTransportMethodEnumMap returns a map of all of the enum values
var UpdateConduitShardsBodyShardsTransportMethodEnumMap = map[UpdateConduitShardsBodyShardsTransportMethod]UpdateConduitShardsBodyShardsTransportMethod{
	UpdateConduitShardsBodyShardsTransportMethodWebhook:   UpdateConduitShardsBodyShardsTransportMethodWebhook,
	UpdateConduitShardsBodyShardsTransportMethodWebsocket: UpdateConduitShardsBodyShardsTransportMethodWebsocket,
}

// Defines values for UpdateConduitShardsResponseDataStatus.
const (
	UpdateConduitShardsResponseDataStatusEnabled UpdateConduitShardsResponseDataStatus = "enabled"

	UpdateConduitShardsResponseDataStatusNotificationFailuresExceeded UpdateConduitShardsResponseDataStatus = "notification_failures_exceeded"

	UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationFailed UpdateConduitShardsResponseDataStatus = "webhook_callback_verification_failed"

	UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationPending UpdateConduitShardsResponseDataStatus = "webhook_callback_verification_pending"

	UpdateConduitShardsResponseDataStatusWebsocketDisconnected UpdateConduitShardsResponseDataStatus = "websocket_disconnected"

	UpdateConduitShardsResponseDataStatusWebsocketFailedPingPong UpdateConduitShardsResponseDataStatus = "websocket_failed_ping_pong"

	UpdateConduitShardsResponseDataStatusWebsocketFailedToReconnect UpdateConduitShardsResponseDataStatus = "websocket_failed_to_reconnect"

	UpdateConduitShardsResponseDataStatusWebsocketInternalError UpdateConduitShardsResponseDataStatus = "websocket_internal_error"

	UpdateConduitShardsResponseDataStatusWebsocketNetworkError UpdateConduitShardsResponseDataStatus = "websocket_network_error"

	UpdateConduitShardsResponseDataStatusWebsocketNetworkTimeout UpdateConduitShardsResponseDataStatus = "websocket_network_timeout"

	UpdateConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic UpdateConduitShardsResponseDataStatus = "websocket_received_inbound_traffic"
)

// IsUpdateConduitShardsResponseDataStatus returns true if the user passes in a value that is contained in the
// list of enums of UpdateConduitShardsResponseDataStatus.
func IsUpdateConduitShardsResponseDataStatus(val UpdateConduitShardsResponseDataStatus) bool {
	switch val {
	case UpdateConduitShardsResponseDataStatusEnabled:
		return true
	case UpdateConduitShardsResponseDataStatusNotificationFailuresExceeded:
		return true
	case UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationFailed:
		return true
	case UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationPending:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketDisconnected:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketFailedPingPong:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketFailedToReconnect:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketInternalError:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketNetworkError:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketNetworkTimeout:
		return true
	case UpdateConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic:
		return true
	default:
		return false
	}
}

// UpdateConduitShardsResponseDataStatusEnumMap returns a map of all of the enum values
var UpdateConduitShardsResponseDataStatusEnumMap = map[UpdateConduitShardsResponseDataStatus]UpdateConduitShardsResponseDataStatus{
	UpdateConduitShardsResponseDataStatusEnabled:                            UpdateConduitShardsResponseDataStatusEnabled,
	UpdateConduitShardsResponseDataStatusNotificationFailuresExceeded:       UpdateConduitShardsResponseDataStatusNotificationFailuresExceeded,
	UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationFailed:  UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationFailed,
	UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationPending: UpdateConduitShardsResponseDataStatusWebhookCallbackVerificationPending,
	UpdateConduitShardsResponseDataStatusWebsocketDisconnected:              UpdateConduitShardsResponseDataStatusWebsocketDisconnected,
	UpdateConduitShardsResponseDataStatusWebsocketFailedPingPong:            UpdateConduitShardsResponseDataStatusWebsocketFailedPingPong,
	UpdateConduitShardsResponseDataStatusWebsocketFailedToReconnect:         UpdateConduitShardsResponseDataStatusWebsocketFailedToReconnect,
	UpdateConduitShardsResponseDataStatusWebsocketInternalError:             UpdateConduitShardsResponseDataStatusWebsocketInternalError,
	UpdateConduitShardsResponseDataStatusWebsocketNetworkError:              UpdateConduitShardsResponseDataStatusWebsocketNetworkError,
	UpdateConduitShardsResponseDataStatusWebsocketNetworkTimeout:            UpdateConduitShardsResponseDataStatusWebsocketNetworkTimeout,
	UpdateConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic:    UpdateConduitShardsResponseDataStatusWebsocketReceivedInboundTraffic,
}

// Defines values for UpdateConduitShardsResponseDataTransportMethod.
const (
	Webhook UpdateConduitShardsResponseDataTransportMethod = "webhook"

	Websocket UpdateConduitShardsResponseDataTransportMethod = "websocket"
)

// IsUpdateConduitShardsResponseDataTransportMethod returns true if the user passes in a value that is contained in the
// list of enums of UpdateConduitShardsResponseDataTransportMethod.
func IsUpdateConduitShardsResponseDataTransportMethod(val UpdateConduitShardsResponseDataTransportMethod) bool {
	switch val {
	case Webhook:
		return true
	case Websocket:
		return true
	default:
		return false
	}
}

// UpdateConduitShardsResponseDataTransportMethodEnumMap returns a map of all of the enum values
var UpdateConduitShardsResponseDataTransportMethodEnumMap = map[UpdateConduitShardsResponseDataTransportMethod]UpdateConduitShardsResponseDataTransportMethod{
	Webhook:   Webhook,
	Websocket: Websocket,
}

// Defines values for UpdateDropsEntitlementsBodyFulfillmentStatus.
const (
	UpdateDropsEntitlementsBodyFulfillmentStatusCLAIMED UpdateDropsEntitlementsBodyFulfillmentStatus = "CLAIMED"

	UpdateDropsEntitlementsBodyFulfillmentStatusFULFILLED UpdateDropsEntitlementsBodyFulfillmentStatus = "FULFILLED"
)

// IsUpdateDropsEntitlementsBodyFulfillmentStatus returns true if the user passes in a value that is contained in the
// list of enums of UpdateDropsEntitlementsBodyFulfillmentStatus.
func IsUpdateDropsEntitlementsBodyFulfillmentStatus(val UpdateDropsEntitlementsBodyFulfillmentStatus) bool {
	switch val {
	case UpdateDropsEntitlementsBodyFulfillmentStatusCLAIMED:
		return true
	case UpdateDropsEntitlementsBodyFulfillmentStatusFULFILLED:
		return true
	default:
		return false
	}
}

// UpdateDropsEntitlementsBodyFulfillmentStatusEnumMap returns a map of all of the enum values
var UpdateDropsEntitlementsBodyFulfillmentStatusEnumMap = map[UpdateDropsEntitlementsBodyFulfillmentStatus]UpdateDropsEntitlementsBodyFulfillmentStatus{
	UpdateDropsEntitlementsBodyFulfillmentStatusCLAIMED:   UpdateDropsEntitlementsBodyFulfillmentStatusCLAIMED,
	UpdateDropsEntitlementsBodyFulfillmentStatusFULFILLED: UpdateDropsEntitlementsBodyFulfillmentStatusFULFILLED,
}

// Defines values for UpdateExtensionBitsProductBodyCostType.
const (
	Bits UpdateExtensionBitsProductBodyCostType = "bits"
)

// IsUpdateExtensionBitsProductBodyCostType returns true if the user passes in a value that is contained in the
// list of enums of UpdateExtensionBitsProductBodyCostType.
func IsUpdateExtensionBitsProductBodyCostType(val UpdateExtensionBitsProductBodyCostType) bool {
	switch val {
	case Bits:
		return true
	default:
		return false
	}
}

// UpdateExtensionBitsProductBodyCostTypeEnumMap returns a map of all of the enum values
var UpdateExtensionBitsProductBodyCostTypeEnumMap = map[UpdateExtensionBitsProductBodyCostType]UpdateExtensionBitsProductBodyCostType{
	Bits: Bits,
}

// Defines values for UpdateRedemptionStatusBodyStatus.
const (
	UpdateRedemptionStatusBodyStatusCANCELED UpdateRedemptionStatusBodyStatus = "CANCELED"

	UpdateRedemptionStatusBodyStatusFULFILLED UpdateRedemptionStatusBodyStatus = "FULFILLED"
)

// IsUpdateRedemptionStatusBodyStatus returns true if the user passes in a value that is contained in the
// list of enums of UpdateRedemptionStatusBodyStatus.
func IsUpdateRedemptionStatusBodyStatus(val UpdateRedemptionStatusBodyStatus) bool {
	switch val {
	case UpdateRedemptionStatusBodyStatusCANCELED:
		return true
	case UpdateRedemptionStatusBodyStatusFULFILLED:
		return true
	default:
		return false
	}
}

// UpdateRedemptionStatusBodyStatusEnumMap returns a map of all of the enum values
var UpdateRedemptionStatusBodyStatusEnumMap = map[UpdateRedemptionStatusBodyStatus]UpdateRedemptionStatusBodyStatus{
	UpdateRedemptionStatusBodyStatusCANCELED:  UpdateRedemptionStatusBodyStatusCANCELED,
	UpdateRedemptionStatusBodyStatusFULFILLED: UpdateRedemptionStatusBodyStatusFULFILLED,
}

// Defines values for UserBroadcasterType.
const (
	UserBroadcasterTypeAffiliate UserBroadcasterType = "affiliate"

	UserBroadcasterTypeEmpty UserBroadcasterType = ""

	UserBroadcasterTypePartner UserBroadcasterType = "partner"
)

// IsUserBroadcasterType returns true if the user passes in a value that is contained in the
// list of enums of UserBroadcasterType.
func IsUserBroadcasterType(val UserBroadcasterType) bool {
	switch val {
	case UserBroadcasterTypeAffiliate:
		return true
	case UserBroadcasterTypeEmpty:
		return true
	case UserBroadcasterTypePartner:
		return true
	default:
		return false
	}
}

// UserBroadcasterTypeEnumMap returns a map of all of the enum values
var UserBroadcasterTypeEnumMap = map[UserBroadcasterType]UserBroadcasterType{
	UserBroadcasterTypeAffiliate: UserBroadcasterTypeAffiliate,
	UserBroadcasterTypeEmpty:     UserBroadcasterTypeEmpty,
	UserBroadcasterTypePartner:   UserBroadcasterTypePartner,
}

// Defines values for UserType.
const (
	UserTypeAdmin UserType = "admin"

	UserTypeEmpty UserType = ""

	UserTypeGlobalMod UserType = "global_mod"

	UserTypeStaff UserType = "staff"
)

// IsUserType returns true if the user passes in a value that is contained in the
// list of enums of UserType.
func IsUserType(val UserType) bool {
	switch val {
	case UserTypeAdmin:
		return true
	case UserTypeEmpty:
		return true
	case UserTypeGlobalMod:
		return true
	case UserTypeStaff:
		return true
	default:
		return false
	}
}

// UserTypeEnumMap returns a map of all of the enum values
var UserTypeEnumMap = map[UserType]UserType{
	UserTypeAdmin:     UserTypeAdmin,
	UserTypeEmpty:     UserTypeEmpty,
	UserTypeGlobalMod: UserTypeGlobalMod,
	UserTypeStaff:     UserTypeStaff,
}

// Defines values for UserExtensionType.
const (
	Component UserExtensionType = "component"

	Mobile UserExtensionType = "mobile"

	Overlay UserExtensionType = "overlay"

	Panel UserExtensionType = "panel"
)

// IsUserExtensionType returns true if the user passes in a value that is contained in the
// list of enums of UserExtensionType.
func IsUserExtensionType(val UserExtensionType) bool {
	switch val {
	case Component:
		return true
	case Mobile:
		return true
	case Overlay:
		return true
	case Panel:
		return true
	default:
		return false
	}
}

// UserExtensionTypeEnumMap returns a map of all of the enum values
var UserExtensionTypeEnumMap = map[UserExtensionType]UserExtensionType{
	Component: Component,
	Mobile:    Mobile,
	Overlay:   Overlay,
	Panel:     Panel,
}

// Defines values for UserSubscriptionTier.
const (
	N1000 UserSubscriptionTier = "1000"

	N2000 UserSubscriptionTier = "2000"

	N3000 UserSubscriptionTier = "3000"
)

// IsUserSubscriptionTier returns true if the user passes in a value that is contained in the
// list of enums of UserSubscriptionTier.
func IsUserSubscriptionTier(val UserSubscriptionTier) bool {
	switch val {
	case N1000:
		return true
	case N2000:
		return true
	case N3000:
		return true
	default:
		return false
	}
}

// UserSubscriptionTierEnumMap returns a map of all of the enum values
var UserSubscriptionTierEnumMap = map[UserSubscriptionTier]UserSubscriptionTier{
	N1000: N1000,
	N2000: N2000,
	N3000: N3000,
}

// Defines values for VideoType.
const (
	VideoTypeArchive VideoType = "archive"

	VideoTypeHighlight VideoType = "highlight"

	VideoTypeUpload VideoType = "upload"
)

// IsVideoType returns true if the user passes in a value that is contained in the
// list of enums of VideoType.
func IsVideoType(val VideoType) bool {
	switch val {
	case VideoTypeArchive:
		return true
	case VideoTypeHighlight:
		return true
	case VideoTypeUpload:
		return true
	default:
		return false
	}
}

// VideoTypeEnumMap returns a map of all of the enum values
var VideoTypeEnumMap = map[VideoType]VideoType{
	VideoTypeArchive:   VideoTypeArchive,
	VideoTypeHighlight: VideoTypeHighlight,
	VideoTypeUpload:    VideoTypeUpload,
}

// Defines values for GetExtensionAnalyticsParamsType.
const (
	GetExtensionAnalyticsParamsTypeOverviewV2 GetExtensionAnalyticsParamsType = "overview_v2"
)

// IsGetExtensionAnalyticsParamsType returns true if the user passes in a value that is contained in the
// list of enums of GetExtensionAnalyticsParamsType.
func IsGetExtensionAnalyticsParamsType(val GetExtensionAnalyticsParamsType) bool {
	switch val {
	case GetExtensionAnalyticsParamsTypeOverviewV2:
		return true
	default:
		return false
	}
}

// GetExtensionAnalyticsParamsTypeEnumMap returns a map of all of the enum values
var GetExtensionAnalyticsParamsTypeEnumMap = map[GetExtensionAnalyticsParamsType]GetExtensionAnalyticsParamsType{
	GetExtensionAnalyticsParamsTypeOverviewV2: GetExtensionAnalyticsParamsTypeOverviewV2,
}

// Defines values for GetGameAnalyticsParamsType.
const (
	GetGameAnalyticsParamsTypeOverviewV2 GetGameAnalyticsParamsType = "overview_v2"
)

// IsGetGameAnalyticsParamsType returns true if the user passes in a value that is contained in the
// list of enums of GetGameAnalyticsParamsType.
func IsGetGameAnalyticsParamsType(val GetGameAnalyticsParamsType) bool {
	switch val {
	case GetGameAnalyticsParamsTypeOverviewV2:
		return true
	default:
		return false
	}
}

// GetGameAnalyticsParamsTypeEnumMap returns a map of all of the enum values
var GetGameAnalyticsParamsTypeEnumMap = map[GetGameAnalyticsParamsType]GetGameAnalyticsParamsType{
	GetGameAnalyticsParamsTypeOverviewV2: GetGameAnalyticsParamsTypeOverviewV2,
}

// Defines values for GetBitsLeaderboardParamsPeriod.
const (
	GetBitsLeaderboardParamsPeriodAll GetBitsLeaderboardParamsPeriod = "all"

	GetBitsLeaderboardParamsPeriodDay GetBitsLeaderboardParamsPeriod = "day"

	GetBitsLeaderboardParamsPeriodMonth GetBitsLeaderboardParamsPeriod = "month"

	GetBitsLeaderboardParamsPeriodWeek GetBitsLeaderboardParamsPeriod = "week"

	GetBitsLeaderboardParamsPeriodYear GetBitsLeaderboardParamsPeriod = "year"
)

// IsGetBitsLeaderboardParamsPeriod returns true if the user passes in a value that is contained in the
// list of enums of GetBitsLeaderboardParamsPeriod.
func IsGetBitsLeaderboardParamsPeriod(val GetBitsLeaderboardParamsPeriod) bool {
	switch val {
	case GetBitsLeaderboardParamsPeriodAll:
		return true
	case GetBitsLeaderboardParamsPeriodDay:
		return true
	case GetBitsLeaderboardParamsPeriodMonth:
		return true
	case GetBitsLeaderboardParamsPeriodWeek:
		return true
	case GetBitsLeaderboardParamsPeriodYear:
		return true
	default:
		return false
	}
}

// GetBitsLeaderboardParamsPeriodEnumMap returns a map of all of the enum values
var GetBitsLeaderboardParamsPeriodEnumMap = map[GetBitsLeaderboardParamsPeriod]GetBitsLeaderboardParamsPeriod{
	GetBitsLeaderboardParamsPeriodAll:   GetBitsLeaderboardParamsPeriodAll,
	GetBitsLeaderboardParamsPeriodDay:   GetBitsLeaderboardParamsPeriodDay,
	GetBitsLeaderboardParamsPeriodMonth: GetBitsLeaderboardParamsPeriodMonth,
	GetBitsLeaderboardParamsPeriodWeek:  GetBitsLeaderboardParamsPeriodWeek,
	GetBitsLeaderboardParamsPeriodYear:  GetBitsLeaderboardParamsPeriodYear,
}

// Defines values for GetCustomRewardRedemptionParamsStatus.
const (
	GetCustomRewardRedemptionParamsStatusCANCELED GetCustomRewardRedemptionParamsStatus = "CANCELED"

	GetCustomRewardRedemptionParamsStatusFULFILLED GetCustomRewardRedemptionParamsStatus = "FULFILLED"

	GetCustomRewardRedemptionParamsStatusUNFULFILLED GetCustomRewardRedemptionParamsStatus = "UNFULFILLED"
)

// IsGetCustomRewardRedemptionParamsStatus returns true if the user passes in a value that is contained in the
// list of enums of GetCustomRewardRedemptionParamsStatus.
func IsGetCustomRewardRedemptionParamsStatus(val GetCustomRewardRedemptionParamsStatus) bool {
	switch val {
	case GetCustomRewardRedemptionParamsStatusCANCELED:
		return true
	case GetCustomRewardRedemptionParamsStatusFULFILLED:
		return true
	case GetCustomRewardRedemptionParamsStatusUNFULFILLED:
		return true
	default:
		return false
	}
}

// GetCustomRewardRedemptionParamsStatusEnumMap returns a map of all of the enum values
var GetCustomRewardRedemptionParamsStatusEnumMap = map[GetCustomRewardRedemptionParamsStatus]GetCustomRewardRedemptionParamsStatus{
	GetCustomRewardRedemptionParamsStatusCANCELED:    GetCustomRewardRedemptionParamsStatusCANCELED,
	GetCustomRewardRedemptionParamsStatusFULFILLED:   GetCustomRewardRedemptionParamsStatusFULFILLED,
	GetCustomRewardRedemptionParamsStatusUNFULFILLED: GetCustomRewardRedemptionParamsStatusUNFULFILLED,
}

// Defines values for GetCustomRewardRedemptionParamsSort.
const (
	NEWEST GetCustomRewardRedemptionParamsSort = "NEWEST"

	OLDEST GetCustomRewardRedemptionParamsSort = "OLDEST"
)

// IsGetCustomRewardRedemptionParamsSort returns true if the user passes in a value that is contained in the
// list of enums of GetCustomRewardRedemptionParamsSort.
func IsGetCustomRewardRedemptionParamsSort(val GetCustomRewardRedemptionParamsSort) bool {
	switch val {
	case NEWEST:
		return true
	case OLDEST:
		return true
	default:
		return false
	}
}

// GetCustomRewardRedemptionParamsSortEnumMap returns a map of all of the enum values
var GetCustomRewardRedemptionParamsSortEnumMap = map[GetCustomRewardRedemptionParamsSort]GetCustomRewardRedemptionParamsSort{
	NEWEST: NEWEST,
	OLDEST: OLDEST,
}

// Defines values for UpdateUserChatColorParamsColor.
const (
	UpdateUserChatColorParamsColorBlue UpdateUserChatColorParamsColor = "blue"

	UpdateUserChatColorParamsColorBlueViolet UpdateUserChatColorParamsColor = "blue_violet"

	UpdateUserChatColorParamsColorCadetBlue UpdateUserChatColorParamsColor = "cadet_blue"

	UpdateUserChatColorParamsColorChocolate UpdateUserChatColorParamsColor = "chocolate"

	UpdateUserChatColorParamsColorCoral UpdateUserChatColorParamsColor = "coral"

	UpdateUserChatColorParamsColorDodgerBlue UpdateUserChatColorParamsColor = "dodger_blue"

	UpdateUserChatColorParamsColorFirebrick UpdateUserChatColorParamsColor = "firebrick"

	UpdateUserChatColorParamsColorGoldenRod UpdateUserChatColorParamsColor = "golden_rod"

	UpdateUserChatColorParamsColorGreen UpdateUserChatColorParamsColor = "green"

	UpdateUserChatColorParamsColorHotPink UpdateUserChatColorParamsColor = "hot_pink"

	UpdateUserChatColorParamsColorOrangeRed UpdateUserChatColorParamsColor = "orange_red"

	UpdateUserChatColorParamsColorRed UpdateUserChatColorParamsColor = "red"

	UpdateUserChatColorParamsColorSeaGreen UpdateUserChatColorParamsColor = "sea_green"

	UpdateUserChatColorParamsColorSpringGreen UpdateUserChatColorParamsColor = "spring_green"

	UpdateUserChatColorParamsColorYellowGreen UpdateUserChatColorParamsColor = "yellow_green"
)

// IsUpdateUserChatColorParamsColor returns true if the user passes in a value that is contained in the
// list of enums of UpdateUserChatColorParamsColor.
func IsUpdateUserChatColorParamsColor(val UpdateUserChatColorParamsColor) bool {
	switch val {
	case UpdateUserChatColorParamsColorBlue:
		return true
	case UpdateUserChatColorParamsColorBlueViolet:
		return true
	case UpdateUserChatColorParamsColorCadetBlue:
		return true
	case UpdateUserChatColorParamsColorChocolate:
		return true
	case UpdateUserChatColorParamsColorCoral:
		return true
	case UpdateUserChatColorParamsColorDodgerBlue:
		return true
	case UpdateUserChatColorParamsColorFirebrick:
		return true
	case UpdateUserChatColorParamsColorGoldenRod:
		return true
	case UpdateUserChatColorParamsColorGreen:
		return true
	case UpdateUserChatColorParamsColorHotPink:
		return true
	case UpdateUserChatColorParamsColorOrangeRed:
		return true
	case UpdateUserChatColorParamsColorRed:
		return true
	case UpdateUserChatColorParamsColorSeaGreen:
		return true
	case UpdateUserChatColorParamsColorSpringGreen:
		return true
	case UpdateUserChatColorParamsColorYellowGreen:
		return true
	default:
		return false
	}
}

// UpdateUserChatColorParamsColorEnumMap returns a map of all of the enum values
var UpdateUserChatColorParamsColorEnumMap = map[UpdateUserChatColorParamsColor]UpdateUserChatColorParamsColor{
	UpdateUserChatColorParamsColorBlue:        UpdateUserChatColorParamsColorBlue,
	UpdateUserChatColorParamsColorBlueViolet:  UpdateUserChatColorParamsColorBlueViolet,
	UpdateUserChatColorParamsColorCadetBlue:   UpdateUserChatColorParamsColorCadetBlue,
	UpdateUserChatColorParamsColorChocolate:   UpdateUserChatColorParamsColorChocolate,
	UpdateUserChatColorParamsColorCoral:       UpdateUserChatColorParamsColorCoral,
	UpdateUserChatColorParamsColorDodgerBlue:  UpdateUserChatColorParamsColorDodgerBlue,
	UpdateUserChatColorParamsColorFirebrick:   UpdateUserChatColorParamsColorFirebrick,
	UpdateUserChatColorParamsColorGoldenRod:   UpdateUserChatColorParamsColorGoldenRod,
	UpdateUserChatColorParamsColorGreen:       UpdateUserChatColorParamsColorGreen,
	UpdateUserChatColorParamsColorHotPink:     UpdateUserChatColorParamsColorHotPink,
	UpdateUserChatColorParamsColorOrangeRed:   UpdateUserChatColorParamsColorOrangeRed,
	UpdateUserChatColorParamsColorRed:         UpdateUserChatColorParamsColorRed,
	UpdateUserChatColorParamsColorSeaGreen:    UpdateUserChatColorParamsColorSeaGreen,
	UpdateUserChatColorParamsColorSpringGreen: UpdateUserChatColorParamsColorSpringGreen,
	UpdateUserChatColorParamsColorYellowGreen: UpdateUserChatColorParamsColorYellowGreen,
}

// Defines values for GetDropsEntitlementsParamsFulfillmentStatus.
const (
	GetDropsEntitlementsParamsFulfillmentStatusCLAIMED GetDropsEntitlementsParamsFulfillmentStatus = "CLAIMED"

	GetDropsEntitlementsParamsFulfillmentStatusFULFILLED GetDropsEntitlementsParamsFulfillmentStatus = "FULFILLED"
)

// IsGetDropsEntitlementsParamsFulfillmentStatus returns true if the user passes in a value that is contained in the
// list of enums of GetDropsEntitlementsParamsFulfillmentStatus.
func IsGetDropsEntitlementsParamsFulfillmentStatus(val GetDropsEntitlementsParamsFulfillmentStatus) bool {
	switch val {
	case GetDropsEntitlementsParamsFulfillmentStatusCLAIMED:
		return true
	case GetDropsEntitlementsParamsFulfillmentStatusFULFILLED:
		return true
	default:
		return false
	}
}

// GetDropsEntitlementsParamsFulfillmentStatusEnumMap returns a map of all of the enum values
var GetDropsEntitlementsParamsFulfillmentStatusEnumMap = map[GetDropsEntitlementsParamsFulfillmentStatus]GetDropsEntitlementsParamsFulfillmentStatus{
	GetDropsEntitlementsParamsFulfillmentStatusCLAIMED:   GetDropsEntitlementsParamsFulfillmentStatusCLAIMED,
	GetDropsEntitlementsParamsFulfillmentStatusFULFILLED: GetDropsEntitlementsParamsFulfillmentStatusFULFILLED,
}

// Defines values for GetEventsubSubscriptionsParamsStatus.
const (
	GetEventsubSubscriptionsParamsStatusAuthorizationRevoked GetEventsubSubscriptionsParamsStatus = "authorization_revoked"

	GetEventsubSubscriptionsParamsStatusBetaMaintenance GetEventsubSubscriptionsParamsStatus = "beta_maintenance"

	GetEventsubSubscriptionsParamsStatusChatUserBanned GetEventsubSubscriptionsParamsStatus = "chat_user_banned"

	GetEventsubSubscriptionsParamsStatusEnabled GetEventsubSubscriptionsParamsStatus = "enabled"

	GetEventsubSubscriptionsParamsStatusModeratorRemoved GetEventsubSubscriptionsParamsStatus = "moderator_removed"

	GetEventsubSubscriptionsParamsStatusNotificationFailuresExceeded GetEventsubSubscriptionsParamsStatus = "notification_failures_exceeded"

	GetEventsubSubscriptionsParamsStatusUserRemoved GetEventsubSubscriptionsParamsStatus = "user_removed"

	GetEventsubSubscriptionsParamsStatusVersionRemoved GetEventsubSubscriptionsParamsStatus = "version_removed"

	GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationFailed GetEventsubSubscriptionsParamsStatus = "webhook_callback_verification_failed"

	GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationPending GetEventsubSubscriptionsParamsStatus = "webhook_callback_verification_pending"

	GetEventsubSubscriptionsParamsStatusWebsocketConnectionUnused GetEventsubSubscriptionsParamsStatus = "websocket_connection_unused"

	GetEventsubSubscriptionsParamsStatusWebsocketDisconnected GetEventsubSubscriptionsParamsStatus = "websocket_disconnected"

	GetEventsubSubscriptionsParamsStatusWebsocketFailedPingPong GetEventsubSubscriptionsParamsStatus = "websocket_failed_ping_pong"

	GetEventsubSubscriptionsParamsStatusWebsocketFailedToReconnect GetEventsubSubscriptionsParamsStatus = "websocket_failed_to_reconnect"

	GetEventsubSubscriptionsParamsStatusWebsocketInternalError GetEventsubSubscriptionsParamsStatus = "websocket_internal_error"

	GetEventsubSubscriptionsParamsStatusWebsocketNetworkError GetEventsubSubscriptionsParamsStatus = "websocket_network_error"

	GetEventsubSubscriptionsParamsStatusWebsocketNetworkTimeout GetEventsubSubscriptionsParamsStatus = "websocket_network_timeout"

	GetEventsubSubscriptionsParamsStatusWebsocketReceivedInboundTraffic GetEventsubSubscriptionsParamsStatus = "websocket_received_inbound_traffic"
)

// IsGetEventsubSubscriptionsParamsStatus returns true if the user passes in a value that is contained in the
// list of enums of GetEventsubSubscriptionsParamsStatus.
func IsGetEventsubSubscriptionsParamsStatus(val GetEventsubSubscriptionsParamsStatus) bool {
	switch val {
	case GetEventsubSubscriptionsParamsStatusAuthorizationRevoked:
		return true
	case GetEventsubSubscriptionsParamsStatusBetaMaintenance:
		return true
	case GetEventsubSubscriptionsParamsStatusChatUserBanned:
		return true
	case GetEventsubSubscriptionsParamsStatusEnabled:
		return true
	case GetEventsubSubscriptionsParamsStatusModeratorRemoved:
		return true
	case GetEventsubSubscriptionsParamsStatusNotificationFailuresExceeded:
		return true
	case GetEventsubSubscriptionsParamsStatusUserRemoved:
		return true
	case GetEventsubSubscriptionsParamsStatusVersionRemoved:
		return true
	case GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationFailed:
		return true
	case GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationPending:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketConnectionUnused:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketDisconnected:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketFailedPingPong:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketFailedToReconnect:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketInternalError:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketNetworkError:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketNetworkTimeout:
		return true
	case GetEventsubSubscriptionsParamsStatusWebsocketReceivedInboundTraffic:
		return true
	default:
		return false
	}
}

// GetEventsubSubscriptionsParamsStatusEnumMap returns a map of all of the enum values
var GetEventsubSubscriptionsParamsStatusEnumMap = map[GetEventsubSubscriptionsParamsStatus]GetEventsubSubscriptionsParamsStatus{
	GetEventsubSubscriptionsParamsStatusAuthorizationRevoked:               GetEventsubSubscriptionsParamsStatusAuthorizationRevoked,
	GetEventsubSubscriptionsParamsStatusBetaMaintenance:                    GetEventsubSubscriptionsParamsStatusBetaMaintenance,
	GetEventsubSubscriptionsParamsStatusChatUserBanned:                     GetEventsubSubscriptionsParamsStatusChatUserBanned,
	GetEventsubSubscriptionsParamsStatusEnabled:                            GetEventsubSubscriptionsParamsStatusEnabled,
	GetEventsubSubscriptionsParamsStatusModeratorRemoved:                   GetEventsubSubscriptionsParamsStatusModeratorRemoved,
	GetEventsubSubscriptionsParamsStatusNotificationFailuresExceeded:       GetEventsubSubscriptionsParamsStatusNotificationFailuresExceeded,
	GetEventsubSubscriptionsParamsStatusUserRemoved:                        GetEventsubSubscriptionsParamsStatusUserRemoved,
	GetEventsubSubscriptionsParamsStatusVersionRemoved:                     GetEventsubSubscriptionsParamsStatusVersionRemoved,
	GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationFailed:  GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationFailed,
	GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationPending: GetEventsubSubscriptionsParamsStatusWebhookCallbackVerificationPending,
	GetEventsubSubscriptionsParamsStatusWebsocketConnectionUnused:          GetEventsubSubscriptionsParamsStatusWebsocketConnectionUnused,
	GetEventsubSubscriptionsParamsStatusWebsocketDisconnected:              GetEventsubSubscriptionsParamsStatusWebsocketDisconnected,
	GetEventsubSubscriptionsParamsStatusWebsocketFailedPingPong:            GetEventsubSubscriptionsParamsStatusWebsocketFailedPingPong,
	GetEventsubSubscriptionsParamsStatusWebsocketFailedToReconnect:         GetEventsubSubscriptionsParamsStatusWebsocketFailedToReconnect,
	GetEventsubSubscriptionsParamsStatusWebsocketInternalError:             GetEventsubSubscriptionsParamsStatusWebsocketInternalError,
	GetEventsubSubscriptionsParamsStatusWebsocketNetworkError:              GetEventsubSubscriptionsParamsStatusWebsocketNetworkError,
	GetEventsubSubscriptionsParamsStatusWebsocketNetworkTimeout:            GetEventsubSubscriptionsParamsStatusWebsocketNetworkTimeout,
	GetEventsubSubscriptionsParamsStatusWebsocketReceivedInboundTraffic:    GetEventsubSubscriptionsParamsStatusWebsocketReceivedInboundTraffic,
}

// Defines values for GetEventsubSubscriptionsParamsType.
const (
	AutomodMessageHold GetEventsubSubscriptionsParamsType = "automod.message.hold"

	AutomodMessageUpdate GetEventsubSubscriptionsParamsType = "automod.message.update"

	AutomodSettingsUpdate GetEventsubSubscriptionsParamsType = "automod.settings.update"

	AutomodTermsUpdate GetEventsubSubscriptionsParamsType = "automod.terms.update"

	ChannelAdBreakBegin GetEventsubSubscriptionsParamsType = "channel.ad_break.begin"

	ChannelBan GetEventsubSubscriptionsParamsType = "channel.ban"

	ChannelChannelPointsAutomaticRewardRedemptionAdd GetEventsubSubscriptionsParamsType = "channel.channel_points_automatic_reward_redemption.add"

	ChannelChannelPointsCustomRewardAdd GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward.add"

	ChannelChannelPointsCustomRewardRedemptionAdd GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward_redemption.add"

	ChannelChannelPointsCustomRewardRedemptionUpdate GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward_redemption.update"

	ChannelChannelPointsCustomRewardRemove GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward.remove"

	ChannelChannelPointsCustomRewardUpdate GetEventsubSubscriptionsParamsType = "channel.channel_points_custom_reward.update"

	ChannelCharityCampaignDonate GetEventsubSubscriptionsParamsType = "channel.charity_campaign.donate"

	ChannelCharityCampaignProgress GetEventsubSubscriptionsParamsType = "channel.charity_campaign.progress"

	ChannelCharityCampaignStart GetEventsubSubscriptionsParamsType = "channel.charity_campaign.start"

	ChannelCharityCampaignStop GetEventsubSubscriptionsParamsType = "channel.charity_campaign.stop"

	ChannelChatClear GetEventsubSubscriptionsParamsType = "channel.chat.clear"

	ChannelChatClearUserMessages GetEventsubSubscriptionsParamsType = "channel.chat.clear_user_messages"

	ChannelChatMessage GetEventsubSubscriptionsParamsType = "channel.chat.message"

	ChannelChatMessageDelete GetEventsubSubscriptionsParamsType = "channel.chat.message_delete"

	ChannelChatNotification GetEventsubSubscriptionsParamsType = "channel.chat.notification"

	ChannelChatSettingsUpdate GetEventsubSubscriptionsParamsType = "channel.chat_settings.update"

	ChannelChatUserMessageHold GetEventsubSubscriptionsParamsType = "channel.chat.user_message_hold"

	ChannelChatUserMessageUpdate GetEventsubSubscriptionsParamsType = "channel.chat.user_message_update"

	ChannelCheer GetEventsubSubscriptionsParamsType = "channel.cheer"

	ChannelFollow GetEventsubSubscriptionsParamsType = "channel.follow"

	ChannelGoalBegin GetEventsubSubscriptionsParamsType = "channel.goal.begin"

	ChannelGoalEnd GetEventsubSubscriptionsParamsType = "channel.goal.end"

	ChannelGoalProgress GetEventsubSubscriptionsParamsType = "channel.goal.progress"

	ChannelGuestStarGuestUpdate GetEventsubSubscriptionsParamsType = "channel.guest_star_guest.update"

	ChannelGuestStarSessionBegin GetEventsubSubscriptionsParamsType = "channel.guest_star_session.begin"

	ChannelGuestStarSessionEnd GetEventsubSubscriptionsParamsType = "channel.guest_star_session.end"

	ChannelGuestStarSettingsUpdate GetEventsubSubscriptionsParamsType = "channel.guest_star_settings.update"

	ChannelHypeTrainBegin GetEventsubSubscriptionsParamsType = "channel.hype_train.begin"

	ChannelHypeTrainEnd GetEventsubSubscriptionsParamsType = "channel.hype_train.end"

	ChannelHypeTrainProgress GetEventsubSubscriptionsParamsType = "channel.hype_train.progress"

	ChannelModerate GetEventsubSubscriptionsParamsType = "channel.moderate"

	ChannelModeratorAdd GetEventsubSubscriptionsParamsType = "channel.moderator.add"

	ChannelModeratorRemove GetEventsubSubscriptionsParamsType = "channel.moderator.remove"

	ChannelPollBegin GetEventsubSubscriptionsParamsType = "channel.poll.begin"

	ChannelPollEnd GetEventsubSubscriptionsParamsType = "channel.poll.end"

	ChannelPollProgress GetEventsubSubscriptionsParamsType = "channel.poll.progress"

	ChannelPredictionBegin GetEventsubSubscriptionsParamsType = "channel.prediction.begin"

	ChannelPredictionEnd GetEventsubSubscriptionsParamsType = "channel.prediction.end"

	ChannelPredictionLock GetEventsubSubscriptionsParamsType = "channel.prediction.lock"

	ChannelPredictionProgress GetEventsubSubscriptionsParamsType = "channel.prediction.progress"

	ChannelRaid GetEventsubSubscriptionsParamsType = "channel.raid"

	ChannelSharedChatBegin GetEventsubSubscriptionsParamsType = "channel.shared_chat.begin"

	ChannelSharedChatEnd GetEventsubSubscriptionsParamsType = "channel.shared_chat.end"

	ChannelSharedChatUpdate GetEventsubSubscriptionsParamsType = "channel.shared_chat.update"

	ChannelShieldModeBegin GetEventsubSubscriptionsParamsType = "channel.shield_mode.begin"

	ChannelShieldModeEnd GetEventsubSubscriptionsParamsType = "channel.shield_mode.end"

	ChannelShoutoutCreate GetEventsubSubscriptionsParamsType = "channel.shoutout.create"

	ChannelShoutoutReceive GetEventsubSubscriptionsParamsType = "channel.shoutout.receive"

	ChannelSubscribe GetEventsubSubscriptionsParamsType = "channel.subscribe"

	ChannelSubscriptionEnd GetEventsubSubscriptionsParamsType = "channel.subscription.end"

	ChannelSubscriptionGift GetEventsubSubscriptionsParamsType = "channel.subscription.gift"

	ChannelSubscriptionMessage GetEventsubSubscriptionsParamsType = "channel.subscription.message"

	ChannelSuspiciousUserMessage GetEventsubSubscriptionsParamsType = "channel.suspicious_user.message"

	ChannelSuspiciousUserUpdate GetEventsubSubscriptionsParamsType = "channel.suspicious_user.update"

	ChannelUnban GetEventsubSubscriptionsParamsType = "channel.unban"

	ChannelUnbanRequestCreate GetEventsubSubscriptionsParamsType = "channel.unban_request.create"

	ChannelUnbanRequestResolve GetEventsubSubscriptionsParamsType = "channel.unban_request.resolve"

	ChannelUpdate GetEventsubSubscriptionsParamsType = "channel.update"

	ChannelVipAdd GetEventsubSubscriptionsParamsType = "channel.vip.add"

	ChannelVipRemove GetEventsubSubscriptionsParamsType = "channel.vip.remove"

	ChannelWarningAcknowledge GetEventsubSubscriptionsParamsType = "channel.warning.acknowledge"

	ChannelWarningSend GetEventsubSubscriptionsParamsType = "channel.warning.send"

	ConduitShardDisabled GetEventsubSubscriptionsParamsType = "conduit.shard.disabled"

	DropEntitlementGrant GetEventsubSubscriptionsParamsType = "drop.entitlement.grant"

	ExtensionBitsTransactionCreate GetEventsubSubscriptionsParamsType = "extension.bits_transaction.create"

	StreamOffline GetEventsubSubscriptionsParamsType = "stream.offline"

	StreamOnline GetEventsubSubscriptionsParamsType = "stream.online"

	UserAuthorizationGrant GetEventsubSubscriptionsParamsType = "user.authorization.grant"

	UserAuthorizationRevoke GetEventsubSubscriptionsParamsType = "user.authorization.revoke"

	UserUpdate GetEventsubSubscriptionsParamsType = "user.update"

	UserWhisperMessage GetEventsubSubscriptionsParamsType = "user.whisper.message"
)

// IsGetEventsubSubscriptionsParamsType returns true if the user passes in a value that is contained in the
// list of enums of GetEventsubSubscriptionsParamsType.
func IsGetEventsubSubscriptionsParamsType(val GetEventsubSubscriptionsParamsType) bool {
	switch val {
	case AutomodMessageHold:
		return true
	case AutomodMessageUpdate:
		return true
	case AutomodSettingsUpdate:
		return true
	case AutomodTermsUpdate:
		return true
	case ChannelAdBreakBegin:
		return true
	case ChannelBan:
		return true
	case ChannelChannelPointsAutomaticRewardRedemptionAdd:
		return true
	case ChannelChannelPointsCustomRewardAdd:
		return true
	case ChannelChannelPointsCustomRewardRedemptionAdd:
		return true
	case ChannelChannelPointsCustomRewardRedemptionUpdate:
		return true
	case ChannelChannelPointsCustomRewardRemove:
		return true
	case ChannelChannelPointsCustomRewardUpdate:
		return true
	case ChannelCharityCampaignDonate:
		return true
	case ChannelCharityCampaignProgress:
		return true
	case ChannelCharityCampaignStart:
		return true
	case ChannelCharityCampaignStop:
		return true
	case ChannelChatClear:
		return true
	case ChannelChatClearUserMessages:
		return true
	case ChannelChatMessage:
		return true
	case ChannelChatMessageDelete:
		return true
	case ChannelChatNotification:
		return true
	case ChannelChatSettingsUpdate:
		return true
	case ChannelChatUserMessageHold:
		return true
	case ChannelChatUserMessageUpdate:
		return true
	case ChannelCheer:
		return true
	case ChannelFollow:
		return true
	case ChannelGoalBegin:
		return true
	case ChannelGoalEnd:
		return true
	case ChannelGoalProgress:
		return true
	case ChannelGuestStarGuestUpdate:
		return true
	case ChannelGuestStarSessionBegin:
		return true
	case ChannelGuestStarSessionEnd:
		return true
	case ChannelGuestStarSettingsUpdate:
		return true
	case ChannelHypeTrainBegin:
		return true
	case ChannelHypeTrainEnd:
		return true
	case ChannelHypeTrainProgress:
		return true
	case ChannelModerate:
		return true
	case ChannelModeratorAdd:
		return true
	case ChannelModeratorRemove:
		return true
	case ChannelPollBegin:
		return true
	case ChannelPollEnd:
		return true
	case ChannelPollProgress:
		return true
	case ChannelPredictionBegin:
		return true
	case ChannelPredictionEnd:
		return true
	case ChannelPredictionLock:
		return true
	case ChannelPredictionProgress:
		return true
	case ChannelRaid:
		return true
	case ChannelSharedChatBegin:
		return true
	case ChannelSharedChatEnd:
		return true
	case ChannelSharedChatUpdate:
		return true
	case ChannelShieldModeBegin:
		return true
	case ChannelShieldModeEnd:
		return true
	case ChannelShoutoutCreate:
		return true
	case ChannelShoutoutReceive:
		return true
	case ChannelSubscribe:
		return true
	case ChannelSubscriptionEnd:
		return true
	case ChannelSubscriptionGift:
		return true
	case ChannelSubscriptionMessage:
		return true
	case ChannelSuspiciousUserMessage:
		return true
	case ChannelSuspiciousUserUpdate:
		return true
	case ChannelUnban:
		return true
	case ChannelUnbanRequestCreate:
		return true
	case ChannelUnbanRequestResolve:
		return true
	case ChannelUpdate:
		return true
	case ChannelVipAdd:
		return true
	case ChannelVipRemove:
		return true
	case ChannelWarningAcknowledge:
		return true
	case ChannelWarningSend:
		return true
	case ConduitShardDisabled:
		return true
	case DropEntitlementGrant:
		return true
	case ExtensionBitsTransactionCreate:
		return true
	case StreamOffline:
		return true
	case StreamOnline:
		return true
	case UserAuthorizationGrant:
		return true
	case UserAuthorizationRevoke:
		return true
	case UserUpdate:
		return true
	case UserWhisperMessage:
		return true
	default:
		return false
	}
}

// GetEventsubSubscriptionsParamsTypeEnumMap returns a map of all of the enum values
var GetEventsubSubscriptionsParamsTypeEnumMap = map[GetEventsubSubscriptionsParamsType]GetEventsubSubscriptionsParamsType{
	AutomodMessageHold:    AutomodMessageHold,
	AutomodMessageUpdate:  AutomodMessageUpdate,
	AutomodSettingsUpdate: AutomodSettingsUpdate,
	AutomodTermsUpdate:    AutomodTermsUpdate,
	ChannelAdBreakBegin:   ChannelAdBreakBegin,
	ChannelBan:            ChannelBan,
	ChannelChannelPointsAutomaticRewardRedemptionAdd: ChannelChannelPointsAutomaticRewardRedemptionAdd,
	ChannelChannelPointsCustomRewardAdd:              ChannelChannelPointsCustomRewardAdd,
	ChannelChannelPointsCustomRewardRedemptionAdd:    ChannelChannelPointsCustomRewardRedemptionAdd,
	ChannelChannelPointsCustomRewardRedemptionUpdate: ChannelChannelPointsCustomRewardRedemptionUpdate,
	ChannelChannelPointsCustomRewardRemove:           ChannelChannelPointsCustomRewardRemove,
	ChannelChannelPointsCustomRewardUpdate:           ChannelChannelPointsCustomRewardUpdate,
	ChannelCharityCampaignDonate:                     ChannelCharityCampaignDonate,
	ChannelCharityCampaignProgress:                   ChannelCharityCampaignProgress,
	ChannelCharityCampaignStart:                      ChannelCharityCampaignStart,
	ChannelCharityCampaignStop:                       ChannelCharityCampaignStop,
	ChannelChatClear:                                 ChannelChatClear,
	ChannelChatClearUserMessages:                     ChannelChatClearUserMessages,
	ChannelChatMessage:                               ChannelChatMessage,
	ChannelChatMessageDelete:                         ChannelChatMessageDelete,
	ChannelChatNotification:                          ChannelChatNotification,
	ChannelChatSettingsUpdate:                        ChannelChatSettingsUpdate,
	ChannelChatUserMessageHold:                       ChannelChatUserMessageHold,
	ChannelChatUserMessageUpdate:                     ChannelChatUserMessageUpdate,
	ChannelCheer:                                     ChannelCheer,
	ChannelFollow:                                    ChannelFollow,
	ChannelGoalBegin:                                 ChannelGoalBegin,
	ChannelGoalEnd:                                   ChannelGoalEnd,
	ChannelGoalProgress:                              ChannelGoalProgress,
	ChannelGuestStarGuestUpdate:                      ChannelGuestStarGuestUpdate,
	ChannelGuestStarSessionBegin:                     ChannelGuestStarSessionBegin,
	ChannelGuestStarSessionEnd:                       ChannelGuestStarSessionEnd,
	ChannelGuestStarSettingsUpdate:                   ChannelGuestStarSettingsUpdate,
	ChannelHypeTrainBegin:                            ChannelHypeTrainBegin,
	ChannelHypeTrainEnd:                              ChannelHypeTrainEnd,
	ChannelHypeTrainProgress:                         ChannelHypeTrainProgress,
	ChannelModerate:                                  ChannelModerate,
	ChannelModeratorAdd:                              ChannelModeratorAdd,
	ChannelModeratorRemove:                           ChannelModeratorRemove,
	ChannelPollBegin:                                 ChannelPollBegin,
	ChannelPollEnd:                                   ChannelPollEnd,
	ChannelPollProgress:                              ChannelPollProgress,
	ChannelPredictionBegin:                           ChannelPredictionBegin,
	ChannelPredictionEnd:                             ChannelPredictionEnd,
	ChannelPredictionLock:                            ChannelPredictionLock,
	ChannelPredictionProgress:                        ChannelPredictionProgress,
	ChannelRaid:                                      ChannelRaid,
	ChannelSharedChatBegin:                           ChannelSharedChatBegin,
	ChannelSharedChatEnd:                             ChannelSharedChatEnd,
	ChannelSharedChatUpdate:                          ChannelSharedChatUpdate,
	ChannelShieldModeBegin:                           ChannelShieldModeBegin,
	ChannelShieldModeEnd:                             ChannelShieldModeEnd,
	ChannelShoutoutCreate:                            ChannelShoutoutCreate,
	ChannelShoutoutReceive:                           ChannelShoutoutReceive,
	ChannelSubscribe:                                 ChannelSubscribe,
	ChannelSubscriptionEnd:                           ChannelSubscriptionEnd,
	ChannelSubscriptionGift:                          ChannelSubscriptionGift,
	ChannelSubscriptionMessage:                       ChannelSubscriptionMessage,
	ChannelSuspiciousUserMessage:                     ChannelSuspiciousUserMessage,
	ChannelSuspiciousUserUpdate:                      ChannelSuspiciousUserUpdate,
	ChannelUnban:                                     ChannelUnban,
	ChannelUnbanRequestCreate:                        ChannelUnbanRequestCreate,
	ChannelUnbanRequestResolve:                       ChannelUnbanRequestResolve,
	ChannelUpdate:                                    ChannelUpdate,
	ChannelVipAdd:                                    ChannelVipAdd,
	ChannelVipRemove:                                 ChannelVipRemove,
	ChannelWarningAcknowledge:                        ChannelWarningAcknowledge,
	ChannelWarningSend:                               ChannelWarningSend,
	ConduitShardDisabled:                             ConduitShardDisabled,
	DropEntitlementGrant:                             DropEntitlementGrant,
	ExtensionBitsTransactionCreate:                   ExtensionBitsTransactionCreate,
	StreamOffline:                                    StreamOffline,
	StreamOnline:                                     StreamOnline,
	UserAuthorizationGrant:                           UserAuthorizationGrant,
	UserAuthorizationRevoke:                          UserAuthorizationRevoke,
	UserUpdate:                                       UserUpdate,
	UserWhisperMessage:                               UserWhisperMessage,
}

// Defines values for GetExtensionConfigurationSegmentParamsSegment.
const (
	GetExtensionConfigurationSegmentParamsSegmentBroadcaster GetExtensionConfigurationSegmentParamsSegment = "broadcaster"

	GetExtensionConfigurationSegmentParamsSegmentDeveloper GetExtensionConfigurationSegmentParamsSegment = "developer"

	GetExtensionConfigurationSegmentParamsSegmentGlobal GetExtensionConfigurationSegmentParamsSegment = "global"
)

// IsGetExtensionConfigurationSegmentParamsSegment returns true if the user passes in a value that is contained in the
// list of enums of GetExtensionConfigurationSegmentParamsSegment.
func IsGetExtensionConfigurationSegmentParamsSegment(val GetExtensionConfigurationSegmentParamsSegment) bool {
	switch val {
	case GetExtensionConfigurationSegmentParamsSegmentBroadcaster:
		return true
	case GetExtensionConfigurationSegmentParamsSegmentDeveloper:
		return true
	case GetExtensionConfigurationSegmentParamsSegmentGlobal:
		return true
	default:
		return false
	}
}

// GetExtensionConfigurationSegmentParamsSegmentEnumMap returns a map of all of the enum values
var GetExtensionConfigurationSegmentParamsSegmentEnumMap = map[GetExtensionConfigurationSegmentParamsSegment]GetExtensionConfigurationSegmentParamsSegment{
	GetExtensionConfigurationSegmentParamsSegmentBroadcaster: GetExtensionConfigurationSegmentParamsSegmentBroadcaster,
	GetExtensionConfigurationSegmentParamsSegmentDeveloper:   GetExtensionConfigurationSegmentParamsSegmentDeveloper,
	GetExtensionConfigurationSegmentParamsSegmentGlobal:      GetExtensionConfigurationSegmentParamsSegmentGlobal,
}

// Defines values for GetStreamsParamsType.
const (
	GetStreamsParamsTypeAll GetStreamsParamsType = "all"

	GetStreamsParamsTypeLive GetStreamsParamsType = "live"
)

// IsGetStreamsParamsType returns true if the user passes in a value that is contained in the
// list of enums of GetStreamsParamsType.
func IsGetStreamsParamsType(val GetStreamsParamsType) bool {
	switch val {
	case GetStreamsParamsTypeAll:
		return true
	case GetStreamsParamsTypeLive:
		return true
	default:
		return false
	}
}

// GetStreamsParamsTypeEnumMap returns a map of all of the enum values
var GetStreamsParamsTypeEnumMap = map[GetStreamsParamsType]GetStreamsParamsType{
	GetStreamsParamsTypeAll:  GetStreamsParamsTypeAll,
	GetStreamsParamsTypeLive: GetStreamsParamsTypeLive,
}

// Defines values for BlockUserParamsSourceContext.
const (
	Chat BlockUserParamsSourceContext = "chat"

	Whisper BlockUserParamsSourceContext = "whisper"
)

// IsBlockUserParamsSourceContext returns true if the user passes in a value that is contained in the
// list of enums of BlockUserParamsSourceContext.
func IsBlockUserParamsSourceContext(val BlockUserParamsSourceContext) bool {
	switch val {
	case Chat:
		return true
	case Whisper:
		return true
	default:
		return false
	}
}

// BlockUserParamsSourceContextEnumMap returns a map of all of the enum values
var BlockUserParamsSourceContextEnumMap = map[BlockUserParamsSourceContext]BlockUserParamsSourceContext{
	Chat:    Chat,
	Whisper: Whisper,
}

// Defines values for BlockUserParamsReason.
const (
	Harassment BlockUserParamsReason = "harassment"

	Other BlockUserParamsReason = "other"

	Spam BlockUserParamsReason = "spam"
)

// IsBlockUserParamsReason returns true if the user passes in a value that is contained in the
// list of enums of BlockUserParamsReason.
func IsBlockUserParamsReason(val BlockUserParamsReason) bool {
	switch val {
	case Harassment:
		return true
	case Other:
		return true
	case Spam:
		return true
	default:
		return false
	}
}

// BlockUserParamsReasonEnumMap returns a map of all of the enum values
var BlockUserParamsReasonEnumMap = map[BlockUserParamsReason]BlockUserParamsReason{
	Harassment: Harassment,
	Other:      Other,
	Spam:       Spam,
}

// Defines values for GetVideosParamsPeriod.
const (
	GetVideosParamsPeriodAll GetVideosParamsPeriod = "all"

	GetVideosParamsPeriodDay GetVideosParamsPeriod = "day"

	GetVideosParamsPeriodMonth GetVideosParamsPeriod = "month"

	GetVideosParamsPeriodWeek GetVideosParamsPeriod = "week"
)

// IsGetVideosParamsPeriod returns true if the user passes in a value that is contained in the
// list of enums of GetVideosParamsPeriod.
func IsGetVideosParamsPeriod(val GetVideosParamsPeriod) bool {
	switch val {
	case GetVideosParamsPeriodAll:
		return true
	case GetVideosParamsPeriodDay:
		return true
	case GetVideosParamsPeriodMonth:
		return true
	case GetVideosParamsPeriodWeek:
		return true
	default:
		return false
	}
}

// GetVideosParamsPeriodEnumMap returns a map of all of the enum values
var GetVideosParamsPeriodEnumMap = map[GetVideosParamsPeriod]GetVideosParamsPeriod{
	GetVideosParamsPeriodAll:   GetVideosParamsPeriodAll,
	GetVideosParamsPeriodDay:   GetVideosParamsPeriodDay,
	GetVideosParamsPeriodMonth: GetVideosParamsPeriodMonth,
	GetVideosParamsPeriodWeek:  GetVideosParamsPeriodWeek,
}

// Defines values for GetVideosParamsSort.
const (
	Time GetVideosParamsSort = "time"

	Trending GetVideosParamsSort = "trending"

	Views GetVideosParamsSort = "views"
)

// IsGetVideosParamsSort returns true if the user passes in a value that is contained in the
// list of enums of GetVideosParamsSort.
func IsGetVideosParamsSort(val GetVideosParamsSort) bool {
	switch val {
	case Time:
		return true
	case Trending:
		return true
	case Views:
		return true
	default:
		return false
	}
}

// GetVideosParamsSortEnumMap returns a map of all of the enum values
var GetVideosParamsSortEnumMap = map[GetVideosParamsSort]GetVideosParamsSort{
	Time:     Time,
	Trending: Trending,
	Views:    Views,
}

// Defines values for GetVideosParamsType.
const (
	GetVideosParamsTypeAll GetVideosParamsType = "all"

	GetVideosParamsTypeArchive GetVideosParamsType = "archive"

	GetVideosParamsTypeHighlight GetVideosParamsType = "highlight"

	GetVideosParamsTypeUpload GetVideosParamsType = "upload"
)

// IsGetVideosParamsType returns true if the user passes in a value that is contained in the
// list of enums of GetVideosParamsType.
func IsGetVideosParamsType(val GetVideosParamsType) bool {
	switch val {
	case GetVideosParamsTypeAll:
		return true
	case GetVideosParamsTypeArchive:
		return true
	case GetVideosParamsTypeHighlight:
		return true
	case GetVideosParamsTypeUpload:
		return true
	default:
		return false
	}
}

// GetVideosParamsTypeEnumMap returns a map of all of the enum values
var GetVideosParamsTypeEnumMap = map[GetVideosParamsType]GetVideosParamsType{
	GetVideosParamsTypeAll:       GetVideosParamsTypeAll,
	GetVideosParamsTypeArchive:   GetVideosParamsTypeArchive,
	GetVideosParamsTypeHighlight: GetVideosParamsTypeHighlight,
	GetVideosParamsTypeUpload:    GetVideosParamsTypeUpload,
}

func RegisterEnumValidators(v *validator.Validate) {

	v.RegisterValidation("isValidBroadcasterSubscriptionTier", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(BroadcasterSubscriptionTier)
		var empty BroadcasterSubscriptionTier
		return data == empty || IsBroadcasterSubscriptionTier(data)
	}, false)

	v.RegisterValidation("isValidChannelEmoteEmoteType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ChannelEmoteEmoteType)
		var empty ChannelEmoteEmoteType
		return data == empty || IsChannelEmoteEmoteType(data)
	}, false)

	v.RegisterValidation("isValidChannelEmoteFormat", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ChannelEmoteFormat)
		var empty ChannelEmoteFormat
		return data == empty || IsChannelEmoteFormat(data)
	}, false)

	v.RegisterValidation("isValidChannelEmoteScale", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ChannelEmoteScale)
		var empty ChannelEmoteScale
		return data == empty || IsChannelEmoteScale(data)
	}, false)

	v.RegisterValidation("isValidChannelEmoteThemeMode", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ChannelEmoteThemeMode)
		var empty ChannelEmoteThemeMode
		return data == empty || IsChannelEmoteThemeMode(data)
	}, false)

	v.RegisterValidation("isValidCheermoteTiersId", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(CheermoteTiersId)
		var empty CheermoteTiersId
		return data == empty || IsCheermoteTiersId(data)
	}, false)

	v.RegisterValidation("isValidCheermoteType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(CheermoteType)
		var empty CheermoteType
		return data == empty || IsCheermoteType(data)
	}, false)

	v.RegisterValidation("isValidCreateEventSubSubscriptionBodyTransportMethod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(CreateEventSubSubscriptionBodyTransportMethod)
		var empty CreateEventSubSubscriptionBodyTransportMethod
		return data == empty || IsCreateEventSubSubscriptionBodyTransportMethod(data)
	}, false)

	v.RegisterValidation("isValidCreateEventSubSubscriptionBodyType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(CreateEventSubSubscriptionBodyType)
		var empty CreateEventSubSubscriptionBodyType
		return data == empty || IsCreateEventSubSubscriptionBodyType(data)
	}, false)

	v.RegisterValidation("isValidCreatorGoalType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(CreatorGoalType)
		var empty CreatorGoalType
		return data == empty || IsCreatorGoalType(data)
	}, false)

	v.RegisterValidation("isValidCustomRewardRedemptionStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(CustomRewardRedemptionStatus)
		var empty CustomRewardRedemptionStatus
		return data == empty || IsCustomRewardRedemptionStatus(data)
	}, false)

	v.RegisterValidation("isValidDropsEntitlementFulfillmentStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(DropsEntitlementFulfillmentStatus)
		var empty DropsEntitlementFulfillmentStatus
		return data == empty || IsDropsEntitlementFulfillmentStatus(data)
	}, false)

	v.RegisterValidation("isValidDropsEntitlementUpdatedStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(DropsEntitlementUpdatedStatus)
		var empty DropsEntitlementUpdatedStatus
		return data == empty || IsDropsEntitlementUpdatedStatus(data)
	}, false)

	v.RegisterValidation("isValidEmoteEmoteType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EmoteEmoteType)
		var empty EmoteEmoteType
		return data == empty || IsEmoteEmoteType(data)
	}, false)

	v.RegisterValidation("isValidEmoteFormat", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EmoteFormat)
		var empty EmoteFormat
		return data == empty || IsEmoteFormat(data)
	}, false)

	v.RegisterValidation("isValidEmoteScale", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EmoteScale)
		var empty EmoteScale
		return data == empty || IsEmoteScale(data)
	}, false)

	v.RegisterValidation("isValidEmoteThemeMode", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EmoteThemeMode)
		var empty EmoteThemeMode
		return data == empty || IsEmoteThemeMode(data)
	}, false)

	v.RegisterValidation("isValidEndPollBodyStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EndPollBodyStatus)
		var empty EndPollBodyStatus
		return data == empty || IsEndPollBodyStatus(data)
	}, false)

	v.RegisterValidation("isValidEndPredictionBodyStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EndPredictionBodyStatus)
		var empty EndPredictionBodyStatus
		return data == empty || IsEndPredictionBodyStatus(data)
	}, false)

	v.RegisterValidation("isValidEventSubSubscriptionStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EventSubSubscriptionStatus)
		var empty EventSubSubscriptionStatus
		return data == empty || IsEventSubSubscriptionStatus(data)
	}, false)

	v.RegisterValidation("isValidEventSubSubscriptionTransportMethod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EventSubSubscriptionTransportMethod)
		var empty EventSubSubscriptionTransportMethod
		return data == empty || IsEventSubSubscriptionTransportMethod(data)
	}, false)

	v.RegisterValidation("isValidEventSubSubscriptionType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(EventSubSubscriptionType)
		var empty EventSubSubscriptionType
		return data == empty || IsEventSubSubscriptionType(data)
	}, false)

	v.RegisterValidation("isValidExtensionConfigurationLocation", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionConfigurationLocation)
		var empty ExtensionConfigurationLocation
		return data == empty || IsExtensionConfigurationLocation(data)
	}, false)

	v.RegisterValidation("isValidExtensionState", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionState)
		var empty ExtensionState
		return data == empty || IsExtensionState(data)
	}, false)

	v.RegisterValidation("isValidExtensionSubscriptionsSupportLevel", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionSubscriptionsSupportLevel)
		var empty ExtensionSubscriptionsSupportLevel
		return data == empty || IsExtensionSubscriptionsSupportLevel(data)
	}, false)

	v.RegisterValidation("isValidExtensionBitsProductCostType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionBitsProductCostType)
		var empty ExtensionBitsProductCostType
		return data == empty || IsExtensionBitsProductCostType(data)
	}, false)

	v.RegisterValidation("isValidExtensionConfigurationSegmentSegment", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionConfigurationSegmentSegment)
		var empty ExtensionConfigurationSegmentSegment
		return data == empty || IsExtensionConfigurationSegmentSegment(data)
	}, false)

	v.RegisterValidation("isValidExtensionTransactionProductDataCostType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionTransactionProductDataCostType)
		var empty ExtensionTransactionProductDataCostType
		return data == empty || IsExtensionTransactionProductDataCostType(data)
	}, false)

	v.RegisterValidation("isValidExtensionTransactionProductType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ExtensionTransactionProductType)
		var empty ExtensionTransactionProductType
		return data == empty || IsExtensionTransactionProductType(data)
	}, false)

	v.RegisterValidation("isValidGetChannelGuestStarSettingsResponseGroupLayout", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetChannelGuestStarSettingsResponseGroupLayout)
		var empty GetChannelGuestStarSettingsResponseGroupLayout
		return data == empty || IsGetChannelGuestStarSettingsResponseGroupLayout(data)
	}, false)

	v.RegisterValidation("isValidGetConduitShardsResponseDataStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetConduitShardsResponseDataStatus)
		var empty GetConduitShardsResponseDataStatus
		return data == empty || IsGetConduitShardsResponseDataStatus(data)
	}, false)

	v.RegisterValidation("isValidGetConduitShardsResponseDataTransportMethod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetConduitShardsResponseDataTransportMethod)
		var empty GetConduitShardsResponseDataTransportMethod
		return data == empty || IsGetConduitShardsResponseDataTransportMethod(data)
	}, false)

	v.RegisterValidation("isValidGetUserEmotesResponseDataEmoteType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetUserEmotesResponseDataEmoteType)
		var empty GetUserEmotesResponseDataEmoteType
		return data == empty || IsGetUserEmotesResponseDataEmoteType(data)
	}, false)

	v.RegisterValidation("isValidGlobalEmoteFormat", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GlobalEmoteFormat)
		var empty GlobalEmoteFormat
		return data == empty || IsGlobalEmoteFormat(data)
	}, false)

	v.RegisterValidation("isValidGlobalEmoteScale", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GlobalEmoteScale)
		var empty GlobalEmoteScale
		return data == empty || IsGlobalEmoteScale(data)
	}, false)

	v.RegisterValidation("isValidGlobalEmoteThemeMode", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GlobalEmoteThemeMode)
		var empty GlobalEmoteThemeMode
		return data == empty || IsGlobalEmoteThemeMode(data)
	}, false)

	v.RegisterValidation("isValidHypeTrainEventEventDataLastContributionType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(HypeTrainEventEventDataLastContributionType)
		var empty HypeTrainEventEventDataLastContributionType
		return data == empty || IsHypeTrainEventEventDataLastContributionType(data)
	}, false)

	v.RegisterValidation("isValidHypeTrainEventEventDataTopContributionsType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(HypeTrainEventEventDataTopContributionsType)
		var empty HypeTrainEventEventDataTopContributionsType
		return data == empty || IsHypeTrainEventEventDataTopContributionsType(data)
	}, false)

	v.RegisterValidation("isValidManageHeldAutoModMessagesBodyAction", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ManageHeldAutoModMessagesBodyAction)
		var empty ManageHeldAutoModMessagesBodyAction
		return data == empty || IsManageHeldAutoModMessagesBodyAction(data)
	}, false)

	v.RegisterValidation("isValidModifyChannelInformationBodyContentClassificationLabelsId", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(ModifyChannelInformationBodyContentClassificationLabelsId)
		var empty ModifyChannelInformationBodyContentClassificationLabelsId
		return data == empty || IsModifyChannelInformationBodyContentClassificationLabelsId(data)
	}, false)

	v.RegisterValidation("isValidPollStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(PollStatus)
		var empty PollStatus
		return data == empty || IsPollStatus(data)
	}, false)

	v.RegisterValidation("isValidPredictionStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(PredictionStatus)
		var empty PredictionStatus
		return data == empty || IsPredictionStatus(data)
	}, false)

	v.RegisterValidation("isValidPredictionOutcomeColor", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(PredictionOutcomeColor)
		var empty PredictionOutcomeColor
		return data == empty || IsPredictionOutcomeColor(data)
	}, false)

	v.RegisterValidation("isValidSendChatAnnouncementBodyColor", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(SendChatAnnouncementBodyColor)
		var empty SendChatAnnouncementBodyColor
		return data == empty || IsSendChatAnnouncementBodyColor(data)
	}, false)

	v.RegisterValidation("isValidSendExtensionPubSubMessageBodyTarget", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(SendExtensionPubSubMessageBodyTarget)
		var empty SendExtensionPubSubMessageBodyTarget
		return data == empty || IsSendExtensionPubSubMessageBodyTarget(data)
	}, false)

	v.RegisterValidation("isValidSetExtensionConfigurationSegmentBodySegment", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(SetExtensionConfigurationSegmentBodySegment)
		var empty SetExtensionConfigurationSegmentBodySegment
		return data == empty || IsSetExtensionConfigurationSegmentBodySegment(data)
	}, false)

	v.RegisterValidation("isValidStreamType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(StreamType)
		var empty StreamType
		return data == empty || IsStreamType(data)
	}, false)

	v.RegisterValidation("isValidUpdateChannelGuestStarSettingsBodyGroupLayout", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateChannelGuestStarSettingsBodyGroupLayout)
		var empty UpdateChannelGuestStarSettingsBodyGroupLayout
		return data == empty || IsUpdateChannelGuestStarSettingsBodyGroupLayout(data)
	}, false)

	v.RegisterValidation("isValidUpdateChatSettingsBodyNonModeratorChatDelayDuration", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateChatSettingsBodyNonModeratorChatDelayDuration)
		var empty UpdateChatSettingsBodyNonModeratorChatDelayDuration
		return data == empty || IsUpdateChatSettingsBodyNonModeratorChatDelayDuration(data)
	}, false)

	v.RegisterValidation("isValidUpdateConduitShardsBodyShardsTransportMethod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateConduitShardsBodyShardsTransportMethod)
		var empty UpdateConduitShardsBodyShardsTransportMethod
		return data == empty || IsUpdateConduitShardsBodyShardsTransportMethod(data)
	}, false)

	v.RegisterValidation("isValidUpdateConduitShardsResponseDataStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateConduitShardsResponseDataStatus)
		var empty UpdateConduitShardsResponseDataStatus
		return data == empty || IsUpdateConduitShardsResponseDataStatus(data)
	}, false)

	v.RegisterValidation("isValidUpdateConduitShardsResponseDataTransportMethod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateConduitShardsResponseDataTransportMethod)
		var empty UpdateConduitShardsResponseDataTransportMethod
		return data == empty || IsUpdateConduitShardsResponseDataTransportMethod(data)
	}, false)

	v.RegisterValidation("isValidUpdateDropsEntitlementsBodyFulfillmentStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateDropsEntitlementsBodyFulfillmentStatus)
		var empty UpdateDropsEntitlementsBodyFulfillmentStatus
		return data == empty || IsUpdateDropsEntitlementsBodyFulfillmentStatus(data)
	}, false)

	v.RegisterValidation("isValidUpdateExtensionBitsProductBodyCostType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateExtensionBitsProductBodyCostType)
		var empty UpdateExtensionBitsProductBodyCostType
		return data == empty || IsUpdateExtensionBitsProductBodyCostType(data)
	}, false)

	v.RegisterValidation("isValidUpdateRedemptionStatusBodyStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateRedemptionStatusBodyStatus)
		var empty UpdateRedemptionStatusBodyStatus
		return data == empty || IsUpdateRedemptionStatusBodyStatus(data)
	}, false)

	v.RegisterValidation("isValidUserBroadcasterType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UserBroadcasterType)
		var empty UserBroadcasterType
		return data == empty || IsUserBroadcasterType(data)
	}, false)

	v.RegisterValidation("isValidUserType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UserType)
		var empty UserType
		return data == empty || IsUserType(data)
	}, false)

	v.RegisterValidation("isValidUserExtensionType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UserExtensionType)
		var empty UserExtensionType
		return data == empty || IsUserExtensionType(data)
	}, false)

	v.RegisterValidation("isValidUserSubscriptionTier", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UserSubscriptionTier)
		var empty UserSubscriptionTier
		return data == empty || IsUserSubscriptionTier(data)
	}, false)

	v.RegisterValidation("isValidVideoType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(VideoType)
		var empty VideoType
		return data == empty || IsVideoType(data)
	}, false)

	v.RegisterValidation("isValidGetExtensionAnalyticsParamsType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetExtensionAnalyticsParamsType)
		var empty GetExtensionAnalyticsParamsType
		return data == empty || IsGetExtensionAnalyticsParamsType(data)
	}, false)

	v.RegisterValidation("isValidGetGameAnalyticsParamsType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetGameAnalyticsParamsType)
		var empty GetGameAnalyticsParamsType
		return data == empty || IsGetGameAnalyticsParamsType(data)
	}, false)

	v.RegisterValidation("isValidGetBitsLeaderboardParamsPeriod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetBitsLeaderboardParamsPeriod)
		var empty GetBitsLeaderboardParamsPeriod
		return data == empty || IsGetBitsLeaderboardParamsPeriod(data)
	}, false)

	v.RegisterValidation("isValidGetCustomRewardRedemptionParamsStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetCustomRewardRedemptionParamsStatus)
		var empty GetCustomRewardRedemptionParamsStatus
		return data == empty || IsGetCustomRewardRedemptionParamsStatus(data)
	}, false)

	v.RegisterValidation("isValidGetCustomRewardRedemptionParamsSort", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetCustomRewardRedemptionParamsSort)
		var empty GetCustomRewardRedemptionParamsSort
		return data == empty || IsGetCustomRewardRedemptionParamsSort(data)
	}, false)

	v.RegisterValidation("isValidUpdateUserChatColorParamsColor", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(UpdateUserChatColorParamsColor)
		var empty UpdateUserChatColorParamsColor
		return data == empty || IsUpdateUserChatColorParamsColor(data)
	}, false)

	v.RegisterValidation("isValidGetDropsEntitlementsParamsFulfillmentStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetDropsEntitlementsParamsFulfillmentStatus)
		var empty GetDropsEntitlementsParamsFulfillmentStatus
		return data == empty || IsGetDropsEntitlementsParamsFulfillmentStatus(data)
	}, false)

	v.RegisterValidation("isValidGetEventsubSubscriptionsParamsStatus", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetEventsubSubscriptionsParamsStatus)
		var empty GetEventsubSubscriptionsParamsStatus
		return data == empty || IsGetEventsubSubscriptionsParamsStatus(data)
	}, false)

	v.RegisterValidation("isValidGetEventsubSubscriptionsParamsType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetEventsubSubscriptionsParamsType)
		var empty GetEventsubSubscriptionsParamsType
		return data == empty || IsGetEventsubSubscriptionsParamsType(data)
	}, false)

	v.RegisterValidation("isValidGetExtensionConfigurationSegmentParamsSegment", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetExtensionConfigurationSegmentParamsSegment)
		var empty GetExtensionConfigurationSegmentParamsSegment
		return data == empty || IsGetExtensionConfigurationSegmentParamsSegment(data)
	}, false)

	v.RegisterValidation("isValidGetStreamsParamsType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetStreamsParamsType)
		var empty GetStreamsParamsType
		return data == empty || IsGetStreamsParamsType(data)
	}, false)

	v.RegisterValidation("isValidBlockUserParamsSourceContext", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(BlockUserParamsSourceContext)
		var empty BlockUserParamsSourceContext
		return data == empty || IsBlockUserParamsSourceContext(data)
	}, false)

	v.RegisterValidation("isValidBlockUserParamsReason", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(BlockUserParamsReason)
		var empty BlockUserParamsReason
		return data == empty || IsBlockUserParamsReason(data)
	}, false)

	v.RegisterValidation("isValidGetVideosParamsPeriod", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetVideosParamsPeriod)
		var empty GetVideosParamsPeriod
		return data == empty || IsGetVideosParamsPeriod(data)
	}, false)

	v.RegisterValidation("isValidGetVideosParamsSort", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetVideosParamsSort)
		var empty GetVideosParamsSort
		return data == empty || IsGetVideosParamsSort(data)
	}, false)

	v.RegisterValidation("isValidGetVideosParamsType", func(sl validator.FieldLevel) bool {
		data := sl.Field().Interface().(GetVideosParamsType)
		var empty GetVideosParamsType
		return data == empty || IsGetVideosParamsType(data)
	}, false)

}

//Generated with typedef.tmpl

// AddBlockedTermBody defines model for AddBlockedTermBody.
type AddBlockedTermBody struct {
	// Text The word or phrase to block from being used in the broadcasters chat room. The term must contain a minimum of 2 characters and may contain up to a maximum of 500 characters.
	//
	// Terms may include a wildcard character (\*). The wildcard character must appear at the beginning or end of a word or set of characters. For example, \*foo or foo\*.
	//
	// If the blocked term already exists, the response contains the existing blocked term.
	Text string `json:"text"`
}

func (datatype AddBlockedTermBody) GetText() string {
	return datatype.Text
}

// AddBlockedTermResponse defines model for AddBlockedTermResponse.
type AddBlockedTermResponse struct {
	// Data A list that contains the single blocked term that the broadcaster added.
	Data []BlockedTerm `json:"data"`
}

func (datatype AddBlockedTermResponse) GetData() []BlockedTerm {
	return datatype.Data
}

// AutoModSettings defines model for AutoModSettings.
type AutoModSettings struct {
	// Aggression The Automod level for hostility involving aggression.
	Aggression int32 `json:"aggression"`

	// BroadcasterId The broadcasters ID.
	BroadcasterId string `json:"broadcaster_id"`

	// Bullying The Automod level for hostility involving name calling or insults.
	Bullying int32 `json:"bullying"`

	// Disability The Automod level for discrimination against disability.
	Disability int32 `json:"disability"`

	// Misogyny The Automod level for discrimination against women.
	Misogyny int32 `json:"misogyny"`

	// ModeratorId The moderators ID.
	ModeratorId string `json:"moderator_id"`

	// OverallLevel The default AutoMod level for the broadcaster. This field is **null** if the broadcaster has set one or more of the individual settings.
	OverallLevel *int32 `json:"overall_level"`

	// RaceEthnicityOrReligion The Automod level for racial discrimination.
	RaceEthnicityOrReligion int32 `json:"race_ethnicity_or_religion"`

	// SexBasedTerms The Automod level for sexual content.
	SexBasedTerms int32 `json:"sex_based_terms"`

	// SexualitySexOrGender The AutoMod level for discrimination based on sexuality, sex, or gender.
	SexualitySexOrGender int32 `json:"sexuality_sex_or_gender"`

	// Swearing The Automod level for profanity.
	Swearing int32 `json:"swearing"`
}

func (datatype AutoModSettings) GetAggression() int32 {
	return datatype.Aggression
}
func (datatype AutoModSettings) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype AutoModSettings) GetBullying() int32 {
	return datatype.Bullying
}
func (datatype AutoModSettings) GetDisability() int32 {
	return datatype.Disability
}
func (datatype AutoModSettings) GetMisogyny() int32 {
	return datatype.Misogyny
}
func (datatype AutoModSettings) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype AutoModSettings) GetOverallLevel() int32 {
	if datatype.OverallLevel == nil {
		var empty int32
		return empty
	}
	return *datatype.OverallLevel
}
func (datatype AutoModSettings) GetRaceEthnicityOrReligion() int32 {
	return datatype.RaceEthnicityOrReligion
}
func (datatype AutoModSettings) GetSexBasedTerms() int32 {
	return datatype.SexBasedTerms
}
func (datatype AutoModSettings) GetSexualitySexOrGender() int32 {
	return datatype.SexualitySexOrGender
}
func (datatype AutoModSettings) GetSwearing() int32 {
	return datatype.Swearing
}

// AutoModStatus defines model for AutoModStatus.
type AutoModStatus struct {
	// IsPermitted A Boolean value that indicates whether Twitch would approve the message for chat or hold it for moderator review or block it from chat. Is **true** if Twitch would approve the message; otherwise, **false** if Twitch would hold the message for moderator review or block it from chat.
	IsPermitted bool `json:"is_permitted"`

	// MsgId The caller-defined ID passed in the request.
	MsgId string `json:"msg_id"`
}

func (datatype AutoModStatus) GetIsPermitted() bool {
	return datatype.IsPermitted
}
func (datatype AutoModStatus) GetMsgId() string {
	return datatype.MsgId
}

// BanUserBody defines model for BanUserBody.
type BanUserBody struct {
	// Data Identifies the user and type of ban.
	Data struct {
		// Duration To ban a user indefinitely, dont include this field.
		//
		// To put a user in a timeout, include this field and specify the timeout period, in seconds. The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks).
		//
		// To end a users timeout early, set this field to 1, or use the [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user) endpoint.
		Duration *int32 `json:"duration,omitempty"`

		// Reason The reason the youre banning the user or putting them in a timeout. The text is user defined and is limited to a maximum of 500 characters.
		Reason *string `json:"reason,omitempty"`

		// UserId The ID of the user to ban or put in a timeout.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype BanUserBody) GetData() struct {
	// Duration To ban a user indefinitely, dont include this field.
	//
	// To put a user in a timeout, include this field and specify the timeout period, in seconds. The minimum timeout is 1 second and the maximum is 1,209,600 seconds (2 weeks).
	//
	// To end a users timeout early, set this field to 1, or use the [Unban user](https://dev.twitch.tv/docs/api/reference#unban-user) endpoint.
	Duration *int32 `json:"duration,omitempty"`

	// Reason The reason the youre banning the user or putting them in a timeout. The text is user defined and is limited to a maximum of 500 characters.
	Reason *string `json:"reason,omitempty"`

	// UserId The ID of the user to ban or put in a timeout.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// BanUserResponse defines model for BanUserResponse.
type BanUserResponse struct {
	// Data A list that contains the user you successfully banned or put in a timeout.
	Data []struct {
		// BroadcasterId The broadcaster whose chat room the user was banned from chatting in.
		BroadcasterId string `json:"broadcaster_id"`

		// CreatedAt The UTC date and time (in RFC3339 format) that the ban or timeout was placed.
		CreatedAt time.Time `json:"created_at"`

		// EndTime The UTC date and time (in RFC3339 format) that the timeout will end. Is **null** if the user was banned instead of being put in a timeout.
		EndTime *time.Time `json:"end_time"`

		// ModeratorId The moderator that banned or put the user in the timeout.
		ModeratorId string `json:"moderator_id"`

		// UserId The user that was banned or put in a timeout.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype BanUserResponse) GetData() []struct {
	// BroadcasterId The broadcaster whose chat room the user was banned from chatting in.
	BroadcasterId string `json:"broadcaster_id"`

	// CreatedAt The UTC date and time (in RFC3339 format) that the ban or timeout was placed.
	CreatedAt time.Time `json:"created_at"`

	// EndTime The UTC date and time (in RFC3339 format) that the timeout will end. Is **null** if the user was banned instead of being put in a timeout.
	EndTime *time.Time `json:"end_time"`

	// ModeratorId The moderator that banned or put the user in the timeout.
	ModeratorId string `json:"moderator_id"`

	// UserId The user that was banned or put in a timeout.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// BannedUser defines model for BannedUser.
type BannedUser struct {
	// CreatedAt The UTC date and time (in RFC3339 format) of when the user was banned.
	CreatedAt time.Time `json:"created_at"`

	// ExpiresAt The UTC date and time (in RFC3339 format) of when the timeout expires, or an empty string if the user is permanently banned.
	ExpiresAt time.Time `json:"expires_at"`

	// ModeratorId The ID of the moderator that banned the user or put them in a timeout.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name.
	ModeratorName string `json:"moderator_name"`

	// Reason The reason the user was banned or put in a timeout if the moderator provided one.
	Reason string `json:"reason"`

	// UserId The ID of the banned user.
	UserId string `json:"user_id"`

	// UserLogin The banned users login name.
	UserLogin string `json:"user_login"`

	// UserName The banned users display name.
	UserName string `json:"user_name"`
}

func (datatype BannedUser) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype BannedUser) GetExpiresAt() time.Time {
	return datatype.ExpiresAt
}
func (datatype BannedUser) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype BannedUser) GetModeratorLogin() string {
	return datatype.ModeratorLogin
}
func (datatype BannedUser) GetModeratorName() string {
	return datatype.ModeratorName
}
func (datatype BannedUser) GetReason() string {
	return datatype.Reason
}
func (datatype BannedUser) GetUserId() string {
	return datatype.UserId
}
func (datatype BannedUser) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype BannedUser) GetUserName() string {
	return datatype.UserName
}

// BitsLeaderboard defines model for BitsLeaderboard.
type BitsLeaderboard struct {
	// Rank The users position on the leaderboard.
	Rank int32 `json:"rank"`

	// Score The number of Bits the user has cheered.
	Score int32 `json:"score"`

	// UserId An ID that identifies a user on the leaderboard.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype BitsLeaderboard) GetRank() int32 {
	return datatype.Rank
}
func (datatype BitsLeaderboard) GetScore() int32 {
	return datatype.Score
}
func (datatype BitsLeaderboard) GetUserId() string {
	return datatype.UserId
}
func (datatype BitsLeaderboard) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype BitsLeaderboard) GetUserName() string {
	return datatype.UserName
}

// BlockedTerm defines model for BlockedTerm.
type BlockedTerm struct {
	// BroadcasterId The broadcaster that owns the list of blocked terms.
	BroadcasterId string `json:"broadcaster_id"`

	// CreatedAt The UTC date and time (in RFC3339 format) that the term was blocked.
	CreatedAt time.Time `json:"created_at"`

	// ExpiresAt The UTC date and time (in RFC3339 format) that the blocked term is set to expire. After the block expires, users may use the term in the broadcasters chat room.
	//
	// This field is **null** if the term was added manually or was permanently blocked by AutoMod.
	ExpiresAt *time.Time `json:"expires_at"`

	// Id An ID that identifies this blocked term.
	Id string `json:"id"`

	// ModeratorId The moderator that blocked the word or phrase from being used in the broadcasters chat room.
	ModeratorId string `json:"moderator_id"`

	// Text The blocked word or phrase.
	Text string `json:"text"`

	// UpdatedAt The UTC date and time (in RFC3339 format) that the term was updated.
	//
	// When the term is added, this timestamp is the same as `created_at`. The timestamp changes as AutoMod continues to deny the term.
	UpdatedAt time.Time `json:"updated_at"`
}

func (datatype BlockedTerm) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype BlockedTerm) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype BlockedTerm) GetExpiresAt() time.Time {
	if datatype.ExpiresAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.ExpiresAt
}
func (datatype BlockedTerm) GetId() string {
	return datatype.Id
}
func (datatype BlockedTerm) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype BlockedTerm) GetText() string {
	return datatype.Text
}
func (datatype BlockedTerm) GetUpdatedAt() time.Time {
	return datatype.UpdatedAt
}

// BroadcasterSubscription defines model for BroadcasterSubscription.
type BroadcasterSubscription struct {
	// BroadcasterId An ID that identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// GifterId The ID of the user that gifted the subscription to the user. Is an empty string if `is_gift` is **false**.
	GifterId string `json:"gifter_id"`

	// GifterLogin The gifters login name. Is an empty string if `is_gift` is **false**.
	GifterLogin string `json:"gifter_login"`

	// GifterName The gifters display name. Is an empty string if `is_gift` is **false**.
	GifterName string `json:"gifter_name"`

	// IsGift A Boolean value that determines whether the subscription is a gift subscription. Is **true** if the subscription was gifted.
	IsGift bool `json:"is_gift"`

	// PlanName The name of the subscription.
	PlanName string `json:"plan_name"`

	// Tier The type of subscription. Possible values are:
	//
	// * 1000  Tier 1
	// * 2000  Tier 2
	// * 3000  Tier 3
	Tier BroadcasterSubscriptionTier `json:"tier"`

	// UserId An ID that identifies the subscribing user.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype BroadcasterSubscription) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype BroadcasterSubscription) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype BroadcasterSubscription) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype BroadcasterSubscription) GetGifterId() string {
	return datatype.GifterId
}
func (datatype BroadcasterSubscription) GetGifterLogin() string {
	return datatype.GifterLogin
}
func (datatype BroadcasterSubscription) GetGifterName() string {
	return datatype.GifterName
}
func (datatype BroadcasterSubscription) GetIsGift() bool {
	return datatype.IsGift
}
func (datatype BroadcasterSubscription) GetPlanName() string {
	return datatype.PlanName
}
func (datatype BroadcasterSubscription) GetTier() BroadcasterSubscriptionTier {
	return datatype.Tier
}
func (datatype BroadcasterSubscription) GetUserId() string {
	return datatype.UserId
}
func (datatype BroadcasterSubscription) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype BroadcasterSubscription) GetUserName() string {
	return datatype.UserName
}

// BroadcasterSubscriptionTier The type of subscription. Possible values are:
//
// * 1000  Tier 1
// * 2000  Tier 2
// * 3000  Tier 3
type BroadcasterSubscriptionTier string

// Category defines model for Category.
type Category struct {
	// BoxArtUrl A URL to an image of the games box art or streaming category.
	BoxArtUrl string `json:"box_art_url"`

	// Id An ID that uniquely identifies the game or category.
	Id string `json:"id"`

	// Name The name of the game or category.
	Name string `json:"name"`
}

func (datatype Category) GetBoxArtUrl() string {
	return datatype.BoxArtUrl
}
func (datatype Category) GetId() string {
	return datatype.Id
}
func (datatype Category) GetName() string {
	return datatype.Name
}

// Channel defines model for Channel.
type Channel struct {
	// BroadcasterLanguage The ISO 639-1 two-letter language code of the language used by the broadcaster. For example, _en_ for English. If the broadcaster uses a language not in the list of [supported stream languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang), the value is _other_.
	BroadcasterLanguage string `json:"broadcaster_language"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// DisplayName The broadcasters display name.
	DisplayName string `json:"display_name"`

	// GameId The ID of the game that the broadcaster is playing or last played.
	GameId string `json:"game_id"`

	// GameName The name of the game that the broadcaster is playing or last played.
	GameName string `json:"game_name"`

	// Id An ID that uniquely identifies the channel (this is the broadcasters ID).
	Id string `json:"id"`

	// IsLive A Boolean value that determines whether the broadcaster is streaming live. Is **true** if the broadcaster is streaming live; otherwise, **false**.
	IsLive bool `json:"is_live"`

	// StartedAt The UTC date and time (in RFC3339 format) of when the broadcaster started streaming. The string is empty if the broadcaster is not streaming live.
	StartedAt time.Time `json:"started_at"`

	// TagIds **IMPORTANT** As of February 28, 2023, this field is deprecated and returns only an empty array. If you use this field, please update your code to use the `tags` field.
	//
	// The list of tags that apply to the stream. The list contains IDs only when the channel is steaming live. For a list of possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags). The list doesnt include Category Tags.
	// Deprecated:
	TagIds []string `json:"tag_ids"`

	// Tags The tags applied to the channel.
	Tags []string `json:"tags"`

	// ThumbnailUrl A URL to a thumbnail of the broadcasters profile image.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The streams title. Is an empty string if the broadcaster didnt set it.
	Title string `json:"title"`
}

func (datatype Channel) GetBroadcasterLanguage() string {
	return datatype.BroadcasterLanguage
}
func (datatype Channel) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype Channel) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype Channel) GetGameId() string {
	return datatype.GameId
}
func (datatype Channel) GetGameName() string {
	return datatype.GameName
}
func (datatype Channel) GetId() string {
	return datatype.Id
}
func (datatype Channel) GetIsLive() bool {
	return datatype.IsLive
}
func (datatype Channel) GetStartedAt() time.Time {
	return datatype.StartedAt
}
func (datatype Channel) GetTagIds() []string {
	return datatype.TagIds
}
func (datatype Channel) GetTags() []string {
	return datatype.Tags
}
func (datatype Channel) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Channel) GetTitle() string {
	return datatype.Title
}

// ChannelEditor defines model for ChannelEditor.
type ChannelEditor struct {
	// CreatedAt The date and time, in RFC3339 format, when the user became one of the broadcasters editors.
	CreatedAt time.Time `json:"created_at"`

	// UserId An ID that uniquely identifies a user with editor permissions.
	UserId string `json:"user_id"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype ChannelEditor) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype ChannelEditor) GetUserId() string {
	return datatype.UserId
}
func (datatype ChannelEditor) GetUserName() string {
	return datatype.UserName
}

// ChannelEmote defines model for ChannelEmote.
type ChannelEmote struct {
	// EmoteSetId An ID that identifies the emote set that the emote belongs to.
	EmoteSetId string `json:"emote_set_id"`

	// EmoteType The type of emote. The possible values are:
	//
	// * bitstier  A custom Bits tier emote.
	// * follower  A custom follower emote.
	// * subscriptions  A custom subscriber emote.
	EmoteType ChannelEmoteEmoteType `json:"emote_type"`

	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:
	//
	// * animated  An animated GIF is available for this emote.
	// * static  A static PNG file is available for this emote.
	Format []ChannelEmoteFormat `json:"format"`

	// Id An ID that identifies this emote.
	Id string `json:"id"`

	// Images The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.
	//
	// **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
	Images struct {
		// Url1x A URL to the small version (28px x 28px) of the emote.
		Url1x string `json:"url_1x"`

		// Url2x A URL to the medium version (56px x 56px) of the emote.
		Url2x string `json:"url_2x"`

		// Url4x A URL to the large version (112px x 112px) of the emote.
		Url4x string `json:"url_4x"`
	} `json:"images"`

	// Name The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
	Name string `json:"name"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:
	//
	// * 1.0  A small version (28px x 28px) is available.
	// * 2.0  A medium version (56px x 56px) is available.
	// * 3.0  A large version (112px x 112px) is available.
	Scale []ChannelEmoteScale `json:"scale"`

	// ThemeMode The background themes that the emote is available in. Possible themes are:
	//
	// * dark
	// * light
	ThemeMode []ChannelEmoteThemeMode `json:"theme_mode"`

	// Tier The subscriber tier at which the emote is unlocked. This field contains the tier information only if `emote_type` is set to `subscriptions`, otherwise, it's an empty string.
	Tier string `json:"tier"`
}

func (datatype ChannelEmote) GetEmoteSetId() string {
	return datatype.EmoteSetId
}
func (datatype ChannelEmote) GetEmoteType() ChannelEmoteEmoteType {
	return datatype.EmoteType
}
func (datatype ChannelEmote) GetFormat() []ChannelEmoteFormat {
	return datatype.Format
}
func (datatype ChannelEmote) GetId() string {
	return datatype.Id
}
func (datatype ChannelEmote) GetImages() struct {
	// Url1x A URL to the small version (28px x 28px) of the emote.
	Url1x string `json:"url_1x"`

	// Url2x A URL to the medium version (56px x 56px) of the emote.
	Url2x string `json:"url_2x"`

	// Url4x A URL to the large version (112px x 112px) of the emote.
	Url4x string `json:"url_4x"`
} {
	return datatype.Images
}
func (datatype ChannelEmote) GetName() string {
	return datatype.Name
}
func (datatype ChannelEmote) GetScale() []ChannelEmoteScale {
	return datatype.Scale
}
func (datatype ChannelEmote) GetThemeMode() []ChannelEmoteThemeMode {
	return datatype.ThemeMode
}
func (datatype ChannelEmote) GetTier() string {
	return datatype.Tier
}

// ChannelEmoteEmoteType The type of emote. The possible values are:
//
// * bitstier  A custom Bits tier emote.
// * follower  A custom follower emote.
// * subscriptions  A custom subscriber emote.
type ChannelEmoteEmoteType string

// ChannelEmoteFormat defines model for ChannelEmote.Format.
type ChannelEmoteFormat string

// ChannelEmoteScale defines model for ChannelEmote.Scale.
type ChannelEmoteScale string

// ChannelEmoteThemeMode defines model for ChannelEmote.ThemeMode.
type ChannelEmoteThemeMode string

// ChannelInformation defines model for ChannelInformation.
type ChannelInformation struct {
	// BroadcasterId An ID that uniquely identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLanguage The broadcasters preferred language. The value is an ISO 639-1 two-letter language code (for example, _en_ for English). The value is set to other if the language is not a Twitch supported language.
	BroadcasterLanguage string `json:"broadcaster_language"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// ContentClassificationLabels The CCLs applied to the channel.
	ContentClassificationLabels []string `json:"content_classification_labels"`

	// Delay The value of the broadcasters stream delay setting, in seconds. This fields value defaults to zero unless 1) the request specifies a user access token, 2) the ID in the _broadcaster\_id_ query parameter matches the user ID in the access token, and 3) the broadcaster has partner status and they set a non-zero stream delay value.
	Delay int32 `json:"delay"`

	// GameId An ID that uniquely identifies the game that the broadcaster is playing or last played. The value is an empty string if the broadcaster has never played a game.
	GameId string `json:"game_id"`

	// GameName The name of the game that the broadcaster is playing or last played. The value is an empty string if the broadcaster has never played a game.
	GameName string `json:"game_name"`

	// IsBrandedContent Boolean flag indicating if the channel has branded content.
	IsBrandedContent bool `json:"is_branded_content"`

	// Tags The tags applied to the channel.
	Tags []string `json:"tags"`

	// Title The title of the stream that the broadcaster is currently streaming or last streamed. The value is an empty string if the broadcaster has never streamed.
	Title string `json:"title"`
}

func (datatype ChannelInformation) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChannelInformation) GetBroadcasterLanguage() string {
	return datatype.BroadcasterLanguage
}
func (datatype ChannelInformation) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype ChannelInformation) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ChannelInformation) GetContentClassificationLabels() []string {
	return datatype.ContentClassificationLabels
}
func (datatype ChannelInformation) GetDelay() int32 {
	return datatype.Delay
}
func (datatype ChannelInformation) GetGameId() string {
	return datatype.GameId
}
func (datatype ChannelInformation) GetGameName() string {
	return datatype.GameName
}
func (datatype ChannelInformation) GetIsBrandedContent() bool {
	return datatype.IsBrandedContent
}
func (datatype ChannelInformation) GetTags() []string {
	return datatype.Tags
}
func (datatype ChannelInformation) GetTitle() string {
	return datatype.Title
}

// ChannelStreamScheduleSegment defines model for ChannelStreamScheduleSegment.
type ChannelStreamScheduleSegment struct {
	// CanceledUntil Indicates whether the broadcaster canceled this segment of a recurring broadcast. If the broadcaster canceled this segment, this field is set to the same value thats in the `end_time` field; otherwise, its set to **null**.
	CanceledUntil *string `json:"canceled_until"`

	// Category The type of content that the broadcaster plans to stream or **null** if not specified.
	Category struct {
		// Id An ID that identifies the category that best represents the content that the broadcaster plans to stream. For example, the games ID if the broadcaster will play a game or the Just Chatting ID if the broadcaster will host a talk show.
		Id string `json:"id"`

		// Name The name of the category. For example, the games title if the broadcaster will play a game or Just Chatting if the broadcaster will host a talk show.
		Name string `json:"name"`
	} `json:"category"`

	// EndTime The UTC date and time (in RFC3339 format) of when the broadcast ends.
	EndTime time.Time `json:"end_time"`

	// Id An ID that identifies this broadcast segment.
	Id string `json:"id"`

	// IsRecurring A Boolean value that determines whether the broadcast is part of a recurring series that streams at the same time each week or is a one-time broadcast. Is **true** if the broadcast is part of a recurring series.
	IsRecurring bool `json:"is_recurring"`

	// StartTime The UTC date and time (in RFC3339 format) of when the broadcast starts.
	StartTime time.Time `json:"start_time"`

	// Title The broadcast segments title.
	Title string `json:"title"`
}

func (datatype ChannelStreamScheduleSegment) GetCanceledUntil() string {
	if datatype.CanceledUntil == nil {
		var empty string
		return empty
	}
	return *datatype.CanceledUntil
}
func (datatype ChannelStreamScheduleSegment) GetCategory() struct {
	// Id An ID that identifies the category that best represents the content that the broadcaster plans to stream. For example, the games ID if the broadcaster will play a game or the Just Chatting ID if the broadcaster will host a talk show.
	Id string `json:"id"`

	// Name The name of the category. For example, the games title if the broadcaster will play a game or Just Chatting if the broadcaster will host a talk show.
	Name string `json:"name"`
} {
	return datatype.Category
}
func (datatype ChannelStreamScheduleSegment) GetEndTime() time.Time {
	return datatype.EndTime
}
func (datatype ChannelStreamScheduleSegment) GetId() string {
	return datatype.Id
}
func (datatype ChannelStreamScheduleSegment) GetIsRecurring() bool {
	return datatype.IsRecurring
}
func (datatype ChannelStreamScheduleSegment) GetStartTime() time.Time {
	return datatype.StartTime
}
func (datatype ChannelStreamScheduleSegment) GetTitle() string {
	return datatype.Title
}

// ChannelTeam defines model for ChannelTeam.
type ChannelTeam struct {
	// BackgroundImageUrl A URL to the teams background image.
	BackgroundImageUrl string `json:"background_image_url"`

	// Banner A URL to the teams banner.
	Banner string `json:"banner"`

	// BroadcasterId An ID that identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The UTC date and time (in RFC3339 format) of when the team was created.
	CreatedAt time.Time `json:"created_at"`

	// Id An ID that identifies the team.
	Id string `json:"id"`

	// Info The teams description. The description may contain formatting such as Markdown, HTML, newline (\\n) characters, etc.
	Info string `json:"info"`

	// TeamDisplayName The teams display name.
	TeamDisplayName string `json:"team_display_name"`

	// TeamName The teams name.
	TeamName string `json:"team_name"`

	// ThumbnailUrl A URL to a thumbnail image of the teams logo.
	ThumbnailUrl string `json:"thumbnail_url"`

	// UpdatedAt The UTC date and time (in RFC3339 format) of the last time the team was updated.
	UpdatedAt time.Time `json:"updated_at"`
}

func (datatype ChannelTeam) GetBackgroundImageUrl() string {
	return datatype.BackgroundImageUrl
}
func (datatype ChannelTeam) GetBanner() string {
	return datatype.Banner
}
func (datatype ChannelTeam) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChannelTeam) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype ChannelTeam) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ChannelTeam) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype ChannelTeam) GetId() string {
	return datatype.Id
}
func (datatype ChannelTeam) GetInfo() string {
	return datatype.Info
}
func (datatype ChannelTeam) GetTeamDisplayName() string {
	return datatype.TeamDisplayName
}
func (datatype ChannelTeam) GetTeamName() string {
	return datatype.TeamName
}
func (datatype ChannelTeam) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype ChannelTeam) GetUpdatedAt() time.Time {
	return datatype.UpdatedAt
}

// CharityCampaign defines model for CharityCampaign.
type CharityCampaign struct {
	// BroadcasterId An ID that identifies the broadcaster thats running the campaign.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CharityDescription A description of the charity.
	CharityDescription string `json:"charity_description"`

	// CharityLogo A URL to an image of the charitys logo. The images type is PNG and its size is 100px X 100px.
	CharityLogo string `json:"charity_logo"`

	// CharityName The charitys name.
	CharityName string `json:"charity_name"`

	// CharityWebsite A URL to the charitys website.
	CharityWebsite string `json:"charity_website"`

	// CurrentAmount The current amount of donations that the campaign has received.
	CurrentAmount struct {
		// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
		Currency string `json:"currency"`

		// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
		//
		// `value / 10^decimal_places`
		DecimalPlaces int32 `json:"decimal_places"`

		// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
		Value int32 `json:"value"`
	} `json:"current_amount"`

	// Id An ID that identifies the charity campaign.
	Id string `json:"id"`

	// TargetAmount The campaigns fundraising goal. This field is **null** if the broadcaster has not defined a fundraising goal.
	TargetAmount struct {
		// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
		Currency string `json:"currency"`

		// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
		//
		// `value / 10^decimal_places`
		DecimalPlaces int32 `json:"decimal_places"`

		// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
		Value int32 `json:"value"`
	} `json:"target_amount"`
}

func (datatype CharityCampaign) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CharityCampaign) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CharityCampaign) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CharityCampaign) GetCharityDescription() string {
	return datatype.CharityDescription
}
func (datatype CharityCampaign) GetCharityLogo() string {
	return datatype.CharityLogo
}
func (datatype CharityCampaign) GetCharityName() string {
	return datatype.CharityName
}
func (datatype CharityCampaign) GetCharityWebsite() string {
	return datatype.CharityWebsite
}
func (datatype CharityCampaign) GetCurrentAmount() struct {
	// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
	Currency string `json:"currency"`

	// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
	//
	// `value / 10^decimal_places`
	DecimalPlaces int32 `json:"decimal_places"`

	// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
	Value int32 `json:"value"`
} {
	return datatype.CurrentAmount
}
func (datatype CharityCampaign) GetId() string {
	return datatype.Id
}
func (datatype CharityCampaign) GetTargetAmount() struct {
	// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
	Currency string `json:"currency"`

	// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
	//
	// `value / 10^decimal_places`
	DecimalPlaces int32 `json:"decimal_places"`

	// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
	Value int32 `json:"value"`
} {
	return datatype.TargetAmount
}

// CharityCampaignDonation defines model for CharityCampaignDonation.
type CharityCampaignDonation struct {
	// Amount An object that contains the amount of money that the user donated.
	Amount struct {
		// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
		Currency string `json:"currency"`

		// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
		//
		// `value / 10^decimal_places`
		DecimalPlaces int32 `json:"decimal_places"`

		// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
		Value int32 `json:"value"`
	} `json:"amount"`

	// CampaignId An ID that identifies the charity campaign that the donation applies to.
	CampaignId string `json:"campaign_id"`

	// Id An ID that identifies the donation. The ID is unique across campaigns.
	Id string `json:"id"`

	// UserId An ID that identifies a user that donated money to the campaign.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype CharityCampaignDonation) GetAmount() struct {
	// Currency The ISO-4217 three-letter currency code that identifies the type of currency in `value`.
	Currency string `json:"currency"`

	// DecimalPlaces The number of decimal places used by the currency. For example, USD uses two decimal places. Use this number to translate `value` from minor units to major units by using the formula:
	//
	// `value / 10^decimal_places`
	DecimalPlaces int32 `json:"decimal_places"`

	// Value The monetary amount. The amount is specified in the currencys minor unit. For example, the minor units for USD is cents, so if the amount is $5.50 USD, `value` is set to 550.
	Value int32 `json:"value"`
} {
	return datatype.Amount
}
func (datatype CharityCampaignDonation) GetCampaignId() string {
	return datatype.CampaignId
}
func (datatype CharityCampaignDonation) GetId() string {
	return datatype.Id
}
func (datatype CharityCampaignDonation) GetUserId() string {
	return datatype.UserId
}
func (datatype CharityCampaignDonation) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype CharityCampaignDonation) GetUserName() string {
	return datatype.UserName
}

// ChatBadge defines model for ChatBadge.
type ChatBadge struct {
	// SetId An ID that identifies this set of chat badges. For example, Bits or Subscriber.
	SetId string `json:"set_id"`

	// Versions The list of chat badges in this set.
	Versions []struct {
		// ClickAction The action to take when clicking on the badge. Set to `null` if no action is specified.
		ClickAction string `json:"click_action"`

		// ClickUrl The URL to navigate to when clicking on the badge. Set to `null` if no URL is specified.
		ClickUrl string `json:"click_url"`

		// Description The description of the badge.
		Description string `json:"description"`

		// Id An ID that identifies this version of the badge. The ID can be any value. For example, for Bits, the ID is the Bits tier level, but for World of Warcraft, it could be Alliance or Horde.
		Id string `json:"id"`

		// ImageUrl1x A URL to the small version (18px x 18px) of the badge.
		ImageUrl1x string `json:"image_url_1x"`

		// ImageUrl2x A URL to the medium version (36px x 36px) of the badge.
		ImageUrl2x string `json:"image_url_2x"`

		// ImageUrl4x A URL to the large version (72px x 72px) of the badge.
		ImageUrl4x string `json:"image_url_4x"`

		// Title The title of the badge.
		Title string `json:"title"`
	} `json:"versions"`
}

func (datatype ChatBadge) GetSetId() string {
	return datatype.SetId
}
func (datatype ChatBadge) GetVersions() []struct {
	// ClickAction The action to take when clicking on the badge. Set to `null` if no action is specified.
	ClickAction string `json:"click_action"`

	// ClickUrl The URL to navigate to when clicking on the badge. Set to `null` if no URL is specified.
	ClickUrl string `json:"click_url"`

	// Description The description of the badge.
	Description string `json:"description"`

	// Id An ID that identifies this version of the badge. The ID can be any value. For example, for Bits, the ID is the Bits tier level, but for World of Warcraft, it could be Alliance or Horde.
	Id string `json:"id"`

	// ImageUrl1x A URL to the small version (18px x 18px) of the badge.
	ImageUrl1x string `json:"image_url_1x"`

	// ImageUrl2x A URL to the medium version (36px x 36px) of the badge.
	ImageUrl2x string `json:"image_url_2x"`

	// ImageUrl4x A URL to the large version (72px x 72px) of the badge.
	ImageUrl4x string `json:"image_url_4x"`

	// Title The title of the badge.
	Title string `json:"title"`
} {
	return datatype.Versions
}

// ChatSettings defines model for ChatSettings.
type ChatSettings struct {
	// BroadcasterId The ID of the broadcaster specified in the request.
	BroadcasterId string `json:"broadcaster_id"`

	// EmoteMode A Boolean value that determines whether chat messages must contain only emotes. Is **true** if chat messages may contain only emotes; otherwise, **false**.
	EmoteMode bool `json:"emote_mode"`

	// FollowerMode A Boolean value that determines whether the broadcaster restricts the chat room to followers only.
	//
	// Is **true** if the broadcaster restricts the chat room to followers only; otherwise, **false**.
	//
	// See the `follower_mode_duration` field for how long users must follow the broadcaster before being able to participate in the chat room.
	FollowerMode bool `json:"follower_mode"`

	// FollowerModeDuration The length of time, in minutes, that users must follow the broadcaster before being able to participate in the chat room. Is **null** if `follower_mode` is **false**.
	FollowerModeDuration *int32 `json:"follower_mode_duration"`

	// ModeratorId The moderators ID. The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope.
	ModeratorId *string `json:"moderator_id,omitempty"`

	// NonModeratorChatDelay A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room. This gives chat moderators and bots a chance to remove them before viewers can see the message. See the `non_moderator_chat_delay_duration` field for the length of the delay. Is **true** if the broadcaster applies a delay; otherwise, **false**.
	//
	// The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope and the user in the _moderator\_id_ query parameter is one of the broadcasters moderators.
	NonModeratorChatDelay *bool `json:"non_moderator_chat_delay,omitempty"`

	// NonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Is **null** if `non_moderator_chat_delay` is **false**.
	//
	// The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope and the user in the _moderator\_id_ query parameter is one of the broadcasters moderators.
	NonModeratorChatDelayDuration *int32 `json:"non_moderator_chat_delay_duration"`

	// SlowMode A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages.
	//
	// Is **true** if the broadcaster applies a delay; otherwise, **false**.
	//
	// See the `slow_mode_wait_time` field for the delay.
	SlowMode bool `json:"slow_mode"`

	// SlowModeWaitTime The amount of time, in seconds, that users must wait between sending messages.
	//
	// Is **null** if slow\_mode is **false**.
	SlowModeWaitTime *int32 `json:"slow_mode_wait_time"`

	// SubscriberMode A Boolean value that determines whether only users that subscribe to the broadcasters channel may talk in the chat room.
	//
	// Is **true** if the broadcaster restricts the chat room to subscribers only; otherwise, **false**.
	SubscriberMode bool `json:"subscriber_mode"`

	// UniqueChatMode A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room.
	//
	// Is **true** if the broadcaster requires unique messages only; otherwise, **false**.
	UniqueChatMode bool `json:"unique_chat_mode"`
}

func (datatype ChatSettings) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChatSettings) GetEmoteMode() bool {
	return datatype.EmoteMode
}
func (datatype ChatSettings) GetFollowerMode() bool {
	return datatype.FollowerMode
}
func (datatype ChatSettings) GetFollowerModeDuration() int32 {
	if datatype.FollowerModeDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.FollowerModeDuration
}
func (datatype ChatSettings) GetModeratorId() string {
	if datatype.ModeratorId == nil {
		var empty string
		return empty
	}
	return *datatype.ModeratorId
}
func (datatype ChatSettings) GetNonModeratorChatDelay() bool {
	if datatype.NonModeratorChatDelay == nil {
		var empty bool
		return empty
	}
	return *datatype.NonModeratorChatDelay
}
func (datatype ChatSettings) GetNonModeratorChatDelayDuration() int32 {
	if datatype.NonModeratorChatDelayDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.NonModeratorChatDelayDuration
}
func (datatype ChatSettings) GetSlowMode() bool {
	return datatype.SlowMode
}
func (datatype ChatSettings) GetSlowModeWaitTime() int32 {
	if datatype.SlowModeWaitTime == nil {
		var empty int32
		return empty
	}
	return *datatype.SlowModeWaitTime
}
func (datatype ChatSettings) GetSubscriberMode() bool {
	return datatype.SubscriberMode
}
func (datatype ChatSettings) GetUniqueChatMode() bool {
	return datatype.UniqueChatMode
}

// ChatSettingsUpdated defines model for ChatSettingsUpdated.
type ChatSettingsUpdated struct {
	// BroadcasterId The ID of the broadcaster specified in the request.
	BroadcasterId string `json:"broadcaster_id"`

	// EmoteMode A Boolean value that determines whether chat messages must contain only emotes. Is **true** if chat messages may contain only emotes; otherwise, **false**.
	EmoteMode bool `json:"emote_mode"`

	// FollowerMode A Boolean value that determines whether the broadcaster restricts the chat room to followers only.
	//
	// Is **true** if the broadcaster restricts the chat room to followers only; otherwise, **false**.
	//
	// See the `follower_mode_duration` field for how long users must follow the broadcaster before being able to participate in the chat room.
	FollowerMode bool `json:"follower_mode"`

	// FollowerModeDuration The length of time, in minutes, that users must follow the broadcaster before being able to participate in the chat room. Is **null** if `follower_mode` is **false**.
	FollowerModeDuration *int32 `json:"follower_mode_duration"`

	// ModeratorId The moderators ID. The response includes this field only if the request specifies a user access token that includes the **moderator:read:chat\_settings** scope.
	ModeratorId *string `json:"moderator_id,omitempty"`

	// NonModeratorChatDelay A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room. This gives chat moderators and bots a chance to remove them before viewers can see the message. See the `non_moderator_chat_delay_duration` field for the length of the delay. Is **true** if the broadcaster applies a delay; otherwise, **false**.
	NonModeratorChatDelay bool `json:"non_moderator_chat_delay"`

	// NonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Is **null** if `non_moderator_chat_delay` is **false**.
	NonModeratorChatDelayDuration *int32 `json:"non_moderator_chat_delay_duration"`

	// SlowMode A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages.
	//
	// Is **true** if the broadcaster applies a delay; otherwise, **false**.
	//
	// See the `slow_mode_wait_time` field for the delay.
	SlowMode bool `json:"slow_mode"`

	// SlowModeWaitTime The amount of time, in seconds, that users must wait between sending messages.
	//
	// Is **null** if slow\_mode is **false**.
	SlowModeWaitTime *int32 `json:"slow_mode_wait_time"`

	// SubscriberMode A Boolean value that determines whether only users that subscribe to the broadcasters channel may talk in the chat room.
	//
	// Is **true** if the broadcaster restricts the chat room to subscribers only; otherwise, **false**.
	SubscriberMode bool `json:"subscriber_mode"`

	// UniqueChatMode A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room.
	//
	// Is **true** if the broadcaster requires unique messages only; otherwise, **false**.
	UniqueChatMode bool `json:"unique_chat_mode"`
}

func (datatype ChatSettingsUpdated) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ChatSettingsUpdated) GetEmoteMode() bool {
	return datatype.EmoteMode
}
func (datatype ChatSettingsUpdated) GetFollowerMode() bool {
	return datatype.FollowerMode
}
func (datatype ChatSettingsUpdated) GetFollowerModeDuration() int32 {
	if datatype.FollowerModeDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.FollowerModeDuration
}
func (datatype ChatSettingsUpdated) GetModeratorId() string {
	if datatype.ModeratorId == nil {
		var empty string
		return empty
	}
	return *datatype.ModeratorId
}
func (datatype ChatSettingsUpdated) GetNonModeratorChatDelay() bool {
	return datatype.NonModeratorChatDelay
}
func (datatype ChatSettingsUpdated) GetNonModeratorChatDelayDuration() int32 {
	if datatype.NonModeratorChatDelayDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.NonModeratorChatDelayDuration
}
func (datatype ChatSettingsUpdated) GetSlowMode() bool {
	return datatype.SlowMode
}
func (datatype ChatSettingsUpdated) GetSlowModeWaitTime() int32 {
	if datatype.SlowModeWaitTime == nil {
		var empty int32
		return empty
	}
	return *datatype.SlowModeWaitTime
}
func (datatype ChatSettingsUpdated) GetSubscriberMode() bool {
	return datatype.SubscriberMode
}
func (datatype ChatSettingsUpdated) GetUniqueChatMode() bool {
	return datatype.UniqueChatMode
}

// Chatter defines model for Chatter.
type Chatter struct {
	// UserId The ID of a user thats connected to the broadcasters chat room.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype Chatter) GetUserId() string {
	return datatype.UserId
}
func (datatype Chatter) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Chatter) GetUserName() string {
	return datatype.UserName
}

// CheckAutoModStatusBody defines model for CheckAutoModStatusBody.
type CheckAutoModStatusBody struct {
	// Data The list of messages to check. The list must contain at least one message and may contain up to a maximum of 100 messages.
	Data []struct {
		// MsgId A caller-defined ID used to correlate this message with the same message in the response.
		MsgId string `json:"msg_id"`

		// MsgText The message to check.
		MsgText string `json:"msg_text"`
	} `json:"data"`
}

func (datatype CheckAutoModStatusBody) GetData() []struct {
	// MsgId A caller-defined ID used to correlate this message with the same message in the response.
	MsgId string `json:"msg_id"`

	// MsgText The message to check.
	MsgText string `json:"msg_text"`
} {
	return datatype.Data
}

// CheckAutoModStatusResponse defines model for CheckAutoModStatusResponse.
type CheckAutoModStatusResponse struct {
	// Data The list of messages and whether Twitch would approve them for chat.
	Data []AutoModStatus `json:"data"`
}

func (datatype CheckAutoModStatusResponse) GetData() []AutoModStatus {
	return datatype.Data
}

// CheckUserSubscriptionResponse defines model for CheckUserSubscriptionResponse.
type CheckUserSubscriptionResponse struct {
	// Data A list that contains a single object with information about the users subscription.
	Data []UserSubscription `json:"data"`
}

func (datatype CheckUserSubscriptionResponse) GetData() []UserSubscription {
	return datatype.Data
}

// Cheermote defines model for Cheermote.
type Cheermote struct {
	// IsCharitable A Boolean value that indicates whether this Cheermote provides a charitable contribution match during charity campaigns.
	IsCharitable bool `json:"is_charitable"`

	// LastUpdated The date and time, in RFC3339 format, when this Cheermote was last updated.
	LastUpdated time.Time `json:"last_updated"`

	// Order The order that the Cheermotes are shown in the Bits card. The numbers may not be consecutive. For example, the numbers may jump from 1 to 7 to 13\. The order numbers are unique within a Cheermote type (for example, global\_first\_party) but may not be unique amongst all Cheermotes in the response.
	Order int32 `json:"order"`

	// Prefix The name portion of the Cheermote string that you use in chat to cheer Bits. The full Cheermote string is the concatenation of {prefix} + {number of Bits}. For example, if the prefix is Cheer and you want to cheer 100 Bits, the full Cheermote string is Cheer100\. When the Cheermote string is entered in chat, Twitch converts it to the image associated with the Bits tier that was cheered.
	Prefix string `json:"prefix"`

	// Tiers A list of tier levels that the Cheermote supports. Each tier identifies the range of Bits that you can cheer at that tier level and an image that graphically identifies the tier level.
	Tiers []struct {
		// CanCheer A Boolean value that determines whether users can cheer at this tier level.
		CanCheer bool `json:"can_cheer"`

		// Color The hex code of the color associated with this tier level (for example, #979797).
		Color string `json:"color"`

		// Id The tier level. Possible tiers are:
		//
		// * 1
		// * 100
		// * 500
		// * 1000
		// * 5000
		// * 10000
		// * 100000
		Id     CheermoteTiersId `json:"id"`
		Images CheermoteImages  `json:"images"`

		// MinBits The minimum number of Bits that you must cheer at this tier level. The maximum number of Bits that you can cheer at this level is determined by the required minimum Bits of the next tier level minus 1\. For example, if `min_bits` is 1 and `min_bits` for the next tier is 100, the Bits range for this tier level is 1 through 99\. The minimum Bits value of the last tier is the maximum number of Bits you can cheer using this Cheermote. For example, 10000.
		MinBits int32 `json:"min_bits"`

		// ShowInBitsCard A Boolean value that determines whether this tier level is shown in the Bits card. Is **true** if this tier level is shown in the Bits card.
		ShowInBitsCard bool `json:"show_in_bits_card"`
	} `json:"tiers"`

	// Type The type of Cheermote. Possible values are:
	//
	// * global\_first\_party  A Twitch-defined Cheermote that is shown in the Bits card.
	// * global\_third\_party  A Twitch-defined Cheermote that is not shown in the Bits card.
	// * channel\_custom  A broadcaster-defined Cheermote.
	// * display\_only  Do not use; for internal use only.
	// * sponsored  A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor's 10 Bits contribution.
	Type CheermoteType `json:"type"`
}

func (datatype Cheermote) GetIsCharitable() bool {
	return datatype.IsCharitable
}
func (datatype Cheermote) GetLastUpdated() time.Time {
	return datatype.LastUpdated
}
func (datatype Cheermote) GetOrder() int32 {
	return datatype.Order
}
func (datatype Cheermote) GetPrefix() string {
	return datatype.Prefix
}
func (datatype Cheermote) GetTiers() []struct {
	// CanCheer A Boolean value that determines whether users can cheer at this tier level.
	CanCheer bool `json:"can_cheer"`

	// Color The hex code of the color associated with this tier level (for example, #979797).
	Color string `json:"color"`

	// Id The tier level. Possible tiers are:
	//
	// * 1
	// * 100
	// * 500
	// * 1000
	// * 5000
	// * 10000
	// * 100000
	Id     CheermoteTiersId `json:"id"`
	Images CheermoteImages  `json:"images"`

	// MinBits The minimum number of Bits that you must cheer at this tier level. The maximum number of Bits that you can cheer at this level is determined by the required minimum Bits of the next tier level minus 1\. For example, if `min_bits` is 1 and `min_bits` for the next tier is 100, the Bits range for this tier level is 1 through 99\. The minimum Bits value of the last tier is the maximum number of Bits you can cheer using this Cheermote. For example, 10000.
	MinBits int32 `json:"min_bits"`

	// ShowInBitsCard A Boolean value that determines whether this tier level is shown in the Bits card. Is **true** if this tier level is shown in the Bits card.
	ShowInBitsCard bool `json:"show_in_bits_card"`
} {
	return datatype.Tiers
}
func (datatype Cheermote) GetType() CheermoteType {
	return datatype.Type
}

// CheermoteTiersId The tier level. Possible tiers are:
//
// * 1
// * 100
// * 500
// * 1000
// * 5000
// * 10000
// * 100000
type CheermoteTiersId string

// CheermoteType The type of Cheermote. Possible values are:
//
// * global\_first\_party  A Twitch-defined Cheermote that is shown in the Bits card.
// * global\_third\_party  A Twitch-defined Cheermote that is not shown in the Bits card.
// * channel\_custom  A broadcaster-defined Cheermote.
// * display\_only  Do not use; for internal use only.
// * sponsored  A sponsor-defined Cheermote. When used, the sponsor adds additional Bits to the amount that the user cheered. For example, if the user cheered Terminator100, the broadcaster might receive 110 Bits, which includes the sponsor's 10 Bits contribution.
type CheermoteType string

// CheermoteImageFormat defines model for CheermoteImageFormat.
type CheermoteImageFormat struct {
	N1  *string `json:"1,omitempty"`
	N15 *string `json:"1.5,omitempty"`
	N2  *string `json:"2,omitempty"`
	N3  *string `json:"3,omitempty"`
	N4  *string `json:"4,omitempty"`
}

func (datatype CheermoteImageFormat) GetN1() string {
	if datatype.N1 == nil {
		var empty string
		return empty
	}
	return *datatype.N1
}
func (datatype CheermoteImageFormat) GetN15() string {
	if datatype.N15 == nil {
		var empty string
		return empty
	}
	return *datatype.N15
}
func (datatype CheermoteImageFormat) GetN2() string {
	if datatype.N2 == nil {
		var empty string
		return empty
	}
	return *datatype.N2
}
func (datatype CheermoteImageFormat) GetN3() string {
	if datatype.N3 == nil {
		var empty string
		return empty
	}
	return *datatype.N3
}
func (datatype CheermoteImageFormat) GetN4() string {
	if datatype.N4 == nil {
		var empty string
		return empty
	}
	return *datatype.N4
}

// CheermoteImageTheme defines model for CheermoteImageTheme.
type CheermoteImageTheme struct {
	Animated *CheermoteImageFormat `json:"animated,omitempty"`
	Static   *CheermoteImageFormat `json:"static,omitempty"`
}

func (datatype CheermoteImageTheme) GetAnimated() CheermoteImageFormat {
	if datatype.Animated == nil {
		var empty CheermoteImageFormat
		return empty
	}
	return *datatype.Animated
}
func (datatype CheermoteImageTheme) GetStatic() CheermoteImageFormat {
	if datatype.Static == nil {
		var empty CheermoteImageFormat
		return empty
	}
	return *datatype.Static
}

// CheermoteImages defines model for CheermoteImages.
type CheermoteImages struct {
	Dark  *CheermoteImageTheme `json:"dark,omitempty"`
	Light *CheermoteImageTheme `json:"light,omitempty"`
}

func (datatype CheermoteImages) GetDark() CheermoteImageTheme {
	if datatype.Dark == nil {
		var empty CheermoteImageTheme
		return empty
	}
	return *datatype.Dark
}
func (datatype CheermoteImages) GetLight() CheermoteImageTheme {
	if datatype.Light == nil {
		var empty CheermoteImageTheme
		return empty
	}
	return *datatype.Light
}

// Clip defines model for Clip.
type Clip struct {
	// BroadcasterId An ID that identifies the broadcaster that the video was clipped from.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The date and time of when the clip was created. The date and time is in RFC3339 format.
	CreatedAt time.Time `json:"created_at"`

	// CreatorId An ID that identifies the user that created the clip.
	CreatorId string `json:"creator_id"`

	// CreatorName The users display name.
	CreatorName string `json:"creator_name"`

	// Duration The length of the clip, in seconds. Precision is 0.1.
	Duration float32 `json:"duration"`

	// EmbedUrl A URL that you can use in an iframe to embed the clip (see [Embedding Video and Clips](https://dev.twitch.tv/docs/embed/video-and-clips/)).
	EmbedUrl string `json:"embed_url"`

	// GameId The ID of the game that was being played when the clip was created.
	GameId string `json:"game_id"`

	// Id An ID that uniquely identifies the clip.
	Id string `json:"id"`

	// IsFeatured A Boolean value that indicates if the clip is featured or not.
	IsFeatured bool `json:"is_featured"`

	// Language The ISO 639-1 two-letter language code that the broadcaster broadcasts in. For example, _en_ for English. The value is _other_ if the broadcaster uses a language that Twitch doesnt support.
	Language string `json:"language"`

	// ThumbnailUrl A URL to a thumbnail image of the clip.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The title of the clip.
	Title string `json:"title"`

	// Url A URL to the clip.
	Url string `json:"url"`

	// VideoId An ID that identifies the video that the clip came from. This field contains an empty string if the video is not available.
	VideoId string `json:"video_id"`

	// ViewCount The number of times the clip has been viewed.
	ViewCount int32 `json:"view_count"`

	// VodOffset The zero-based offset, in seconds, to where the clip starts in the video (VOD). Is **null** if the video is not available or hasnt been created yet from the live stream (see `video_id`).
	//
	// Note that theres a delay between when a clip is created during a broadcast and when the offset is set. During the delay period, `vod_offset` is **null**. The delay is indeterminant but is typically minutes long.
	VodOffset *int32 `json:"vod_offset"`
}

func (datatype Clip) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype Clip) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype Clip) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Clip) GetCreatorId() string {
	return datatype.CreatorId
}
func (datatype Clip) GetCreatorName() string {
	return datatype.CreatorName
}
func (datatype Clip) GetDuration() float32 {
	return datatype.Duration
}
func (datatype Clip) GetEmbedUrl() string {
	return datatype.EmbedUrl
}
func (datatype Clip) GetGameId() string {
	return datatype.GameId
}
func (datatype Clip) GetId() string {
	return datatype.Id
}
func (datatype Clip) GetIsFeatured() bool {
	return datatype.IsFeatured
}
func (datatype Clip) GetLanguage() string {
	return datatype.Language
}
func (datatype Clip) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Clip) GetTitle() string {
	return datatype.Title
}
func (datatype Clip) GetUrl() string {
	return datatype.Url
}
func (datatype Clip) GetVideoId() string {
	return datatype.VideoId
}
func (datatype Clip) GetViewCount() int32 {
	return datatype.ViewCount
}
func (datatype Clip) GetVodOffset() int32 {
	if datatype.VodOffset == nil {
		var empty int32
		return empty
	}
	return *datatype.VodOffset
}

// ContentClassificationLabel defines model for ContentClassificationLabel.
type ContentClassificationLabel struct {
	// Description Localized description of the CCL.
	Description string `json:"description"`

	// Id Unique identifier for the CCL.
	Id string `json:"id"`

	// Name Localized name of the CCL.
	Name string `json:"name"`
}

func (datatype ContentClassificationLabel) GetDescription() string {
	return datatype.Description
}
func (datatype ContentClassificationLabel) GetId() string {
	return datatype.Id
}
func (datatype ContentClassificationLabel) GetName() string {
	return datatype.Name
}

// CreateChannelStreamScheduleSegmentBody defines model for CreateChannelStreamScheduleSegmentBody.
type CreateChannelStreamScheduleSegmentBody struct {
	// CategoryId The ID of the category that best represents the broadcasts content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
	CategoryId *string `json:"category_id,omitempty"`

	// Duration The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).
	Duration string `json:"duration"`

	// IsRecurring A Boolean value that determines whether the broadcast recurs weekly. Is **true** if the broadcast recurs weekly. Only partners and affiliates may add non-recurring broadcasts.
	IsRecurring *bool `json:"is_recurring,omitempty"`

	// StartTime The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2021-07-01T18:00:00Z).
	StartTime time.Time `json:"start_time"`

	// Timezone The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\_York).
	Timezone string `json:"timezone"`

	// Title The broadcasts title. The title may contain a maximum of 140 characters.
	Title *string `json:"title,omitempty"`
}

func (datatype CreateChannelStreamScheduleSegmentBody) GetCategoryId() string {
	if datatype.CategoryId == nil {
		var empty string
		return empty
	}
	return *datatype.CategoryId
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetDuration() string {
	return datatype.Duration
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetIsRecurring() bool {
	if datatype.IsRecurring == nil {
		var empty bool
		return empty
	}
	return *datatype.IsRecurring
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetStartTime() time.Time {
	return datatype.StartTime
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetTimezone() string {
	return datatype.Timezone
}
func (datatype CreateChannelStreamScheduleSegmentBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// CreateChannelStreamScheduleSegmentResponse defines model for CreateChannelStreamScheduleSegmentResponse.
type CreateChannelStreamScheduleSegmentResponse struct {
	// Data The broadcasters streaming scheduled.
	Data struct {
		// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// Segments A list that contains the single broadcast segment that you added.
		Segments []ChannelStreamScheduleSegment `json:"segments"`

		// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
		Vacation struct {
			// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
			EndTime time.Time `json:"end_time"`

			// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
			StartTime time.Time `json:"start_time"`
		} `json:"vacation"`
	} `json:"data"`
}

func (datatype CreateChannelStreamScheduleSegmentResponse) GetData() struct {
	// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Segments A list that contains the single broadcast segment that you added.
	Segments []ChannelStreamScheduleSegment `json:"segments"`

	// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	Vacation struct {
		// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
		EndTime time.Time `json:"end_time"`

		// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
		StartTime time.Time `json:"start_time"`
	} `json:"vacation"`
} {
	return datatype.Data
}

// CreateClipResponse defines model for CreateClipResponse.
type CreateClipResponse struct {
	Data []struct {
		// EditUrl A URL that you can use to edit the clips title, identify the part of the clip to publish, and publish the clip. [Learn More](https://help.twitch.tv/s/article/how-to-use-clips)
		//
		// The URL is valid for up to 24 hours or until the clip is published, whichever comes first.
		EditUrl string `json:"edit_url"`

		// Id An ID that uniquely identifies the clip.
		Id string `json:"id"`
	} `json:"data"`
}

func (datatype CreateClipResponse) GetData() []struct {
	// EditUrl A URL that you can use to edit the clips title, identify the part of the clip to publish, and publish the clip. [Learn More](https://help.twitch.tv/s/article/how-to-use-clips)
	//
	// The URL is valid for up to 24 hours or until the clip is published, whichever comes first.
	EditUrl string `json:"edit_url"`

	// Id An ID that uniquely identifies the clip.
	Id string `json:"id"`
} {
	return datatype.Data
}

// CreateConduitsBody defines model for CreateConduitsBody.
type CreateConduitsBody struct {
	// ShardCount The number of shards to create for this conduit.
	ShardCount int32 `json:"shard_count"`
}

func (datatype CreateConduitsBody) GetShardCount() int32 {
	return datatype.ShardCount
}

// CreateConduitsResponse defines model for CreateConduitsResponse.
type CreateConduitsResponse struct {
	// Data List of information about the clients conduits.
	Data []struct {
		// Id Conduit ID.
		Id string `json:"id"`

		// ShardCount Number of shards created for this conduit.
		ShardCount int32 `json:"shard_count"`
	} `json:"data"`
}

func (datatype CreateConduitsResponse) GetData() []struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount Number of shards created for this conduit.
	ShardCount int32 `json:"shard_count"`
} {
	return datatype.Data
}

// CreateCustomRewardsBody defines model for CreateCustomRewardsBody.
type CreateCustomRewardsBody struct {
	// BackgroundColor The background color to use for the reward. Specify the color using Hex format (for example, #9147FF).
	BackgroundColor *string `json:"background_color,omitempty"`

	// Cost The cost of the reward, in Channel Points. The minimum is 1 point.
	Cost int64 `json:"cost"`

	// GlobalCooldownSeconds The cooldown period, in seconds. Applied only if the `is_global_cooldown_enabled` field is **true**. The minimum value is 1; however, the minimum value is 60 for it to be shown in the Twitch UX.
	GlobalCooldownSeconds *int32 `json:"global_cooldown_seconds,omitempty"`

	// IsEnabled A Boolean value that determines whether the reward is enabled. Viewers see only enabled rewards. The default is **true**.
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// IsGlobalCooldownEnabled A Boolean value that determines whether to apply a cooldown period between redemptions (see the `global_cooldown_seconds` field for the duration of the cooldown period). The default is **false**.
	IsGlobalCooldownEnabled *bool `json:"is_global_cooldown_enabled,omitempty"`

	// IsMaxPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the `max_per_stream` field). The default is **false**.
	IsMaxPerStreamEnabled *bool `json:"is_max_per_stream_enabled,omitempty"`

	// IsMaxPerUserPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see the `max_per_user_per_stream` field). The default is **false**.
	IsMaxPerUserPerStreamEnabled *bool `json:"is_max_per_user_per_stream_enabled,omitempty"`

	// IsUserInputRequired A Boolean value that determines whether the user needs to enter information when redeeming the reward. See the `prompt` field. The default is **false**.
	IsUserInputRequired *bool `json:"is_user_input_required,omitempty"`

	// MaxPerStream The maximum number of redemptions allowed per live stream. Applied only if `is_max_per_stream_enabled` is **true**. The minimum value is 1.
	MaxPerStream *int32 `json:"max_per_stream,omitempty"`

	// MaxPerUserPerStream The maximum number of redemptions allowed per user per stream. Applied only if `is_max_per_user_per_stream_enabled` is **true**. The minimum value is 1.
	MaxPerUserPerStream *int32 `json:"max_per_user_per_stream,omitempty"`

	// Prompt The prompt shown to the viewer when they redeem the reward. Specify a prompt if `is_user_input_required` is **true**. The prompt is limited to a maximum of 200 characters.
	Prompt *string `json:"prompt,omitempty"`

	// ShouldRedemptionsSkipRequestQueue A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process. The default is **false**.
	ShouldRedemptionsSkipRequestQueue *bool `json:"should_redemptions_skip_request_queue,omitempty"`

	// Title The custom rewards title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcasters custom rewards.
	Title string `json:"title"`
}

func (datatype CreateCustomRewardsBody) GetBackgroundColor() string {
	if datatype.BackgroundColor == nil {
		var empty string
		return empty
	}
	return *datatype.BackgroundColor
}
func (datatype CreateCustomRewardsBody) GetCost() int64 {
	return datatype.Cost
}
func (datatype CreateCustomRewardsBody) GetGlobalCooldownSeconds() int32 {
	if datatype.GlobalCooldownSeconds == nil {
		var empty int32
		return empty
	}
	return *datatype.GlobalCooldownSeconds
}
func (datatype CreateCustomRewardsBody) GetIsEnabled() bool {
	if datatype.IsEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsEnabled
}
func (datatype CreateCustomRewardsBody) GetIsGlobalCooldownEnabled() bool {
	if datatype.IsGlobalCooldownEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsGlobalCooldownEnabled
}
func (datatype CreateCustomRewardsBody) GetIsMaxPerStreamEnabled() bool {
	if datatype.IsMaxPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerStreamEnabled
}
func (datatype CreateCustomRewardsBody) GetIsMaxPerUserPerStreamEnabled() bool {
	if datatype.IsMaxPerUserPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerUserPerStreamEnabled
}
func (datatype CreateCustomRewardsBody) GetIsUserInputRequired() bool {
	if datatype.IsUserInputRequired == nil {
		var empty bool
		return empty
	}
	return *datatype.IsUserInputRequired
}
func (datatype CreateCustomRewardsBody) GetMaxPerStream() int32 {
	if datatype.MaxPerStream == nil {
		var empty int32
		return empty
	}
	return *datatype.MaxPerStream
}
func (datatype CreateCustomRewardsBody) GetMaxPerUserPerStream() int32 {
	if datatype.MaxPerUserPerStream == nil {
		var empty int32
		return empty
	}
	return *datatype.MaxPerUserPerStream
}
func (datatype CreateCustomRewardsBody) GetPrompt() string {
	if datatype.Prompt == nil {
		var empty string
		return empty
	}
	return *datatype.Prompt
}
func (datatype CreateCustomRewardsBody) GetShouldRedemptionsSkipRequestQueue() bool {
	if datatype.ShouldRedemptionsSkipRequestQueue == nil {
		var empty bool
		return empty
	}
	return *datatype.ShouldRedemptionsSkipRequestQueue
}
func (datatype CreateCustomRewardsBody) GetTitle() string {
	return datatype.Title
}

// CreateCustomRewardsResponse defines model for CreateCustomRewardsResponse.
type CreateCustomRewardsResponse struct {
	// Data A list that contains the single custom reward you created.
	Data []CustomReward `json:"data"`
}

func (datatype CreateCustomRewardsResponse) GetData() []CustomReward {
	return datatype.Data
}

// CreateEventSubSubscriptionBody defines model for CreateEventSubSubscriptionBody.
type CreateEventSubSubscriptionBody struct {
	// Condition A JSON object that contains the parameter values that are specific to the specified subscription type. For the objects required and optional fields, see the subscription types documentation.
	Condition map[string]interface{} `json:"condition"`

	// Transport The transport details that you want Twitch to use when sending you notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See [Processing an event](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#processing-an-event). Specify this field only if `method` is set to **webhook**.
		//
		// **NOTE**: Redirects are not followed.
		Callback *string `json:"callback,omitempty"`

		// ConduitId An ID that identifies the conduit to send notifications to. When you create a conduit, the server returns the conduit ID. Specify this field only if `method` is set to **conduit**.
		ConduitId *string `json:"conduit_id,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		// * conduit
		Method CreateEventSubSubscriptionBodyTransportMethod `json:"method"`

		// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see [Verifying the event message](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#verifying-the-event-message). Specify this field only if `method` is set to **webhook**.
		Secret *string `json:"secret,omitempty"`

		// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message. Specify this field only if `method` is set to **websocket**.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`

	// Type The type of subscription to create. For a list of subscriptions that you can create, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). Set this field to the value in the **Name** column of the Subscription Types table.
	Type CreateEventSubSubscriptionBodyType `json:"type"`

	// Version The version number that identifies the definition of the subscription type that you want the response to use.
	Version string `json:"version"`
}

func (datatype CreateEventSubSubscriptionBody) GetCondition() map[string]interface{} {
	return datatype.Condition
}
func (datatype CreateEventSubSubscriptionBody) GetTransport() struct {
	// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See [Processing an event](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#processing-an-event). Specify this field only if `method` is set to **webhook**.
	//
	// **NOTE**: Redirects are not followed.
	Callback *string `json:"callback,omitempty"`

	// ConduitId An ID that identifies the conduit to send notifications to. When you create a conduit, the server returns the conduit ID. Specify this field only if `method` is set to **conduit**.
	ConduitId *string `json:"conduit_id,omitempty"`

	// Method The transport method. Possible values are:
	//
	// * webhook
	// * websocket
	// * conduit
	Method CreateEventSubSubscriptionBodyTransportMethod `json:"method"`

	// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see [Verifying the event message](https://dev.twitch.tv/docs/eventsub/handling-webhook-events#verifying-the-event-message). Specify this field only if `method` is set to **webhook**.
	Secret *string `json:"secret,omitempty"`

	// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message. Specify this field only if `method` is set to **websocket**.
	SessionId *string `json:"session_id,omitempty"`
} {
	return datatype.Transport
}
func (datatype CreateEventSubSubscriptionBody) GetType() CreateEventSubSubscriptionBodyType {
	return datatype.Type
}
func (datatype CreateEventSubSubscriptionBody) GetVersion() string {
	return datatype.Version
}

// CreateEventSubSubscriptionBodyTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
// * conduit
type CreateEventSubSubscriptionBodyTransportMethod string

// CreateEventSubSubscriptionBodyType The type of subscription to create. For a list of subscriptions that you can create, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types). Set this field to the value in the **Name** column of the Subscription Types table.
type CreateEventSubSubscriptionBodyType string

// CreateEventSubSubscriptionResponse defines model for CreateEventSubSubscriptionResponse.
type CreateEventSubSubscriptionResponse struct {
	// Data A list that contains the single subscription that you created.
	Data []EventSubSubscription `json:"data"`

	// MaxTotalCost The maximum total cost that youre allowed to incur for all subscriptions you create.
	MaxTotalCost int32 `json:"max_total_cost"`

	// Total The total number of subscriptions youve created.
	Total int32 `json:"total"`

	// TotalCost The sum of all of your subscription costs. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	TotalCost int32 `json:"total_cost"`
}

func (datatype CreateEventSubSubscriptionResponse) GetData() []EventSubSubscription {
	return datatype.Data
}
func (datatype CreateEventSubSubscriptionResponse) GetMaxTotalCost() int32 {
	return datatype.MaxTotalCost
}
func (datatype CreateEventSubSubscriptionResponse) GetTotal() int32 {
	return datatype.Total
}
func (datatype CreateEventSubSubscriptionResponse) GetTotalCost() int32 {
	return datatype.TotalCost
}

// CreateExtensionSecretResponse defines model for CreateExtensionSecretResponse.
type CreateExtensionSecretResponse struct {
	// Data A list that contains the newly added secrets.
	Data []ExtensionSecret `json:"data"`
}

func (datatype CreateExtensionSecretResponse) GetData() []ExtensionSecret {
	return datatype.Data
}

// CreateGuestStarSessionResponse defines model for CreateGuestStarSessionResponse.
type CreateGuestStarSessionResponse struct {
	// Data Summary of the session details.
	Data []GuestStarSession `json:"data"`
}

func (datatype CreateGuestStarSessionResponse) GetData() []GuestStarSession {
	return datatype.Data
}

// CreatePollBody defines model for CreatePollBody.
type CreatePollBody struct {
	// BroadcasterId The ID of the broadcaster thats running the poll. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// ChannelPointsPerVote The number of points that the viewer must spend to cast one additional vote. The minimum is 1 and the maximum is 1000000\. Set only if `ChannelPointsVotingEnabled` is **true**.
	ChannelPointsPerVote *int32 `json:"channel_points_per_vote,omitempty"`

	// ChannelPointsVotingEnabled A Boolean value that indicates whether viewers may cast additional votes using Channel Points. If **true**, the viewer may cast more than one vote but each additional vote costs the number of Channel Points specified in `channel_points_per_vote`. The default is **false** (viewers may cast only one vote). For information about Channel Points, see [Channel Points Guide](https://help.twitch.tv/s/article/channel-points-guide).
	ChannelPointsVotingEnabled *bool `json:"channel_points_voting_enabled,omitempty"`

	// Choices A list of choices that viewers may choose from. The list must contain a minimum of 2 choices and up to a maximum of 5 choices.
	Choices []struct {
		// Title One of the choices the viewer may select. The choice may contain a maximum of 25 characters.
		Title string `json:"title"`
	} `json:"choices"`

	// Duration The length of time (in seconds) that the poll will run for. The minimum is 15 seconds and the maximum is 1800 seconds (30 minutes).
	Duration int32 `json:"duration"`

	// Title The question that viewers will vote on. For example, _What game should I play next?_ The question may contain a maximum of 60 characters.
	Title string `json:"title"`
}

func (datatype CreatePollBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreatePollBody) GetChannelPointsPerVote() int32 {
	if datatype.ChannelPointsPerVote == nil {
		var empty int32
		return empty
	}
	return *datatype.ChannelPointsPerVote
}
func (datatype CreatePollBody) GetChannelPointsVotingEnabled() bool {
	if datatype.ChannelPointsVotingEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.ChannelPointsVotingEnabled
}
func (datatype CreatePollBody) GetChoices() []struct {
	// Title One of the choices the viewer may select. The choice may contain a maximum of 25 characters.
	Title string `json:"title"`
} {
	return datatype.Choices
}
func (datatype CreatePollBody) GetDuration() int32 {
	return datatype.Duration
}
func (datatype CreatePollBody) GetTitle() string {
	return datatype.Title
}

// CreatePollResponse defines model for CreatePollResponse.
type CreatePollResponse struct {
	// Data A list that contains the single poll that you created.
	Data []Poll `json:"data"`
}

func (datatype CreatePollResponse) GetData() []Poll {
	return datatype.Data
}

// CreatePredictionBody defines model for CreatePredictionBody.
type CreatePredictionBody struct {
	// BroadcasterId The ID of the broadcaster thats running the prediction. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// Outcomes The list of possible outcomes that the viewers may choose from. The list must contain a minimum of 2 choices and up to a maximum of 10 choices.
	Outcomes []struct {
		// Title The text of one of the outcomes that the viewer may select. The title is limited to a maximum of 25 characters.
		Title string `json:"title"`
	} `json:"outcomes"`

	// PredictionWindow The length of time (in seconds) that the prediction will run for. The minimum is 30 seconds and the maximum is 1800 seconds (30 minutes).
	PredictionWindow int32 `json:"prediction_window"`

	// Title The question that the broadcaster is asking. For example, _Will I finish this entire pizza?_ The title is limited to a maximum of 45 characters.
	Title string `json:"title"`
}

func (datatype CreatePredictionBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreatePredictionBody) GetOutcomes() []struct {
	// Title The text of one of the outcomes that the viewer may select. The title is limited to a maximum of 25 characters.
	Title string `json:"title"`
} {
	return datatype.Outcomes
}
func (datatype CreatePredictionBody) GetPredictionWindow() int32 {
	return datatype.PredictionWindow
}
func (datatype CreatePredictionBody) GetTitle() string {
	return datatype.Title
}

// CreatePredictionResponse defines model for CreatePredictionResponse.
type CreatePredictionResponse struct {
	// Data A list that contains the single prediction that you created.
	Data []Prediction `json:"data"`
}

func (datatype CreatePredictionResponse) GetData() []Prediction {
	return datatype.Data
}

// CreateStreamMarkerBody defines model for CreateStreamMarkerBody.
type CreateStreamMarkerBody struct {
	// Description A short description of the marker to help the user remember why they marked the location. The maximum length of the description is 140 characters.
	Description *string `json:"description,omitempty"`

	// UserId The ID of the broadcaster thats streaming content. This ID must match the user ID in the access token or the user in the access token must be one of the broadcasters editors.
	UserId string `json:"user_id"`
}

func (datatype CreateStreamMarkerBody) GetDescription() string {
	if datatype.Description == nil {
		var empty string
		return empty
	}
	return *datatype.Description
}
func (datatype CreateStreamMarkerBody) GetUserId() string {
	return datatype.UserId
}

// CreateStreamMarkerResponse defines model for CreateStreamMarkerResponse.
type CreateStreamMarkerResponse struct {
	// Data A list that contains the single marker that you added.
	Data []StreamMarkerCreated `json:"data"`
}

func (datatype CreateStreamMarkerResponse) GetData() []StreamMarkerCreated {
	return datatype.Data
}

// CreatorGoal defines model for CreatorGoal.
type CreatorGoal struct {
	// BroadcasterId An ID that identifies the broadcaster that created the goal.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The UTC date and time (in RFC3339 format) that the broadcaster created the goal.
	CreatedAt time.Time `json:"created_at"`

	// CurrentAmount The goals current value.
	//
	// The goals `type` determines how this value is increased or decreased.
	//
	// * If `type` is follower, this field is set to the broadcaster's current number of followers. This number increases with new followers and decreases when users unfollow the broadcaster.
	// * If `type` is subscription, this field is increased and decreased by the points value associated with the subscription tier. For example, if a tier-two subscription is worth 2 points, this field is increased or decreased by 2, not 1.
	// * If `type` is subscription\_count, this field is increased by 1 for each new subscription and decreased by 1 for each user that unsubscribes.
	// * If `type` is new\_subscription, this field is increased by the points value associated with the subscription tier. For example, if a tier-two subscription is worth 2 points, this field is increased by 2, not 1.
	// * If `type` is new\_subscription\_count, this field is increased by 1 for each new subscription.
	CurrentAmount int32 `json:"current_amount"`

	// Description A description of the goal. Is an empty string if not specified.
	Description string `json:"description"`

	// Id An ID that identifies this goal.
	Id string `json:"id"`

	// TargetAmount The goals target value. For example, if the broadcaster has 200 followers before creating the goal, and their goal is to double that number, this field is set to 400.
	TargetAmount int32 `json:"target_amount"`

	// Type The type of goal. Possible values are:
	//
	// * follower  The goal is to increase followers.
	// * subscription  The goal is to increase subscriptions. This type shows the net increase or decrease in tier points associated with the subscriptions.
	// * subscription\_count  The goal is to increase subscriptions. This type shows the net increase or decrease in the number of subscriptions.
	// * new\_subscription  The goal is to increase subscriptions. This type shows only the net increase in tier points associated with the subscriptions (it does not account for users that unsubscribed since the goal started).
	// * new\_subscription\_count  The goal is to increase subscriptions. This type shows only the net increase in the number of subscriptions (it does not account for users that unsubscribed since the goal started).
	Type CreatorGoalType `json:"type"`
}

func (datatype CreatorGoal) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreatorGoal) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CreatorGoal) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CreatorGoal) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype CreatorGoal) GetCurrentAmount() int32 {
	return datatype.CurrentAmount
}
func (datatype CreatorGoal) GetDescription() string {
	return datatype.Description
}
func (datatype CreatorGoal) GetId() string {
	return datatype.Id
}
func (datatype CreatorGoal) GetTargetAmount() int32 {
	return datatype.TargetAmount
}
func (datatype CreatorGoal) GetType() CreatorGoalType {
	return datatype.Type
}

// CreatorGoalType The type of goal. Possible values are:
//
// * follower  The goal is to increase followers.
// * subscription  The goal is to increase subscriptions. This type shows the net increase or decrease in tier points associated with the subscriptions.
// * subscription\_count  The goal is to increase subscriptions. This type shows the net increase or decrease in the number of subscriptions.
// * new\_subscription  The goal is to increase subscriptions. This type shows only the net increase in tier points associated with the subscriptions (it does not account for users that unsubscribed since the goal started).
// * new\_subscription\_count  The goal is to increase subscriptions. This type shows only the net increase in the number of subscriptions (it does not account for users that unsubscribed since the goal started).
type CreatorGoalType string

// CustomReward defines model for CustomReward.
type CustomReward struct {
	// BackgroundColor The background color to use for the reward. The color is in Hex format (for example, #00E5CB).
	BackgroundColor string `json:"background_color"`

	// BroadcasterId The ID that uniquely identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CooldownExpiresAt The timestamp of when the cooldown period expires. Is **null** if the reward isnt in a cooldown state. See the `global_cooldown_setting` field.
	CooldownExpiresAt *time.Time `json:"cooldown_expires_at"`

	// Cost The cost of the reward in Channel Points.
	Cost int64 `json:"cost"`

	// DefaultImage A set of default images for the reward.
	DefaultImage struct {
		// Url1x The URL to a small version of the image.
		Url1x string `json:"url_1x"`

		// Url2x The URL to a medium version of the image.
		Url2x string `json:"url_2x"`

		// Url4x The URL to a large version of the image.
		Url4x string `json:"url_4x"`
	} `json:"default_image"`

	// GlobalCooldownSetting The settings used to determine whether to apply a cooldown period between redemptions and the length of the cooldown.
	GlobalCooldownSetting struct {
		// GlobalCooldownSeconds The cooldown period, in seconds.
		GlobalCooldownSeconds int64 `json:"global_cooldown_seconds"`

		// IsEnabled A Boolean value that determines whether to apply a cooldown period. Is **true** if a cooldown period is enabled.
		IsEnabled bool `json:"is_enabled"`
	} `json:"global_cooldown_setting"`

	// Id The ID that uniquely identifies this custom reward.
	Id string `json:"id"`

	// Image A set of custom images for the reward. This field is **null** if the broadcaster didnt upload images.
	Image struct {
		// Url1x The URL to a small version of the image.
		Url1x string `json:"url_1x"`

		// Url2x The URL to a medium version of the image.
		Url2x string `json:"url_2x"`

		// Url4x The URL to a large version of the image.
		Url4x string `json:"url_4x"`
	} `json:"image"`

	// IsEnabled A Boolean value that determines whether the reward is enabled. Is **true** if enabled; otherwise, **false**. Disabled rewards arent shown to the user.
	IsEnabled bool `json:"is_enabled"`

	// IsInStock A Boolean value that determines whether the reward is currently in stock. Is **true** if the reward is in stock. Viewers cant redeem out of stock rewards.
	IsInStock bool `json:"is_in_stock"`

	// IsPaused A Boolean value that determines whether the reward is currently paused. Is **true** if the reward is paused. Viewers cant redeem paused rewards.
	IsPaused bool `json:"is_paused"`

	// IsUserInputRequired A Boolean value that determines whether the user must enter information when they redeem the reward. Is **true** if the user is prompted.
	IsUserInputRequired bool `json:"is_user_input_required"`

	// MaxPerStreamSetting The settings used to determine whether to apply a maximum to the number of redemptions allowed per live stream.
	MaxPerStreamSetting struct {
		// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per live stream. Is **true** if the reward applies a limit.
		IsEnabled bool `json:"is_enabled"`

		// MaxPerStream The maximum number of redemptions allowed per live stream.
		MaxPerStream int64 `json:"max_per_stream"`
	} `json:"max_per_stream_setting"`

	// MaxPerUserPerStreamSetting The settings used to determine whether to apply a maximum to the number of redemptions allowed per user per live stream.
	MaxPerUserPerStreamSetting struct {
		// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per user per live stream. Is **true** if the reward applies a limit.
		IsEnabled bool `json:"is_enabled"`

		// MaxPerUserPerStream The maximum number of redemptions allowed per user per live stream.
		MaxPerUserPerStream int64 `json:"max_per_user_per_stream"`
	} `json:"max_per_user_per_stream_setting"`

	// Prompt The prompt shown to the viewer when they redeem the reward if user input is required. See the `is_user_input_required` field.
	Prompt string `json:"prompt"`

	// RedemptionsRedeemedCurrentStream The number of redemptions redeemed during the current live stream. The number counts against the `max_per_stream_setting` limit. This field is **null** if the broadcasters stream isnt live or _max\_per\_stream\_setting_ isnt enabled.
	RedemptionsRedeemedCurrentStream *int32 `json:"redemptions_redeemed_current_stream"`

	// ShouldRedemptionsSkipRequestQueue A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.
	ShouldRedemptionsSkipRequestQueue bool `json:"should_redemptions_skip_request_queue"`

	// Title The title of the reward.
	Title string `json:"title"`
}

func (datatype CustomReward) GetBackgroundColor() string {
	return datatype.BackgroundColor
}
func (datatype CustomReward) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CustomReward) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CustomReward) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CustomReward) GetCooldownExpiresAt() time.Time {
	if datatype.CooldownExpiresAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.CooldownExpiresAt
}
func (datatype CustomReward) GetCost() int64 {
	return datatype.Cost
}
func (datatype CustomReward) GetDefaultImage() struct {
	// Url1x The URL to a small version of the image.
	Url1x string `json:"url_1x"`

	// Url2x The URL to a medium version of the image.
	Url2x string `json:"url_2x"`

	// Url4x The URL to a large version of the image.
	Url4x string `json:"url_4x"`
} {
	return datatype.DefaultImage
}
func (datatype CustomReward) GetGlobalCooldownSetting() struct {
	// GlobalCooldownSeconds The cooldown period, in seconds.
	GlobalCooldownSeconds int64 `json:"global_cooldown_seconds"`

	// IsEnabled A Boolean value that determines whether to apply a cooldown period. Is **true** if a cooldown period is enabled.
	IsEnabled bool `json:"is_enabled"`
} {
	return datatype.GlobalCooldownSetting
}
func (datatype CustomReward) GetId() string {
	return datatype.Id
}
func (datatype CustomReward) GetImage() struct {
	// Url1x The URL to a small version of the image.
	Url1x string `json:"url_1x"`

	// Url2x The URL to a medium version of the image.
	Url2x string `json:"url_2x"`

	// Url4x The URL to a large version of the image.
	Url4x string `json:"url_4x"`
} {
	return datatype.Image
}
func (datatype CustomReward) GetIsEnabled() bool {
	return datatype.IsEnabled
}
func (datatype CustomReward) GetIsInStock() bool {
	return datatype.IsInStock
}
func (datatype CustomReward) GetIsPaused() bool {
	return datatype.IsPaused
}
func (datatype CustomReward) GetIsUserInputRequired() bool {
	return datatype.IsUserInputRequired
}
func (datatype CustomReward) GetMaxPerStreamSetting() struct {
	// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per live stream. Is **true** if the reward applies a limit.
	IsEnabled bool `json:"is_enabled"`

	// MaxPerStream The maximum number of redemptions allowed per live stream.
	MaxPerStream int64 `json:"max_per_stream"`
} {
	return datatype.MaxPerStreamSetting
}
func (datatype CustomReward) GetMaxPerUserPerStreamSetting() struct {
	// IsEnabled A Boolean value that determines whether the reward applies a limit on the number of redemptions allowed per user per live stream. Is **true** if the reward applies a limit.
	IsEnabled bool `json:"is_enabled"`

	// MaxPerUserPerStream The maximum number of redemptions allowed per user per live stream.
	MaxPerUserPerStream int64 `json:"max_per_user_per_stream"`
} {
	return datatype.MaxPerUserPerStreamSetting
}
func (datatype CustomReward) GetPrompt() string {
	return datatype.Prompt
}
func (datatype CustomReward) GetRedemptionsRedeemedCurrentStream() int32 {
	if datatype.RedemptionsRedeemedCurrentStream == nil {
		var empty int32
		return empty
	}
	return *datatype.RedemptionsRedeemedCurrentStream
}
func (datatype CustomReward) GetShouldRedemptionsSkipRequestQueue() bool {
	return datatype.ShouldRedemptionsSkipRequestQueue
}
func (datatype CustomReward) GetTitle() string {
	return datatype.Title
}

// CustomRewardRedemption defines model for CustomRewardRedemption.
type CustomRewardRedemption struct {
	// BroadcasterId The ID that uniquely identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Id The ID that uniquely identifies this redemption..
	Id string `json:"id"`

	// RedeemedAt The date and time of when the reward was redeemed, in RFC3339 format.
	RedeemedAt time.Time `json:"redeemed_at"`

	// Reward An object that describes the reward that the user redeemed.
	Reward struct {
		// Cost The rewards cost, in Channel Points.
		Cost int64 `json:"cost"`

		// Id The ID that uniquely identifies the reward.
		Id string `json:"id"`

		// Prompt The prompt displayed to the viewer if user input is required.
		Prompt string `json:"prompt"`

		// Title The rewards title.
		Title string `json:"title"`
	} `json:"reward"`

	// Status The state of the redemption. Possible values are:
	//
	// * CANCELED
	// * FULFILLED
	// * UNFULFILLED
	Status CustomRewardRedemptionStatus `json:"status"`

	// UserId The ID of the user that redeemed the reward.
	UserId string `json:"user_id"`

	// UserInput The text that the user entered at the prompt when they redeemed the reward; otherwise, an empty string if user input was not required.
	UserInput string `json:"user_input"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype CustomRewardRedemption) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CustomRewardRedemption) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype CustomRewardRedemption) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype CustomRewardRedemption) GetId() string {
	return datatype.Id
}
func (datatype CustomRewardRedemption) GetRedeemedAt() time.Time {
	return datatype.RedeemedAt
}
func (datatype CustomRewardRedemption) GetReward() struct {
	// Cost The rewards cost, in Channel Points.
	Cost int64 `json:"cost"`

	// Id The ID that uniquely identifies the reward.
	Id string `json:"id"`

	// Prompt The prompt displayed to the viewer if user input is required.
	Prompt string `json:"prompt"`

	// Title The rewards title.
	Title string `json:"title"`
} {
	return datatype.Reward
}
func (datatype CustomRewardRedemption) GetStatus() CustomRewardRedemptionStatus {
	return datatype.Status
}
func (datatype CustomRewardRedemption) GetUserId() string {
	return datatype.UserId
}
func (datatype CustomRewardRedemption) GetUserInput() string {
	return datatype.UserInput
}
func (datatype CustomRewardRedemption) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype CustomRewardRedemption) GetUserName() string {
	return datatype.UserName
}

// CustomRewardRedemptionStatus The state of the redemption. Possible values are:
//
// * CANCELED
// * FULFILLED
// * UNFULFILLED
type CustomRewardRedemptionStatus string

// DeleteVideosResponse defines model for DeleteVideosResponse.
type DeleteVideosResponse struct {
	// Data The list of IDs of the videos that were deleted.
	Data []string `json:"data"`
}

func (datatype DeleteVideosResponse) GetData() []string {
	return datatype.Data
}

// DropsEntitlement defines model for DropsEntitlement.
type DropsEntitlement struct {
	// BenefitId An ID that identifies the benefit (reward).
	BenefitId string `json:"benefit_id"`

	// FulfillmentStatus The entitlements fulfillment status. Possible values are:
	//
	// * CLAIMED
	// * FULFILLED
	FulfillmentStatus DropsEntitlementFulfillmentStatus `json:"fulfillment_status"`

	// GameId An ID that identifies the game the user was playing when the reward was entitled.
	GameId string `json:"game_id"`

	// Id An ID that identifies the entitlement.
	Id string `json:"id"`

	// LastUpdated The UTC date and time (in RFC3339 format) of when the entitlement was last updated.
	LastUpdated time.Time `json:"last_updated"`

	// Timestamp The UTC date and time (in RFC3339 format) of when the entitlement was granted.
	Timestamp time.Time `json:"timestamp"`

	// UserId An ID that identifies the user who was granted the entitlement.
	UserId string `json:"user_id"`
}

func (datatype DropsEntitlement) GetBenefitId() string {
	return datatype.BenefitId
}
func (datatype DropsEntitlement) GetFulfillmentStatus() DropsEntitlementFulfillmentStatus {
	return datatype.FulfillmentStatus
}
func (datatype DropsEntitlement) GetGameId() string {
	return datatype.GameId
}
func (datatype DropsEntitlement) GetId() string {
	return datatype.Id
}
func (datatype DropsEntitlement) GetLastUpdated() time.Time {
	return datatype.LastUpdated
}
func (datatype DropsEntitlement) GetTimestamp() time.Time {
	return datatype.Timestamp
}
func (datatype DropsEntitlement) GetUserId() string {
	return datatype.UserId
}

// DropsEntitlementFulfillmentStatus The entitlements fulfillment status. Possible values are:
//
// * CLAIMED
// * FULFILLED
type DropsEntitlementFulfillmentStatus string

// DropsEntitlementUpdated defines model for DropsEntitlementUpdated.
type DropsEntitlementUpdated struct {
	// Ids The list of entitlements that the status in the `status` field applies to.
	Ids []string `json:"ids"`

	// Status A string that indicates whether the status of the entitlements in the `ids` field were successfully updated. Possible values are:
	//
	// * INVALID\_ID  The entitlement IDs in the `ids` field are not valid.
	// * NOT\_FOUND  The entitlement IDs in the `ids` field were not found.
	// * SUCCESS  The status of the entitlements in the `ids` field were successfully updated.
	// * UNAUTHORIZED  The user or organization identified by the user access token is not authorized to update the entitlements.
	// * UPDATE\_FAILED  The update failed. These are considered transient errors and the request should be retried later.
	Status DropsEntitlementUpdatedStatus `json:"status"`
}

func (datatype DropsEntitlementUpdated) GetIds() []string {
	return datatype.Ids
}
func (datatype DropsEntitlementUpdated) GetStatus() DropsEntitlementUpdatedStatus {
	return datatype.Status
}

// DropsEntitlementUpdatedStatus A string that indicates whether the status of the entitlements in the `ids` field were successfully updated. Possible values are:
//
// * INVALID\_ID  The entitlement IDs in the `ids` field are not valid.
// * NOT\_FOUND  The entitlement IDs in the `ids` field were not found.
// * SUCCESS  The status of the entitlements in the `ids` field were successfully updated.
// * UNAUTHORIZED  The user or organization identified by the user access token is not authorized to update the entitlements.
// * UPDATE\_FAILED  The update failed. These are considered transient errors and the request should be retried later.
type DropsEntitlementUpdatedStatus string

// Emote defines model for Emote.
type Emote struct {
	// EmoteSetId An ID that identifies the emote set that the emote belongs to.
	EmoteSetId string `json:"emote_set_id"`

	// EmoteType The type of emote. The possible values are:
	//
	// * bitstier  A Bits tier emote.
	// * follower  A follower emote.
	// * subscriptions  A subscriber emote.
	EmoteType EmoteEmoteType `json:"emote_type"`

	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:
	//
	// * animated  An animated GIF is available for this emote.
	// * static  A static PNG file is available for this emote.
	Format []EmoteFormat `json:"format"`

	// Id An ID that uniquely identifies this emote.
	Id string `json:"id"`

	// Images The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.
	//
	// **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
	Images struct {
		// Url1x A URL to the small version (28px x 28px) of the emote.
		Url1x string `json:"url_1x"`

		// Url2x A URL to the medium version (56px x 56px) of the emote.
		Url2x string `json:"url_2x"`

		// Url4x A URL to the large version (112px x 112px) of the emote.
		Url4x string `json:"url_4x"`
	} `json:"images"`

	// Name The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
	Name string `json:"name"`

	// OwnerId The ID of the broadcaster who owns the emote.
	OwnerId string `json:"owner_id"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:
	//
	// * 1.0  A small version (28px x 28px) is available.
	// * 2.0  A medium version (56px x 56px) is available.
	// * 3.0  A large version (112px x 112px) is available.
	Scale []EmoteScale `json:"scale"`

	// ThemeMode The background themes that the emote is available in. Possible themes are:
	//
	// * dark
	// * light
	ThemeMode []EmoteThemeMode `json:"theme_mode"`
}

func (datatype Emote) GetEmoteSetId() string {
	return datatype.EmoteSetId
}
func (datatype Emote) GetEmoteType() EmoteEmoteType {
	return datatype.EmoteType
}
func (datatype Emote) GetFormat() []EmoteFormat {
	return datatype.Format
}
func (datatype Emote) GetId() string {
	return datatype.Id
}
func (datatype Emote) GetImages() struct {
	// Url1x A URL to the small version (28px x 28px) of the emote.
	Url1x string `json:"url_1x"`

	// Url2x A URL to the medium version (56px x 56px) of the emote.
	Url2x string `json:"url_2x"`

	// Url4x A URL to the large version (112px x 112px) of the emote.
	Url4x string `json:"url_4x"`
} {
	return datatype.Images
}
func (datatype Emote) GetName() string {
	return datatype.Name
}
func (datatype Emote) GetOwnerId() string {
	return datatype.OwnerId
}
func (datatype Emote) GetScale() []EmoteScale {
	return datatype.Scale
}
func (datatype Emote) GetThemeMode() []EmoteThemeMode {
	return datatype.ThemeMode
}

// EmoteEmoteType The type of emote. The possible values are:
//
// * bitstier  A Bits tier emote.
// * follower  A follower emote.
// * subscriptions  A subscriber emote.
type EmoteEmoteType string

// EmoteFormat defines model for Emote.Format.
type EmoteFormat string

// EmoteScale defines model for Emote.Scale.
type EmoteScale string

// EmoteThemeMode defines model for Emote.ThemeMode.
type EmoteThemeMode string

// EndGuestStarSessionResponse defines model for EndGuestStarSessionResponse.
type EndGuestStarSessionResponse struct {
	// Data Summary of the session details when the session was ended.
	Data []GuestStarSession `json:"data"`
}

func (datatype EndGuestStarSessionResponse) GetData() []GuestStarSession {
	return datatype.Data
}

// EndPollBody defines model for EndPollBody.
type EndPollBody struct {
	// BroadcasterId The ID of the broadcaster thats running the poll. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// Id The ID of the poll to update.
	Id string `json:"id"`

	// Status The status to set the poll to. Possible case-sensitive values are:
	//
	// * TERMINATED  Ends the poll before the poll is scheduled to end. The poll remains publicly visible.
	// * ARCHIVED  Ends the poll before the poll is scheduled to end, and then archives it so it's no longer publicly visible.
	Status EndPollBodyStatus `json:"status"`
}

func (datatype EndPollBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype EndPollBody) GetId() string {
	return datatype.Id
}
func (datatype EndPollBody) GetStatus() EndPollBodyStatus {
	return datatype.Status
}

// EndPollBodyStatus The status to set the poll to. Possible case-sensitive values are:
//
// * TERMINATED  Ends the poll before the poll is scheduled to end. The poll remains publicly visible.
// * ARCHIVED  Ends the poll before the poll is scheduled to end, and then archives it so it's no longer publicly visible.
type EndPollBodyStatus string

// EndPollResponse defines model for EndPollResponse.
type EndPollResponse struct {
	// Data A list that contains the poll that you ended.
	Data []Poll `json:"data"`
}

func (datatype EndPollResponse) GetData() []Poll {
	return datatype.Data
}

// EndPredictionBody defines model for EndPredictionBody.
type EndPredictionBody struct {
	// BroadcasterId The ID of the broadcaster thats running the prediction. This ID must match the user ID in the user access token.
	BroadcasterId string `json:"broadcaster_id"`

	// Id The ID of the prediction to update.
	Id string `json:"id"`

	// Status The status to set the prediction to. Possible case-sensitive values are:
	//
	// * RESOLVED  The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome.
	// * CANCELED  The broadcaster is canceling the prediction and sending refunds to the participants.
	// * LOCKED  The broadcaster is locking the prediction, which means viewers may no longer make predictions.
	//
	// The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.
	//
	// The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.
	Status EndPredictionBodyStatus `json:"status"`

	// WinningOutcomeId The ID of the winning outcome. You must set this parameter if you set `status` to RESOLVED.
	WinningOutcomeId *string `json:"winning_outcome_id,omitempty"`
}

func (datatype EndPredictionBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype EndPredictionBody) GetId() string {
	return datatype.Id
}
func (datatype EndPredictionBody) GetStatus() EndPredictionBodyStatus {
	return datatype.Status
}
func (datatype EndPredictionBody) GetWinningOutcomeId() string {
	if datatype.WinningOutcomeId == nil {
		var empty string
		return empty
	}
	return *datatype.WinningOutcomeId
}

// EndPredictionBodyStatus The status to set the prediction to. Possible case-sensitive values are:
//
// * RESOLVED  The winning outcome is determined and the Channel Points are distributed to the viewers who predicted the correct outcome.
// * CANCELED  The broadcaster is canceling the prediction and sending refunds to the participants.
// * LOCKED  The broadcaster is locking the prediction, which means viewers may no longer make predictions.
//
// The broadcaster can update an active prediction to LOCKED, RESOLVED, or CANCELED; and update a locked prediction to RESOLVED or CANCELED.
//
// The broadcaster has up to 24 hours after the prediction window closes to resolve the prediction. If not, Twitch sets the status to CANCELED and returns the points.
type EndPredictionBodyStatus string

// EndPredictionResponse defines model for EndPredictionResponse.
type EndPredictionResponse struct {
	// Data A list that contains the single prediction that you updated.
	Data []Prediction `json:"data"`
}

func (datatype EndPredictionResponse) GetData() []Prediction {
	return datatype.Data
}

// EventSubSubscription defines model for EventSubSubscription.
type EventSubSubscription struct {
	// Condition The subscription's parameter values. This is a string-encoded JSON object whose contents are determined by the subscription type.
	Condition map[string]interface{} `json:"condition"`

	// Cost The amount that the subscription counts against your limit. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	Cost int32 `json:"cost"`

	// CreatedAt The date and time (in RFC3339 format) of when the subscription was created.
	CreatedAt time.Time `json:"created_at"`

	// Id An ID that identifies the subscription.
	Id string `json:"id"`

	// Status The subscription's status. The subscriber receives events only for **enabled** subscriptions. Possible values are:
	//
	// * enabled  The subscription is enabled.
	// * webhook\_callback\_verification\_pending  The subscription is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * authorization\_revoked  The authorization was revoked for one or more users specified in the **Condition** object.
	// * moderator\_removed  The moderator that authorized the subscription is no longer one of the broadcaster's moderators.
	// * user\_removed  One of the users specified in the **Condition** object was removed.
	// * version\_removed  The subscription to subscription type and version is no longer supported.
	// * beta\_maintenance  The subscription to the beta subscription type was removed due to maintenance.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_connection\_unused  The client failed to subscribe to events within the required time.
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	Status EventSubSubscriptionStatus `json:"status"`

	// Transport The transport details used to send the notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. Included only if `method` is set to **webhook**.
		Callback *string `json:"callback,omitempty"`

		// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if `method` is set to **websocket**.
		ConnectedAt *time.Time `json:"connected_at,omitempty"`

		// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if `method` is set to **websocket**.
		DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method EventSubSubscriptionTransportMethod `json:"method"`

		// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if `method` is set to **websocket**.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`

	// Type The subscription's type. See [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types).
	Type EventSubSubscriptionType `json:"type"`

	// Version The version number that identifies this definition of the subscription's data.
	Version string `json:"version"`
}

func (datatype EventSubSubscription) GetCondition() map[string]interface{} {
	return datatype.Condition
}
func (datatype EventSubSubscription) GetCost() int32 {
	return datatype.Cost
}
func (datatype EventSubSubscription) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype EventSubSubscription) GetId() string {
	return datatype.Id
}
func (datatype EventSubSubscription) GetStatus() EventSubSubscriptionStatus {
	return datatype.Status
}
func (datatype EventSubSubscription) GetTransport() struct {
	// Callback The callback URL where the notifications are sent. Included only if `method` is set to **webhook**.
	Callback *string `json:"callback,omitempty"`

	// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if `method` is set to **websocket**.
	ConnectedAt *time.Time `json:"connected_at,omitempty"`

	// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if `method` is set to **websocket**.
	DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

	// Method The transport method. Possible values are:
	//
	// * webhook
	// * websocket
	Method EventSubSubscriptionTransportMethod `json:"method"`

	// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if `method` is set to **websocket**.
	SessionId *string `json:"session_id,omitempty"`
} {
	return datatype.Transport
}
func (datatype EventSubSubscription) GetType() EventSubSubscriptionType {
	return datatype.Type
}
func (datatype EventSubSubscription) GetVersion() string {
	return datatype.Version
}

// EventSubSubscriptionStatus The subscription's status. The subscriber receives events only for **enabled** subscriptions. Possible values are:
//
// * enabled  The subscription is enabled.
// * webhook\_callback\_verification\_pending  The subscription is pending verification of the specified callback URL.
// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
// * authorization\_revoked  The authorization was revoked for one or more users specified in the **Condition** object.
// * moderator\_removed  The moderator that authorized the subscription is no longer one of the broadcaster's moderators.
// * user\_removed  One of the users specified in the **Condition** object was removed.
// * version\_removed  The subscription to subscription type and version is no longer supported.
// * beta\_maintenance  The subscription to the beta subscription type was removed due to maintenance.
// * websocket\_disconnected  The client closed the connection.
// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
// * websocket\_connection\_unused  The client failed to subscribe to events within the required time.
// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
type EventSubSubscriptionStatus string

// EventSubSubscriptionTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type EventSubSubscriptionTransportMethod string

// EventSubSubscriptionType The subscription's type. See [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types).
type EventSubSubscriptionType string

// Extension defines model for Extension.
type Extension struct {
	// AllowlistedConfigUrls Allowlisted configuration URLs for displaying the extension (the allowlist is configured on Twitchs [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \-> **Extension** \-> **Version** \-> **Capabilities**).
	AllowlistedConfigUrls []string `json:"allowlisted_config_urls"`

	// AllowlistedPanelUrls Allowlisted panel URLs for displaying the extension (the allowlist is configured on Twitchs [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \-> **Extension** \-> **Version** \-> **Capabilities**).
	AllowlistedPanelUrls []string `json:"allowlisted_panel_urls"`

	// AuthorName The name of the user or organization that owns the extension.
	AuthorName string `json:"author_name"`

	// BitsEnabled A Boolean value that determines whether the extension has features that use Bits. Is **true** if the extension has features that use Bits.
	BitsEnabled bool `json:"bits_enabled"`

	// CanInstall A Boolean value that determines whether a user can install the extension on their channel. Is **true** if a user can install the extension.
	//
	// Typically, this is set to **false** if the extension is currently in testing mode and requires users to be allowlisted (the allowlist is configured on Twitchs [developer site](https://dev.twitch.tv/console/extensions) under the **Extensions** \-> **Extension** \-> **Version** \-> **Access**).
	CanInstall bool `json:"can_install"`

	// ConfigurationLocation The location of where the extensions configuration is stored. Possible values are:
	//
	// * hosted  The Extensions Configuration Service hosts the configuration.
	// * custom  The Extension Backend Service (EBS) hosts the configuration.
	// * none  The extension doesn't require configuration.
	ConfigurationLocation ExtensionConfigurationLocation `json:"configuration_location"`

	// Description A longer description of the extension. It appears on the details page.
	Description string `json:"description"`

	// EulaTosUrl A URL to the extensions Terms of Service.
	EulaTosUrl string `json:"eula_tos_url"`

	// HasChatSupport A Boolean value that determines whether the extension can communicate with the installed channels chat. Is **true** if the extension can communicate with the channels chat room.
	HasChatSupport bool `json:"has_chat_support"`

	// IconUrl A URL to the default icon thats displayed in the Extensions directory.
	IconUrl string `json:"icon_url"`

	// IconUrls A dictionary that contains URLs to different sizes of the default icon. The dictionarys key identifies the icons size (for example, 24x24), and the dictionarys value contains the URL to the icon.
	IconUrls ExtensionIconUrls `json:"icon_urls"`

	// Id The extensions ID.
	Id string `json:"id"`

	// Name The extensions name.
	Name string `json:"name"`

	// PrivacyPolicyUrl A URL to the extensions privacy policy.
	PrivacyPolicyUrl string `json:"privacy_policy_url"`

	// RequestIdentityLink A Boolean value that determines whether the extension wants to explicitly ask viewers to link their Twitch identity.
	RequestIdentityLink bool `json:"request_identity_link"`

	// ScreenshotUrls A list of URLs to screenshots that are shown in the Extensions marketplace.
	ScreenshotUrls []string `json:"screenshot_urls"`

	// State The extensions state. Possible values are:
	//
	// * Approved
	// * AssetsUploaded
	// * Deleted
	// * Deprecated
	// * InReview
	// * InTest
	// * PendingAction
	// * Rejected
	// * Released
	State ExtensionState `json:"state"`

	// SubscriptionsSupportLevel Indicates whether the extension can view the users subscription level on the channel that the extension is installed on. Possible values are:
	//
	// * none  The extension can't view the users subscription level.
	// * optional  The extension can view the users subscription level.
	SubscriptionsSupportLevel ExtensionSubscriptionsSupportLevel `json:"subscriptions_support_level"`

	// Summary A short description of the extension that streamers see when hovering over the discovery splash screen in the Extensions manager.
	Summary string `json:"summary"`

	// SupportEmail The email address that users use to get support for the extension.
	SupportEmail string `json:"support_email"`

	// Version The extensions version number.
	Version string `json:"version"`

	// ViewerSummary A brief description displayed on the channel to explain how the extension works.
	ViewerSummary string `json:"viewer_summary"`

	// Views Describes all views-related information such as how the extension is displayed on mobile devices.
	Views struct {
		// Component Describes how the extension is rendered if the extension may be activated as a video-component extension.
		Component struct {
			// AspectRatioX The width value of the ratio (width : height) which determines the extensions width, and how the extensions iframe will resize in different video player environments.
			AspectRatioX int32 `json:"aspect_ratio_x"`

			// AspectRatioY The height value of the ratio (width : height) which determines the extensions height, and how the extensions iframe will resize in different video player environments.
			AspectRatioY int32 `json:"aspect_ratio_y"`

			// Autoscale A Boolean value that determines whether to apply CSS zoom. If **true**, a CSS zoom is applied such that the size of the extension is variable but the inner dimensions are fixed based on Scale Pixels. This allows your extension to render as if it is of fixed width and height. If **false**, the inner dimensions of the extension iframe are variable, meaning your extension must implement responsiveness.
			Autoscale bool `json:"autoscale"`

			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// ScalePixels The base width, in pixels, of the extension to use when scaling (see `autoscale`). This value is ignored if `autoscale` is **false**.
			ScalePixels int32 `json:"scale_pixels"`

			// TargetHeight The height as a percent of the maximum height of a video component extension. Values are between 1% - 100%.
			TargetHeight int32 `json:"target_height"`

			// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Video - Component slot.
			ViewerUrl string `json:"viewer_url"`
		} `json:"component"`

		// Config Describes the view that is shown to broadcasters while they are configuring your extension within the Extension Manager.
		Config struct {
			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// ViewerUrl The HTML file shown to broadcasters while they are configuring your extension within the Extension Manager.
			ViewerUrl string `json:"viewer_url"`
		} `json:"config"`

		// Mobile Describes how the extension is displayed on mobile devices.
		Mobile struct {
			// ViewerUrl The HTML file that is shown to viewers on mobile devices. This page is presented to viewers as a panel behind the chat area of the mobile app.
			ViewerUrl string `json:"viewer_url"`
		} `json:"mobile"`

		// Panel Describes how the extension is rendered if the extension may be activated as a panel extension.
		Panel struct {
			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// Height The height, in pixels, of the panel component that the extension is rendered in.
			Height int32 `json:"height"`

			// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Panel slot.
			ViewerUrl string `json:"viewer_url"`
		} `json:"panel"`

		// VideoOverlay Describes how the extension is rendered if the extension may be activated as a video-overlay extension.
		VideoOverlay struct {
			// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
			CanLinkExternalContent bool `json:"can_link_external_content"`

			// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated on the Video - Overlay slot.
			ViewerUrl string `json:"viewer_url"`
		} `json:"video_overlay"`
	} `json:"views"`
}

func (datatype Extension) GetAllowlistedConfigUrls() []string {
	return datatype.AllowlistedConfigUrls
}
func (datatype Extension) GetAllowlistedPanelUrls() []string {
	return datatype.AllowlistedPanelUrls
}
func (datatype Extension) GetAuthorName() string {
	return datatype.AuthorName
}
func (datatype Extension) GetBitsEnabled() bool {
	return datatype.BitsEnabled
}
func (datatype Extension) GetCanInstall() bool {
	return datatype.CanInstall
}
func (datatype Extension) GetConfigurationLocation() ExtensionConfigurationLocation {
	return datatype.ConfigurationLocation
}
func (datatype Extension) GetDescription() string {
	return datatype.Description
}
func (datatype Extension) GetEulaTosUrl() string {
	return datatype.EulaTosUrl
}
func (datatype Extension) GetHasChatSupport() bool {
	return datatype.HasChatSupport
}
func (datatype Extension) GetIconUrl() string {
	return datatype.IconUrl
}
func (datatype Extension) GetIconUrls() ExtensionIconUrls {
	return datatype.IconUrls
}
func (datatype Extension) GetId() string {
	return datatype.Id
}
func (datatype Extension) GetName() string {
	return datatype.Name
}
func (datatype Extension) GetPrivacyPolicyUrl() string {
	return datatype.PrivacyPolicyUrl
}
func (datatype Extension) GetRequestIdentityLink() bool {
	return datatype.RequestIdentityLink
}
func (datatype Extension) GetScreenshotUrls() []string {
	return datatype.ScreenshotUrls
}
func (datatype Extension) GetState() ExtensionState {
	return datatype.State
}
func (datatype Extension) GetSubscriptionsSupportLevel() ExtensionSubscriptionsSupportLevel {
	return datatype.SubscriptionsSupportLevel
}
func (datatype Extension) GetSummary() string {
	return datatype.Summary
}
func (datatype Extension) GetSupportEmail() string {
	return datatype.SupportEmail
}
func (datatype Extension) GetVersion() string {
	return datatype.Version
}
func (datatype Extension) GetViewerSummary() string {
	return datatype.ViewerSummary
}
func (datatype Extension) GetViews() struct {
	// Component Describes how the extension is rendered if the extension may be activated as a video-component extension.
	Component struct {
		// AspectRatioX The width value of the ratio (width : height) which determines the extensions width, and how the extensions iframe will resize in different video player environments.
		AspectRatioX int32 `json:"aspect_ratio_x"`

		// AspectRatioY The height value of the ratio (width : height) which determines the extensions height, and how the extensions iframe will resize in different video player environments.
		AspectRatioY int32 `json:"aspect_ratio_y"`

		// Autoscale A Boolean value that determines whether to apply CSS zoom. If **true**, a CSS zoom is applied such that the size of the extension is variable but the inner dimensions are fixed based on Scale Pixels. This allows your extension to render as if it is of fixed width and height. If **false**, the inner dimensions of the extension iframe are variable, meaning your extension must implement responsiveness.
		Autoscale bool `json:"autoscale"`

		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// ScalePixels The base width, in pixels, of the extension to use when scaling (see `autoscale`). This value is ignored if `autoscale` is **false**.
		ScalePixels int32 `json:"scale_pixels"`

		// TargetHeight The height as a percent of the maximum height of a video component extension. Values are between 1% - 100%.
		TargetHeight int32 `json:"target_height"`

		// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Video - Component slot.
		ViewerUrl string `json:"viewer_url"`
	} `json:"component"`

	// Config Describes the view that is shown to broadcasters while they are configuring your extension within the Extension Manager.
	Config struct {
		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// ViewerUrl The HTML file shown to broadcasters while they are configuring your extension within the Extension Manager.
		ViewerUrl string `json:"viewer_url"`
	} `json:"config"`

	// Mobile Describes how the extension is displayed on mobile devices.
	Mobile struct {
		// ViewerUrl The HTML file that is shown to viewers on mobile devices. This page is presented to viewers as a panel behind the chat area of the mobile app.
		ViewerUrl string `json:"viewer_url"`
	} `json:"mobile"`

	// Panel Describes how the extension is rendered if the extension may be activated as a panel extension.
	Panel struct {
		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// Height The height, in pixels, of the panel component that the extension is rendered in.
		Height int32 `json:"height"`

		// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated in a Panel slot.
		ViewerUrl string `json:"viewer_url"`
	} `json:"panel"`

	// VideoOverlay Describes how the extension is rendered if the extension may be activated as a video-overlay extension.
	VideoOverlay struct {
		// CanLinkExternalContent A Boolean value that determines whether the extension can link to non-Twitch domains.
		CanLinkExternalContent bool `json:"can_link_external_content"`

		// ViewerUrl The HTML file that is shown to viewers on the channel page when the extension is activated on the Video - Overlay slot.
		ViewerUrl string `json:"viewer_url"`
	} `json:"video_overlay"`
} {
	return datatype.Views
}

// ExtensionConfigurationLocation The location of where the extensions configuration is stored. Possible values are:
//
// * hosted  The Extensions Configuration Service hosts the configuration.
// * custom  The Extension Backend Service (EBS) hosts the configuration.
// * none  The extension doesn't require configuration.
type ExtensionConfigurationLocation string

// ExtensionState The extensions state. Possible values are:
//
// * Approved
// * AssetsUploaded
// * Deleted
// * Deprecated
// * InReview
// * InTest
// * PendingAction
// * Rejected
// * Released
type ExtensionState string

// ExtensionSubscriptionsSupportLevel Indicates whether the extension can view the users subscription level on the channel that the extension is installed on. Possible values are:
//
// * none  The extension can't view the users subscription level.
// * optional  The extension can view the users subscription level.
type ExtensionSubscriptionsSupportLevel string

// ExtensionAnalytics defines model for ExtensionAnalytics.
type ExtensionAnalytics struct {
	// URL The URL that you use to download the report. The URL is valid for 5 minutes.
	URL string `json:"URL"`

	// DateRange The reporting windows start and end dates, in RFC3339 format.
	DateRange struct {
		// EndedAt The reporting windows end date.
		EndedAt time.Time `json:"ended_at"`

		// StartedAt The reporting windows start date.
		StartedAt time.Time `json:"started_at"`
	} `json:"date_range"`

	// ExtensionId An ID that identifies the extension that the report was generated for.
	ExtensionId string `json:"extension_id"`

	// Type The type of report.
	Type string `json:"type"`
}

func (datatype ExtensionAnalytics) GetURL() string {
	return datatype.URL
}
func (datatype ExtensionAnalytics) GetDateRange() struct {
	// EndedAt The reporting windows end date.
	EndedAt time.Time `json:"ended_at"`

	// StartedAt The reporting windows start date.
	StartedAt time.Time `json:"started_at"`
} {
	return datatype.DateRange
}
func (datatype ExtensionAnalytics) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype ExtensionAnalytics) GetType() string {
	return datatype.Type
}

// ExtensionBitsProduct defines model for ExtensionBitsProduct.
type ExtensionBitsProduct struct {
	// Cost An object that contains the product's cost information.
	Cost struct {
		// Amount The product's price.
		Amount int32 `json:"amount"`

		// Type The type of currency. Possible values are:
		//
		// * bits
		Type ExtensionBitsProductCostType `json:"type"`
	} `json:"cost"`

	// DisplayName The product's name as displayed in the extension.
	DisplayName string `json:"display_name"`

	// Expiration The date and time, in RFC3339 format, when the product expires.
	Expiration time.Time `json:"expiration"`

	// InDevelopment A Boolean value that indicates whether the product is in development. If **true**, the product is not available for public use.
	InDevelopment bool `json:"in_development"`

	// IsBroadcast A Boolean value that determines whether Bits product purchase events are broadcast to all instances of an extension on a channel. The events are broadcast via the `onTransactionComplete` helper callback. Is **true** if the event is broadcast to all instances.
	IsBroadcast bool `json:"is_broadcast"`

	// Sku The product's SKU. The SKU is unique across an extension's products.
	Sku string `json:"sku"`
}

func (datatype ExtensionBitsProduct) GetCost() struct {
	// Amount The product's price.
	Amount int32 `json:"amount"`

	// Type The type of currency. Possible values are:
	//
	// * bits
	Type ExtensionBitsProductCostType `json:"type"`
} {
	return datatype.Cost
}
func (datatype ExtensionBitsProduct) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype ExtensionBitsProduct) GetExpiration() time.Time {
	return datatype.Expiration
}
func (datatype ExtensionBitsProduct) GetInDevelopment() bool {
	return datatype.InDevelopment
}
func (datatype ExtensionBitsProduct) GetIsBroadcast() bool {
	return datatype.IsBroadcast
}
func (datatype ExtensionBitsProduct) GetSku() string {
	return datatype.Sku
}

// ExtensionBitsProductCostType The type of currency. Possible values are:
//
// * bits
type ExtensionBitsProductCostType string

// ExtensionConfigurationSegment defines model for ExtensionConfigurationSegment.
type ExtensionConfigurationSegment struct {
	// BroadcasterId The ID of the broadcaster that installed the extension. The object includes this field only if the `segment` query parameter is set to developer or broadcaster.
	BroadcasterId *string `json:"broadcaster_id,omitempty"`

	// Content The contents of the segment. This string may be a plain-text string or a string-encoded JSON object.
	Content string `json:"content"`

	// Segment The type of segment. Possible values are:
	//
	// * broadcaster
	// * developer
	// * global
	Segment ExtensionConfigurationSegmentSegment `json:"segment"`

	// Version The version number that identifies this definition of the segments data.
	Version string `json:"version"`
}

func (datatype ExtensionConfigurationSegment) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype ExtensionConfigurationSegment) GetContent() string {
	return datatype.Content
}
func (datatype ExtensionConfigurationSegment) GetSegment() ExtensionConfigurationSegmentSegment {
	return datatype.Segment
}
func (datatype ExtensionConfigurationSegment) GetVersion() string {
	return datatype.Version
}

// ExtensionConfigurationSegmentSegment The type of segment. Possible values are:
//
// * broadcaster
// * developer
// * global
type ExtensionConfigurationSegmentSegment string

// ExtensionIconUrls A dictionary that contains URLs to different sizes of the default icon. The dictionarys key identifies the icons size (for example, 24x24), and the dictionarys value contains the URL to the icon.
type ExtensionIconUrls struct {
	N100x100 *string `json:"100x100,omitempty"`
	N24x24   *string `json:"24x24,omitempty"`
	N300x200 *string `json:"300x200,omitempty"`
}

func (datatype ExtensionIconUrls) GetN100x100() string {
	if datatype.N100x100 == nil {
		var empty string
		return empty
	}
	return *datatype.N100x100
}
func (datatype ExtensionIconUrls) GetN24x24() string {
	if datatype.N24x24 == nil {
		var empty string
		return empty
	}
	return *datatype.N24x24
}
func (datatype ExtensionIconUrls) GetN300x200() string {
	if datatype.N300x200 == nil {
		var empty string
		return empty
	}
	return *datatype.N300x200
}

// ExtensionLiveChannel defines model for ExtensionLiveChannel.
type ExtensionLiveChannel struct {
	// BroadcasterId The ID of the broadcaster that is streaming live and has installed or activated the extension.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// GameId The ID of the category or game being streamed.
	GameId string `json:"game_id"`

	// GameName The name of the category or game being streamed.
	GameName string `json:"game_name"`

	// Title The title of the broadcasters stream. May be an empty string if not specified.
	Title string `json:"title"`
}

func (datatype ExtensionLiveChannel) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ExtensionLiveChannel) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ExtensionLiveChannel) GetGameId() string {
	return datatype.GameId
}
func (datatype ExtensionLiveChannel) GetGameName() string {
	return datatype.GameName
}
func (datatype ExtensionLiveChannel) GetTitle() string {
	return datatype.Title
}

// ExtensionSecret defines model for ExtensionSecret.
type ExtensionSecret struct {
	// FormatVersion The version number that identifies this definition of the secrets data.
	FormatVersion int32 `json:"format_version"`

	// Secrets The list of secrets.
	Secrets []struct {
		// ActiveAt The UTC date and time (in RFC3339 format) that you may begin using this secret to sign a JWT.
		ActiveAt time.Time `json:"active_at"`

		// Content The raw secret that you use with JWT encoding.
		Content string `json:"content"`

		// ExpiresAt The UTC date and time (in RFC3339 format) that you must stop using this secret to decode a JWT.
		ExpiresAt time.Time `json:"expires_at"`
	} `json:"secrets"`
}

func (datatype ExtensionSecret) GetFormatVersion() int32 {
	return datatype.FormatVersion
}
func (datatype ExtensionSecret) GetSecrets() []struct {
	// ActiveAt The UTC date and time (in RFC3339 format) that you may begin using this secret to sign a JWT.
	ActiveAt time.Time `json:"active_at"`

	// Content The raw secret that you use with JWT encoding.
	Content string `json:"content"`

	// ExpiresAt The UTC date and time (in RFC3339 format) that you must stop using this secret to decode a JWT.
	ExpiresAt time.Time `json:"expires_at"`
} {
	return datatype.Secrets
}

// ExtensionTransaction defines model for ExtensionTransaction.
type ExtensionTransaction struct {
	// BroadcasterId The ID of the broadcaster that owns the channel where the transaction occurred.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Id An ID that identifies the transaction.
	Id string `json:"id"`

	// ProductData Contains details about the digital product.
	ProductData struct {
		// Broadcast A Boolean value that determines whether the data was broadcast to all instances of the extension. Is **true** if the data was broadcast to all instances.
		Broadcast bool `json:"broadcast"`

		// Cost Contains details about the digital products cost.
		Cost struct {
			// Amount The amount exchanged for the digital product.
			Amount int32 `json:"amount"`

			// Type The type of currency exchanged. Possible values are:
			//
			// * bits
			Type ExtensionTransactionProductDataCostType `json:"type"`
		} `json:"cost"`

		// DisplayName The name of the digital product.
		DisplayName string `json:"displayName"`

		// Domain Set to `twitch.ext.` \+ `<the extension's ID>`.
		Domain string `json:"domain"`

		// Expiration This field is always empty since you may purchase only unexpired products.
		Expiration string `json:"expiration"`

		// InDevelopment A Boolean value that determines whether the product is in development. Is **true** if the digital product is in development and cannot be exchanged.
		InDevelopment bool `json:"inDevelopment"`

		// Sku An ID that identifies the digital product.
		Sku string `json:"sku"`
	} `json:"product_data"`

	// ProductType The type of transaction. Possible values are:
	//
	// * BITS\_IN\_EXTENSION
	ProductType ExtensionTransactionProductType `json:"product_type"`

	// Timestamp The UTC date and time (in RFC3339 format) of the transaction.
	Timestamp time.Time `json:"timestamp"`

	// UserId The ID of the user that purchased the digital product.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype ExtensionTransaction) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ExtensionTransaction) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype ExtensionTransaction) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype ExtensionTransaction) GetId() string {
	return datatype.Id
}
func (datatype ExtensionTransaction) GetProductData() struct {
	// Broadcast A Boolean value that determines whether the data was broadcast to all instances of the extension. Is **true** if the data was broadcast to all instances.
	Broadcast bool `json:"broadcast"`

	// Cost Contains details about the digital products cost.
	Cost struct {
		// Amount The amount exchanged for the digital product.
		Amount int32 `json:"amount"`

		// Type The type of currency exchanged. Possible values are:
		//
		// * bits
		Type ExtensionTransactionProductDataCostType `json:"type"`
	} `json:"cost"`

	// DisplayName The name of the digital product.
	DisplayName string `json:"displayName"`

	// Domain Set to `twitch.ext.` \+ `<the extension's ID>`.
	Domain string `json:"domain"`

	// Expiration This field is always empty since you may purchase only unexpired products.
	Expiration string `json:"expiration"`

	// InDevelopment A Boolean value that determines whether the product is in development. Is **true** if the digital product is in development and cannot be exchanged.
	InDevelopment bool `json:"inDevelopment"`

	// Sku An ID that identifies the digital product.
	Sku string `json:"sku"`
} {
	return datatype.ProductData
}
func (datatype ExtensionTransaction) GetProductType() ExtensionTransactionProductType {
	return datatype.ProductType
}
func (datatype ExtensionTransaction) GetTimestamp() time.Time {
	return datatype.Timestamp
}
func (datatype ExtensionTransaction) GetUserId() string {
	return datatype.UserId
}
func (datatype ExtensionTransaction) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype ExtensionTransaction) GetUserName() string {
	return datatype.UserName
}

// ExtensionTransactionProductDataCostType The type of currency exchanged. Possible values are:
//
// * bits
type ExtensionTransactionProductDataCostType string

// ExtensionTransactionProductType The type of transaction. Possible values are:
//
// * BITS\_IN\_EXTENSION
type ExtensionTransactionProductType string

// Game defines model for Game.
type Game struct {
	// BoxArtUrl A URL to the categorys or games box art. You must replace the `{width}x{height}` placeholder with the size of image you want.
	BoxArtUrl string `json:"box_art_url"`

	// Id An ID that identifies the category or game.
	Id string `json:"id"`

	// IgdbId The ID that [IGDB](https://www.igdb.com/) uses to identify this game. If the IGDB ID is not available to Twitch, this field is set to an empty string.
	IgdbId string `json:"igdb_id"`

	// Name The categorys or games name.
	Name string `json:"name"`
}

func (datatype Game) GetBoxArtUrl() string {
	return datatype.BoxArtUrl
}
func (datatype Game) GetId() string {
	return datatype.Id
}
func (datatype Game) GetIgdbId() string {
	return datatype.IgdbId
}
func (datatype Game) GetName() string {
	return datatype.Name
}

// GameAnalytics defines model for GameAnalytics.
type GameAnalytics struct {
	// URL The URL that you use to download the report. The URL is valid for 5 minutes.
	URL string `json:"URL"`

	// DateRange The reporting windows start and end dates, in RFC3339 format.
	DateRange struct {
		// EndedAt The reporting windows end date.
		EndedAt time.Time `json:"ended_at"`

		// StartedAt The reporting windows start date.
		StartedAt time.Time `json:"started_at"`
	} `json:"date_range"`

	// GameId An ID that identifies the game that the report was generated for.
	GameId string `json:"game_id"`

	// Type The type of report.
	Type string `json:"type"`
}

func (datatype GameAnalytics) GetURL() string {
	return datatype.URL
}
func (datatype GameAnalytics) GetDateRange() struct {
	// EndedAt The reporting windows end date.
	EndedAt time.Time `json:"ended_at"`

	// StartedAt The reporting windows start date.
	StartedAt time.Time `json:"started_at"`
} {
	return datatype.DateRange
}
func (datatype GameAnalytics) GetGameId() string {
	return datatype.GameId
}
func (datatype GameAnalytics) GetType() string {
	return datatype.Type
}

// GetAdScheduleResponse defines model for GetAdScheduleResponse.
type GetAdScheduleResponse struct {
	// Data A list that contains information related to the channels ad schedule.
	Data []struct {
		// Duration The length in seconds of the scheduled upcoming ad break.
		Duration int32 `json:"duration"`

		// LastAdAt The UTC timestamp of the broadcasters last ad-break, in RFC3339 format. Empty if the channel has not run an ad or is not live.
		LastAdAt time.Time `json:"last_ad_at"`

		// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format. Empty if the channel has no ad scheduled or is not live.
		NextAdAt time.Time `json:"next_ad_at"`

		// PrerollFreeTime The amount of pre-roll free time remaining for the channel in seconds. Returns 0 if they are currently not pre-roll free.
		PrerollFreeTime int32 `json:"preroll_free_time"`

		// SnoozeCount The number of snoozes available for the broadcaster.
		SnoozeCount int32 `json:"snooze_count"`

		// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
		SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
	} `json:"data"`
}

func (datatype GetAdScheduleResponse) GetData() []struct {
	// Duration The length in seconds of the scheduled upcoming ad break.
	Duration int32 `json:"duration"`

	// LastAdAt The UTC timestamp of the broadcasters last ad-break, in RFC3339 format. Empty if the channel has not run an ad or is not live.
	LastAdAt time.Time `json:"last_ad_at"`

	// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format. Empty if the channel has no ad scheduled or is not live.
	NextAdAt time.Time `json:"next_ad_at"`

	// PrerollFreeTime The amount of pre-roll free time remaining for the channel in seconds. Returns 0 if they are currently not pre-roll free.
	PrerollFreeTime int32 `json:"preroll_free_time"`

	// SnoozeCount The number of snoozes available for the broadcaster.
	SnoozeCount int32 `json:"snooze_count"`

	// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
	SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
} {
	return datatype.Data
}

// GetAllStreamTagsResponse defines model for GetAllStreamTagsResponse.
type GetAllStreamTagsResponse struct {
	// Data The list of stream tags that the broadcaster can apply to their channel.
	Data []StreamTag `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forwards through the results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetAllStreamTagsResponse) GetData() []StreamTag {
	return datatype.Data
}
func (datatype GetAllStreamTagsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forwards through the results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forwards through the results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetAutoModSettingsResponse defines model for GetAutoModSettingsResponse.
type GetAutoModSettingsResponse struct {
	// Data The list of AutoMod settings. The list contains a single object that contains all the AutoMod settings.
	Data []AutoModSettings `json:"data"`
}

func (datatype GetAutoModSettingsResponse) GetData() []AutoModSettings {
	return datatype.Data
}

// GetBannedUsersResponse defines model for GetBannedUsersResponse.
type GetBannedUsersResponse struct {
	// Data The list of users that were banned or put in a timeout.
	Data []BannedUser `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetBannedUsersResponse) GetData() []BannedUser {
	return datatype.Data
}
func (datatype GetBannedUsersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetBitsLeaderboardResponse defines model for GetBitsLeaderboardResponse.
type GetBitsLeaderboardResponse struct {
	// Data A list of leaderboard leaders. The leaders are returned in rank order by how much theyve cheered. The array is empty if nobody has cheered bits.
	Data []BitsLeaderboard `json:"data"`

	// DateRange The reporting windows start and end dates, in RFC3339 format. The dates are calculated by using the _started\_at_ and _period_ query parameters. If you dont specify the _started\_at_ query parameter, the fields contain empty strings.
	DateRange struct {
		// EndedAt The reporting windows end date.
		EndedAt time.Time `json:"ended_at"`

		// StartedAt The reporting windows start date.
		StartedAt time.Time `json:"started_at"`
	} `json:"date_range"`

	// Total The number of ranked users in `data`. This is the value in the _count_ query parameter or the total number of entries on the leaderboard, whichever is less.
	Total int32 `json:"total"`
}

func (datatype GetBitsLeaderboardResponse) GetData() []BitsLeaderboard {
	return datatype.Data
}
func (datatype GetBitsLeaderboardResponse) GetDateRange() struct {
	// EndedAt The reporting windows end date.
	EndedAt time.Time `json:"ended_at"`

	// StartedAt The reporting windows start date.
	StartedAt time.Time `json:"started_at"`
} {
	return datatype.DateRange
}
func (datatype GetBitsLeaderboardResponse) GetTotal() int32 {
	return datatype.Total
}

// GetBlockedTermsResponse defines model for GetBlockedTermsResponse.
type GetBlockedTermsResponse struct {
	// Data The list of blocked terms. The list is in descending order of when they were created (see the `created_at` timestamp).
	Data []BlockedTerm `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetBlockedTermsResponse) GetData() []BlockedTerm {
	return datatype.Data
}
func (datatype GetBlockedTermsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetBroadcasterSubscriptionsResponse defines model for GetBroadcasterSubscriptionsResponse.
type GetBroadcasterSubscriptionsResponse struct {
	// Data The list of users that subscribe to the broadcaster. The list is empty if the broadcaster has no subscribers.
	Data []BroadcasterSubscription `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next or previous page of results. Use the cursor to set the requests _after_ or _before_ query parameter depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Points The current number of subscriber points earned by this broadcaster. Points are based on the subscription tier of each user that subscribes to this broadcaster. For example, a Tier 1 subscription is worth 1 point, Tier 2 is worth 2 points, and Tier 3 is worth 6 points. The number of points determines the number of emote slots that are unlocked for the broadcaster (see [Subscriber Emote Slots](https://help.twitch.tv/s/article/subscriber-emote-guide#emoteslots)).
	Points int32 `json:"points"`

	// Total The total number of users that subscribe to this broadcaster.
	Total int32 `json:"total"`
}

func (datatype GetBroadcasterSubscriptionsResponse) GetData() []BroadcasterSubscription {
	return datatype.Data
}
func (datatype GetBroadcasterSubscriptionsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next or previous page of results. Use the cursor to set the requests _after_ or _before_ query parameter depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next or previous page of results. Use the cursor to set the requests _after_ or _before_ query parameter depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetBroadcasterSubscriptionsResponse) GetPoints() int32 {
	return datatype.Points
}
func (datatype GetBroadcasterSubscriptionsResponse) GetTotal() int32 {
	return datatype.Total
}

// GetChannelChatBadgesResponse defines model for GetChannelChatBadgesResponse.
type GetChannelChatBadgesResponse struct {
	// Data The list of chat badges. The list is sorted in ascending order by `set_id`, and within a set, the list is sorted in ascending order by `id`.
	Data []ChatBadge `json:"data"`
}

func (datatype GetChannelChatBadgesResponse) GetData() []ChatBadge {
	return datatype.Data
}

// GetChannelEditorsResponse defines model for GetChannelEditorsResponse.
type GetChannelEditorsResponse struct {
	// Data A list of users that are editors for the specified broadcaster. The list is empty if the broadcaster doesnt have editors.
	Data []ChannelEditor `json:"data"`
}

func (datatype GetChannelEditorsResponse) GetData() []ChannelEditor {
	return datatype.Data
}

// GetChannelEmotesResponse defines model for GetChannelEmotesResponse.
type GetChannelEmotesResponse struct {
	// Data The list of emotes that the specified broadcaster created. If the broadcaster hasn't created custom emotes, the list is empty.
	Data []ChannelEmote `json:"data"`

	// Template A templated URL. Use the values from the `id`, `format`, `scale`, and `theme_mode` fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote. For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You should use this template instead of using the URLs in the `images` object.
	Template string `json:"template"`
}

func (datatype GetChannelEmotesResponse) GetData() []ChannelEmote {
	return datatype.Data
}
func (datatype GetChannelEmotesResponse) GetTemplate() string {
	return datatype.Template
}

// GetChannelFollowersResponse defines model for GetChannelFollowersResponse.
type GetChannelFollowersResponse struct {
	// Data The list of users that follow the specified broadcaster. The list is in descending order by `followed_at` (with the most recent follower first). The list is empty if nobody follows the broadcaster, the specified `user_id` isnt in the follower list, the user access token is missing the **moderator:read:followers** scope, or the user isnt the broadcaster or moderator for the channel.
	Data []struct {
		// FollowedAt The UTC timestamp when the user started following the broadcaster.
		FollowedAt time.Time `json:"followed_at"`

		// UserId An ID that uniquely identifies the user thats following the broadcaster.
		UserId string `json:"user_id"`

		// UserLogin The users login name.
		UserLogin string `json:"user_login"`

		// UserName The users display name.
		UserName string `json:"user_name"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of users that follow this broadcaster. As someone pages through the list, the number of users may change as users follow or unfollow the broadcaster.
	Total int32 `json:"total"`
}

func (datatype GetChannelFollowersResponse) GetData() []struct {
	// FollowedAt The UTC timestamp when the user started following the broadcaster.
	FollowedAt time.Time `json:"followed_at"`

	// UserId An ID that uniquely identifies the user thats following the broadcaster.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
} {
	return datatype.Data
}
func (datatype GetChannelFollowersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetChannelFollowersResponse) GetTotal() int32 {
	return datatype.Total
}

// GetChannelGuestStarSettingsResponse defines model for GetChannelGuestStarSettingsResponse.
type GetChannelGuestStarSettingsResponse struct {
	// BrowserSourceToken View only token to generate browser source URLs
	BrowserSourceToken string `json:"browser_source_token"`

	// GroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
	//
	// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
	// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
	GroupLayout GetChannelGuestStarSettingsResponseGroupLayout `json:"group_layout"`

	// IsBrowserSourceAudioEnabled Flag determining if Browser Sources subscribed to sessions on this channel should output audio
	IsBrowserSourceAudioEnabled bool `json:"is_browser_source_audio_enabled"`

	// IsModeratorSendLiveEnabled Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot.
	IsModeratorSendLiveEnabled bool `json:"is_moderator_send_live_enabled"`

	// SlotCount Number of slots the Guest Star call interface will allow the host to add to a call. Required to be between 1 and 6.
	SlotCount int32 `json:"slot_count"`
}

func (datatype GetChannelGuestStarSettingsResponse) GetBrowserSourceToken() string {
	return datatype.BrowserSourceToken
}
func (datatype GetChannelGuestStarSettingsResponse) GetGroupLayout() GetChannelGuestStarSettingsResponseGroupLayout {
	return datatype.GroupLayout
}
func (datatype GetChannelGuestStarSettingsResponse) GetIsBrowserSourceAudioEnabled() bool {
	return datatype.IsBrowserSourceAudioEnabled
}
func (datatype GetChannelGuestStarSettingsResponse) GetIsModeratorSendLiveEnabled() bool {
	return datatype.IsModeratorSendLiveEnabled
}
func (datatype GetChannelGuestStarSettingsResponse) GetSlotCount() int32 {
	return datatype.SlotCount
}

// GetChannelGuestStarSettingsResponseGroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
//
// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
type GetChannelGuestStarSettingsResponseGroupLayout string

// GetChannelInformationResponse defines model for GetChannelInformationResponse.
type GetChannelInformationResponse struct {
	// Data A list that contains information about the specified channels. The list is empty if the specified channels werent found.
	Data []ChannelInformation `json:"data"`
}

func (datatype GetChannelInformationResponse) GetData() []ChannelInformation {
	return datatype.Data
}

// GetChannelStreamScheduleResponse defines model for GetChannelStreamScheduleResponse.
type GetChannelStreamScheduleResponse struct {
	// Data The broadcasters streaming schedule.
	Data struct {
		// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// Pagination The information used to page through a list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
		Pagination *struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
			Cursor *string `json:"cursor,omitempty"`
		} `json:"pagination,omitempty"`

		// Segments The list of broadcasts in the broadcasters streaming schedule.
		Segments []ChannelStreamScheduleSegment `json:"segments"`

		// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
		Vacation struct {
			// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
			EndTime time.Time `json:"end_time"`

			// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
			StartTime time.Time `json:"start_time"`
		} `json:"vacation"`
	} `json:"data"`
}

func (datatype GetChannelStreamScheduleResponse) GetData() struct {
	// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Pagination The information used to page through a list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Segments The list of broadcasts in the broadcasters streaming schedule.
	Segments []ChannelStreamScheduleSegment `json:"segments"`

	// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	Vacation struct {
		// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
		EndTime time.Time `json:"end_time"`

		// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
		StartTime time.Time `json:"start_time"`
	} `json:"vacation"`
} {
	return datatype.Data
}

// GetChannelTeamsResponse defines model for GetChannelTeamsResponse.
type GetChannelTeamsResponse struct {
	// Data The list of teams that the broadcaster is a member of. Returns an empty array if the broadcaster is not a member of a team.
	Data []ChannelTeam `json:"data"`
}

func (datatype GetChannelTeamsResponse) GetData() []ChannelTeam {
	return datatype.Data
}

// GetCharityCampaignDonationsResponse defines model for GetCharityCampaignDonationsResponse.
type GetCharityCampaignDonationsResponse struct {
	// Data A list that contains the donations that users have made to the broadcasters charity campaign. The list is empty if the broadcaster is not currently running a charity campaign; the donation information is not available after the campaign ends.
	Data []CharityCampaignDonation `json:"data"`

	// Pagination An object that contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetCharityCampaignDonationsResponse) GetData() []CharityCampaignDonation {
	return datatype.Data
}
func (datatype GetCharityCampaignDonationsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetCharityCampaignResponse defines model for GetCharityCampaignResponse.
type GetCharityCampaignResponse struct {
	// Data A list that contains the charity campaign that the broadcaster is currently running. The list is empty if the broadcaster is not running a charity campaign; the campaign information is not available after the campaign ends.
	Data []CharityCampaign `json:"data"`
}

func (datatype GetCharityCampaignResponse) GetData() []CharityCampaign {
	return datatype.Data
}

// GetChatSettingsResponse defines model for GetChatSettingsResponse.
type GetChatSettingsResponse struct {
	// Data The list of chat settings. The list contains a single object with all the settings.
	Data []ChatSettings `json:"data"`
}

func (datatype GetChatSettingsResponse) GetData() []ChatSettings {
	return datatype.Data
}

// GetChattersResponse defines model for GetChattersResponse.
type GetChattersResponse struct {
	// Data The list of users that are connected to the broadcasters chat room. The list is empty if no users are connected to the chat room.
	Data []Chatter `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of users that are connected to the broadcasters chat room. As you page through the list, the number of users may change as users join and leave the chat room.
	Total int32 `json:"total"`
}

func (datatype GetChattersResponse) GetData() []Chatter {
	return datatype.Data
}
func (datatype GetChattersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetChattersResponse) GetTotal() int32 {
	return datatype.Total
}

// GetCheermotesResponse defines model for GetCheermotesResponse.
type GetCheermotesResponse struct {
	// Data The list of Cheermotes. The list is in ascending order by the `order` fields value.
	Data []Cheermote `json:"data"`
}

func (datatype GetCheermotesResponse) GetData() []Cheermote {
	return datatype.Data
}

// GetClipsResponse defines model for GetClipsResponse.
type GetClipsResponse struct {
	// Data The list of video clips. For clips returned by _game\_id_ or _broadcaster\_id_, the list is in descending order by view count. For lists returned by _id_, the list is in the same order as the input IDs.
	Data []Clip `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetClipsResponse) GetData() []Clip {
	return datatype.Data
}
func (datatype GetClipsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetConduitShardsResponse defines model for GetConduitShardsResponse.
type GetConduitShardsResponse struct {
	// Data List of information about a conduit's shards.
	Data []struct {
		// Id Shard ID.
		Id string `json:"id"`

		// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
		//
		// * enabled  The shard is enabled.
		// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
		// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
		// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
		// * websocket\_disconnected  The client closed the connection.
		// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
		// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
		// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
		// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
		// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
		// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
		Status GetConduitShardsResponseDataStatus `json:"status"`

		// Transport The transport details used to send the notifications.
		Transport struct {
			// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
			Callback *string `json:"callback,omitempty"`

			// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
			ConnectedAt *time.Time `json:"connected_at,omitempty"`

			// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
			DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

			// Method The transport method. Possible values are:
			//
			// * webhook
			// * websocket
			Method GetConduitShardsResponseDataTransportMethod `json:"method"`

			// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
			SessionId *string `json:"session_id,omitempty"`
		} `json:"transport"`
	} `json:"data"`

	// Pagination Contains information used to page through a list of results. The object is empty if there are no more pages left to page through.
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetConduitShardsResponse) GetData() []struct {
	// Id Shard ID.
	Id string `json:"id"`

	// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
	//
	// * enabled  The shard is enabled.
	// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	Status GetConduitShardsResponseDataStatus `json:"status"`

	// Transport The transport details used to send the notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
		Callback *string `json:"callback,omitempty"`

		// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
		ConnectedAt *time.Time `json:"connected_at,omitempty"`

		// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
		DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method GetConduitShardsResponseDataTransportMethod `json:"method"`

		// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`
} {
	return datatype.Data
}
func (datatype GetConduitShardsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetConduitShardsResponseDataStatus The shard status. The subscriber receives events only for enabled shards. Possible values are:
//
// * enabled  The shard is enabled.
// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
// * websocket\_disconnected  The client closed the connection.
// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
type GetConduitShardsResponseDataStatus string

// GetConduitShardsResponseDataTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type GetConduitShardsResponseDataTransportMethod string

// GetConduitsResponse defines model for GetConduitsResponse.
type GetConduitsResponse struct {
	// Data List of information about the clients conduits.
	Data []struct {
		// Id Conduit ID.
		Id string `json:"id"`

		// ShardCount Number of shards associated with this conduit.
		ShardCount int32 `json:"shard_count"`
	} `json:"data"`
}

func (datatype GetConduitsResponse) GetData() []struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount Number of shards associated with this conduit.
	ShardCount int32 `json:"shard_count"`
} {
	return datatype.Data
}

// GetContentClassificationLabelsResponse defines model for GetContentClassificationLabelsResponse.
type GetContentClassificationLabelsResponse struct {
	// Data A list that contains information about the available content classification labels.
	Data []ContentClassificationLabel `json:"data"`
}

func (datatype GetContentClassificationLabelsResponse) GetData() []ContentClassificationLabel {
	return datatype.Data
}

// GetCreatorGoalsResponse defines model for GetCreatorGoalsResponse.
type GetCreatorGoalsResponse struct {
	// Data The list of goals. The list is empty if the broadcaster hasnt created goals.
	Data []CreatorGoal `json:"data"`
}

func (datatype GetCreatorGoalsResponse) GetData() []CreatorGoal {
	return datatype.Data
}

// GetCustomRewardRedemptionResponse defines model for GetCustomRewardRedemptionResponse.
type GetCustomRewardRedemptionResponse struct {
	// Data The list of redemptions for the specified reward. The list is empty if there are no redemptions that match the redemption criteria.
	Data []CustomRewardRedemption `json:"data"`
}

func (datatype GetCustomRewardRedemptionResponse) GetData() []CustomRewardRedemption {
	return datatype.Data
}

// GetCustomRewardResponse defines model for GetCustomRewardResponse.
type GetCustomRewardResponse struct {
	// Data A list of custom rewards. The list is in ascending order by `id`. If the broadcaster hasnt created custom rewards, the list is empty.
	Data []CustomReward `json:"data"`
}

func (datatype GetCustomRewardResponse) GetData() []CustomReward {
	return datatype.Data
}

// GetDropsEntitlementsResponse defines model for GetDropsEntitlementsResponse.
type GetDropsEntitlementsResponse struct {
	// Data The list of entitlements.
	Data []DropsEntitlement `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forward through the results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetDropsEntitlementsResponse) GetData() []DropsEntitlement {
	return datatype.Data
}
func (datatype GetDropsEntitlementsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forward through the results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value to page forward through the results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetEmoteSetsResponse defines model for GetEmoteSetsResponse.
type GetEmoteSetsResponse struct {
	// Data The list of emotes found in the specified emote sets. The list is empty if none of the IDs were found. The list is in the same order as the set IDs specified in the request. Each set contains one or more emoticons.
	Data []Emote `json:"data"`

	// Template A templated URL. Use the values from the `id`, `format`, `scale`, and `theme_mode` fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote. For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You should use this template instead of using the URLs in the `images` object.
	Template string `json:"template"`
}

func (datatype GetEmoteSetsResponse) GetData() []Emote {
	return datatype.Data
}
func (datatype GetEmoteSetsResponse) GetTemplate() string {
	return datatype.Template
}

// GetEventSubSubscriptionsResponse defines model for GetEventSubSubscriptionsResponse.
type GetEventSubSubscriptionsResponse struct {
	// Data The list of subscriptions. The list is ordered by the oldest subscription first. The list is empty if the client hasn't created subscriptions or there are no subscriptions that match the specified filter criteria.
	Data []EventSubSubscription `json:"data"`

	// MaxTotalCost The maximum total cost that you're allowed to incur for all subscriptions that you create.
	MaxTotalCost int32 `json:"max_total_cost"`

	// Pagination An object that contains the cursor used to get the next page of subscriptions. The object is empty if there are no more pages to get. The number of subscriptions returned per page is undertermined.
	Pagination *struct {
		// Cursor The cursor value that you set the _after_ query parameter to.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of subscriptions that you've created.
	Total int32 `json:"total"`

	// TotalCost The sum of all of your subscription costs. [Learn More](https://dev.twitch.tv/docs/eventsub/manage-subscriptions/#subscription-limits)
	TotalCost int32 `json:"total_cost"`
}

func (datatype GetEventSubSubscriptionsResponse) GetData() []EventSubSubscription {
	return datatype.Data
}
func (datatype GetEventSubSubscriptionsResponse) GetMaxTotalCost() int32 {
	return datatype.MaxTotalCost
}
func (datatype GetEventSubSubscriptionsResponse) GetPagination() struct {
	// Cursor The cursor value that you set the _after_ query parameter to.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor value that you set the _after_ query parameter to.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetEventSubSubscriptionsResponse) GetTotal() int32 {
	return datatype.Total
}
func (datatype GetEventSubSubscriptionsResponse) GetTotalCost() int32 {
	return datatype.TotalCost
}

// GetExtensionAnalyticsResponse defines model for GetExtensionAnalyticsResponse.
type GetExtensionAnalyticsResponse struct {
	// Data A list of reports. The reports are returned in no particular order; however, the data within each report is in ascending order by date (newest first). The report contains one row of data per day of the reporting window; the report contains rows for only those days that the extension was used. The array is empty if there are no reports.
	Data []ExtensionAnalytics `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetExtensionAnalyticsResponse) GetData() []ExtensionAnalytics {
	return datatype.Data
}
func (datatype GetExtensionAnalyticsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetExtensionBitsProductsResponse defines model for GetExtensionBitsProductsResponse.
type GetExtensionBitsProductsResponse struct {
	// Data A list of Bits products that the extension created. The list is in ascending SKU order. The list is empty if the extension hasnt created any products or theyre all expired or disabled.
	Data []ExtensionBitsProduct `json:"data"`
}

func (datatype GetExtensionBitsProductsResponse) GetData() []ExtensionBitsProduct {
	return datatype.Data
}

// GetExtensionConfigurationSegmentResponse defines model for GetExtensionConfigurationSegmentResponse.
type GetExtensionConfigurationSegmentResponse struct {
	// Data The list of requested configuration segments. The list is returned in the same order that you specified the list of segments in the request.
	Data []ExtensionConfigurationSegment `json:"data"`
}

func (datatype GetExtensionConfigurationSegmentResponse) GetData() []ExtensionConfigurationSegment {
	return datatype.Data
}

// GetExtensionLiveChannelsResponse defines model for GetExtensionLiveChannelsResponse.
type GetExtensionLiveChannelsResponse struct {
	// Data The list of broadcasters that are streaming live and that have installed or activated the extension.
	Data []ExtensionLiveChannel `json:"data"`

	// Pagination This field contains the cursor used to page through the results. The field is empty if there are no more pages left to page through. Note that this field is a string compared to other endpoints that use a **Pagination** object. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *string `json:"pagination,omitempty"`
}

func (datatype GetExtensionLiveChannelsResponse) GetData() []ExtensionLiveChannel {
	return datatype.Data
}
func (datatype GetExtensionLiveChannelsResponse) GetPagination() string {
	if datatype.Pagination == nil {
		var empty string
		return empty
	}
	return *datatype.Pagination
}

// GetExtensionSecretsResponse defines model for GetExtensionSecretsResponse.
type GetExtensionSecretsResponse struct {
	// Data The list of shared secrets that the extension created.
	Data []ExtensionSecret `json:"data"`
}

func (datatype GetExtensionSecretsResponse) GetData() []ExtensionSecret {
	return datatype.Data
}

// GetExtensionTransactionsResponse defines model for GetExtensionTransactionsResponse.
type GetExtensionTransactionsResponse struct {
	// Data The list of transactions.
	Data []ExtensionTransaction `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetExtensionTransactionsResponse) GetData() []ExtensionTransaction {
	return datatype.Data
}
func (datatype GetExtensionTransactionsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetExtensionsResponse defines model for GetExtensionsResponse.
type GetExtensionsResponse struct {
	// Data A list that contains the specified extension.
	Data []Extension `json:"data"`
}

func (datatype GetExtensionsResponse) GetData() []Extension {
	return datatype.Data
}

// GetFollowedChannelsResponse defines model for GetFollowedChannelsResponse.
type GetFollowedChannelsResponse struct {
	// Data The list of broadcasters that the user follows. The list is in descending order by `followed_at` (with the most recently followed broadcaster first). The list is empty if the user doesnt follow anyone.
	Data []struct {
		// BroadcasterId An ID that uniquely identifies the broadcaster that this user is following.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// FollowedAt The UTC timestamp when the user started following the broadcaster.
		FollowedAt time.Time `json:"followed_at"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Total The total number of broadcasters that the user follows. As someone pages through the list, the number may change as the user follows or unfollows broadcasters.
	Total int32 `json:"total"`
}

func (datatype GetFollowedChannelsResponse) GetData() []struct {
	// BroadcasterId An ID that uniquely identifies the broadcaster that this user is following.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// FollowedAt The UTC timestamp when the user started following the broadcaster.
	FollowedAt time.Time `json:"followed_at"`
} {
	return datatype.Data
}
func (datatype GetFollowedChannelsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetFollowedChannelsResponse) GetTotal() int32 {
	return datatype.Total
}

// GetFollowedStreamsResponse defines model for GetFollowedStreamsResponse.
type GetFollowedStreamsResponse struct {
	// Data The list of live streams of broadcasters that the specified user follows. The list is in descending order by the number of viewers watching the stream. Because viewers come and go during a stream, its possible to find duplicate or missing streams in the list as you page through the results. The list is empty if none of the followed broadcasters are streaming live.
	Data []Stream `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetFollowedStreamsResponse) GetData() []Stream {
	return datatype.Data
}
func (datatype GetFollowedStreamsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ query parameter to this value.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetGameAnalyticsResponse defines model for GetGameAnalyticsResponse.
type GetGameAnalyticsResponse struct {
	// Data A list of reports. The reports are returned in no particular order; however, the data within each report is in ascending order by date (newest first). The report contains one row of data per day of the reporting window; the report contains rows for only those days that the game was used. A report is available only if the game was broadcast for at least 5 hours over the reporting period. The array is empty if there are no reports.
	Data []GameAnalytics `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetGameAnalyticsResponse) GetData() []GameAnalytics {
	return datatype.Data
}
func (datatype GetGameAnalyticsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetGamesResponse defines model for GetGamesResponse.
type GetGamesResponse struct {
	// Data The list of categories and games. The list is empty if the specified categories and games werent found.
	Data []Game `json:"data"`
}

func (datatype GetGamesResponse) GetData() []Game {
	return datatype.Data
}

// GetGlobalChatBadgesResponse defines model for GetGlobalChatBadgesResponse.
type GetGlobalChatBadgesResponse struct {
	// Data The list of chat badges. The list is sorted in ascending order by `set_id`, and within a set, the list is sorted in ascending order by `id`.
	Data []ChatBadge `json:"data"`
}

func (datatype GetGlobalChatBadgesResponse) GetData() []ChatBadge {
	return datatype.Data
}

// GetGlobalEmotesResponse defines model for GetGlobalEmotesResponse.
type GetGlobalEmotesResponse struct {
	// Data The list of global emotes.
	Data []GlobalEmote `json:"data"`

	// Template A templated URL. Use the values from the `id`, `format`, `scale`, and `theme_mode` fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote. For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL format](https://dev.twitch.tv/docs/irc/emotes#cdn-template). You should use this template instead of using the URLs in the `images` object.
	Template string `json:"template"`
}

func (datatype GetGlobalEmotesResponse) GetData() []GlobalEmote {
	return datatype.Data
}
func (datatype GetGlobalEmotesResponse) GetTemplate() string {
	return datatype.Template
}

// GetGuestStarInvitesResponse defines model for GetGuestStarInvitesResponse.
type GetGuestStarInvitesResponse struct {
	// Data A list of invite objects describing the invited user as well as their ready status.
	Data []GuestStarInvite `json:"data"`
}

func (datatype GetGuestStarInvitesResponse) GetData() []GuestStarInvite {
	return datatype.Data
}

// GetGuestStarSessionResponse defines model for GetGuestStarSessionResponse.
type GetGuestStarSessionResponse struct {
	// Data Summary of the session details
	Data []GuestStarSession `json:"data"`
}

func (datatype GetGuestStarSessionResponse) GetData() []GuestStarSession {
	return datatype.Data
}

// GetHypeTrainEventsResponse defines model for GetHypeTrainEventsResponse.
type GetHypeTrainEventsResponse struct {
	// Data The list of Hype Train events. The list is empty if the broadcaster hasnt run a Hype Train within the last 5 days.
	Data []HypeTrainEvent `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetHypeTrainEventsResponse) GetData() []HypeTrainEvent {
	return datatype.Data
}
func (datatype GetHypeTrainEventsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetModeratedChannelsResponse defines model for GetModeratedChannelsResponse.
type GetModeratedChannelsResponse struct {
	// Data The list of channels that the user has moderator privileges in.
	Data []struct {
		// BroadcasterId An ID that uniquely identifies the channel this user can moderate.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The channels login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The channels display name.
		BroadcasterName string `json:"broadcaster_name"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetModeratedChannelsResponse) GetData() []struct {
	// BroadcasterId An ID that uniquely identifies the channel this user can moderate.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The channels login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The channels display name.
	BroadcasterName string `json:"broadcaster_name"`
} {
	return datatype.Data
}
func (datatype GetModeratedChannelsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetModeratorsResponse defines model for GetModeratorsResponse.
type GetModeratorsResponse struct {
	// Data The list of moderators.
	Data []UserModerator `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetModeratorsResponse) GetData() []UserModerator {
	return datatype.Data
}
func (datatype GetModeratorsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetPollsResponse defines model for GetPollsResponse.
type GetPollsResponse struct {
	// Data A list of polls. The polls are returned in descending order of start time unless you specify IDs in the request, in which case they're returned in the same order as you passed them in the request. The list is empty if the broadcaster hasn't created polls.
	Data []Poll `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetPollsResponse) GetData() []Poll {
	return datatype.Data
}
func (datatype GetPollsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetPredictionsResponse defines model for GetPredictionsResponse.
type GetPredictionsResponse struct {
	// Data The broadcasters list of Channel Points Predictions. The list is sorted in descending ordered by when the prediction began (the most recent prediction is first). The list is empty if the broadcaster hasnt created predictions.
	Data []Prediction `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetPredictionsResponse) GetData() []Prediction {
	return datatype.Data
}
func (datatype GetPredictionsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetReleasedExtensionsResponse defines model for GetReleasedExtensionsResponse.
type GetReleasedExtensionsResponse struct {
	// Data A list that contains the specified extension.
	Data []Extension `json:"data"`
}

func (datatype GetReleasedExtensionsResponse) GetData() []Extension {
	return datatype.Data
}

// GetSharedChatSessionResponse defines model for GetSharedChatSessionResponse.
type GetSharedChatSessionResponse struct {
	Data []struct {
		// CreatedAt The UTC date and time (in RFC3339 format) for when the session was created.
		CreatedAt time.Time `json:"created_at"`

		// HostBroadcasterId The User ID of the host channel.
		HostBroadcasterId string `json:"host_broadcaster_id"`

		// Participants The list of participants in the session.
		Participants []struct {
			// BroadcasterId The User ID of the participant channel.
			BroadcasterId string `json:"broadcaster_id"`
		} `json:"participants"`

		// SessionId The unique identifier for the shared chat session.
		SessionId string `json:"session_id"`

		// UpdatedAt The UTC date and time (in RFC3339 format) for when the session was last updated.
		UpdatedAt time.Time `json:"updated_at"`
	} `json:"data"`
}

func (datatype GetSharedChatSessionResponse) GetData() []struct {
	// CreatedAt The UTC date and time (in RFC3339 format) for when the session was created.
	CreatedAt time.Time `json:"created_at"`

	// HostBroadcasterId The User ID of the host channel.
	HostBroadcasterId string `json:"host_broadcaster_id"`

	// Participants The list of participants in the session.
	Participants []struct {
		// BroadcasterId The User ID of the participant channel.
		BroadcasterId string `json:"broadcaster_id"`
	} `json:"participants"`

	// SessionId The unique identifier for the shared chat session.
	SessionId string `json:"session_id"`

	// UpdatedAt The UTC date and time (in RFC3339 format) for when the session was last updated.
	UpdatedAt time.Time `json:"updated_at"`
} {
	return datatype.Data
}

// GetShieldModeStatusResponse defines model for GetShieldModeStatusResponse.
type GetShieldModeStatusResponse struct {
	// Data A list that contains a single object with the broadcasters Shield Mode status.
	Data []struct {
		// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if the broadcaster activated Shield Mode; otherwise, **false**.
		IsActive bool `json:"is_active"`

		// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated. Is an empty string if Shield Mode hasnt been previously activated.
		LastActivatedAt time.Time `json:"last_activated_at"`

		// ModeratorId An ID that identifies the moderator that last activated Shield Mode. Is an empty string if Shield Mode hasnt been previously activated.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderators login name. Is an empty string if Shield Mode hasnt been previously activated.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderators display name. Is an empty string if Shield Mode hasnt been previously activated.
		ModeratorName string `json:"moderator_name"`
	} `json:"data"`
}

func (datatype GetShieldModeStatusResponse) GetData() []struct {
	// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if the broadcaster activated Shield Mode; otherwise, **false**.
	IsActive bool `json:"is_active"`

	// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated. Is an empty string if Shield Mode hasnt been previously activated.
	LastActivatedAt time.Time `json:"last_activated_at"`

	// ModeratorId An ID that identifies the moderator that last activated Shield Mode. Is an empty string if Shield Mode hasnt been previously activated.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name. Is an empty string if Shield Mode hasnt been previously activated.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name. Is an empty string if Shield Mode hasnt been previously activated.
	ModeratorName string `json:"moderator_name"`
} {
	return datatype.Data
}

// GetStreamKeyResponse defines model for GetStreamKeyResponse.
type GetStreamKeyResponse struct {
	// Data A list that contains the channels stream key.
	Data []struct {
		// StreamKey The channels stream key.
		StreamKey string `json:"stream_key"`
	} `json:"data"`
}

func (datatype GetStreamKeyResponse) GetData() []struct {
	// StreamKey The channels stream key.
	StreamKey string `json:"stream_key"`
} {
	return datatype.Data
}

// GetStreamMarkersResponse defines model for GetStreamMarkersResponse.
type GetStreamMarkersResponse struct {
	// Data The list of markers grouped by the user that created the marks.
	Data []StreamMarkers `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetStreamMarkersResponse) GetData() []StreamMarkers {
	return datatype.Data
}
func (datatype GetStreamMarkersResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetStreamTagsResponse defines model for GetStreamTagsResponse.
type GetStreamTagsResponse struct {
	// Data The list of stream tags. The list is empty if the broadcaster or Twitch hasnt added tags to the broadcasters channel.
	Data []StreamTag `json:"data"`
}

func (datatype GetStreamTagsResponse) GetData() []StreamTag {
	return datatype.Data
}

// GetStreamsResponse defines model for GetStreamsResponse.
type GetStreamsResponse struct {
	// Data The list of streams.
	Data []Stream `json:"data"`

	// Pagination The information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetStreamsResponse) GetData() []Stream {
	return datatype.Data
}
func (datatype GetStreamsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Set the requests _after_ or _before_ query parameter to this value depending on whether youre paging forwards or backwards.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetTeamsResponse defines model for GetTeamsResponse.
type GetTeamsResponse struct {
	// Data A list that contains the single team that you requested.
	Data []Team `json:"data"`
}

func (datatype GetTeamsResponse) GetData() []Team {
	return datatype.Data
}

// GetTopGamesResponse defines model for GetTopGamesResponse.
type GetTopGamesResponse struct {
	// Data The list of broadcasts. The broadcasts are sorted by the number of viewers, with the most popular first.
	Data []Game `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ or _before_ query parameter to get the next or previous page of results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetTopGamesResponse) GetData() []Game {
	return datatype.Data
}
func (datatype GetTopGamesResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ or _before_ query parameter to get the next or previous page of results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ or _before_ query parameter to get the next or previous page of results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetUnbanRequestsResponse defines model for GetUnbanRequestsResponse.
type GetUnbanRequestsResponse struct {
	// Data A list that contains information about the channel's unban requests.
	Data []struct {
		// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcaster's login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcaster's display name.
		BroadcasterName string `json:"broadcaster_name"`

		// CreatedAt Timestamp of when the unban request was created.
		CreatedAt time.Time `json:"created_at"`

		// Id Unban request ID.
		Id string `json:"id"`

		// ModeratorId User ID of moderator who approved/denied the request.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderator's login name.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderator's display name.
		ModeratorName string `json:"moderator_name"`

		// ResolutionText Text input by the resolver (moderator) of the unban. request
		ResolutionText string `json:"resolution_text"`

		// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
		ResolvedAt time.Time `json:"resolved_at"`

		// Status Status of the request. One of:
		//
		// * pending
		// * approved
		// * denied
		// * acknowledged
		// * canceled
		Status string `json:"status"`

		// Text Text of the request from the requesting user.
		Text string `json:"text"`

		// UserId User ID of the requestor who is asking for an unban.
		UserId string `json:"user_id"`

		// UserLogin The user's login name.
		UserLogin string `json:"user_login"`

		// UserName The user's display name.
		UserName string `json:"user_name"`
	} `json:"data"`

	// Pagination Contains information used to page through a list of results. The object is empty if there are no more pages left to page through.
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetUnbanRequestsResponse) GetData() []struct {
	// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcaster's login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcaster's display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt Timestamp of when the unban request was created.
	CreatedAt time.Time `json:"created_at"`

	// Id Unban request ID.
	Id string `json:"id"`

	// ModeratorId User ID of moderator who approved/denied the request.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderator's login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderator's display name.
	ModeratorName string `json:"moderator_name"`

	// ResolutionText Text input by the resolver (moderator) of the unban. request
	ResolutionText string `json:"resolution_text"`

	// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
	ResolvedAt time.Time `json:"resolved_at"`

	// Status Status of the request. One of:
	//
	// * pending
	// * approved
	// * denied
	// * acknowledged
	// * canceled
	Status string `json:"status"`

	// Text Text of the request from the requesting user.
	Text string `json:"text"`

	// UserId User ID of the requestor who is asking for an unban.
	UserId string `json:"user_id"`

	// UserLogin The user's login name.
	UserLogin string `json:"user_login"`

	// UserName The user's display name.
	UserName string `json:"user_name"`
} {
	return datatype.Data
}
func (datatype GetUnbanRequestsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetUserActiveExtensionsResponse defines model for GetUserActiveExtensionsResponse.
type GetUserActiveExtensionsResponse struct {
	// Data The active extensions that the broadcaster has installed.
	Data *struct {
		// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
		Component *map[string]UserExtensionComponent `json:"component,omitempty"`

		// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
		Overlay *map[string]UserExtensionOverlay `json:"overlay,omitempty"`

		// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
		Panel *map[string]UserExtensionPanel `json:"panel,omitempty"`
	} `json:"data,omitempty"`
}

func (datatype GetUserActiveExtensionsResponse) GetData() struct {
	// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
	Component *map[string]UserExtensionComponent `json:"component,omitempty"`

	// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
	Overlay *map[string]UserExtensionOverlay `json:"overlay,omitempty"`

	// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
	Panel *map[string]UserExtensionPanel `json:"panel,omitempty"`
} {
	if datatype.Data == nil {
		var empty struct {
			// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
			Component *map[string]UserExtensionComponent `json:"component,omitempty"`

			// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
			Overlay *map[string]UserExtensionOverlay `json:"overlay,omitempty"`

			// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
			Panel *map[string]UserExtensionPanel `json:"panel,omitempty"`
		}
		return empty
	}
	return *datatype.Data
}

// GetUserBlockListResponse defines model for GetUserBlockListResponse.
type GetUserBlockListResponse struct {
	// Data The list of blocked users. The list is in descending order by when the user was blocked.
	Data []UserBlockList `json:"data"`
}

func (datatype GetUserBlockListResponse) GetData() []UserBlockList {
	return datatype.Data
}

// GetUserChatColorResponse defines model for GetUserChatColorResponse.
type GetUserChatColorResponse struct {
	// Data The list of users and the color code they use for their name.
	Data []UserChatColor `json:"data"`
}

func (datatype GetUserChatColorResponse) GetData() []UserChatColor {
	return datatype.Data
}

// GetUserEmotesResponse defines model for GetUserEmotesResponse.
type GetUserEmotesResponse struct {
	Data []struct {
		// EmoteSetId An ID that identifies the emote set that the emote belongs to.
		EmoteSetId string `json:"emote_set_id"`

		// EmoteType The type of emote. The possible values are:
		//
		// * **none**  No emote type was assigned to this emote.
		// * **bitstier**  A Bits tier emote.
		// * **follower**  A follower emote.
		// * **subscriptions**  A subscriber emote.
		// * **channelpoints**  An emote granted by using channel points.
		// * **rewards**  An emote granted to the user through a special event.
		// * **hypetrain**  An emote granted for participation in a Hype Train.
		// * **prime**  An emote granted for linking an Amazon Prime account.
		// * **turbo**  An emote granted for having Twitch Turbo.
		// * **smilies**  Emoticons supported by Twitch.
		// * **globals**  An emote accessible by everyone.
		// * **owl2019**  Emotes related to Overwatch League 2019.
		// * **twofactor**  Emotes granted by enabling two-factor authentication on an account.
		// * **limitedtime**  Emotes that were granted for only a limited time.
		EmoteType GetUserEmotesResponseDataEmoteType `json:"emote_type"`

		// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated.
		//
		// * **animated**  An animated GIF is available for this emote.
		// * **static**  A static PNG file is available for this emote.
		Format []string `json:"format"`

		// Id An ID that uniquely identifies this emote.
		Id string `json:"id"`

		// Name The User ID of broadcaster whose channel is receiving the unban request.
		Name string `json:"name"`

		// OwnerId The ID of the broadcaster who owns the emote.
		OwnerId string `json:"owner_id"`

		// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\.
		//
		// * **1.0**  A small version (28px x 28px) is available.
		// * **2.0**  A medium version (56px x 56px) is available.
		// * **3.0**  A large version (112px x 112px) is available.
		Scale []string `json:"scale"`

		// ThemeMode The background themes that the emote is available in.
		//
		// * **dark**
		// * **light**
		ThemeMode []string `json:"theme_mode"`
	} `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through.
	//
	//  For more information about pagination support, see [Twitch API Guide - Pagination](https://dev.twitch.tv/docs/api/guide#pagination).
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`

	// Template A templated URL. Uses the values from the _id_, _format_, _scale_, and _theme\_mode_ fields to replace the like-named placeholder strings in the templated URL to create a CDN (content delivery network) URL that you use to fetch the emote.
	//
	//  For information about what the template looks like and how to use it to fetch emotes, see [Emote CDN URL](https://dev.twitch.tv/docs/irc/emotes#cdn-template) format.
	Template string `json:"template"`
}

func (datatype GetUserEmotesResponse) GetData() []struct {
	// EmoteSetId An ID that identifies the emote set that the emote belongs to.
	EmoteSetId string `json:"emote_set_id"`

	// EmoteType The type of emote. The possible values are:
	//
	// * **none**  No emote type was assigned to this emote.
	// * **bitstier**  A Bits tier emote.
	// * **follower**  A follower emote.
	// * **subscriptions**  A subscriber emote.
	// * **channelpoints**  An emote granted by using channel points.
	// * **rewards**  An emote granted to the user through a special event.
	// * **hypetrain**  An emote granted for participation in a Hype Train.
	// * **prime**  An emote granted for linking an Amazon Prime account.
	// * **turbo**  An emote granted for having Twitch Turbo.
	// * **smilies**  Emoticons supported by Twitch.
	// * **globals**  An emote accessible by everyone.
	// * **owl2019**  Emotes related to Overwatch League 2019.
	// * **twofactor**  Emotes granted by enabling two-factor authentication on an account.
	// * **limitedtime**  Emotes that were granted for only a limited time.
	EmoteType GetUserEmotesResponseDataEmoteType `json:"emote_type"`

	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only static. But if the emote is available as a static PNG and an animated GIF, the array contains static and animated.
	//
	// * **animated**  An animated GIF is available for this emote.
	// * **static**  A static PNG file is available for this emote.
	Format []string `json:"format"`

	// Id An ID that uniquely identifies this emote.
	Id string `json:"id"`

	// Name The User ID of broadcaster whose channel is receiving the unban request.
	Name string `json:"name"`

	// OwnerId The ID of the broadcaster who owns the emote.
	OwnerId string `json:"owner_id"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\.
	//
	// * **1.0**  A small version (28px x 28px) is available.
	// * **2.0**  A medium version (56px x 56px) is available.
	// * **3.0**  A large version (112px x 112px) is available.
	Scale []string `json:"scale"`

	// ThemeMode The background themes that the emote is available in.
	//
	// * **dark**
	// * **light**
	ThemeMode []string `json:"theme_mode"`
} {
	return datatype.Data
}
func (datatype GetUserEmotesResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests after query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}
func (datatype GetUserEmotesResponse) GetTemplate() string {
	return datatype.Template
}

// GetUserEmotesResponseDataEmoteType The type of emote. The possible values are:
//
// * **none**  No emote type was assigned to this emote.
// * **bitstier**  A Bits tier emote.
// * **follower**  A follower emote.
// * **subscriptions**  A subscriber emote.
// * **channelpoints**  An emote granted by using channel points.
// * **rewards**  An emote granted to the user through a special event.
// * **hypetrain**  An emote granted for participation in a Hype Train.
// * **prime**  An emote granted for linking an Amazon Prime account.
// * **turbo**  An emote granted for having Twitch Turbo.
// * **smilies**  Emoticons supported by Twitch.
// * **globals**  An emote accessible by everyone.
// * **owl2019**  Emotes related to Overwatch League 2019.
// * **twofactor**  Emotes granted by enabling two-factor authentication on an account.
// * **limitedtime**  Emotes that were granted for only a limited time.
type GetUserEmotesResponseDataEmoteType string

// GetUserExtensionsResponse defines model for GetUserExtensionsResponse.
type GetUserExtensionsResponse struct {
	// Data The list of extensions that the user has installed.
	Data []UserExtension `json:"data"`
}

func (datatype GetUserExtensionsResponse) GetData() []UserExtension {
	return datatype.Data
}

// GetUsersResponse defines model for GetUsersResponse.
type GetUsersResponse struct {
	// Data The list of users.
	Data []User `json:"data"`
}

func (datatype GetUsersResponse) GetData() []User {
	return datatype.Data
}

// GetVIPsResponse defines model for GetVIPsResponse.
type GetVIPsResponse struct {
	// Data The list of VIPs. The list is empty if the broadcaster doesnt have VIP users.
	Data []UserVip `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetVIPsResponse) GetData() []UserVip {
	return datatype.Data
}
func (datatype GetVIPsResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the requests _after_ query parameter.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GetVideosResponse defines model for GetVideosResponse.
type GetVideosResponse struct {
	// Data The list of published videos that match the filter criteria.
	Data []Video `json:"data"`

	// Pagination Contains the information used to page through the list of results. The object is empty if there are no more pages left to page through. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Pagination *struct {
		// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ or _before_ query parameter depending on whether you're paging forwards or backwards through the results.
		Cursor *string `json:"cursor,omitempty"`
	} `json:"pagination,omitempty"`
}

func (datatype GetVideosResponse) GetData() []Video {
	return datatype.Data
}
func (datatype GetVideosResponse) GetPagination() struct {
	// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ or _before_ query parameter depending on whether you're paging forwards or backwards through the results.
	Cursor *string `json:"cursor,omitempty"`
} {
	if datatype.Pagination == nil {
		var empty struct {
			// Cursor The cursor used to get the next page of results. Use the cursor to set the request's _after_ or _before_ query parameter depending on whether you're paging forwards or backwards through the results.
			Cursor *string `json:"cursor,omitempty"`
		}
		return empty
	}
	return *datatype.Pagination
}

// GlobalEmote defines model for GlobalEmote.
type GlobalEmote struct {
	// Format The formats that the emote is available in. For example, if the emote is available only as a static PNG, the array contains only `static`. But if the emote is available as a static PNG and an animated GIF, the array contains `static` and `animated`. The possible formats are:
	//
	// * animated  An animated GIF is available for this emote.
	// * static  A static PNG file is available for this emote.
	Format []GlobalEmoteFormat `json:"format"`

	// Id An ID that identifies this emote.
	Id string `json:"id"`

	// Images The image URLs for the emote. These image URLs always provide a static, non-animated emote image with a light background.
	//
	// **NOTE:** You should use the templated URL in the `template` field to fetch the image instead of using these URLs.
	Images struct {
		// Url1x A URL to the small version (28px x 28px) of the emote.
		Url1x string `json:"url_1x"`

		// Url2x A URL to the medium version (56px x 56px) of the emote.
		Url2x string `json:"url_2x"`

		// Url4x A URL to the large version (112px x 112px) of the emote.
		Url4x string `json:"url_4x"`
	} `json:"images"`

	// Name The name of the emote. This is the name that viewers type in the chat window to get the emote to appear.
	Name string `json:"name"`

	// Scale The sizes that the emote is available in. For example, if the emote is available in small and medium sizes, the array contains 1.0 and 2.0\. Possible sizes are:
	//
	// * 1.0  A small version (28px x 28px) is available.
	// * 2.0  A medium version (56px x 56px) is available.
	// * 3.0  A large version (112px x 112px) is available.
	Scale []GlobalEmoteScale `json:"scale"`

	// ThemeMode The background themes that the emote is available in. Possible themes are:
	//
	// * dark
	// * light
	ThemeMode []GlobalEmoteThemeMode `json:"theme_mode"`
}

func (datatype GlobalEmote) GetFormat() []GlobalEmoteFormat {
	return datatype.Format
}
func (datatype GlobalEmote) GetId() string {
	return datatype.Id
}
func (datatype GlobalEmote) GetImages() struct {
	// Url1x A URL to the small version (28px x 28px) of the emote.
	Url1x string `json:"url_1x"`

	// Url2x A URL to the medium version (56px x 56px) of the emote.
	Url2x string `json:"url_2x"`

	// Url4x A URL to the large version (112px x 112px) of the emote.
	Url4x string `json:"url_4x"`
} {
	return datatype.Images
}
func (datatype GlobalEmote) GetName() string {
	return datatype.Name
}
func (datatype GlobalEmote) GetScale() []GlobalEmoteScale {
	return datatype.Scale
}
func (datatype GlobalEmote) GetThemeMode() []GlobalEmoteThemeMode {
	return datatype.ThemeMode
}

// GlobalEmoteFormat defines model for GlobalEmote.Format.
type GlobalEmoteFormat string

// GlobalEmoteScale defines model for GlobalEmote.Scale.
type GlobalEmoteScale string

// GlobalEmoteThemeMode defines model for GlobalEmote.ThemeMode.
type GlobalEmoteThemeMode string

// Guest defines model for Guest.
type Guest struct {
	// AssignedAt Timestamp when this guest was assigned a slot in the session.
	AssignedAt time.Time `json:"assigned_at"`

	// AudioSettings Information about the guests audio settings
	AudioSettings struct {
		// IsAvailable Flag determining whether the guest has an appropriate audio device available to be transmitted to the session.
		IsAvailable bool `json:"is_available"`

		// IsGuestEnabled Flag determining whether the guest is allowing their audio to be transmitted to the session.
		IsGuestEnabled bool `json:"is_guest_enabled"`

		// IsHostEnabled Flag determining whether the host is allowing the guests audio to be seen or heard within the session.
		IsHostEnabled bool `json:"is_host_enabled"`
	} `json:"audio_settings"`

	// IsLive Flag determining whether or not the guest is visible in the browser source in the hosts streaming software.
	IsLive bool `json:"is_live"`

	// SlotId ID representing this guests slot assignment.
	//
	// * Host is always in slot "0"
	// * Guests are assigned the following consecutive IDs (e.g, "1", "2", "3", etc)
	// * Screen Share is represented as a special guest with the ID "SCREENSHARE"
	// * The identifier here matches the ID referenced in browser source links used in broadcasting software.
	SlotId string `json:"slot_id"`

	// UserDisplayName Display name of the guest assigned to this slot.
	UserDisplayName string `json:"user_display_name"`

	// UserId User ID of the guest assigned to this slot.
	UserId string `json:"user_id"`

	// UserLogin Login of the guest assigned to this slot.
	UserLogin string `json:"user_login"`

	// VideoSettings Information about the guests video settings
	VideoSettings struct {
		// IsAvailable Flag determining whether the guest has an appropriate video device available to be transmitted to the session.
		IsAvailable bool `json:"is_available"`

		// IsGuestEnabled Flag determining whether the guest is allowing their video to be transmitted to the session.
		IsGuestEnabled bool `json:"is_guest_enabled"`

		// IsHostEnabled Flag determining whether the host is allowing the guests video to be seen or heard within the session.
		IsHostEnabled bool `json:"is_host_enabled"`
	} `json:"video_settings"`

	// Volume Value from 0 to 100 representing the hosts volume setting for this guest.
	Volume int32 `json:"volume"`
}

func (datatype Guest) GetAssignedAt() time.Time {
	return datatype.AssignedAt
}
func (datatype Guest) GetAudioSettings() struct {
	// IsAvailable Flag determining whether the guest has an appropriate audio device available to be transmitted to the session.
	IsAvailable bool `json:"is_available"`

	// IsGuestEnabled Flag determining whether the guest is allowing their audio to be transmitted to the session.
	IsGuestEnabled bool `json:"is_guest_enabled"`

	// IsHostEnabled Flag determining whether the host is allowing the guests audio to be seen or heard within the session.
	IsHostEnabled bool `json:"is_host_enabled"`
} {
	return datatype.AudioSettings
}
func (datatype Guest) GetIsLive() bool {
	return datatype.IsLive
}
func (datatype Guest) GetSlotId() string {
	return datatype.SlotId
}
func (datatype Guest) GetUserDisplayName() string {
	return datatype.UserDisplayName
}
func (datatype Guest) GetUserId() string {
	return datatype.UserId
}
func (datatype Guest) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Guest) GetVideoSettings() struct {
	// IsAvailable Flag determining whether the guest has an appropriate video device available to be transmitted to the session.
	IsAvailable bool `json:"is_available"`

	// IsGuestEnabled Flag determining whether the guest is allowing their video to be transmitted to the session.
	IsGuestEnabled bool `json:"is_guest_enabled"`

	// IsHostEnabled Flag determining whether the host is allowing the guests video to be seen or heard within the session.
	IsHostEnabled bool `json:"is_host_enabled"`
} {
	return datatype.VideoSettings
}
func (datatype Guest) GetVolume() int32 {
	return datatype.Volume
}

// GuestStarInvite defines model for GuestStarInvite.
type GuestStarInvite struct {
	// InvitedAt Timestamp when this user was invited to the session.
	InvitedAt time.Time `json:"invited_at"`

	// IsAudioAvailable Flag signaling that the invited user has an audio device available for sharing.
	IsAudioAvailable bool `json:"is_audio_available"`

	// IsAudioEnabled Flag signaling that the invited user has chosen to disable their local audio device. The user has muted themselves, but they may choose to unmute their audio feed upon joining the session.
	IsAudioEnabled bool `json:"is_audio_enabled"`

	// IsVideoAvailable Flag signaling that the invited user has a video device available for sharing.
	IsVideoAvailable bool `json:"is_video_available"`

	// IsVideoEnabled Flag signaling that the invited user has chosen to disable their local video device. The user has hidden themselves, but they may choose to reveal their video feed upon joining the session.
	IsVideoEnabled bool `json:"is_video_enabled"`

	// Status Status representing the invited users join state. Can be one of the following:
	//
	// * `INVITED`: The user has been invited to the session but has not acknowledged it.
	// * `ACCEPTED`: The invited user has acknowledged the invite and joined the waiting room, but may still be setting up their media devices or otherwise preparing to join the call.
	// * `READY`: The invited user has signaled they are ready to join the call from the waiting room.
	Status string `json:"status"`

	// UserId Twitch User ID corresponding to the invited guest
	UserId string `json:"user_id"`
}

func (datatype GuestStarInvite) GetInvitedAt() time.Time {
	return datatype.InvitedAt
}
func (datatype GuestStarInvite) GetIsAudioAvailable() bool {
	return datatype.IsAudioAvailable
}
func (datatype GuestStarInvite) GetIsAudioEnabled() bool {
	return datatype.IsAudioEnabled
}
func (datatype GuestStarInvite) GetIsVideoAvailable() bool {
	return datatype.IsVideoAvailable
}
func (datatype GuestStarInvite) GetIsVideoEnabled() bool {
	return datatype.IsVideoEnabled
}
func (datatype GuestStarInvite) GetStatus() string {
	return datatype.Status
}
func (datatype GuestStarInvite) GetUserId() string {
	return datatype.UserId
}

// GuestStarSession defines model for GuestStarSession.
type GuestStarSession struct {
	// Guests List of guests currently interacting with the Guest Star session.
	Guests []Guest `json:"guests"`

	// Id ID uniquely representing the Guest Star session.
	Id string `json:"id"`
}

func (datatype GuestStarSession) GetGuests() []Guest {
	return datatype.Guests
}
func (datatype GuestStarSession) GetId() string {
	return datatype.Id
}

// HypeTrainEvent defines model for HypeTrainEvent.
type HypeTrainEvent struct {
	// EventData The events data.
	EventData struct {
		// BroadcasterId The ID of the broadcaster thats running the Hype Train.
		BroadcasterId string `json:"broadcaster_id"`

		// CooldownEndTime The UTC date and time (in RFC3339 format) that another Hype Train can start.
		CooldownEndTime time.Time `json:"cooldown_end_time"`

		// ExpiresAt The UTC date and time (in RFC3339 format) that the Hype Train ends.
		ExpiresAt time.Time `json:"expires_at"`

		// Goal The value needed to reach the next level.
		Goal int32 `json:"goal"`

		// Id An ID that identifies this Hype Train.
		Id string `json:"id"`

		// LastContribution The most recent contribution towards the Hype Trains goal.
		LastContribution struct {
			// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
			Total int32 `json:"total"`

			// Type The contribution method used. Possible values are:
			//
			// * BITS  Cheering with Bits.
			// * SUBS  Subscription activity like subscribing or gifting subscriptions.
			// * OTHER  Covers other contribution methods not listed.
			Type HypeTrainEventEventDataLastContributionType `json:"type"`

			// User The ID of the user that made the contribution.
			User string `json:"user"`
		} `json:"last_contribution"`

		// Level The highest level that the Hype Train reached (the levels are 1 through 5).
		Level int32 `json:"level"`

		// StartedAt The UTC date and time (in RFC3339 format) that this Hype Train started.
		StartedAt time.Time `json:"started_at"`

		// TopContributions The top contributors for each contribution type. For example, the top contributor using BITS (by aggregate) and the top contributor using SUBS (by count).
		TopContributions []struct {
			// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
			Total int32 `json:"total"`

			// Type The contribution method used. Possible values are:
			//
			// * BITS  Cheering with Bits.
			// * SUBS  Subscription activity like subscribing or gifting subscriptions.
			// * OTHER  Covers other contribution methods not listed.
			Type HypeTrainEventEventDataTopContributionsType `json:"type"`

			// User The ID of the user that made the contribution.
			User string `json:"user"`
		} `json:"top_contributions"`

		// Total The current total amount raised.
		Total int32 `json:"total"`
	} `json:"event_data"`

	// EventTimestamp The UTC date and time (in RFC3339 format) that the event occurred.
	EventTimestamp time.Time `json:"event_timestamp"`

	// EventType The type of event. The string is in the form, hypetrain.{event\_name}. The request returns only progress event types (i.e., hypetrain.progression).
	EventType string `json:"event_type"`

	// Id An ID that identifies this event.
	Id string `json:"id"`

	// Version The version number of the definition of the events data. For example, the value is 1 if the data in `event_data` uses the first definition of the events data.
	Version string `json:"version"`
}

func (datatype HypeTrainEvent) GetEventData() struct {
	// BroadcasterId The ID of the broadcaster thats running the Hype Train.
	BroadcasterId string `json:"broadcaster_id"`

	// CooldownEndTime The UTC date and time (in RFC3339 format) that another Hype Train can start.
	CooldownEndTime time.Time `json:"cooldown_end_time"`

	// ExpiresAt The UTC date and time (in RFC3339 format) that the Hype Train ends.
	ExpiresAt time.Time `json:"expires_at"`

	// Goal The value needed to reach the next level.
	Goal int32 `json:"goal"`

	// Id An ID that identifies this Hype Train.
	Id string `json:"id"`

	// LastContribution The most recent contribution towards the Hype Trains goal.
	LastContribution struct {
		// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
		Total int32 `json:"total"`

		// Type The contribution method used. Possible values are:
		//
		// * BITS  Cheering with Bits.
		// * SUBS  Subscription activity like subscribing or gifting subscriptions.
		// * OTHER  Covers other contribution methods not listed.
		Type HypeTrainEventEventDataLastContributionType `json:"type"`

		// User The ID of the user that made the contribution.
		User string `json:"user"`
	} `json:"last_contribution"`

	// Level The highest level that the Hype Train reached (the levels are 1 through 5).
	Level int32 `json:"level"`

	// StartedAt The UTC date and time (in RFC3339 format) that this Hype Train started.
	StartedAt time.Time `json:"started_at"`

	// TopContributions The top contributors for each contribution type. For example, the top contributor using BITS (by aggregate) and the top contributor using SUBS (by count).
	TopContributions []struct {
		// Total The total amount contributed. If `type` is BITS, `total` represents the amount of Bits used. If `type` is SUBS, `total` is 500, 1000, or 2500 to represent tier 1, 2, or 3 subscriptions, respectively.
		Total int32 `json:"total"`

		// Type The contribution method used. Possible values are:
		//
		// * BITS  Cheering with Bits.
		// * SUBS  Subscription activity like subscribing or gifting subscriptions.
		// * OTHER  Covers other contribution methods not listed.
		Type HypeTrainEventEventDataTopContributionsType `json:"type"`

		// User The ID of the user that made the contribution.
		User string `json:"user"`
	} `json:"top_contributions"`

	// Total The current total amount raised.
	Total int32 `json:"total"`
} {
	return datatype.EventData
}
func (datatype HypeTrainEvent) GetEventTimestamp() time.Time {
	return datatype.EventTimestamp
}
func (datatype HypeTrainEvent) GetEventType() string {
	return datatype.EventType
}
func (datatype HypeTrainEvent) GetId() string {
	return datatype.Id
}
func (datatype HypeTrainEvent) GetVersion() string {
	return datatype.Version
}

// HypeTrainEventEventDataLastContributionType The contribution method used. Possible values are:
//
// * BITS  Cheering with Bits.
// * SUBS  Subscription activity like subscribing or gifting subscriptions.
// * OTHER  Covers other contribution methods not listed.
type HypeTrainEventEventDataLastContributionType string

// HypeTrainEventEventDataTopContributionsType The contribution method used. Possible values are:
//
// * BITS  Cheering with Bits.
// * SUBS  Subscription activity like subscribing or gifting subscriptions.
// * OTHER  Covers other contribution methods not listed.
type HypeTrainEventEventDataTopContributionsType string

// ManageHeldAutoModMessagesBody defines model for ManageHeldAutoModMessagesBody.
type ManageHeldAutoModMessagesBody struct {
	// Action The action to take for the message. Possible values are:
	//
	// * ALLOW
	// * DENY
	Action ManageHeldAutoModMessagesBodyAction `json:"action"`

	// MsgId The ID of the message to allow or deny.
	MsgId string `json:"msg_id"`

	// UserId The moderator who is approving or denying the held message. This ID must match the user ID in the access token.
	UserId string `json:"user_id"`
}

func (datatype ManageHeldAutoModMessagesBody) GetAction() ManageHeldAutoModMessagesBodyAction {
	return datatype.Action
}
func (datatype ManageHeldAutoModMessagesBody) GetMsgId() string {
	return datatype.MsgId
}
func (datatype ManageHeldAutoModMessagesBody) GetUserId() string {
	return datatype.UserId
}

// ManageHeldAutoModMessagesBodyAction The action to take for the message. Possible values are:
//
// * ALLOW
// * DENY
type ManageHeldAutoModMessagesBodyAction string

// ModifyChannelInformationBody defines model for ModifyChannelInformationBody.
type ModifyChannelInformationBody struct {
	// BroadcasterLanguage The users preferred language. Set the value to an ISO 639-1 two-letter language code (for example, _en_ for English). Set to other if the users preferred language is not a Twitch supported language. The language isnt updated if the language code isnt a Twitch supported language.
	BroadcasterLanguage *string `json:"broadcaster_language,omitempty"`

	// ContentClassificationLabels List of labels that should be set as the Channels CCLs.
	ContentClassificationLabels *[]struct {
		// Id ID of the [Content Classification Labels](https://blog.twitch.tv/en/2023/06/20/introducing-content-classification-labels/) that must be added/removed from the channel. Can be one of the following values:
		//
		// * DrugsIntoxication
		// * SexualThemes
		// * ViolentGraphic
		// * Gambling
		// * ProfanityVulgarity
		Id ModifyChannelInformationBodyContentClassificationLabelsId `json:"id"`

		// IsEnabled Boolean flag indicating whether the label should be enabled (true) or disabled for the channel.
		IsEnabled bool `json:"is_enabled"`
	} `json:"content_classification_labels,omitempty"`

	// Delay The number of seconds you want your broadcast buffered before streaming it live. The delay helps ensure fairness during competitive play. Only users with Partner status may set this field. The maximum delay is 900 seconds (15 minutes).
	Delay *int32 `json:"delay,omitempty"`

	// GameId The ID of the game that the user plays. The game is not updated if the ID isnt a game ID that Twitch recognizes. To unset this field, use 0 or  (an empty string).
	GameId *string `json:"game_id,omitempty"`

	// IsBrandedContent Boolean flag indicating if the channel has branded content.
	IsBrandedContent *bool `json:"is_branded_content,omitempty"`

	// Tags A list of channel-defined tags to apply to the channel. To remove all tags from the channel, set tags to an empty array. Tags help identify the content that the channel streams. [Learn More](https://help.twitch.tv/s/article/guide-to-tags)
	//
	// A channel may specify a maximum of 10 tags. Each tag is limited to a maximum of 25 characters and may not be an empty string or contain spaces or special characters. Tags are case insensitive. For readability, consider using camelCasing or PascalCasing.
	Tags *[]string `json:"tags,omitempty"`

	// Title The title of the users stream. You may not set this field to an empty string.
	Title *string `json:"title,omitempty"`
}

func (datatype ModifyChannelInformationBody) GetBroadcasterLanguage() string {
	if datatype.BroadcasterLanguage == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterLanguage
}
func (datatype ModifyChannelInformationBody) GetContentClassificationLabels() []struct {
	// Id ID of the [Content Classification Labels](https://blog.twitch.tv/en/2023/06/20/introducing-content-classification-labels/) that must be added/removed from the channel. Can be one of the following values:
	//
	// * DrugsIntoxication
	// * SexualThemes
	// * ViolentGraphic
	// * Gambling
	// * ProfanityVulgarity
	Id ModifyChannelInformationBodyContentClassificationLabelsId `json:"id"`

	// IsEnabled Boolean flag indicating whether the label should be enabled (true) or disabled for the channel.
	IsEnabled bool `json:"is_enabled"`
} {
	if datatype.ContentClassificationLabels == nil {
		var empty []struct {
			// Id ID of the [Content Classification Labels](https://blog.twitch.tv/en/2023/06/20/introducing-content-classification-labels/) that must be added/removed from the channel. Can be one of the following values:
			//
			// * DrugsIntoxication
			// * SexualThemes
			// * ViolentGraphic
			// * Gambling
			// * ProfanityVulgarity
			Id ModifyChannelInformationBodyContentClassificationLabelsId `json:"id"`

			// IsEnabled Boolean flag indicating whether the label should be enabled (true) or disabled for the channel.
			IsEnabled bool `json:"is_enabled"`
		}
		return empty
	}
	return *datatype.ContentClassificationLabels
}
func (datatype ModifyChannelInformationBody) GetDelay() int32 {
	if datatype.Delay == nil {
		var empty int32
		return empty
	}
	return *datatype.Delay
}
func (datatype ModifyChannelInformationBody) GetGameId() string {
	if datatype.GameId == nil {
		var empty string
		return empty
	}
	return *datatype.GameId
}
func (datatype ModifyChannelInformationBody) GetIsBrandedContent() bool {
	if datatype.IsBrandedContent == nil {
		var empty bool
		return empty
	}
	return *datatype.IsBrandedContent
}
func (datatype ModifyChannelInformationBody) GetTags() []string {
	if datatype.Tags == nil {
		var empty []string
		return empty
	}
	return *datatype.Tags
}
func (datatype ModifyChannelInformationBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// ModifyChannelInformationBodyContentClassificationLabelsId ID of the [Content Classification Labels](https://blog.twitch.tv/en/2023/06/20/introducing-content-classification-labels/) that must be added/removed from the channel. Can be one of the following values:
//
// * DrugsIntoxication
// * SexualThemes
// * ViolentGraphic
// * Gambling
// * ProfanityVulgarity
type ModifyChannelInformationBodyContentClassificationLabelsId string

// Poll defines model for Poll.
type Poll struct {
	// BitsPerVote Not used; will be set to 0.
	BitsPerVote int32 `json:"bits_per_vote"`

	// BitsVotingEnabled Not used; will be set to **false**.
	BitsVotingEnabled bool `json:"bits_voting_enabled"`

	// BroadcasterId An ID that identifies the broadcaster that created the poll.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// ChannelPointsPerVote The number of points the viewer must spend to cast one additional vote.
	ChannelPointsPerVote int32 `json:"channel_points_per_vote"`

	// ChannelPointsVotingEnabled A Boolean value that indicates whether viewers may cast additional votes using Channel Points. For information about Channel Points, see [Channel Points Guide](https://help.twitch.tv/s/article/channel-points-guide).
	ChannelPointsVotingEnabled bool `json:"channel_points_voting_enabled"`

	// Choices A list of choices that viewers can choose from. The list will contain a minimum of two choices and up to a maximum of five choices.
	Choices []struct {
		// BitsVotes Not used; will be set to 0.
		BitsVotes int32 `json:"bits_votes"`

		// ChannelPointsVotes The number of votes cast using Channel Points.
		ChannelPointsVotes int32 `json:"channel_points_votes"`

		// Id An ID that identifies this choice.
		Id string `json:"id"`

		// Title The choices title. The title may contain a maximum of 25 characters.
		Title string `json:"title"`

		// Votes The total number of votes cast for this choice.
		Votes int32 `json:"votes"`
	} `json:"choices"`

	// Duration The length of time (in seconds) that the poll will run for.
	Duration int32 `json:"duration"`

	// EndedAt The UTC date and time (in RFC3339 format) of when the poll ended. If `status` is ACTIVE, this field is set to **null**.
	EndedAt *time.Time `json:"ended_at"`

	// Id An ID that identifies the poll.
	Id string `json:"id"`

	// StartedAt The UTC date and time (in RFC3339 format) of when the poll began.
	StartedAt time.Time `json:"started_at"`

	// Status The polls status. Valid values are:
	//
	// * ACTIVE  The poll is running.
	// * COMPLETED  The poll ended on schedule (see the `duration` field).
	// * TERMINATED  The poll was terminated before its scheduled end.
	// * ARCHIVED  The poll has been archived and is no longer visible on the channel.
	// * MODERATED  The poll was deleted.
	// * INVALID  Something went wrong while determining the state.
	Status PollStatus `json:"status"`

	// Title The question that viewers are voting on. For example, _What game should I play next?_ The title may contain a maximum of 60 characters.
	Title string `json:"title"`
}

func (datatype Poll) GetBitsPerVote() int32 {
	return datatype.BitsPerVote
}
func (datatype Poll) GetBitsVotingEnabled() bool {
	return datatype.BitsVotingEnabled
}
func (datatype Poll) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype Poll) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype Poll) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype Poll) GetChannelPointsPerVote() int32 {
	return datatype.ChannelPointsPerVote
}
func (datatype Poll) GetChannelPointsVotingEnabled() bool {
	return datatype.ChannelPointsVotingEnabled
}
func (datatype Poll) GetChoices() []struct {
	// BitsVotes Not used; will be set to 0.
	BitsVotes int32 `json:"bits_votes"`

	// ChannelPointsVotes The number of votes cast using Channel Points.
	ChannelPointsVotes int32 `json:"channel_points_votes"`

	// Id An ID that identifies this choice.
	Id string `json:"id"`

	// Title The choices title. The title may contain a maximum of 25 characters.
	Title string `json:"title"`

	// Votes The total number of votes cast for this choice.
	Votes int32 `json:"votes"`
} {
	return datatype.Choices
}
func (datatype Poll) GetDuration() int32 {
	return datatype.Duration
}
func (datatype Poll) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype Poll) GetId() string {
	return datatype.Id
}
func (datatype Poll) GetStartedAt() time.Time {
	return datatype.StartedAt
}
func (datatype Poll) GetStatus() PollStatus {
	return datatype.Status
}
func (datatype Poll) GetTitle() string {
	return datatype.Title
}

// PollStatus The polls status. Valid values are:
//
// * ACTIVE  The poll is running.
// * COMPLETED  The poll ended on schedule (see the `duration` field).
// * TERMINATED  The poll was terminated before its scheduled end.
// * ARCHIVED  The poll has been archived and is no longer visible on the channel.
// * MODERATED  The poll was deleted.
// * INVALID  Something went wrong while determining the state.
type PollStatus string

// Prediction defines model for Prediction.
type Prediction struct {
	// BroadcasterId An ID that identifies the broadcaster that created the prediction.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt The UTC date and time of when the Prediction began.
	CreatedAt time.Time `json:"created_at"`

	// EndedAt The UTC date and time of when the Prediction ended. If `status` is ACTIVE, this is set to **null**.
	EndedAt *time.Time `json:"ended_at"`

	// Id An ID that identifies this prediction.
	Id string `json:"id"`

	// LockedAt The UTC date and time of when the Prediction was locked. If `status` is not LOCKED, this is set to **null**.
	LockedAt *time.Time `json:"locked_at"`

	// Outcomes The list of possible outcomes for the prediction.
	Outcomes []PredictionOutcome `json:"outcomes"`

	// PredictionWindow The length of time (in seconds) that the prediction will run for.
	PredictionWindow int32 `json:"prediction_window"`

	// Status The predictions status. Valid values are:
	//
	// * ACTIVE  The Prediction is running and viewers can make predictions.
	// * CANCELED  The broadcaster canceled the Prediction and refunded the Channel Points to the participants.
	// * LOCKED  The broadcaster locked the Prediction, which means viewers can no longer make predictions.
	// * RESOLVED  The winning outcome was determined and the Channel Points were distributed to the viewers who predicted the correct outcome.
	Status PredictionStatus `json:"status"`

	// Title The question that the prediction asks. For example, _Will I finish this entire pizza?_
	Title string `json:"title"`

	// WinningOutcomeId The ID of the winning outcome. Is **null** unless `status` is RESOLVED.
	WinningOutcomeId *string `json:"winning_outcome_id"`
}

func (datatype Prediction) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype Prediction) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype Prediction) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype Prediction) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Prediction) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype Prediction) GetId() string {
	return datatype.Id
}
func (datatype Prediction) GetLockedAt() time.Time {
	if datatype.LockedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.LockedAt
}
func (datatype Prediction) GetOutcomes() []PredictionOutcome {
	return datatype.Outcomes
}
func (datatype Prediction) GetPredictionWindow() int32 {
	return datatype.PredictionWindow
}
func (datatype Prediction) GetStatus() PredictionStatus {
	return datatype.Status
}
func (datatype Prediction) GetTitle() string {
	return datatype.Title
}
func (datatype Prediction) GetWinningOutcomeId() string {
	if datatype.WinningOutcomeId == nil {
		var empty string
		return empty
	}
	return *datatype.WinningOutcomeId
}

// PredictionStatus The predictions status. Valid values are:
//
// * ACTIVE  The Prediction is running and viewers can make predictions.
// * CANCELED  The broadcaster canceled the Prediction and refunded the Channel Points to the participants.
// * LOCKED  The broadcaster locked the Prediction, which means viewers can no longer make predictions.
// * RESOLVED  The winning outcome was determined and the Channel Points were distributed to the viewers who predicted the correct outcome.
type PredictionStatus string

// PredictionOutcome defines model for PredictionOutcome.
type PredictionOutcome struct {
	// ChannelPoints The number of Channel Points spent by viewers on this outcome.
	ChannelPoints int32 `json:"channel_points"`

	// Color The color that visually identifies this outcome in the UX. Possible values are:
	//
	// * BLUE
	// * PINK
	//
	// If the number of outcomes is two, the color is BLUE for the first outcome and PINK for the second outcome. If there are more than two outcomes, the color is BLUE for all outcomes.
	Color PredictionOutcomeColor `json:"color"`

	// Id An ID that identifies this outcome.
	Id string `json:"id"`

	// Title The outcomes text.
	Title string `json:"title"`

	// TopPredictors A list of viewers who were the top predictors; otherwise, **null** if none.
	TopPredictors *[]struct {
		// ChannelPointsUsed The number of Channel Points the viewer spent.
		ChannelPointsUsed int32 `json:"channel_points_used"`

		// ChannelPointsWon The number of Channel Points distributed to the viewer.
		ChannelPointsWon int32 `json:"channel_points_won"`

		// UserId An ID that identifies the viewer.
		UserId string `json:"user_id"`

		// UserLogin The viewers login name.
		UserLogin string `json:"user_login"`

		// UserName The viewers display name.
		UserName string `json:"user_name"`
	} `json:"top_predictors"`

	// Users The number of unique viewers that chose this outcome.
	Users int32 `json:"users"`
}

func (datatype PredictionOutcome) GetChannelPoints() int32 {
	return datatype.ChannelPoints
}
func (datatype PredictionOutcome) GetColor() PredictionOutcomeColor {
	return datatype.Color
}
func (datatype PredictionOutcome) GetId() string {
	return datatype.Id
}
func (datatype PredictionOutcome) GetTitle() string {
	return datatype.Title
}
func (datatype PredictionOutcome) GetTopPredictors() []struct {
	// ChannelPointsUsed The number of Channel Points the viewer spent.
	ChannelPointsUsed int32 `json:"channel_points_used"`

	// ChannelPointsWon The number of Channel Points distributed to the viewer.
	ChannelPointsWon int32 `json:"channel_points_won"`

	// UserId An ID that identifies the viewer.
	UserId string `json:"user_id"`

	// UserLogin The viewers login name.
	UserLogin string `json:"user_login"`

	// UserName The viewers display name.
	UserName string `json:"user_name"`
} {
	if datatype.TopPredictors == nil {
		var empty []struct {
			// ChannelPointsUsed The number of Channel Points the viewer spent.
			ChannelPointsUsed int32 `json:"channel_points_used"`

			// ChannelPointsWon The number of Channel Points distributed to the viewer.
			ChannelPointsWon int32 `json:"channel_points_won"`

			// UserId An ID that identifies the viewer.
			UserId string `json:"user_id"`

			// UserLogin The viewers login name.
			UserLogin string `json:"user_login"`

			// UserName The viewers display name.
			UserName string `json:"user_name"`
		}
		return empty
	}
	return *datatype.TopPredictors
}
func (datatype PredictionOutcome) GetUsers() int32 {
	return datatype.Users
}

// PredictionOutcomeColor The color that visually identifies this outcome in the UX. Possible values are:
//
// * BLUE
// * PINK
//
// If the number of outcomes is two, the color is BLUE for the first outcome and PINK for the second outcome. If there are more than two outcomes, the color is BLUE for all outcomes.
type PredictionOutcomeColor string

// ResolveUnbanRequestsResponse defines model for ResolveUnbanRequestsResponse.
type ResolveUnbanRequestsResponse struct {
	Data []struct {
		// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// CreatedAt Timestamp of when the unban request was created.
		CreatedAt time.Time `json:"created_at"`

		// Id Unban request ID.
		Id string `json:"id"`

		// ModeratorId User ID of moderator who approved/denied the request.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderators login name.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderators display name.
		ModeratorName string `json:"moderator_name"`

		// ResolutionText Text input by the resolver (moderator) of the unban request.
		ResolutionText string `json:"resolution_text"`

		// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
		ResolvedAt time.Time `json:"resolved_at"`

		// Status Status of the request. One of:
		//
		// * approved
		// * denied
		Status string `json:"status"`

		// Text Text of the request from the requesting user.
		Text string `json:"text"`

		// UserId User ID of the requestor who is asking for an unban.
		UserId string `json:"user_id"`

		// UserLogin The users login name.
		UserLogin string `json:"user_login"`

		// UserName The users display name.
		UserName string `json:"user_name"`
	} `json:"data"`
}

func (datatype ResolveUnbanRequestsResponse) GetData() []struct {
	// BroadcasterId User ID of broadcaster whose channel is receiving the unban request.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// CreatedAt Timestamp of when the unban request was created.
	CreatedAt time.Time `json:"created_at"`

	// Id Unban request ID.
	Id string `json:"id"`

	// ModeratorId User ID of moderator who approved/denied the request.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name.
	ModeratorName string `json:"moderator_name"`

	// ResolutionText Text input by the resolver (moderator) of the unban request.
	ResolutionText string `json:"resolution_text"`

	// ResolvedAt Timestamp of when moderator/broadcaster approved or denied the request.
	ResolvedAt time.Time `json:"resolved_at"`

	// Status Status of the request. One of:
	//
	// * approved
	// * denied
	Status string `json:"status"`

	// Text Text of the request from the requesting user.
	Text string `json:"text"`

	// UserId User ID of the requestor who is asking for an unban.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
} {
	return datatype.Data
}

// SearchCategoriesResponse defines model for SearchCategoriesResponse.
type SearchCategoriesResponse struct {
	// Data The list of games or categories that match the query. The list is empty if there are no matches.
	Data []Category `json:"data"`
}

func (datatype SearchCategoriesResponse) GetData() []Category {
	return datatype.Data
}

// SearchChannelsResponse defines model for SearchChannelsResponse.
type SearchChannelsResponse struct {
	// Data The list of channels that match the query. The list is empty if there are no matches.
	Data []Channel `json:"data"`
}

func (datatype SearchChannelsResponse) GetData() []Channel {
	return datatype.Data
}

// SendChatAnnouncementBody defines model for SendChatAnnouncementBody.
type SendChatAnnouncementBody struct {
	// Color The color used to highlight the announcement. Possible case-sensitive values are:
	//
	// * blue
	// * green
	// * orange
	// * purple
	// * primary (default)
	//
	// If `color` is set to _primary_ or is not set, the channels accent color is used to highlight the announcement (see **Profile Accent Color** under [profile settings](https://www.twitch.tv/settings/profile), **Channel and Videos**, and **Brand**).
	Color *SendChatAnnouncementBodyColor `json:"color,omitempty"`

	// Message The announcement to make in the broadcasters chat room. Announcements are limited to a maximum of 500 characters; announcements longer than 500 characters are truncated.
	Message string `json:"message"`
}

func (datatype SendChatAnnouncementBody) GetColor() SendChatAnnouncementBodyColor {
	if datatype.Color == nil {
		var empty SendChatAnnouncementBodyColor
		return empty
	}
	return *datatype.Color
}
func (datatype SendChatAnnouncementBody) GetMessage() string {
	return datatype.Message
}

// SendChatAnnouncementBodyColor The color used to highlight the announcement. Possible case-sensitive values are:
//
// * blue
// * green
// * orange
// * purple
// * primary (default)
//
// If `color` is set to _primary_ or is not set, the channels accent color is used to highlight the announcement (see **Profile Accent Color** under [profile settings](https://www.twitch.tv/settings/profile), **Channel and Videos**, and **Brand**).
type SendChatAnnouncementBodyColor string

// SendChatMessageBody defines model for SendChatMessageBody.
type SendChatMessageBody struct {
	// BroadcasterId The ID of the broadcaster whose chat room the message will be sent to.
	BroadcasterId string `json:"broadcaster_id"`

	// Message The message to send. The message is limited to a maximum of 500 characters. Chat messages can also include emoticons. To include emoticons, use the name of the emote. The names are case sensitive. Dont include colons around the name (e.g., :bleedPurple:). If Twitch recognizes the name, Twitch converts the name to the emote before writing the chat message to the chat room
	Message string `json:"message"`

	// ReplyParentMessageId The ID of the chat message being replied to.
	ReplyParentMessageId *string `json:"reply_parent_message_id,omitempty"`

	// SenderId The ID of the user sending the message. This ID must match the user ID in the user access token.
	SenderId string `json:"sender_id"`
}

func (datatype SendChatMessageBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype SendChatMessageBody) GetMessage() string {
	return datatype.Message
}
func (datatype SendChatMessageBody) GetReplyParentMessageId() string {
	if datatype.ReplyParentMessageId == nil {
		var empty string
		return empty
	}
	return *datatype.ReplyParentMessageId
}
func (datatype SendChatMessageBody) GetSenderId() string {
	return datatype.SenderId
}

// SendChatMessageResponse defines model for SendChatMessageResponse.
type SendChatMessageResponse struct {
	Data []struct {
		// DropReason The reason the message was dropped, if any.
		DropReason *struct {
			// Code Code for why the message was dropped.
			Code string `json:"code"`

			// Message Message for why the message was dropped.
			Message string `json:"message"`
		} `json:"drop_reason,omitempty"`

		// IsSent If the message passed all checks and was sent.
		IsSent bool `json:"is_sent"`

		// MessageId The message id for the message that was sent.
		MessageId string `json:"message_id"`
	} `json:"data"`
}

func (datatype SendChatMessageResponse) GetData() []struct {
	// DropReason The reason the message was dropped, if any.
	DropReason *struct {
		// Code Code for why the message was dropped.
		Code string `json:"code"`

		// Message Message for why the message was dropped.
		Message string `json:"message"`
	} `json:"drop_reason,omitempty"`

	// IsSent If the message passed all checks and was sent.
	IsSent bool `json:"is_sent"`

	// MessageId The message id for the message that was sent.
	MessageId string `json:"message_id"`
} {
	return datatype.Data
}

// SendExtensionChatMessageBody defines model for SendExtensionChatMessageBody.
type SendExtensionChatMessageBody struct {
	// ExtensionId The ID of the extension thats sending the chat message.
	ExtensionId string `json:"extension_id"`

	// ExtensionVersion The extensions version number.
	ExtensionVersion string `json:"extension_version"`

	// Text The message. The message may contain a maximum of 280 characters.
	Text string `json:"text"`
}

func (datatype SendExtensionChatMessageBody) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype SendExtensionChatMessageBody) GetExtensionVersion() string {
	return datatype.ExtensionVersion
}
func (datatype SendExtensionChatMessageBody) GetText() string {
	return datatype.Text
}

// SendExtensionPubSubMessageBody defines model for SendExtensionPubSubMessageBody.
type SendExtensionPubSubMessageBody struct {
	// BroadcasterId The ID of the broadcaster to send the message to. Dont include this field if `is_global_broadcast` is set to **true**.
	BroadcasterId string `json:"broadcaster_id"`

	// IsGlobalBroadcast A Boolean value that determines whether the message should be sent to all channels where your extension is active. Set to **true** if the message should be sent to all channels. The default is **false**.
	IsGlobalBroadcast *bool `json:"is_global_broadcast,omitempty"`

	// Message The message to send. The message can be a plain-text string or a string-encoded JSON object. The message is limited to a maximum of 5 KB.
	Message string `json:"message"`

	// Target The target of the message. Possible values are:
	//
	// * broadcast
	// * global
	// * whisper-<user-id>
	//
	// If `is_global_broadcast` is **true**, you must set this field to global. The broadcast and global values are mutually exclusive; specify only one of them.
	Target []SendExtensionPubSubMessageBodyTarget `json:"target"`
}

func (datatype SendExtensionPubSubMessageBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype SendExtensionPubSubMessageBody) GetIsGlobalBroadcast() bool {
	if datatype.IsGlobalBroadcast == nil {
		var empty bool
		return empty
	}
	return *datatype.IsGlobalBroadcast
}
func (datatype SendExtensionPubSubMessageBody) GetMessage() string {
	return datatype.Message
}
func (datatype SendExtensionPubSubMessageBody) GetTarget() []SendExtensionPubSubMessageBodyTarget {
	return datatype.Target
}

// SendExtensionPubSubMessageBodyTarget defines model for SendExtensionPubSubMessageBody.Target.
type SendExtensionPubSubMessageBodyTarget string

// SendWhisperBody defines model for SendWhisperBody.
type SendWhisperBody struct {
	// Message The whisper message to send. The message must not be empty.
	//
	// The maximum message lengths are:
	//
	// * 500 characters if the user you're sending the message to hasn't whispered you before.
	// * 10,000 characters if the user you're sending the message to has whispered you before.
	//
	// Messages that exceed the maximum length are truncated.
	Message string `json:"message"`
}

func (datatype SendWhisperBody) GetMessage() string {
	return datatype.Message
}

// SetExtensionConfigurationSegmentBody defines model for SetExtensionConfigurationSegmentBody.
type SetExtensionConfigurationSegmentBody struct {
	// BroadcasterId The ID of the broadcaster that installed the extension. Include this field only if the `segment` is set to developer or broadcaster.
	BroadcasterId *string `json:"broadcaster_id,omitempty"`

	// Content The contents of the segment. This string may be a plain-text string or a string-encoded JSON object.
	Content *string `json:"content,omitempty"`

	// ExtensionId The ID of the extension to update.
	ExtensionId string `json:"extension_id"`

	// Segment The configuration segment to update. Possible case-sensitive values are:
	//
	// * broadcaster
	// * developer
	// * global
	Segment SetExtensionConfigurationSegmentBodySegment `json:"segment"`

	// Version The version number that identifies this definition of the segments data. If not specified, the latest definition is updated.
	Version *string `json:"version,omitempty"`
}

func (datatype SetExtensionConfigurationSegmentBody) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype SetExtensionConfigurationSegmentBody) GetContent() string {
	if datatype.Content == nil {
		var empty string
		return empty
	}
	return *datatype.Content
}
func (datatype SetExtensionConfigurationSegmentBody) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype SetExtensionConfigurationSegmentBody) GetSegment() SetExtensionConfigurationSegmentBodySegment {
	return datatype.Segment
}
func (datatype SetExtensionConfigurationSegmentBody) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// SetExtensionConfigurationSegmentBodySegment The configuration segment to update. Possible case-sensitive values are:
//
// * broadcaster
// * developer
// * global
type SetExtensionConfigurationSegmentBodySegment string

// SetExtensionRequiredConfigurationBody defines model for SetExtensionRequiredConfigurationBody.
type SetExtensionRequiredConfigurationBody struct {
	// ExtensionId The ID of the extension to update.
	ExtensionId string `json:"extension_id"`

	// ExtensionVersion The version of the extension to update.
	ExtensionVersion string `json:"extension_version"`

	// RequiredConfiguration The required\_configuration string to use with the extension.
	RequiredConfiguration string `json:"required_configuration"`
}

func (datatype SetExtensionRequiredConfigurationBody) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype SetExtensionRequiredConfigurationBody) GetExtensionVersion() string {
	return datatype.ExtensionVersion
}
func (datatype SetExtensionRequiredConfigurationBody) GetRequiredConfiguration() string {
	return datatype.RequiredConfiguration
}

// SnoozeNextAdResponse defines model for SnoozeNextAdResponse.
type SnoozeNextAdResponse struct {
	// Data A list that contains information about the channels snoozes and next upcoming ad after successfully snoozing.
	Data []struct {
		// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format.
		NextAdAt time.Time `json:"next_ad_at"`

		// SnoozeCount The number of snoozes available for the broadcaster.
		SnoozeCount int32 `json:"snooze_count"`

		// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
		SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
	} `json:"data"`
}

func (datatype SnoozeNextAdResponse) GetData() []struct {
	// NextAdAt The UTC timestamp of the broadcasters next scheduled ad, in RFC3339 format.
	NextAdAt time.Time `json:"next_ad_at"`

	// SnoozeCount The number of snoozes available for the broadcaster.
	SnoozeCount int32 `json:"snooze_count"`

	// SnoozeRefreshAt The UTC timestamp when the broadcaster will gain an additional snooze, in RFC3339 format.
	SnoozeRefreshAt time.Time `json:"snooze_refresh_at"`
} {
	return datatype.Data
}

// StartCommercialBody defines model for StartCommercialBody.
type StartCommercialBody struct {
	// BroadcasterId The ID of the partner or affiliate broadcaster that wants to run the commercial. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `json:"broadcaster_id"`

	// Length The length of the commercial to run, in seconds. Twitch tries to serve a commercial thats the requested length, but it may be shorter or longer. The maximum length you should request is 180 seconds.
	Length int32 `json:"length"`
}

func (datatype StartCommercialBody) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype StartCommercialBody) GetLength() int32 {
	return datatype.Length
}

// StartCommercialResponse defines model for StartCommercialResponse.
type StartCommercialResponse struct {
	// Data An array that contains a single object with the status of your start commercial request.
	Data []struct {
		// Length The length of the commercial you requested. If you request a commercial thats longer than 180 seconds, the API uses 180 seconds.
		Length int32 `json:"length"`

		// Message A message that indicates whether Twitch was able to serve an ad.
		Message string `json:"message"`

		// RetryAfter The number of seconds you must wait before running another commercial.
		RetryAfter int32 `json:"retry_after"`
	} `json:"data"`
}

func (datatype StartCommercialResponse) GetData() []struct {
	// Length The length of the commercial you requested. If you request a commercial thats longer than 180 seconds, the API uses 180 seconds.
	Length int32 `json:"length"`

	// Message A message that indicates whether Twitch was able to serve an ad.
	Message string `json:"message"`

	// RetryAfter The number of seconds you must wait before running another commercial.
	RetryAfter int32 `json:"retry_after"`
} {
	return datatype.Data
}

// StartRaidResponse defines model for StartRaidResponse.
type StartRaidResponse struct {
	// Data A list that contains a single object with information about the pending raid.
	Data []struct {
		// CreatedAt The UTC date and time, in RFC3339 format, of when the raid was requested.
		CreatedAt time.Time `json:"created_at"`

		// IsMature A Boolean value that indicates whether the channel being raided contains mature content.
		IsMature bool `json:"is_mature"`
	} `json:"data"`
}

func (datatype StartRaidResponse) GetData() []struct {
	// CreatedAt The UTC date and time, in RFC3339 format, of when the raid was requested.
	CreatedAt time.Time `json:"created_at"`

	// IsMature A Boolean value that indicates whether the channel being raided contains mature content.
	IsMature bool `json:"is_mature"`
} {
	return datatype.Data
}

// Stream defines model for Stream.
type Stream struct {
	// GameId The ID of the category or game being played.
	GameId string `json:"game_id"`

	// GameName The ID of the category or game being played.
	GameName string `json:"game_name"`

	// Id An ID that identifies the stream. You can use this ID later to look up the video on demand (VOD).
	Id string `json:"id"`

	// IsMature A Boolean value that indicates whether the stream is meant for mature audiences.
	IsMature bool `json:"is_mature"`

	// Language The language that the stream uses. This is an ISO 639-1 two-letter language code or _other_ if the stream uses a language not in the list of [supported stream languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang).
	Language string `json:"language"`

	// StartedAt The UTC date and time (in RFC3339 format) of when the broadcast began.
	StartedAt time.Time `json:"started_at"`

	// TagIds **IMPORTANT** As of February 28, 2023, this field is deprecated and returns only an empty array. If you use this field, please update your code to use the `tags` field.
	//
	// The list of tags that apply to the stream. The list contains IDs only when the channel is steaming live. For a list of possible tags, see [List of All Tags](https://www.twitch.tv/directory/all/tags). The list doesnt include Category Tags.
	// Deprecated:
	TagIds []string `json:"tag_ids"`

	// Tags The tags applied to the stream.
	Tags []string `json:"tags"`

	// ThumbnailUrl A URL to an image of a frame from the last 5 minutes of the stream. Replace the width and height placeholders in the URL (`{width}x{height}`) with the size of the image you want, in pixels.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The streams title. Is an empty string if not set.
	Title string `json:"title"`

	// Type The type of stream. Possible values are:
	//
	// * live
	//
	// If an error occurs, this field is set to an empty string.
	Type StreamType `json:"type"`

	// UserId The ID of the user thats broadcasting the stream.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`

	// ViewerCount The number of users watching the stream.
	ViewerCount int32 `json:"viewer_count"`
}

func (datatype Stream) GetGameId() string {
	return datatype.GameId
}
func (datatype Stream) GetGameName() string {
	return datatype.GameName
}
func (datatype Stream) GetId() string {
	return datatype.Id
}
func (datatype Stream) GetIsMature() bool {
	return datatype.IsMature
}
func (datatype Stream) GetLanguage() string {
	return datatype.Language
}
func (datatype Stream) GetStartedAt() time.Time {
	return datatype.StartedAt
}
func (datatype Stream) GetTagIds() []string {
	return datatype.TagIds
}
func (datatype Stream) GetTags() []string {
	return datatype.Tags
}
func (datatype Stream) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Stream) GetTitle() string {
	return datatype.Title
}
func (datatype Stream) GetType() StreamType {
	return datatype.Type
}
func (datatype Stream) GetUserId() string {
	return datatype.UserId
}
func (datatype Stream) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Stream) GetUserName() string {
	return datatype.UserName
}
func (datatype Stream) GetViewerCount() int32 {
	return datatype.ViewerCount
}

// StreamType The type of stream. Possible values are:
//
// * live
//
// If an error occurs, this field is set to an empty string.
type StreamType string

// StreamMarkerCreated defines model for StreamMarkerCreated.
type StreamMarkerCreated struct {
	// CreatedAt The UTC date and time (in RFC3339 format) of when the user created the marker.
	CreatedAt time.Time `json:"created_at"`

	// Description A description that the user gave the marker to help them remember why they marked the location.
	Description string `json:"description"`

	// Id An ID that identifies this marker.
	Id string `json:"id"`

	// PositionSeconds The relative offset (in seconds) of the marker from the beginning of the stream.
	PositionSeconds int32 `json:"position_seconds"`
}

func (datatype StreamMarkerCreated) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype StreamMarkerCreated) GetDescription() string {
	return datatype.Description
}
func (datatype StreamMarkerCreated) GetId() string {
	return datatype.Id
}
func (datatype StreamMarkerCreated) GetPositionSeconds() int32 {
	return datatype.PositionSeconds
}

// StreamMarkers defines model for StreamMarkers.
type StreamMarkers struct {
	// Markers The list of markers in this video. The list in ascending order by when the marker was created.
	Markers []struct {
		// CreatedAt The UTC date and time (in RFC3339 format) of when the user created the marker.
		CreatedAt time.Time `json:"created_at"`

		// Description The description that the user gave the marker to help them remember why they marked the location. Is an empty string if the user didnt provide one.
		Description string `json:"description"`

		// Id An ID that identifies this marker.
		Id string `json:"id"`

		// PositionSeconds The relative offset (in seconds) of the marker from the beginning of the stream.
		PositionSeconds int32 `json:"position_seconds"`

		// Url A URL that opens the video in Twitch Highlighter.
		Url string `json:"url"`
	} `json:"markers"`

	// UserId The ID of the user that created the marker.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`

	// VideoId An ID that identifies this video.
	VideoId string `json:"video_id"`

	// Videos A list of videos that contain markers. The list contains a single video.
	Videos []map[string]interface{} `json:"videos"`
}

func (datatype StreamMarkers) GetMarkers() []struct {
	// CreatedAt The UTC date and time (in RFC3339 format) of when the user created the marker.
	CreatedAt time.Time `json:"created_at"`

	// Description The description that the user gave the marker to help them remember why they marked the location. Is an empty string if the user didnt provide one.
	Description string `json:"description"`

	// Id An ID that identifies this marker.
	Id string `json:"id"`

	// PositionSeconds The relative offset (in seconds) of the marker from the beginning of the stream.
	PositionSeconds int32 `json:"position_seconds"`

	// Url A URL that opens the video in Twitch Highlighter.
	Url string `json:"url"`
} {
	return datatype.Markers
}
func (datatype StreamMarkers) GetUserId() string {
	return datatype.UserId
}
func (datatype StreamMarkers) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype StreamMarkers) GetUserName() string {
	return datatype.UserName
}
func (datatype StreamMarkers) GetVideoId() string {
	return datatype.VideoId
}
func (datatype StreamMarkers) GetVideos() []map[string]interface{} {
	return datatype.Videos
}

// StreamTag defines model for StreamTag.
type StreamTag struct {
	// IsAuto A Boolean value that determines whether the tag is an automatic tag. An automatic tag is one that Twitch adds to the stream. Broadcasters may not add automatic tags to their channel. The value is **true** if the tag is an automatic tag; otherwise, **false**.
	IsAuto bool `json:"is_auto"`

	// LocalizationDescriptions A dictionary that contains the localized descriptions of the tag. The key is in the form, <locale>-<coutry/region>. For example, en-us. The value is the localized description.
	LocalizationDescriptions map[string]string `json:"localization_descriptions"`

	// LocalizationNames A dictionary that contains the localized names of the tag. The key is in the form, <locale>-<coutry/region>. For example, en-us. The value is the localized name.
	LocalizationNames map[string]string `json:"localization_names"`

	// TagId An ID that identifies this tag.
	TagId string `json:"tag_id"`
}

func (datatype StreamTag) GetIsAuto() bool {
	return datatype.IsAuto
}
func (datatype StreamTag) GetLocalizationDescriptions() map[string]string {
	return datatype.LocalizationDescriptions
}
func (datatype StreamTag) GetLocalizationNames() map[string]string {
	return datatype.LocalizationNames
}
func (datatype StreamTag) GetTagId() string {
	return datatype.TagId
}

// Team defines model for Team.
type Team struct {
	// BackgroundImageUrl A URL to the teams background image.
	BackgroundImageUrl string `json:"background_image_url"`

	// Banner A URL to the teams banner.
	Banner string `json:"banner"`

	// CreatedAt The UTC date and time (in RFC3339 format) of when the team was created.
	CreatedAt time.Time `json:"created_at"`

	// Id An ID that identifies the team.
	Id string `json:"id"`

	// Info The teams description. The description may contain formatting such as Markdown, HTML, newline (\\n) characters, etc.
	Info string `json:"info"`

	// TeamDisplayName The teams display name.
	TeamDisplayName string `json:"team_display_name"`

	// TeamName The teams name.
	TeamName string `json:"team_name"`

	// ThumbnailUrl A URL to a thumbnail image of the teams logo.
	ThumbnailUrl string `json:"thumbnail_url"`

	// UpdatedAt The UTC date and time (in RFC3339 format) of the last time the team was updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Users The list of team members.
	Users []struct {
		// UserId An ID that identifies the team member.
		UserId string `json:"user_id"`

		// UserLogin The team members login name.
		UserLogin string `json:"user_login"`

		// UserName The team members display name.
		UserName string `json:"user_name"`
	} `json:"users"`
}

func (datatype Team) GetBackgroundImageUrl() string {
	return datatype.BackgroundImageUrl
}
func (datatype Team) GetBanner() string {
	return datatype.Banner
}
func (datatype Team) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Team) GetId() string {
	return datatype.Id
}
func (datatype Team) GetInfo() string {
	return datatype.Info
}
func (datatype Team) GetTeamDisplayName() string {
	return datatype.TeamDisplayName
}
func (datatype Team) GetTeamName() string {
	return datatype.TeamName
}
func (datatype Team) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Team) GetUpdatedAt() time.Time {
	return datatype.UpdatedAt
}
func (datatype Team) GetUsers() []struct {
	// UserId An ID that identifies the team member.
	UserId string `json:"user_id"`

	// UserLogin The team members login name.
	UserLogin string `json:"user_login"`

	// UserName The team members display name.
	UserName string `json:"user_name"`
} {
	return datatype.Users
}

// UpdateAutoModSettingsBody defines model for UpdateAutoModSettingsBody.
type UpdateAutoModSettingsBody struct {
	// Aggression The Automod level for hostility involving aggression.
	Aggression *int32 `json:"aggression,omitempty"`

	// Bullying The Automod level for hostility involving name calling or insults.
	Bullying *int32 `json:"bullying,omitempty"`

	// Disability The Automod level for discrimination against disability.
	Disability *int32 `json:"disability,omitempty"`

	// Misogyny The Automod level for discrimination against women.
	Misogyny *int32 `json:"misogyny,omitempty"`

	// OverallLevel The default AutoMod level for the broadcaster.
	OverallLevel *int32 `json:"overall_level,omitempty"`

	// RaceEthnicityOrReligion The Automod level for racial discrimination.
	RaceEthnicityOrReligion *int32 `json:"race_ethnicity_or_religion,omitempty"`

	// SexBasedTerms The Automod level for sexual content.
	SexBasedTerms *int32 `json:"sex_based_terms,omitempty"`

	// SexualitySexOrGender The AutoMod level for discrimination based on sexuality, sex, or gender.
	SexualitySexOrGender *int32 `json:"sexuality_sex_or_gender,omitempty"`

	// Swearing The Automod level for profanity.
	Swearing *int32 `json:"swearing,omitempty"`
}

func (datatype UpdateAutoModSettingsBody) GetAggression() int32 {
	if datatype.Aggression == nil {
		var empty int32
		return empty
	}
	return *datatype.Aggression
}
func (datatype UpdateAutoModSettingsBody) GetBullying() int32 {
	if datatype.Bullying == nil {
		var empty int32
		return empty
	}
	return *datatype.Bullying
}
func (datatype UpdateAutoModSettingsBody) GetDisability() int32 {
	if datatype.Disability == nil {
		var empty int32
		return empty
	}
	return *datatype.Disability
}
func (datatype UpdateAutoModSettingsBody) GetMisogyny() int32 {
	if datatype.Misogyny == nil {
		var empty int32
		return empty
	}
	return *datatype.Misogyny
}
func (datatype UpdateAutoModSettingsBody) GetOverallLevel() int32 {
	if datatype.OverallLevel == nil {
		var empty int32
		return empty
	}
	return *datatype.OverallLevel
}
func (datatype UpdateAutoModSettingsBody) GetRaceEthnicityOrReligion() int32 {
	if datatype.RaceEthnicityOrReligion == nil {
		var empty int32
		return empty
	}
	return *datatype.RaceEthnicityOrReligion
}
func (datatype UpdateAutoModSettingsBody) GetSexBasedTerms() int32 {
	if datatype.SexBasedTerms == nil {
		var empty int32
		return empty
	}
	return *datatype.SexBasedTerms
}
func (datatype UpdateAutoModSettingsBody) GetSexualitySexOrGender() int32 {
	if datatype.SexualitySexOrGender == nil {
		var empty int32
		return empty
	}
	return *datatype.SexualitySexOrGender
}
func (datatype UpdateAutoModSettingsBody) GetSwearing() int32 {
	if datatype.Swearing == nil {
		var empty int32
		return empty
	}
	return *datatype.Swearing
}

// UpdateAutoModSettingsResponse defines model for UpdateAutoModSettingsResponse.
type UpdateAutoModSettingsResponse struct {
	// Data The list of AutoMod settings. The list contains a single object that contains all the AutoMod settings.
	Data []AutoModSettings `json:"data"`
}

func (datatype UpdateAutoModSettingsResponse) GetData() []AutoModSettings {
	return datatype.Data
}

// UpdateChannelGuestStarSettingsBody defines model for UpdateChannelGuestStarSettingsBody.
type UpdateChannelGuestStarSettingsBody struct {
	// GroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
	//
	// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
	// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
	// * `HORIZONTAL_LAYOUT`: All live guests are arranged in a horizontal bar within the browser source
	// * `VERTICAL_LAYOUT`: All live guests are arranged in a vertical bar within the browser source
	GroupLayout *UpdateChannelGuestStarSettingsBodyGroupLayout `json:"group_layout,omitempty"`

	// IsBrowserSourceAudioEnabled Flag determining if Browser Sources subscribed to sessions on this channel should output audio
	IsBrowserSourceAudioEnabled *bool `json:"is_browser_source_audio_enabled,omitempty"`

	// IsModeratorSendLiveEnabled Flag determining if Guest Star moderators have access to control whether a guest is live once assigned to a slot.
	IsModeratorSendLiveEnabled *bool `json:"is_moderator_send_live_enabled,omitempty"`

	// RegenerateBrowserSources Flag determining if Guest Star should regenerate the auth token associated with the channels browser sources. Providing a true value for this will immediately invalidate all browser sources previously configured in your streaming software.
	RegenerateBrowserSources *bool `json:"regenerate_browser_sources,omitempty"`

	// SlotCount Number of slots the Guest Star call interface will allow the host to add to a call. Required to be between 1 and 6.
	SlotCount *int32 `json:"slot_count,omitempty"`
}

func (datatype UpdateChannelGuestStarSettingsBody) GetGroupLayout() UpdateChannelGuestStarSettingsBodyGroupLayout {
	if datatype.GroupLayout == nil {
		var empty UpdateChannelGuestStarSettingsBodyGroupLayout
		return empty
	}
	return *datatype.GroupLayout
}
func (datatype UpdateChannelGuestStarSettingsBody) GetIsBrowserSourceAudioEnabled() bool {
	if datatype.IsBrowserSourceAudioEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsBrowserSourceAudioEnabled
}
func (datatype UpdateChannelGuestStarSettingsBody) GetIsModeratorSendLiveEnabled() bool {
	if datatype.IsModeratorSendLiveEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsModeratorSendLiveEnabled
}
func (datatype UpdateChannelGuestStarSettingsBody) GetRegenerateBrowserSources() bool {
	if datatype.RegenerateBrowserSources == nil {
		var empty bool
		return empty
	}
	return *datatype.RegenerateBrowserSources
}
func (datatype UpdateChannelGuestStarSettingsBody) GetSlotCount() int32 {
	if datatype.SlotCount == nil {
		var empty int32
		return empty
	}
	return *datatype.SlotCount
}

// UpdateChannelGuestStarSettingsBodyGroupLayout This setting determines how the guests within a session should be laid out within the browser source. Can be one of the following values:
//
// * `TILED_LAYOUT`: All live guests are tiled within the browser source with the same size.
// * `SCREENSHARE_LAYOUT`: All live guests are tiled within the browser source with the same size. If there is an active screen share, it is sized larger than the other guests.
// * `HORIZONTAL_LAYOUT`: All live guests are arranged in a horizontal bar within the browser source
// * `VERTICAL_LAYOUT`: All live guests are arranged in a vertical bar within the browser source
type UpdateChannelGuestStarSettingsBodyGroupLayout string

// UpdateChannelStreamScheduleSegmentBody defines model for UpdateChannelStreamScheduleSegmentBody.
type UpdateChannelStreamScheduleSegmentBody struct {
	// CategoryId The ID of the category that best represents the broadcasts content. To get the category ID, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
	CategoryId *string `json:"category_id,omitempty"`

	// Duration The length of time, in minutes, that the broadcast is scheduled to run. The duration must be in the range 30 through 1380 (23 hours).
	Duration *string `json:"duration,omitempty"`

	// IsCanceled A Boolean value that indicates whether the broadcast is canceled. Set to **true** to cancel the segment.
	//
	// **NOTE**: For recurring segments, the API cancels the first segment after the current UTC date and time and not the specified segment (unless the specified segment is the next segment after the current UTC date and time).
	IsCanceled *bool `json:"is_canceled,omitempty"`

	// StartTime The date and time that the broadcast segment starts. Specify the date and time in RFC3339 format (for example, 2022-08-02T06:00:00Z).
	//
	// **NOTE**: Only partners and affiliates may update a broadcasts start time and only for non-recurring segments.
	StartTime *time.Time `json:"start_time,omitempty"`

	// Timezone The time zone where the broadcast takes place. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\_York).
	Timezone *string `json:"timezone,omitempty"`

	// Title The broadcasts title. The title may contain a maximum of 140 characters.
	Title *string `json:"title,omitempty"`
}

func (datatype UpdateChannelStreamScheduleSegmentBody) GetCategoryId() string {
	if datatype.CategoryId == nil {
		var empty string
		return empty
	}
	return *datatype.CategoryId
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetDuration() string {
	if datatype.Duration == nil {
		var empty string
		return empty
	}
	return *datatype.Duration
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetIsCanceled() bool {
	if datatype.IsCanceled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsCanceled
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetStartTime() time.Time {
	if datatype.StartTime == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartTime
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetTimezone() string {
	if datatype.Timezone == nil {
		var empty string
		return empty
	}
	return *datatype.Timezone
}
func (datatype UpdateChannelStreamScheduleSegmentBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// UpdateChannelStreamScheduleSegmentResponse defines model for UpdateChannelStreamScheduleSegmentResponse.
type UpdateChannelStreamScheduleSegmentResponse struct {
	// Data The broadcasters streaming scheduled.
	Data struct {
		// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
		BroadcasterId string `json:"broadcaster_id"`

		// BroadcasterLogin The broadcasters login name.
		BroadcasterLogin string `json:"broadcaster_login"`

		// BroadcasterName The broadcasters display name.
		BroadcasterName string `json:"broadcaster_name"`

		// Segments A list that contains the single broadcast segment that you updated.
		Segments []ChannelStreamScheduleSegment `json:"segments"`

		// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
		Vacation struct {
			// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
			EndTime time.Time `json:"end_time"`

			// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
			StartTime time.Time `json:"start_time"`
		} `json:"vacation"`
	} `json:"data"`
}

func (datatype UpdateChannelStreamScheduleSegmentResponse) GetData() struct {
	// BroadcasterId The ID of the broadcaster that owns the broadcast schedule.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// Segments A list that contains the single broadcast segment that you updated.
	Segments []ChannelStreamScheduleSegment `json:"segments"`

	// Vacation The dates when the broadcaster is on vacation and not streaming. Is set to **null** if vacation mode is not enabled.
	Vacation struct {
		// EndTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation ends.
		EndTime time.Time `json:"end_time"`

		// StartTime The UTC date and time (in RFC3339 format) of when the broadcasters vacation starts.
		StartTime time.Time `json:"start_time"`
	} `json:"vacation"`
} {
	return datatype.Data
}

// UpdateChatSettingsBody defines model for UpdateChatSettingsBody.
type UpdateChatSettingsBody struct {
	// EmoteMode A Boolean value that determines whether chat messages must contain only emotes.
	//
	// Set to **true** if only emotes are allowed; otherwise, **false**. The default is **false**.
	EmoteMode *bool `json:"emote_mode,omitempty"`

	// FollowerMode A Boolean value that determines whether the broadcaster restricts the chat room to followers only.
	//
	// Set to **true** if the broadcaster restricts the chat room to followers only; otherwise, **false**. The default is **true**.
	//
	// To specify how long users must follow the broadcaster before being able to participate in the chat room, see the `follower_mode_duration` field.
	FollowerMode *bool `json:"follower_mode,omitempty"`

	// FollowerModeDuration The length of time, in minutes, that users must follow the broadcaster before being able to participate in the chat room. Set only if `follower_mode` is **true**. Possible values are: 0 (no restriction) through 129600 (3 months). The default is 0.
	FollowerModeDuration *int32 `json:"follower_mode_duration,omitempty"`

	// NonModeratorChatDelay A Boolean value that determines whether the broadcaster adds a short delay before chat messages appear in the chat room. This gives chat moderators and bots a chance to remove them before viewers can see the message.
	//
	// Set to **true** if the broadcaster applies a delay; otherwise, **false**. The default is **false**.
	//
	// To specify the length of the delay, see the `non_moderator_chat_delay_duration` field.
	NonModeratorChatDelay *bool `json:"non_moderator_chat_delay,omitempty"`

	// NonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Set only if `non_moderator_chat_delay` is **true**. Possible values are:
	//
	// * 2  2 second delay (recommended)
	// * 4  4 second delay
	// * 6  6 second delay
	NonModeratorChatDelayDuration *UpdateChatSettingsBodyNonModeratorChatDelayDuration `json:"non_moderator_chat_delay_duration,omitempty"`

	// SlowMode A Boolean value that determines whether the broadcaster limits how often users in the chat room are allowed to send messages. Set to **true** if the broadcaster applies a wait period between messages; otherwise, **false**. The default is **false**.
	//
	// To specify the delay, see the `slow_mode_wait_time` field.
	SlowMode *bool `json:"slow_mode,omitempty"`

	// SlowModeWaitTime The amount of time, in seconds, that users must wait between sending messages. Set only if `slow_mode` is **true**.
	//
	// Possible values are: 3 (3 second delay) through 120 (2 minute delay). The default is 30 seconds.
	SlowModeWaitTime *int32 `json:"slow_mode_wait_time,omitempty"`

	// SubscriberMode A Boolean value that determines whether only users that subscribe to the broadcasters channel may talk in the chat room.
	//
	// Set to **true** if the broadcaster restricts the chat room to subscribers only; otherwise, **false**. The default is **false**.
	SubscriberMode *bool `json:"subscriber_mode,omitempty"`

	// UniqueChatMode A Boolean value that determines whether the broadcaster requires users to post only unique messages in the chat room.
	//
	// Set to **true** if the broadcaster allows only unique messages; otherwise, **false**. The default is **false**.
	UniqueChatMode *bool `json:"unique_chat_mode,omitempty"`
}

func (datatype UpdateChatSettingsBody) GetEmoteMode() bool {
	if datatype.EmoteMode == nil {
		var empty bool
		return empty
	}
	return *datatype.EmoteMode
}
func (datatype UpdateChatSettingsBody) GetFollowerMode() bool {
	if datatype.FollowerMode == nil {
		var empty bool
		return empty
	}
	return *datatype.FollowerMode
}
func (datatype UpdateChatSettingsBody) GetFollowerModeDuration() int32 {
	if datatype.FollowerModeDuration == nil {
		var empty int32
		return empty
	}
	return *datatype.FollowerModeDuration
}
func (datatype UpdateChatSettingsBody) GetNonModeratorChatDelay() bool {
	if datatype.NonModeratorChatDelay == nil {
		var empty bool
		return empty
	}
	return *datatype.NonModeratorChatDelay
}
func (datatype UpdateChatSettingsBody) GetNonModeratorChatDelayDuration() UpdateChatSettingsBodyNonModeratorChatDelayDuration {
	if datatype.NonModeratorChatDelayDuration == nil {
		var empty UpdateChatSettingsBodyNonModeratorChatDelayDuration
		return empty
	}
	return *datatype.NonModeratorChatDelayDuration
}
func (datatype UpdateChatSettingsBody) GetSlowMode() bool {
	if datatype.SlowMode == nil {
		var empty bool
		return empty
	}
	return *datatype.SlowMode
}
func (datatype UpdateChatSettingsBody) GetSlowModeWaitTime() int32 {
	if datatype.SlowModeWaitTime == nil {
		var empty int32
		return empty
	}
	return *datatype.SlowModeWaitTime
}
func (datatype UpdateChatSettingsBody) GetSubscriberMode() bool {
	if datatype.SubscriberMode == nil {
		var empty bool
		return empty
	}
	return *datatype.SubscriberMode
}
func (datatype UpdateChatSettingsBody) GetUniqueChatMode() bool {
	if datatype.UniqueChatMode == nil {
		var empty bool
		return empty
	}
	return *datatype.UniqueChatMode
}

// UpdateChatSettingsBodyNonModeratorChatDelayDuration The amount of time, in seconds, that messages are delayed before appearing in chat. Set only if `non_moderator_chat_delay` is **true**. Possible values are:
//
// * 2  2 second delay (recommended)
// * 4  4 second delay
// * 6  6 second delay
type UpdateChatSettingsBodyNonModeratorChatDelayDuration int32

// UpdateChatSettingsResponse defines model for UpdateChatSettingsResponse.
type UpdateChatSettingsResponse struct {
	// Data The list of chat settings. The list contains a single object with all the settings.
	Data []ChatSettingsUpdated `json:"data"`
}

func (datatype UpdateChatSettingsResponse) GetData() []ChatSettingsUpdated {
	return datatype.Data
}

// UpdateConduitShardsBody defines model for UpdateConduitShardsBody.
type UpdateConduitShardsBody struct {
	// ConduitId Conduit ID.
	ConduitId string `json:"conduit_id"`

	// Shards List of shards to update.
	Shards []struct {
		// Id Shard ID.
		Id string `json:"id"`

		// Transport The transport details that you want Twitch to use when sending you notifications.
		Transport struct {
			// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See Processing an event.Specify this field only if method is set to webhook.NOTE: Redirects are not followed.
			Callback *string `json:"callback,omitempty"`

			// Method The transport method. Possible values are:
			//
			// * webhook
			// * websocket
			Method *UpdateConduitShardsBodyShardsTransportMethod `json:"method,omitempty"`

			// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see Verifying the event message.Specify this field only if method is set to webhook.
			Secret *string `json:"secret,omitempty"`

			// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message.Specify this field only if method is set to websocket.
			SessionId *string `json:"session_id,omitempty"`
		} `json:"transport"`
	} `json:"shards"`
}

func (datatype UpdateConduitShardsBody) GetConduitId() string {
	return datatype.ConduitId
}
func (datatype UpdateConduitShardsBody) GetShards() []struct {
	// Id Shard ID.
	Id string `json:"id"`

	// Transport The transport details that you want Twitch to use when sending you notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. The URL must use the HTTPS protocol and port 443\. See Processing an event.Specify this field only if method is set to webhook.NOTE: Redirects are not followed.
		Callback *string `json:"callback,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method *UpdateConduitShardsBodyShardsTransportMethod `json:"method,omitempty"`

		// Secret The secret used to verify the signature. The secret must be an ASCII string thats a minimum of 10 characters long and a maximum of 100 characters long. For information about how the secret is used, see Verifying the event message.Specify this field only if method is set to webhook.
		Secret *string `json:"secret,omitempty"`

		// SessionId An ID that identifies the WebSocket to send notifications to. When you connect to EventSub using WebSockets, the server returns the ID in the Welcome message.Specify this field only if method is set to websocket.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`
} {
	return datatype.Shards
}

// UpdateConduitShardsBodyShardsTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type UpdateConduitShardsBodyShardsTransportMethod string

// UpdateConduitShardsResponse defines model for UpdateConduitShardsResponse.
type UpdateConduitShardsResponse struct {
	// Data List of successful shard updates.
	Data []struct {
		// Id Shard ID.
		Id string `json:"id"`

		// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
		//
		// * enabled  The shard is enabled.
		// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
		// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
		// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
		// * websocket\_disconnected  The client closed the connection.
		// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
		// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
		// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
		// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
		// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
		// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
		Status UpdateConduitShardsResponseDataStatus `json:"status"`

		// Transport The transport details used to send the notifications.
		Transport struct {
			// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
			Callback *string `json:"callback,omitempty"`

			// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
			ConnectedAt *time.Time `json:"connected_at,omitempty"`

			// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
			DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

			// Method The transport method. Possible values are:
			//
			// * webhook
			// * websocket
			Method UpdateConduitShardsResponseDataTransportMethod `json:"method"`

			// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
			SessionId *string `json:"session_id,omitempty"`
		} `json:"transport"`
	} `json:"data"`

	// Errors List of unsuccessful updates.
	Errors []struct {
		// Code Error codes used to represent a specific error condition while attempting to update shards.
		Code string `json:"code"`

		// Id Shard ID.
		Id string `json:"id"`

		// Message The error that occurred while updating the shard. Possible errors:
		//
		// * The length of the string in the secret field is not valid.
		// * The URL in the transport's callback field is not valid. The URL must use the HTTPS protocol and the 443 port number.
		// * The value specified in the method field is not valid.
		// * The callback field is required if you specify the webhook transport method.
		// * The session\_id field is required if you specify the WebSocket transport method.
		// * The websocket session is not connected.
		// * The shard id is outside of the conduits range.
		Message string `json:"message"`
	} `json:"errors"`
}

func (datatype UpdateConduitShardsResponse) GetData() []struct {
	// Id Shard ID.
	Id string `json:"id"`

	// Status The shard status. The subscriber receives events only for enabled shards. Possible values are:
	//
	// * enabled  The shard is enabled.
	// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	Status UpdateConduitShardsResponseDataStatus `json:"status"`

	// Transport The transport details used to send the notifications.
	Transport struct {
		// Callback The callback URL where the notifications are sent. Included only if method is set to webhook.
		Callback *string `json:"callback,omitempty"`

		// ConnectedAt The UTC date and time that the WebSocket connection was established. Included only if method is set to websocket.
		ConnectedAt *time.Time `json:"connected_at,omitempty"`

		// DisconnectedAt The UTC date and time that the WebSocket connection was lost. Included only if method is set to websocket.
		DisconnectedAt *time.Time `json:"disconnected_at,omitempty"`

		// Method The transport method. Possible values are:
		//
		// * webhook
		// * websocket
		Method UpdateConduitShardsResponseDataTransportMethod `json:"method"`

		// SessionId An ID that identifies the WebSocket that notifications are sent to. Included only if method is set to websocket.
		SessionId *string `json:"session_id,omitempty"`
	} `json:"transport"`
} {
	return datatype.Data
}
func (datatype UpdateConduitShardsResponse) GetErrors() []struct {
	// Code Error codes used to represent a specific error condition while attempting to update shards.
	Code string `json:"code"`

	// Id Shard ID.
	Id string `json:"id"`

	// Message The error that occurred while updating the shard. Possible errors:
	//
	// * The length of the string in the secret field is not valid.
	// * The URL in the transport's callback field is not valid. The URL must use the HTTPS protocol and the 443 port number.
	// * The value specified in the method field is not valid.
	// * The callback field is required if you specify the webhook transport method.
	// * The session\_id field is required if you specify the WebSocket transport method.
	// * The websocket session is not connected.
	// * The shard id is outside of the conduits range.
	Message string `json:"message"`
} {
	return datatype.Errors
}

// UpdateConduitShardsResponseDataStatus The shard status. The subscriber receives events only for enabled shards. Possible values are:
//
// * enabled  The shard is enabled.
// * webhook\_callback\_verification\_pending  The shard is pending verification of the specified callback URL.
// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
// * websocket\_disconnected  The client closed the connection.
// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
type UpdateConduitShardsResponseDataStatus string

// UpdateConduitShardsResponseDataTransportMethod The transport method. Possible values are:
//
// * webhook
// * websocket
type UpdateConduitShardsResponseDataTransportMethod string

// UpdateConduitsBody defines model for UpdateConduitsBody.
type UpdateConduitsBody struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount The new number of shards for this conduit.
	ShardCount int32 `json:"shard_count"`
}

func (datatype UpdateConduitsBody) GetId() string {
	return datatype.Id
}
func (datatype UpdateConduitsBody) GetShardCount() int32 {
	return datatype.ShardCount
}

// UpdateConduitsResponse defines model for UpdateConduitsResponse.
type UpdateConduitsResponse struct {
	// Data List of information about the clients conduits.
	Data []struct {
		// Id Conduit ID.
		Id string `json:"id"`

		// ShardCount Number of shards associated with this conduit after the update.
		ShardCount int32 `json:"shard_count"`
	} `json:"data"`
}

func (datatype UpdateConduitsResponse) GetData() []struct {
	// Id Conduit ID.
	Id string `json:"id"`

	// ShardCount Number of shards associated with this conduit after the update.
	ShardCount int32 `json:"shard_count"`
} {
	return datatype.Data
}

// UpdateCustomRewardBody defines model for UpdateCustomRewardBody.
type UpdateCustomRewardBody struct {
	// BackgroundColor The background color to use for the reward. Specify the color using Hex format (for example, \\#00E5CB).
	BackgroundColor *string `json:"background_color,omitempty"`

	// Cost The cost of the reward, in channel points. The minimum is 1 point.
	Cost *int64 `json:"cost,omitempty"`

	// GlobalCooldownSeconds The cooldown period, in seconds. Applied only if `is_global_cooldown_enabled` is **true**. The minimum value is 1; however, for it to be shown in the Twitch UX, the minimum value is 60.
	GlobalCooldownSeconds *int64 `json:"global_cooldown_seconds,omitempty"`

	// IsEnabled A Boolean value that indicates whether the reward is enabled. Set to **true** to enable the reward. Viewers see only enabled rewards.
	IsEnabled *bool `json:"is_enabled,omitempty"`

	// IsGlobalCooldownEnabled A Boolean value that determines whether to apply a cooldown period between redemptions. Set to **true** to apply a cooldown period. For the duration of the cooldown period, see `global_cooldown_seconds`.
	IsGlobalCooldownEnabled *bool `json:"is_global_cooldown_enabled,omitempty"`

	// IsMaxPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per live stream (see the `max_per_stream` field). Set to **true** to limit redemptions.
	IsMaxPerStreamEnabled *bool `json:"is_max_per_stream_enabled,omitempty"`

	// IsMaxPerUserPerStreamEnabled A Boolean value that determines whether to limit the maximum number of redemptions allowed per user per stream (see `max_per_user_per_stream`). The minimum value is 1\. Set to **true** to limit redemptions.
	IsMaxPerUserPerStreamEnabled *bool `json:"is_max_per_user_per_stream_enabled,omitempty"`

	// IsPaused A Boolean value that determines whether to pause the reward. Set to **true** to pause the reward. Viewers cant redeem paused rewards..
	IsPaused *bool `json:"is_paused,omitempty"`

	// IsUserInputRequired A Boolean value that determines whether users must enter information to redeem the reward. Set to **true** if user input is required. See the `prompt` field.
	IsUserInputRequired *bool `json:"is_user_input_required,omitempty"`

	// MaxPerStream The maximum number of redemptions allowed per live stream. Applied only if `is_max_per_stream_enabled` is **true**. The minimum value is 1.
	MaxPerStream *int64 `json:"max_per_stream,omitempty"`

	// MaxPerUserPerStream The maximum number of redemptions allowed per user per stream. Applied only if `is_max_per_user_per_stream_enabled` is **true**.
	MaxPerUserPerStream *int64 `json:"max_per_user_per_stream,omitempty"`

	// Prompt The prompt shown to the viewer when they redeem the reward. Specify a prompt if `is_user_input_required` is **true**. The prompt is limited to a maximum of 200 characters.
	Prompt *string `json:"prompt,omitempty"`

	// ShouldRedemptionsSkipRequestQueue A Boolean value that determines whether redemptions should be set to FULFILLED status immediately when a reward is redeemed. If **false**, status is set to UNFULFILLED and follows the normal request queue process.
	ShouldRedemptionsSkipRequestQueue *bool `json:"should_redemptions_skip_request_queue,omitempty"`

	// Title The rewards title. The title may contain a maximum of 45 characters and it must be unique amongst all of the broadcasters custom rewards.
	Title *string `json:"title,omitempty"`
}

func (datatype UpdateCustomRewardBody) GetBackgroundColor() string {
	if datatype.BackgroundColor == nil {
		var empty string
		return empty
	}
	return *datatype.BackgroundColor
}
func (datatype UpdateCustomRewardBody) GetCost() int64 {
	if datatype.Cost == nil {
		var empty int64
		return empty
	}
	return *datatype.Cost
}
func (datatype UpdateCustomRewardBody) GetGlobalCooldownSeconds() int64 {
	if datatype.GlobalCooldownSeconds == nil {
		var empty int64
		return empty
	}
	return *datatype.GlobalCooldownSeconds
}
func (datatype UpdateCustomRewardBody) GetIsEnabled() bool {
	if datatype.IsEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsEnabled
}
func (datatype UpdateCustomRewardBody) GetIsGlobalCooldownEnabled() bool {
	if datatype.IsGlobalCooldownEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsGlobalCooldownEnabled
}
func (datatype UpdateCustomRewardBody) GetIsMaxPerStreamEnabled() bool {
	if datatype.IsMaxPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerStreamEnabled
}
func (datatype UpdateCustomRewardBody) GetIsMaxPerUserPerStreamEnabled() bool {
	if datatype.IsMaxPerUserPerStreamEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsMaxPerUserPerStreamEnabled
}
func (datatype UpdateCustomRewardBody) GetIsPaused() bool {
	if datatype.IsPaused == nil {
		var empty bool
		return empty
	}
	return *datatype.IsPaused
}
func (datatype UpdateCustomRewardBody) GetIsUserInputRequired() bool {
	if datatype.IsUserInputRequired == nil {
		var empty bool
		return empty
	}
	return *datatype.IsUserInputRequired
}
func (datatype UpdateCustomRewardBody) GetMaxPerStream() int64 {
	if datatype.MaxPerStream == nil {
		var empty int64
		return empty
	}
	return *datatype.MaxPerStream
}
func (datatype UpdateCustomRewardBody) GetMaxPerUserPerStream() int64 {
	if datatype.MaxPerUserPerStream == nil {
		var empty int64
		return empty
	}
	return *datatype.MaxPerUserPerStream
}
func (datatype UpdateCustomRewardBody) GetPrompt() string {
	if datatype.Prompt == nil {
		var empty string
		return empty
	}
	return *datatype.Prompt
}
func (datatype UpdateCustomRewardBody) GetShouldRedemptionsSkipRequestQueue() bool {
	if datatype.ShouldRedemptionsSkipRequestQueue == nil {
		var empty bool
		return empty
	}
	return *datatype.ShouldRedemptionsSkipRequestQueue
}
func (datatype UpdateCustomRewardBody) GetTitle() string {
	if datatype.Title == nil {
		var empty string
		return empty
	}
	return *datatype.Title
}

// UpdateCustomRewardResponse defines model for UpdateCustomRewardResponse.
type UpdateCustomRewardResponse struct {
	// Data The list contains the single reward that you updated.
	Data []CustomReward `json:"data"`
}

func (datatype UpdateCustomRewardResponse) GetData() []CustomReward {
	return datatype.Data
}

// UpdateDropsEntitlementsBody defines model for UpdateDropsEntitlementsBody.
type UpdateDropsEntitlementsBody struct {
	// EntitlementIds A list of IDs that identify the entitlements to update. You may specify a maximum of 100 IDs.
	EntitlementIds *[]string `json:"entitlement_ids,omitempty"`

	// FulfillmentStatus The fulfillment status to set the entitlements to. Possible values are:
	//
	// * CLAIMED  The user claimed the benefit.
	// * FULFILLED  The developer granted the benefit that the user claimed.
	FulfillmentStatus *UpdateDropsEntitlementsBodyFulfillmentStatus `json:"fulfillment_status,omitempty"`
}

func (datatype UpdateDropsEntitlementsBody) GetEntitlementIds() []string {
	if datatype.EntitlementIds == nil {
		var empty []string
		return empty
	}
	return *datatype.EntitlementIds
}
func (datatype UpdateDropsEntitlementsBody) GetFulfillmentStatus() UpdateDropsEntitlementsBodyFulfillmentStatus {
	if datatype.FulfillmentStatus == nil {
		var empty UpdateDropsEntitlementsBodyFulfillmentStatus
		return empty
	}
	return *datatype.FulfillmentStatus
}

// UpdateDropsEntitlementsBodyFulfillmentStatus The fulfillment status to set the entitlements to. Possible values are:
//
// * CLAIMED  The user claimed the benefit.
// * FULFILLED  The developer granted the benefit that the user claimed.
type UpdateDropsEntitlementsBodyFulfillmentStatus string

// UpdateDropsEntitlementsResponse defines model for UpdateDropsEntitlementsResponse.
type UpdateDropsEntitlementsResponse struct {
	// Data A list that indicates which entitlements were successfully updated and those that werent.
	Data []DropsEntitlementUpdated `json:"data"`
}

func (datatype UpdateDropsEntitlementsResponse) GetData() []DropsEntitlementUpdated {
	return datatype.Data
}

// UpdateExtensionBitsProductBody defines model for UpdateExtensionBitsProductBody.
type UpdateExtensionBitsProductBody struct {
	// Cost An object that contains the product's cost information.
	Cost struct {
		// Amount The product's price.
		Amount int32 `json:"amount"`

		// Type The type of currency. Possible values are:
		//
		// * bits  The minimum price is 1 and the maximum is 10000.
		Type UpdateExtensionBitsProductBodyCostType `json:"type"`
	} `json:"cost"`

	// DisplayName The product's name as displayed in the extension. The maximum length is 255 characters.
	DisplayName string `json:"display_name"`

	// Expiration The date and time, in RFC3339 format, when the product expires. If not set, the product does not expire. To disable the product, set the expiration date to a date in the past.
	Expiration *time.Time `json:"expiration,omitempty"`

	// InDevelopment A Boolean value that indicates whether the product is in development. Set to **true** if the product is in development and not available for public use. The default is **false**.
	InDevelopment *bool `json:"in_development,omitempty"`

	// IsBroadcast A Boolean value that determines whether Bits product purchase events are broadcast to all instances of the extension on a channel. The events are broadcast via the `onTransactionComplete` helper callback. The default is **false**.
	IsBroadcast *bool `json:"is_broadcast,omitempty"`

	// Sku The product's SKU. The SKU must be unique within an extension. The product's SKU cannot be changed. The SKU may contain only alphanumeric characters, dashes (-), underscores (\_), and periods (.) and is limited to a maximum of 255 characters. No spaces.
	Sku string `json:"sku"`
}

func (datatype UpdateExtensionBitsProductBody) GetCost() struct {
	// Amount The product's price.
	Amount int32 `json:"amount"`

	// Type The type of currency. Possible values are:
	//
	// * bits  The minimum price is 1 and the maximum is 10000.
	Type UpdateExtensionBitsProductBodyCostType `json:"type"`
} {
	return datatype.Cost
}
func (datatype UpdateExtensionBitsProductBody) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype UpdateExtensionBitsProductBody) GetExpiration() time.Time {
	if datatype.Expiration == nil {
		var empty time.Time
		return empty
	}
	return *datatype.Expiration
}
func (datatype UpdateExtensionBitsProductBody) GetInDevelopment() bool {
	if datatype.InDevelopment == nil {
		var empty bool
		return empty
	}
	return *datatype.InDevelopment
}
func (datatype UpdateExtensionBitsProductBody) GetIsBroadcast() bool {
	if datatype.IsBroadcast == nil {
		var empty bool
		return empty
	}
	return *datatype.IsBroadcast
}
func (datatype UpdateExtensionBitsProductBody) GetSku() string {
	return datatype.Sku
}

// UpdateExtensionBitsProductBodyCostType The type of currency. Possible values are:
//
// * bits  The minimum price is 1 and the maximum is 10000.
type UpdateExtensionBitsProductBodyCostType string

// UpdateExtensionBitsProductResponse defines model for UpdateExtensionBitsProductResponse.
type UpdateExtensionBitsProductResponse struct {
	// Data A list of Bits products that the extension created. The list is in ascending SKU order. The list is empty if the extension hasn't created any products or they're all expired or disabled.
	Data []ExtensionBitsProduct `json:"data"`
}

func (datatype UpdateExtensionBitsProductResponse) GetData() []ExtensionBitsProduct {
	return datatype.Data
}

// UpdateRedemptionStatusBody defines model for UpdateRedemptionStatusBody.
type UpdateRedemptionStatusBody struct {
	// Status The status to set the redemption to. Possible values are:
	//
	// * CANCELED
	// * FULFILLED
	//
	// Setting the status to CANCELED refunds the users channel points.
	Status UpdateRedemptionStatusBodyStatus `json:"status"`
}

func (datatype UpdateRedemptionStatusBody) GetStatus() UpdateRedemptionStatusBodyStatus {
	return datatype.Status
}

// UpdateRedemptionStatusBodyStatus The status to set the redemption to. Possible values are:
//
// * CANCELED
// * FULFILLED
//
// Setting the status to CANCELED refunds the users channel points.
type UpdateRedemptionStatusBodyStatus string

// UpdateRedemptionStatusResponse defines model for UpdateRedemptionStatusResponse.
type UpdateRedemptionStatusResponse struct {
	// Data The list contains the single redemption that you updated.
	Data []CustomRewardRedemption `json:"data"`
}

func (datatype UpdateRedemptionStatusResponse) GetData() []CustomRewardRedemption {
	return datatype.Data
}

// UpdateShieldModeStatusBody defines model for UpdateShieldModeStatusBody.
type UpdateShieldModeStatusBody struct {
	// IsActive A Boolean value that determines whether to activate Shield Mode. Set to **true** to activate Shield Mode; otherwise, **false** to deactivate Shield Mode.
	IsActive bool `json:"is_active"`
}

func (datatype UpdateShieldModeStatusBody) GetIsActive() bool {
	return datatype.IsActive
}

// UpdateShieldModeStatusResponse defines model for UpdateShieldModeStatusResponse.
type UpdateShieldModeStatusResponse struct {
	// Data A list that contains a single object with the broadcasters updated Shield Mode status.
	Data []struct {
		// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if Shield Mode is active; otherwise, **false**.
		IsActive bool `json:"is_active"`

		// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated.
		LastActivatedAt time.Time `json:"last_activated_at"`

		// ModeratorId An ID that identifies the moderator that last activated Shield Mode.
		ModeratorId string `json:"moderator_id"`

		// ModeratorLogin The moderators login name.
		ModeratorLogin string `json:"moderator_login"`

		// ModeratorName The moderators display name.
		ModeratorName string `json:"moderator_name"`
	} `json:"data"`
}

func (datatype UpdateShieldModeStatusResponse) GetData() []struct {
	// IsActive A Boolean value that determines whether Shield Mode is active. Is **true** if Shield Mode is active; otherwise, **false**.
	IsActive bool `json:"is_active"`

	// LastActivatedAt The UTC timestamp (in RFC3339 format) of when Shield Mode was last activated.
	LastActivatedAt time.Time `json:"last_activated_at"`

	// ModeratorId An ID that identifies the moderator that last activated Shield Mode.
	ModeratorId string `json:"moderator_id"`

	// ModeratorLogin The moderators login name.
	ModeratorLogin string `json:"moderator_login"`

	// ModeratorName The moderators display name.
	ModeratorName string `json:"moderator_name"`
} {
	return datatype.Data
}

// UpdateUserExtensionsBody defines model for UpdateUserExtensionsBody.
type UpdateUserExtensionsBody struct {
	// Data The extensions to update. The `data` field is a dictionary of extension types. The dictionarys possible keys are: panel, overlay, or component. The keys value is a dictionary of extensions.
	//
	// For the extensions dictionary, the key is a sequential number beginning with 1\. For panel and overlay extensions, the keys value is an object that contains the following fields: `active` (true/false), `id` (the extensions ID), and `version` (the extensions version).
	//
	// For component extensions, the keys value includes the above fields plus the `x` and `y` fields, which identify the coordinate where the extension is placed.
	Data struct {
		Component *map[string]UserExtensionComponentUpdate `json:"component,omitempty"`
		Overlay   *map[string]UserExtensionOverlayUpdate   `json:"overlay,omitempty"`
		Panel     *map[string]UserExtensionPanelUpdate     `json:"panel,omitempty"`
	} `json:"data"`
}

func (datatype UpdateUserExtensionsBody) GetData() struct {
	Component *map[string]UserExtensionComponentUpdate `json:"component,omitempty"`
	Overlay   *map[string]UserExtensionOverlayUpdate   `json:"overlay,omitempty"`
	Panel     *map[string]UserExtensionPanelUpdate     `json:"panel,omitempty"`
} {
	return datatype.Data
}

// UpdateUserExtensionsResponse defines model for UpdateUserExtensionsResponse.
type UpdateUserExtensionsResponse struct {
	// Data The extensions that the broadcaster updated.
	Data struct {
		// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
		Component map[string]UserExtensionComponent `json:"component"`

		// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
		Overlay map[string]UserExtensionOverlay `json:"overlay"`

		// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
		Panel map[string]UserExtensionPanel `json:"panel"`
	} `json:"data"`
}

func (datatype UpdateUserExtensionsResponse) GetData() struct {
	// Component A dictionary that contains the data for a video-component extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the components data for each key.
	Component map[string]UserExtensionComponent `json:"component"`

	// Overlay A dictionary that contains the data for a video-overlay extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the overlays data for each key.
	Overlay map[string]UserExtensionOverlay `json:"overlay"`

	// Panel A dictionary that contains the data for a panel extension. The dictionarys key is a sequential number beginning with 1\. The following fields contain the panels data for each key.
	Panel map[string]UserExtensionPanel `json:"panel"`
} {
	return datatype.Data
}

// UpdateUserResponse defines model for UpdateUserResponse.
type UpdateUserResponse struct {
	// Data A list contains the single user that you updated.
	Data []User `json:"data"`
}

func (datatype UpdateUserResponse) GetData() []User {
	return datatype.Data
}

// User defines model for User.
type User struct {
	// BroadcasterType The type of broadcaster. Possible values are:
	//
	// * affiliate  An [affiliate broadcaster](https://help.twitch.tv/s/article/joining-the-affiliate-program)
	// * partner  A [partner broadcaster](https://help.twitch.tv/s/article/partner-program-overview)
	// * ""  A normal broadcaster
	BroadcasterType UserBroadcasterType `json:"broadcaster_type"`

	// CreatedAt The UTC date and time that the user's account was created. The timestamp is in RFC3339 format.
	CreatedAt time.Time `json:"created_at"`

	// Description The user's description of their channel.
	Description string `json:"description"`

	// DisplayName The user's display name.
	DisplayName string `json:"display_name"`

	// Email The user's verified email address. The object includes this field only if the user access token includes the **user:read:email** scope.
	//
	// If the request contains more than one user, only the user associated with the access token that provided consent will include an email address  the email address for all other users will be empty.
	Email *string `json:"email,omitempty"`

	// Id An ID that identifies the user.
	Id string `json:"id"`

	// Login The user's login name.
	Login string `json:"login"`

	// OfflineImageUrl A URL to the user's offline image.
	OfflineImageUrl string `json:"offline_image_url"`

	// ProfileImageUrl A URL to the user's profile image.
	ProfileImageUrl string `json:"profile_image_url"`

	// Type The type of user. Possible values are:
	//
	// * admin  Twitch administrator
	// * global\_mod
	// * staff  Twitch staff
	// * ""  Normal user
	Type UserType `json:"type"`

	// ViewCount The number of times the user's channel has been viewed.
	//
	// **NOTE**: This field has been deprecated (see [Get Users API endpoint  "view\_count" deprecation](https://discuss.dev.twitch.tv/t/get-users-api-endpoint-view-count-deprecation/37777)). Any data in this field is not valid and should not be used.
	ViewCount int32 `json:"view_count"`
}

func (datatype User) GetBroadcasterType() UserBroadcasterType {
	return datatype.BroadcasterType
}
func (datatype User) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype User) GetDescription() string {
	return datatype.Description
}
func (datatype User) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype User) GetEmail() string {
	if datatype.Email == nil {
		var empty string
		return empty
	}
	return *datatype.Email
}
func (datatype User) GetId() string {
	return datatype.Id
}
func (datatype User) GetLogin() string {
	return datatype.Login
}
func (datatype User) GetOfflineImageUrl() string {
	return datatype.OfflineImageUrl
}
func (datatype User) GetProfileImageUrl() string {
	return datatype.ProfileImageUrl
}
func (datatype User) GetType() UserType {
	return datatype.Type
}
func (datatype User) GetViewCount() int32 {
	return datatype.ViewCount
}

// UserBroadcasterType The type of broadcaster. Possible values are:
//
// * affiliate  An [affiliate broadcaster](https://help.twitch.tv/s/article/joining-the-affiliate-program)
// * partner  A [partner broadcaster](https://help.twitch.tv/s/article/partner-program-overview)
// * ""  A normal broadcaster
type UserBroadcasterType string

// UserType The type of user. Possible values are:
//
// * admin  Twitch administrator
// * global\_mod
// * staff  Twitch staff
// * ""  Normal user
type UserType string

// UserBlockList defines model for UserBlockList.
type UserBlockList struct {
	// DisplayName The blocked users display name.
	DisplayName string `json:"display_name"`

	// UserId An ID that identifies the blocked user.
	UserId string `json:"user_id"`

	// UserLogin The blocked users login name.
	UserLogin string `json:"user_login"`
}

func (datatype UserBlockList) GetDisplayName() string {
	return datatype.DisplayName
}
func (datatype UserBlockList) GetUserId() string {
	return datatype.UserId
}
func (datatype UserBlockList) GetUserLogin() string {
	return datatype.UserLogin
}

// UserChatColor defines model for UserChatColor.
type UserChatColor struct {
	// Color The Hex color code that the user uses in chat for their name. If the user hasnt specified a color in their settings, the string is empty.
	Color string `json:"color"`

	// UserId An ID that uniquely identifies the user.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype UserChatColor) GetColor() string {
	return datatype.Color
}
func (datatype UserChatColor) GetUserId() string {
	return datatype.UserId
}
func (datatype UserChatColor) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype UserChatColor) GetUserName() string {
	return datatype.UserName
}

// UserExtension defines model for UserExtension.
type UserExtension struct {
	// CanActivate A Boolean value that determines whether the extension is configured and can be activated. Is **true** if the extension is configured and can be activated.
	CanActivate bool `json:"can_activate"`

	// Id An ID that identifies the extension.
	Id string `json:"id"`

	// Name The extension's name.
	Name string `json:"name"`

	// Type The extension types that you can activate for this extension. Possible values are:
	//
	// * component
	// * mobile
	// * overlay
	// * panel
	Type []UserExtensionType `json:"type"`

	// Version The extension's version.
	Version string `json:"version"`
}

func (datatype UserExtension) GetCanActivate() bool {
	return datatype.CanActivate
}
func (datatype UserExtension) GetId() string {
	return datatype.Id
}
func (datatype UserExtension) GetName() string {
	return datatype.Name
}
func (datatype UserExtension) GetType() []UserExtensionType {
	return datatype.Type
}
func (datatype UserExtension) GetVersion() string {
	return datatype.Version
}

// UserExtensionType defines model for UserExtension.Type.
type UserExtensionType string

// UserExtensionComponent defines model for UserExtensionComponent.
type UserExtensionComponent struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a component extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Name The extensions name.
	Name *string `json:"name,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`

	// X The x-coordinate where the extension is placed.
	X *int32 `json:"x,omitempty"`

	// Y The y-coordinate where the extension is placed.
	Y *int32 `json:"y,omitempty"`
}

func (datatype UserExtensionComponent) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionComponent) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionComponent) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype UserExtensionComponent) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}
func (datatype UserExtensionComponent) GetX() int32 {
	if datatype.X == nil {
		var empty int32
		return empty
	}
	return *datatype.X
}
func (datatype UserExtensionComponent) GetY() int32 {
	if datatype.Y == nil {
		var empty int32
		return empty
	}
	return *datatype.Y
}

// UserExtensionComponentUpdate defines model for UserExtensionComponentUpdate.
type UserExtensionComponentUpdate struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a component extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`

	// X The x-coordinate where the extension is placed.
	X *int32 `json:"x,omitempty"`

	// Y The y-coordinate where the extension is placed.
	Y *int32 `json:"y,omitempty"`
}

func (datatype UserExtensionComponentUpdate) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionComponentUpdate) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionComponentUpdate) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}
func (datatype UserExtensionComponentUpdate) GetX() int32 {
	if datatype.X == nil {
		var empty int32
		return empty
	}
	return *datatype.X
}
func (datatype UserExtensionComponentUpdate) GetY() int32 {
	if datatype.Y == nil {
		var empty int32
		return empty
	}
	return *datatype.Y
}

// UserExtensionOverlay defines model for UserExtensionOverlay.
type UserExtensionOverlay struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured an overlay extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Name The extensions name.
	Name *string `json:"name,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionOverlay) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionOverlay) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionOverlay) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype UserExtensionOverlay) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserExtensionOverlayUpdate defines model for UserExtensionOverlayUpdate.
type UserExtensionOverlayUpdate struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured an overlay extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionOverlayUpdate) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionOverlayUpdate) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionOverlayUpdate) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserExtensionPanel defines model for UserExtensionPanel.
type UserExtensionPanel struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a panel extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Name The extensions name.
	Name *string `json:"name,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionPanel) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionPanel) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionPanel) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype UserExtensionPanel) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserExtensionPanelUpdate defines model for UserExtensionPanelUpdate.
type UserExtensionPanelUpdate struct {
	// Active A Boolean value that determines the extensions activation state. If **false**, the user has not configured a panel extension.
	Active bool `json:"active"`

	// Id An ID that identifies the extension.
	Id *string `json:"id,omitempty"`

	// Version The extensions version.
	Version *string `json:"version,omitempty"`
}

func (datatype UserExtensionPanelUpdate) GetActive() bool {
	return datatype.Active
}
func (datatype UserExtensionPanelUpdate) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}
func (datatype UserExtensionPanelUpdate) GetVersion() string {
	if datatype.Version == nil {
		var empty string
		return empty
	}
	return *datatype.Version
}

// UserModerator defines model for UserModerator.
type UserModerator struct {
	// UserId The ID of the user that has permission to moderate the broadcasters channel.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype UserModerator) GetUserId() string {
	return datatype.UserId
}
func (datatype UserModerator) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype UserModerator) GetUserName() string {
	return datatype.UserName
}

// UserSubscription defines model for UserSubscription.
type UserSubscription struct {
	// BroadcasterId An ID that identifies the broadcaster.
	BroadcasterId string `json:"broadcaster_id"`

	// BroadcasterLogin The broadcasters login name.
	BroadcasterLogin string `json:"broadcaster_login"`

	// BroadcasterName The broadcasters display name.
	BroadcasterName string `json:"broadcaster_name"`

	// GifterId The ID of the user that gifted the subscription. The object includes this field only if `is_gift` is **true**.
	GifterId *string `json:"gifter_id,omitempty"`

	// GifterLogin The gifters login name. The object includes this field only if `is_gift` is **true**.
	GifterLogin *string `json:"gifter_login,omitempty"`

	// GifterName The gifters display name. The object includes this field only if `is_gift` is **true**.
	GifterName *string `json:"gifter_name,omitempty"`

	// IsGift A Boolean value that determines whether the subscription is a gift subscription. Is **true** if the subscription was gifted.
	IsGift bool `json:"is_gift"`

	// Tier The type of subscription. Possible values are:
	//
	// * 1000  Tier 1
	// * 2000  Tier 2
	// * 3000  Tier 3
	Tier UserSubscriptionTier `json:"tier"`
}

func (datatype UserSubscription) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UserSubscription) GetBroadcasterLogin() string {
	return datatype.BroadcasterLogin
}
func (datatype UserSubscription) GetBroadcasterName() string {
	return datatype.BroadcasterName
}
func (datatype UserSubscription) GetGifterId() string {
	if datatype.GifterId == nil {
		var empty string
		return empty
	}
	return *datatype.GifterId
}
func (datatype UserSubscription) GetGifterLogin() string {
	if datatype.GifterLogin == nil {
		var empty string
		return empty
	}
	return *datatype.GifterLogin
}
func (datatype UserSubscription) GetGifterName() string {
	if datatype.GifterName == nil {
		var empty string
		return empty
	}
	return *datatype.GifterName
}
func (datatype UserSubscription) GetIsGift() bool {
	return datatype.IsGift
}
func (datatype UserSubscription) GetTier() UserSubscriptionTier {
	return datatype.Tier
}

// UserSubscriptionTier The type of subscription. Possible values are:
//
// * 1000  Tier 1
// * 2000  Tier 2
// * 3000  Tier 3
type UserSubscriptionTier string

// UserVip defines model for UserVip.
type UserVip struct {
	// UserId An ID that uniquely identifies the VIP user.
	UserId string `json:"user_id"`

	// UserLogin The users login name.
	UserLogin string `json:"user_login"`

	// UserName The users display name.
	UserName string `json:"user_name"`
}

func (datatype UserVip) GetUserId() string {
	return datatype.UserId
}
func (datatype UserVip) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype UserVip) GetUserName() string {
	return datatype.UserName
}

// Video defines model for Video.
type Video struct {
	// CreatedAt The date and time, in UTC, of when the video was created. The timestamp is in RFC3339 format.
	CreatedAt time.Time `json:"created_at"`

	// Description The video's description.
	Description string `json:"description"`

	// Duration The video's length in ISO 8601 duration format. For example, 3m21s represents 3 minutes, 21 seconds.
	Duration string `json:"duration"`

	// Id An ID that identifies the video.
	Id string `json:"id"`

	// Language The ISO 639-1 two-letter language code that the video was broadcast in. For example, the language code is DE if the video was broadcast in German. For a list of supported languages, see [Supported Stream Language](https://help.twitch.tv/s/article/languages-on-twitch#streamlang). The language value is "other" if the video was broadcast in a language not in the list of supported languages.
	Language string `json:"language"`

	// MutedSegments The segments that Twitch Audio Recognition muted; otherwise, **null**.
	MutedSegments *[]struct {
		// Duration The duration of the muted segment, in seconds.
		Duration int32 `json:"duration"`

		// Offset The offset, in seconds, from the beginning of the video to where the muted segment begins.
		Offset int32 `json:"offset"`
	} `json:"muted_segments"`

	// PublishedAt The date and time, in UTC, of when the video was published. The timestamp is in RFC3339 format.
	PublishedAt time.Time `json:"published_at"`

	// StreamId The ID of the stream that the video originated from if the video's type is "archive;" otherwise, **null**.
	StreamId *string `json:"stream_id"`

	// ThumbnailUrl A URL to a thumbnail image of the video. Before using the URL, you must replace the `%{width}` and `%{height}` placeholders with the width and height of the thumbnail you want returned. Due to current limitations, `${width}` must be 320 and `${height}` must be 180.
	ThumbnailUrl string `json:"thumbnail_url"`

	// Title The video's title.
	Title string `json:"title"`

	// Type The video's type. Possible values are:
	//
	// * archive  An on-demand video (VOD) of one of the broadcaster's past streams.
	// * highlight  A highlight reel of one of the broadcaster's past streams. See [Creating Highlights](https://help.twitch.tv/s/article/creating-highlights-and-stream-markers).
	// * upload  A video that the broadcaster uploaded to their video library. See Upload under [Video Producer](https://help.twitch.tv/s/article/video-on-demand?language=en%5FUS#videoproducer).
	Type VideoType `json:"type"`

	// Url The video's URL.
	Url string `json:"url"`

	// UserId The ID of the broadcaster that owns the video.
	UserId string `json:"user_id"`

	// UserLogin The broadcaster's login name.
	UserLogin string `json:"user_login"`

	// UserName The broadcaster's display name.
	UserName string `json:"user_name"`

	// ViewCount The number of times that users have watched the video.
	ViewCount int32 `json:"view_count"`

	// Viewable The video's viewable state. Always set to **public**.
	Viewable string `json:"viewable"`
}

func (datatype Video) GetCreatedAt() time.Time {
	return datatype.CreatedAt
}
func (datatype Video) GetDescription() string {
	return datatype.Description
}
func (datatype Video) GetDuration() string {
	return datatype.Duration
}
func (datatype Video) GetId() string {
	return datatype.Id
}
func (datatype Video) GetLanguage() string {
	return datatype.Language
}
func (datatype Video) GetMutedSegments() []struct {
	// Duration The duration of the muted segment, in seconds.
	Duration int32 `json:"duration"`

	// Offset The offset, in seconds, from the beginning of the video to where the muted segment begins.
	Offset int32 `json:"offset"`
} {
	if datatype.MutedSegments == nil {
		var empty []struct {
			// Duration The duration of the muted segment, in seconds.
			Duration int32 `json:"duration"`

			// Offset The offset, in seconds, from the beginning of the video to where the muted segment begins.
			Offset int32 `json:"offset"`
		}
		return empty
	}
	return *datatype.MutedSegments
}
func (datatype Video) GetPublishedAt() time.Time {
	return datatype.PublishedAt
}
func (datatype Video) GetStreamId() string {
	if datatype.StreamId == nil {
		var empty string
		return empty
	}
	return *datatype.StreamId
}
func (datatype Video) GetThumbnailUrl() string {
	return datatype.ThumbnailUrl
}
func (datatype Video) GetTitle() string {
	return datatype.Title
}
func (datatype Video) GetType() VideoType {
	return datatype.Type
}
func (datatype Video) GetUrl() string {
	return datatype.Url
}
func (datatype Video) GetUserId() string {
	return datatype.UserId
}
func (datatype Video) GetUserLogin() string {
	return datatype.UserLogin
}
func (datatype Video) GetUserName() string {
	return datatype.UserName
}
func (datatype Video) GetViewCount() int32 {
	return datatype.ViewCount
}
func (datatype Video) GetViewable() string {
	return datatype.Viewable
}

// VideoType The video's type. Possible values are:
//
// * archive  An on-demand video (VOD) of one of the broadcaster's past streams.
// * highlight  A highlight reel of one of the broadcaster's past streams. See [Creating Highlights](https://help.twitch.tv/s/article/creating-highlights-and-stream-markers).
// * upload  A video that the broadcaster uploaded to their video library. See Upload under [Video Producer](https://help.twitch.tv/s/article/video-on-demand?language=en%5FUS#videoproducer).
type VideoType string

// WarnChatUserBody defines model for WarnChatUserBody.
type WarnChatUserBody struct {
	// Data A list that contains information about the warning.
	Data struct {
		// Reason A custom reason for the warning. **Max 500 chars.**
		Reason string `json:"reason"`

		// UserId The ID of the twitch user to be warned.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype WarnChatUserBody) GetData() struct {
	// Reason A custom reason for the warning. **Max 500 chars.**
	Reason string `json:"reason"`

	// UserId The ID of the twitch user to be warned.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

// WarnChatUserResponse defines model for WarnChatUserResponse.
type WarnChatUserResponse struct {
	// Data A list that contains information about the warning.
	Data []struct {
		// BroadcasterId The ID of the channel in which the warning will take effect.
		BroadcasterId string `json:"broadcaster_id"`

		// ModeratorId The ID of the user who applied the warning.
		ModeratorId string `json:"moderator_id"`

		// Reason The reason provided for warning.
		Reason string `json:"reason"`

		// UserId The ID of the warned user.
		UserId string `json:"user_id"`
	} `json:"data"`
}

func (datatype WarnChatUserResponse) GetData() []struct {
	// BroadcasterId The ID of the channel in which the warning will take effect.
	BroadcasterId string `json:"broadcaster_id"`

	// ModeratorId The ID of the user who applied the warning.
	ModeratorId string `json:"moderator_id"`

	// Reason The reason provided for warning.
	Reason string `json:"reason"`

	// UserId The ID of the warned user.
	UserId string `json:"user_id"`
} {
	return datatype.Data
}

//Generated with gorm/gorm.go.tmpl

type TXMiddleware func(in *gorm.DB) (out *gorm.DB)

// Generated with gorm/gorm-interface.go.tmpl
type GormInterface interface {
	//Transaction allows initiating a transaction from the root database object
	Transaction(fc func(tx *gorm.DB) error, opts ...*sql.TxOptions) (err error)
}

// Options struct
type txMiddlewaresOption struct {
	txMiddlewares []TXMiddleware
}
type returningObjOption struct {
	returningObj any
}
type transactionOption struct {
	transaction *gorm.DB
}
type updateOverrideOption struct {
	value any
}
type overrideSpanNameOption struct {
	name string
}
type closerFunctionOption struct {
	function TXMiddleware
}

// WithTxMiddlewares Allows the user to set and apply a series of middlewares that are added to the request.
func WithTxMiddlewares(txMiddlewares ...TXMiddleware) *txMiddlewaresOption {
	return &txMiddlewaresOption{txMiddlewares: txMiddlewares}
}

// WithReturningObject allows the user to set the object returned from the "Returning" call
func WithReturningObject(obj any) *returningObjOption {
	return &returningObjOption{returningObj: obj}
}

// WithTransaction Allows the user to pass in a transaction that can be used instead of the base request.
func WithTransaction(tx *gorm.DB) *transactionOption {
	return &transactionOption{transaction: tx}
}

// WithUpdateOverride Allows the user to pass in a value to use in the updates clause that is different from the normal update value.
//
// Deprecated: WithUpdateOverride exists for compatability.
// Use WithCloserFunc and a dedicated call to .Update() instead as that will have type safety.
func WithUpdateOverride(value any) *updateOverrideOption {
	return &updateOverrideOption{value: value}
}

// WithOverrideSpanNameOption Allows the user to pass in a custom span name that can be used to identify the request in the open telemetry traceing.
func WithOverrideSpanNameOption(name string) *overrideSpanNameOption {
	return &overrideSpanNameOption{name: name}
}

// WithCloserFunction Allows the user to pass in a function that will be called instead of the expected "closing" function.
// For example, this allows the user to specify a Count function instead of the normal .Find().
func WithCloserFunction(function TXMiddleware) *closerFunctionOption {
	return &closerFunctionOption{function: function}
}

// Generated with gorm/gorm-impl.go.tmpl
var _ GormInterface = (*GormImpl)(nil)

type GormImpl struct {
	DB              *gorm.DB
	Tracer          trace.Tracer
	CreateValidator *validator.Validate
	UpdateValidator *validator.Validate
	DeleteValidator *validator.Validate
}

func (g *GormImpl) Transaction(fc func(tx *gorm.DB) error, opts ...*sql.TxOptions) (err error) {
	return g.DB.Transaction(fc, opts...)
}

//Created by gorm-dataloader.go.tmpl/DataloaderStruct

type GormDataloader struct {
	g                    *GormImpl
	GormDataloaderParams GormDataloaderParams
}

type GormDataloaderParams struct {
}

func NewGormDataloader(g *GormImpl, params GormDataloaderParams) *GormDataloader {
	dl := &GormDataloader{
		g:                    g,
		GormDataloaderParams: params,
	}

	return dl
}

//Created by gorm-dataloader.go.tmpl/DataloaderDataloaders

//Generated with param-types.tmpl

// GetExtensionAnalyticsParams defines parameters for GetExtensionAnalytics.
type GetExtensionAnalyticsParams struct {
	// ExtensionId The extension's client ID. If specified, the response contains a report for the specified extension. If not specified, the response includes a report for each extension that the authenticated user owns.
	ExtensionId *string `form:"extension_id,omitempty" json:"extension_id,omitempty"`

	// Type The type of analytics report to get. Possible values are:
	//
	// * overview\_v2
	Type *GetExtensionAnalyticsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// StartedAt The reporting window's start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z).
	//
	// The start date must be on or after January 31, 2018\. If you specify an earlier date, the API ignores it and uses January 31, 2018\. If you specify a start date, you must specify an end date. If you don't specify a start and end date, the report includes all available data since January 31, 2018.
	//
	// The report contains one row of data for each day in the reporting window.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// EndedAt The reporting window's end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-27T00:00:00Z). The report is inclusive of the end date.
	//
	// Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date that's earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days.
	EndedAt *time.Time `form:"ended_at,omitempty" json:"ended_at,omitempty"`

	// First The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.
	//
	// **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// This parameter is ignored if the _extension\_id_ parameter is set.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetExtensionAnalyticsParams) GetExtensionId() string {
	if datatype.ExtensionId == nil {
		var empty string
		return empty
	}
	return *datatype.ExtensionId
}
func (datatype GetExtensionAnalyticsParams) GetType() GetExtensionAnalyticsParamsType {
	if datatype.Type == nil {
		var empty GetExtensionAnalyticsParamsType
		return empty
	}
	return *datatype.Type
}
func (datatype GetExtensionAnalyticsParams) GetStartedAt() time.Time {
	if datatype.StartedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartedAt
}
func (datatype GetExtensionAnalyticsParams) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype GetExtensionAnalyticsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetExtensionAnalyticsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetExtensionAnalyticsParamsType defines parameters for GetExtensionAnalytics.
type GetExtensionAnalyticsParamsType string

// GetGameAnalyticsParams defines parameters for GetGameAnalytics.
type GetGameAnalyticsParams struct {
	// GameId The games client ID. If specified, the response contains a report for the specified game. If not specified, the response includes a report for each of the authenticated users games.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Type The type of analytics report to get. Possible values are:
	//
	// * overview\_v2
	Type *GetGameAnalyticsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// StartedAt The reporting windows start date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). If you specify a start date, you must specify an end date.
	//
	// The start date must be within one year of todays date. If you specify an earlier date, the API ignores it and uses a date thats one year prior to todays date. If you dont specify a start and end date, the report includes all available data for the last 365 days from today.
	//
	// The report contains one row of data for each day in the reporting window.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// EndedAt The reporting windows end date, in RFC3339 format. Set the time portion to zeroes (for example, 2021-10-22T00:00:00Z). The report is inclusive of the end date.
	//
	// Specify an end date only if you provide a start date. Because it can take up to two days for the data to be available, you must specify an end date thats earlier than today minus one to two days. If not, the API ignores your end date and uses an end date that is today minus one to two days.
	EndedAt *time.Time `form:"ended_at,omitempty" json:"ended_at,omitempty"`

	// First The maximum number of report URLs to return per page in the response. The minimum page size is 1 URL per page and the maximum is 100 URLs per page. The default is 20.
	//
	// **NOTE**: While you may specify a maximum value of 100, the response will contain at most 20 URLs per page.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// This parameter is ignored if _game\_id_ parameter is set.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetGameAnalyticsParams) GetGameId() string {
	if datatype.GameId == nil {
		var empty string
		return empty
	}
	return *datatype.GameId
}
func (datatype GetGameAnalyticsParams) GetType() GetGameAnalyticsParamsType {
	if datatype.Type == nil {
		var empty GetGameAnalyticsParamsType
		return empty
	}
	return *datatype.Type
}
func (datatype GetGameAnalyticsParams) GetStartedAt() time.Time {
	if datatype.StartedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartedAt
}
func (datatype GetGameAnalyticsParams) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype GetGameAnalyticsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetGameAnalyticsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetGameAnalyticsParamsType defines parameters for GetGameAnalytics.
type GetGameAnalyticsParamsType string

// GetCheermotesParams defines parameters for GetCheermotes.
type GetCheermotesParams struct {
	// BroadcasterId The ID of the broadcaster whose custom Cheermotes you want to get. Specify the broadcasters ID if you want to include the broadcasters Cheermotes in the response (not all broadcasters upload Cheermotes). If not specified, the response contains only global Cheermotes.
	//
	// If the broadcaster uploaded Cheermotes, the `type` field in the response is set to **channel\_custom**.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`
}

func (datatype GetCheermotesParams) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}

// GetExtensionBitsProductsParams defines parameters for GetExtensionBitsProducts.
type GetExtensionBitsProductsParams struct {
	// ShouldIncludeAll A Boolean value that determines whether to include disabled or expired Bits products in the response. The default is **false**.
	ShouldIncludeAll *bool `form:"should_include_all,omitempty" json:"should_include_all,omitempty"`
}

func (datatype GetExtensionBitsProductsParams) GetShouldIncludeAll() bool {
	if datatype.ShouldIncludeAll == nil {
		var empty bool
		return empty
	}
	return *datatype.ShouldIncludeAll
}

// GetBitsLeaderboardParams defines parameters for GetBitsLeaderboard.
type GetBitsLeaderboardParams struct {
	// Count The number of results to return. The minimum count is 1 and the maximum is 100\. The default is 10.
	Count *int32 `form:"count,omitempty" json:"count,omitempty"`

	// Period The time period over which data is aggregated (uses the PST time zone). Possible values are:
	//
	// * day  A day spans from 00:00:00 on the day specified in _started\_at_ and runs through 00:00:00 of the next day.
	// * week  A week spans from 00:00:00 on the Monday of the week specified in _started\_at_ and runs through 00:00:00 of the next Monday.
	// * month  A month spans from 00:00:00 on the first day of the month specified in _started\_at_ and runs through 00:00:00 of the first day of the next month.
	// * year  A year spans from 00:00:00 on the first day of the year specified in _started\_at_ and runs through 00:00:00 of the first day of the next year.
	// * all  Default. The lifetime of the broadcaster's channel.
	Period *GetBitsLeaderboardParamsPeriod `form:"period,omitempty" json:"period,omitempty"`

	// StartedAt The start date, in RFC3339 format, used for determining the aggregation period. Specify this parameter only if you specify the _period_ query parameter. The start date is ignored if _period_ is all.
	//
	// Note that the date is converted to PST before being used, so if you set the start time to `2022-01-01T00:00:00.0Z` and _period_ to month, the actual reporting period is December 2021, not January 2022\. If you want the reporting period to be January 2022, you must set the start time to `2022-01-01T08:00:00.0Z` or `2022-01-01T00:00:00.0-08:00`.
	//
	// If your start date uses the + offset operator (for example, `2022-01-01T00:00:00.0+05:00`), you must URL encode the start date.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// UserId An ID that identifies a user that cheered bits in the channel. If _count_ is greater than 1, the response may include users ranked above and below the specified user. To get the leaderboards top leaders, dont specify a user ID.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

func (datatype GetBitsLeaderboardParams) GetCount() int32 {
	if datatype.Count == nil {
		var empty int32
		return empty
	}
	return *datatype.Count
}
func (datatype GetBitsLeaderboardParams) GetPeriod() GetBitsLeaderboardParamsPeriod {
	if datatype.Period == nil {
		var empty GetBitsLeaderboardParamsPeriod
		return empty
	}
	return *datatype.Period
}
func (datatype GetBitsLeaderboardParams) GetStartedAt() time.Time {
	if datatype.StartedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartedAt
}
func (datatype GetBitsLeaderboardParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}

// GetBitsLeaderboardParamsPeriod defines parameters for GetBitsLeaderboard.
type GetBitsLeaderboardParamsPeriod string

// DeleteCustomRewardParams defines parameters for DeleteCustomReward.
type DeleteCustomRewardParams struct {
	// BroadcasterId The ID of the broadcaster that created the custom reward. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the custom reward to delete.
	Id string `form:"id" json:"id"`
}

func (datatype DeleteCustomRewardParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype DeleteCustomRewardParams) GetId() string {
	return datatype.Id
}

// GetCustomRewardParams defines parameters for GetCustomReward.
type GetCustomRewardParams struct {
	// BroadcasterId The ID of the broadcaster whose custom rewards you want to get. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id A list of IDs to filter the rewards by. To specify more than one ID, include this parameter for each reward you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 50 IDs.
	//
	// Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyManageableRewards A Boolean value that determines whether the response contains only the custom rewards that the app may manage (the app is identified by the ID in the Client-Id header). Set to **true** to get only the custom rewards that the app may manage. The default is **false**.
	OnlyManageableRewards *bool `form:"only_manageable_rewards,omitempty" json:"only_manageable_rewards,omitempty"`
}

func (datatype GetCustomRewardParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetCustomRewardParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetCustomRewardParams) GetOnlyManageableRewards() bool {
	if datatype.OnlyManageableRewards == nil {
		var empty bool
		return empty
	}
	return *datatype.OnlyManageableRewards
}

// UpdateCustomRewardParams defines parameters for UpdateCustomReward.
type UpdateCustomRewardParams struct {
	// BroadcasterId The ID of the broadcaster thats updating the reward. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the reward to update.
	Id string `form:"id" json:"id"`
}

func (datatype UpdateCustomRewardParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateCustomRewardParams) GetId() string {
	return datatype.Id
}

// CreateCustomRewardsParams defines parameters for CreateCustomRewards.
type CreateCustomRewardsParams struct {
	// BroadcasterId The ID of the broadcaster to add the custom reward to. This ID must match the user ID found in the OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype CreateCustomRewardsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetCustomRewardRedemptionParams defines parameters for GetCustomRewardRedemption.
type GetCustomRewardRedemptionParams struct {
	// BroadcasterId The ID of the broadcaster that owns the custom reward. This ID must match the user ID found in the user OAuth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// RewardId The ID that identifies the custom reward whose redemptions you want to get.
	RewardId string `form:"reward_id" json:"reward_id"`

	// Status The status of the redemptions to return. The possible case-sensitive values are:
	//
	// * CANCELED
	// * FULFILLED
	// * UNFULFILLED
	//
	// **NOTE**: This field is required only if you dont specify the _id_ query parameter.
	//
	// **NOTE**: Canceled and fulfilled redemptions are returned for only a few days after theyre canceled or fulfilled.
	Status *GetCustomRewardRedemptionParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Id A list of IDs to filter the redemptions by. To specify more than one ID, include this parameter for each redemption you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 50 IDs.
	//
	// Duplicate IDs are ignored. The response contains only the IDs that were found. If none of the IDs were found, the response is 404 Not Found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Sort The order to sort redemptions by. The possible case-sensitive values are:
	//
	// * OLDEST
	// * NEWEST
	//
	// The default is OLDEST.
	Sort *GetCustomRewardRedemptionParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of redemptions to return per page in the response. The minimum page size is 1 redemption per page and the maximum is 50\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

func (datatype GetCustomRewardRedemptionParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetCustomRewardRedemptionParams) GetRewardId() string {
	return datatype.RewardId
}
func (datatype GetCustomRewardRedemptionParams) GetStatus() GetCustomRewardRedemptionParamsStatus {
	if datatype.Status == nil {
		var empty GetCustomRewardRedemptionParamsStatus
		return empty
	}
	return *datatype.Status
}
func (datatype GetCustomRewardRedemptionParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetCustomRewardRedemptionParams) GetSort() GetCustomRewardRedemptionParamsSort {
	if datatype.Sort == nil {
		var empty GetCustomRewardRedemptionParamsSort
		return empty
	}
	return *datatype.Sort
}
func (datatype GetCustomRewardRedemptionParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetCustomRewardRedemptionParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}

// GetCustomRewardRedemptionParamsStatus defines parameters for GetCustomRewardRedemption.
type GetCustomRewardRedemptionParamsStatus string

// GetCustomRewardRedemptionParamsSort defines parameters for GetCustomRewardRedemption.
type GetCustomRewardRedemptionParamsSort string

// UpdateRedemptionStatusParams defines parameters for UpdateRedemptionStatus.
type UpdateRedemptionStatusParams struct {
	// Id A list of IDs that identify the redemptions to update. To specify more than one ID, include this parameter for each redemption you want to update. For example, `id=1234&id=5678`. You may specify a maximum of 50 IDs.
	Id []string `form:"id" json:"id"`

	// BroadcasterId The ID of the broadcaster thats updating the redemption. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// RewardId The ID that identifies the reward thats been redeemed.
	RewardId string `form:"reward_id" json:"reward_id"`
}

func (datatype UpdateRedemptionStatusParams) GetId() []string {
	return datatype.Id
}
func (datatype UpdateRedemptionStatusParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateRedemptionStatusParams) GetRewardId() string {
	return datatype.RewardId
}

// GetChannelInformationParams defines parameters for GetChannelInformation.
type GetChannelInformationParams struct {
	// BroadcasterId The ID of the broadcaster whose channel you want to get. To specify more than one ID, include this parameter for each broadcaster you want to get. For example, `broadcaster_id=1234&broadcaster_id=5678`. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that are not found.
	BroadcasterId []string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetChannelInformationParams) GetBroadcasterId() []string {
	return datatype.BroadcasterId
}

// ModifyChannelInformationParams defines parameters for ModifyChannelInformation.
type ModifyChannelInformationParams struct {
	// BroadcasterId The ID of the broadcaster whose channel you want to update. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype ModifyChannelInformationParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetAdScheduleParams defines parameters for GetAdSchedule.
type GetAdScheduleParams struct {
	// BroadcasterId Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetAdScheduleParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// SnoozeNextAdParams defines parameters for SnoozeNextAd.
type SnoozeNextAdParams struct {
	// BroadcasterId Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype SnoozeNextAdParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetChannelEditorsParams defines parameters for GetChannelEditors.
type GetChannelEditorsParams struct {
	// BroadcasterId The ID of the broadcaster that owns the channel. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetChannelEditorsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetFollowedChannelsParams defines parameters for GetFollowedChannels.
type GetFollowedChannelsParams struct {
	// UserId A users ID. Returns the list of broadcasters that this user follows. This ID must match the user ID in the user OAuth token.
	UserId string `form:"user_id" json:"user_id"`

	// BroadcasterId A broadcasters ID. Use this parameter to see whether the user follows this broadcaster. If specified, the response contains this broadcaster if the user follows them. If not specified, the response contains all broadcasters that the user follows.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetFollowedChannelsParams) GetUserId() string {
	return datatype.UserId
}
func (datatype GetFollowedChannelsParams) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype GetFollowedChannelsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetFollowedChannelsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetChannelFollowersParams defines parameters for GetChannelFollowers.
type GetChannelFollowersParams struct {
	// UserId A users ID. Use this parameter to see whether the user follows this broadcaster. If specified, the response contains this user if they follow the broadcaster. If not specified, the response contains all users that follow the broadcaster.
	//
	// Using this parameter requires both a user access token with the **moderator:read:followers** scope and the user ID in the access token match the broadcaster\_id or be the user ID for a moderator of the specified broadcaster.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// BroadcasterId The broadcasters ID. Returns the list of users that follow this broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read more](https://dev.twitch.tv/docs/api/guide#pagination).
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetChannelFollowersParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetChannelFollowersParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetChannelFollowersParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetChannelFollowersParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// RemoveChannelVipParams defines parameters for RemoveChannelVip.
type RemoveChannelVipParams struct {
	// UserId The ID of the user to remove VIP status from.
	UserId string `form:"user_id" json:"user_id"`

	// BroadcasterId The ID of the broadcaster who owns the channel where the user has VIP status.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype RemoveChannelVipParams) GetUserId() string {
	return datatype.UserId
}
func (datatype RemoveChannelVipParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetVipsParams defines parameters for GetVips.
type GetVipsParams struct {
	// UserId Filters the list for specific VIPs. To specify more than one user, include the _user\_id_ parameter for each user to get. For example, `&user_id=1234&user_id=5678`. The maximum number of IDs that you may specify is 100\. Ignores the ID of those users in the list that arent VIPs.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// BroadcasterId The ID of the broadcaster whose list of VIPs you want to get. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetVipsParams) GetUserId() []string {
	if datatype.UserId == nil {
		var empty []string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetVipsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetVipsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetVipsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// AddChannelVipParams defines parameters for AddChannelVip.
type AddChannelVipParams struct {
	// UserId The ID of the user to give VIP status to.
	UserId string `form:"user_id" json:"user_id"`

	// BroadcasterId The ID of the broadcaster thats adding the user as a VIP. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype AddChannelVipParams) GetUserId() string {
	return datatype.UserId
}
func (datatype AddChannelVipParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetCharityCampaignParams defines parameters for GetCharityCampaign.
type GetCharityCampaignParams struct {
	// BroadcasterId The ID of the broadcaster thats currently running a charity campaign. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetCharityCampaignParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetCharityCampaignDonationsParams defines parameters for GetCharityCampaignDonations.
type GetCharityCampaignDonationsParams struct {
	// BroadcasterId The ID of the broadcaster thats currently running a charity campaign. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetCharityCampaignDonationsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetCharityCampaignDonationsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetCharityCampaignDonationsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// SendChatAnnouncementParams defines parameters for SendChatAnnouncement.
type SendChatAnnouncementParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room to send the announcement to.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of a user who has permission to moderate the broadcasters chat room, or the broadcasters ID if theyre sending the announcement. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype SendChatAnnouncementParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype SendChatAnnouncementParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// GetChannelChatBadgesParams defines parameters for GetChannelChatBadges.
type GetChannelChatBadgesParams struct {
	// BroadcasterId The ID of the broadcaster whose chat badges you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetChannelChatBadgesParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetChattersParams defines parameters for GetChatters.
type GetChattersParams struct {
	// BroadcasterId The ID of the broadcaster whose list of chatters you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or one of the broadcasters moderators. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 1,000\. The default is 100.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetChattersParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetChattersParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype GetChattersParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetChattersParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetUserChatColorParams defines parameters for GetUserChatColor.
type GetUserChatColorParams struct {
	// UserId The ID of the user whose username color you want to get. To specify more than one user, include the _user\_id_ parameter for each user to get. For example, `&user_id=1234&user_id=5678`. The maximum number of IDs that you may specify is 100.
	//
	// The API ignores duplicate IDs and IDs that werent found.
	UserId []string `form:"user_id" json:"user_id"`
}

func (datatype GetUserChatColorParams) GetUserId() []string {
	return datatype.UserId
}

// UpdateUserChatColorParams defines parameters for UpdateUserChatColor.
type UpdateUserChatColorParams struct {
	// UserId The ID of the user whose chat color you want to update. This ID must match the user ID in the access token.
	UserId string `form:"user_id" json:"user_id"`

	// Color The color to use for the user's name in chat. All users may specify one of the following named color values.
	//
	// * blue
	// * blue\_violet
	// * cadet\_blue
	// * chocolate
	// * coral
	// * dodger\_blue
	// * firebrick
	// * golden\_rod
	// * green
	// * hot\_pink
	// * orange\_red
	// * red
	// * sea\_green
	// * spring\_green
	// * yellow\_green
	//
	// Turbo and Prime users may specify a named color or a Hex color code like #9146FF. If you use a Hex color code, remember to URL encode it.
	Color UpdateUserChatColorParamsColor `form:"color" json:"color"`
}

func (datatype UpdateUserChatColorParams) GetUserId() string {
	return datatype.UserId
}
func (datatype UpdateUserChatColorParams) GetColor() UpdateUserChatColorParamsColor {
	return datatype.Color
}

// UpdateUserChatColorParamsColor defines parameters for UpdateUserChatColor.
type UpdateUserChatColorParamsColor string

// GetChannelEmotesParams defines parameters for GetChannelEmotes.
type GetChannelEmotesParams struct {
	// BroadcasterId An ID that identifies the broadcaster whose emotes you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetChannelEmotesParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetEmoteSetsParams defines parameters for GetEmoteSets.
type GetEmoteSetsParams struct {
	// EmoteSetId An ID that identifies the emote set to get. Include this parameter for each emote set you want to get. For example, `emote_set_id=1234&emote_set_id=5678`. You may specify a maximum of 25 IDs. The response contains only the IDs that were found and ignores duplicate IDs.
	//
	// To get emote set IDs, use the [Get Channel Emotes](https://dev.twitch.tv/docs/api/reference#get-channel-emotes) API.
	EmoteSetId []string `form:"emote_set_id" json:"emote_set_id"`
}

func (datatype GetEmoteSetsParams) GetEmoteSetId() []string {
	return datatype.EmoteSetId
}

// GetUserEmotesParams defines parameters for GetUserEmotes.
type GetUserEmotesParams struct {
	// UserId The ID of the user. This ID must match the user ID in the user access token.
	UserId string `form:"user_id" json:"user_id"`

	// After The cursor used to get the next page of results. The Pagination object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// BroadcasterId The User ID of a broadcaster you wish to get follower emotes of. Using this query parameter will guarantee inclusion of the broadcasters follower emotes in the response body.
	//
	// **Note:** If the user specified in `user_id` is subscribed to the broadcaster specified, their follower emotes will appear in the response body regardless if this query parameter is used.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`
}

func (datatype GetUserEmotesParams) GetUserId() string {
	return datatype.UserId
}
func (datatype GetUserEmotesParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetUserEmotesParams) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}

// GetChatSettingsParams defines parameters for GetChatSettings.
type GetChatSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose chat settings you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or one of the broadcasters moderators.
	//
	// This field is required only if you want to include the `non_moderator_chat_delay` and `non_moderator_chat_delay_duration` settings in the response.
	//
	// If you specify this field, this ID must match the user ID in the user access token.
	ModeratorId *string `form:"moderator_id,omitempty" json:"moderator_id,omitempty"`
}

func (datatype GetChatSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetChatSettingsParams) GetModeratorId() string {
	if datatype.ModeratorId == nil {
		var empty string
		return empty
	}
	return *datatype.ModeratorId
}

// UpdateChatSettingsParams defines parameters for UpdateChatSettings.
type UpdateChatSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose chat settings you want to update.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of a user that has permission to moderate the broadcasters chat room, or the broadcasters ID if theyre making the update. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype UpdateChatSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateChatSettingsParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// SendAShoutoutParams defines parameters for SendAShoutout.
type SendAShoutoutParams struct {
	// FromBroadcasterId The ID of the broadcaster thats sending the Shoutout.
	FromBroadcasterId string `form:"from_broadcaster_id" json:"from_broadcaster_id"`

	// ToBroadcasterId The ID of the broadcaster thats receiving the Shoutout.
	ToBroadcasterId string `form:"to_broadcaster_id" json:"to_broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that is one of the broadcasters moderators. This ID must match the user ID in the access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype SendAShoutoutParams) GetFromBroadcasterId() string {
	return datatype.FromBroadcasterId
}
func (datatype SendAShoutoutParams) GetToBroadcasterId() string {
	return datatype.ToBroadcasterId
}
func (datatype SendAShoutoutParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// GetClipsParams defines parameters for GetClips.
type GetClipsParams struct {
	// BroadcasterId An ID that identifies the broadcaster whose video clips you want to get. Use this parameter to get clips that were captured from the broadcasters streams.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`

	// GameId An ID that identifies the game whose clips you want to get. Use this parameter to get clips that were captured from streams that were playing this game.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Id An ID that identifies the clip to get. To specify more than one ID, include this parameter for each clip you want to get. For example, `id=foo&id=bar`. You may specify a maximum of 100 IDs. The API ignores duplicate IDs and IDs that arent found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// StartedAt The start date used to filter clips. The API returns only clips within the start and end date window. Specify the date and time in RFC3339 format.
	StartedAt *time.Time `form:"started_at,omitempty" json:"started_at,omitempty"`

	// EndedAt The end date used to filter clips. If not specified, the time window is the start date plus one week. Specify the date and time in RFC3339 format.
	EndedAt *time.Time `form:"ended_at,omitempty" json:"ended_at,omitempty"`

	// First The maximum number of clips to return per page in the response. The minimum page size is 1 clip per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// IsFeatured A Boolean value that determines whether the response includes featured clips. If **true**, returns only clips that are featured. If **false**, returns only clips that arent featured. All clips are returned if this parameter is not present.
	IsFeatured *bool `form:"is_featured,omitempty" json:"is_featured,omitempty"`
}

func (datatype GetClipsParams) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype GetClipsParams) GetGameId() string {
	if datatype.GameId == nil {
		var empty string
		return empty
	}
	return *datatype.GameId
}
func (datatype GetClipsParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetClipsParams) GetStartedAt() time.Time {
	if datatype.StartedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartedAt
}
func (datatype GetClipsParams) GetEndedAt() time.Time {
	if datatype.EndedAt == nil {
		var empty time.Time
		return empty
	}
	return *datatype.EndedAt
}
func (datatype GetClipsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetClipsParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}
func (datatype GetClipsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetClipsParams) GetIsFeatured() bool {
	if datatype.IsFeatured == nil {
		var empty bool
		return empty
	}
	return *datatype.IsFeatured
}

// CreateClipParams defines parameters for CreateClip.
type CreateClipParams struct {
	// BroadcasterId The ID of the broadcaster whose stream you want to create a clip from.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// HasDelay A Boolean value that determines whether the API captures the clip at the moment the viewer requests it or after a delay. If **false** (default), Twitch captures the clip at the moment the viewer requests it (this is the same clip experience as the Twitch UX). If **true**, Twitch adds a delay before capturing the clip (this basically shifts the capture window to the right slightly).
	HasDelay *bool `form:"has_delay,omitempty" json:"has_delay,omitempty"`
}

func (datatype CreateClipParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CreateClipParams) GetHasDelay() bool {
	if datatype.HasDelay == nil {
		var empty bool
		return empty
	}
	return *datatype.HasDelay
}

// GetContentClassificationLabelsParams defines parameters for GetContentClassificationLabels.
type GetContentClassificationLabelsParams struct {
	// Locale Locale for the Content Classification Labels. You may specify a maximum of 1 locale. Default: `en-US`
	// Supported locales: `"bg-BG", "cs-CZ", "da-DK", "da-DK", "de-DE", "el-GR", "en-GB", "en-US", "es-ES", "es-MX", "fi-FI", "fr-FR", "hu-HU", "it-IT", "ja-JP", "ko-KR", "nl-NL", "no-NO", "pl-PL", "pt-BT", "pt-PT", "ro-RO", "ru-RU", "sk-SK", "sv-SE", "th-TH", "tr-TR", "vi-VN", "zh-CN", "zh-TW"`
	Locale *string `form:"locale,omitempty" json:"locale,omitempty"`
}

func (datatype GetContentClassificationLabelsParams) GetLocale() string {
	if datatype.Locale == nil {
		var empty string
		return empty
	}
	return *datatype.Locale
}

// GetDropsEntitlementsParams defines parameters for GetDropsEntitlements.
type GetDropsEntitlementsParams struct {
	// Id An ID that identifies the entitlement to get. Include this parameter for each entitlement you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// UserId An ID that identifies a user that was granted entitlements.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// GameId An ID that identifies a game that offered entitlements.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// FulfillmentStatus The entitlements fulfillment status. Used to filter the list to only those with the specified status. Possible values are:
	//
	// * CLAIMED
	// * FULFILLED
	FulfillmentStatus *GetDropsEntitlementsParamsFulfillmentStatus `form:"fulfillment_status,omitempty" json:"fulfillment_status,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of entitlements to return per page in the response. The minimum page size is 1 entitlement per page and the maximum is 1000\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

func (datatype GetDropsEntitlementsParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetDropsEntitlementsParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetDropsEntitlementsParams) GetGameId() string {
	if datatype.GameId == nil {
		var empty string
		return empty
	}
	return *datatype.GameId
}
func (datatype GetDropsEntitlementsParams) GetFulfillmentStatus() GetDropsEntitlementsParamsFulfillmentStatus {
	if datatype.FulfillmentStatus == nil {
		var empty GetDropsEntitlementsParamsFulfillmentStatus
		return empty
	}
	return *datatype.FulfillmentStatus
}
func (datatype GetDropsEntitlementsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetDropsEntitlementsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}

// GetDropsEntitlementsParamsFulfillmentStatus defines parameters for GetDropsEntitlements.
type GetDropsEntitlementsParamsFulfillmentStatus string

// DeleteConduitParams defines parameters for DeleteConduit.
type DeleteConduitParams struct {
	// Id Conduit ID.
	Id string `form:"id" json:"id"`
}

func (datatype DeleteConduitParams) GetId() string {
	return datatype.Id
}

// GetConduitShardsParams defines parameters for GetConduitShards.
type GetConduitShardsParams struct {
	// ConduitId Conduit ID.
	ConduitId string `form:"conduit_id" json:"conduit_id"`

	// Status Status to filter by.
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// After The cursor used to get the next page of results. The pagination object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetConduitShardsParams) GetConduitId() string {
	return datatype.ConduitId
}
func (datatype GetConduitShardsParams) GetStatus() string {
	if datatype.Status == nil {
		var empty string
		return empty
	}
	return *datatype.Status
}
func (datatype GetConduitShardsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// DeleteEventsubSubscriptionParams defines parameters for DeleteEventsubSubscription.
type DeleteEventsubSubscriptionParams struct {
	// Id The ID of the subscription to delete.
	Id string `form:"id" json:"id"`
}

func (datatype DeleteEventsubSubscriptionParams) GetId() string {
	return datatype.Id
}

// GetEventsubSubscriptionsParams defines parameters for GetEventsubSubscriptions.
type GetEventsubSubscriptionsParams struct {
	// Status Filter subscriptions by its status. Possible values are:
	//
	// * enabled  The subscription is enabled.
	// * webhook\_callback\_verification\_pending  The subscription is pending verification of the specified callback URL.
	// * webhook\_callback\_verification\_failed  The specified callback URL failed verification.
	// * notification\_failures\_exceeded  The notification delivery failure rate was too high.
	// * authorization\_revoked  The authorization was revoked for one or more users specified in the **Condition** object.
	// * moderator\_removed  The moderator that authorized the subscription is no longer one of the broadcaster's moderators.
	// * user\_removed  One of the users specified in the **Condition** object was removed.
	// * chat\_user\_banned - The user specified in the **Condition** object was banned from the broadcaster's chat.
	// * version\_removed  The subscription to subscription type and version is no longer supported.
	// * beta\_maintenance  The subscription to the beta subscription type was removed due to maintenance.
	// * websocket\_disconnected  The client closed the connection.
	// * websocket\_failed\_ping\_pong  The client failed to respond to a ping message.
	// * websocket\_received\_inbound\_traffic  The client sent a non-pong message. Clients may only send pong messages (and only in response to a ping message).
	// * websocket\_connection\_unused  The client failed to subscribe to events within the required time.
	// * websocket\_internal\_error  The Twitch WebSocket server experienced an unexpected error.
	// * websocket\_network\_timeout  The Twitch WebSocket server timed out writing the message to the client.
	// * websocket\_network\_error  The Twitch WebSocket server experienced a network error writing the message to the client.
	// * websocket\_failed\_to\_reconnect - The client failed to reconnect to the Twitch WebSocket server within the required time after a Reconnect Message.
	Status *GetEventsubSubscriptionsParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Type Filter subscriptions by subscription type. For a list of subscription types, see [Subscription Types](https://dev.twitch.tv/docs/eventsub/eventsub-subscription-types#subscription-types).
	Type *GetEventsubSubscriptionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// UserId Filter subscriptions by user ID. The response contains subscriptions where this ID matches a user ID that you specified in the **Condition** object when you [created the subscription](https://dev.twitch.tv/docs/api/reference#create-eventsub-subscription).
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// After The cursor used to get the next page of results. The `pagination` object in the response contains the cursor's value.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetEventsubSubscriptionsParams) GetStatus() GetEventsubSubscriptionsParamsStatus {
	if datatype.Status == nil {
		var empty GetEventsubSubscriptionsParamsStatus
		return empty
	}
	return *datatype.Status
}
func (datatype GetEventsubSubscriptionsParams) GetType() GetEventsubSubscriptionsParamsType {
	if datatype.Type == nil {
		var empty GetEventsubSubscriptionsParamsType
		return empty
	}
	return *datatype.Type
}
func (datatype GetEventsubSubscriptionsParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetEventsubSubscriptionsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetEventsubSubscriptionsParamsStatus defines parameters for GetEventsubSubscriptions.
type GetEventsubSubscriptionsParamsStatus string

// GetEventsubSubscriptionsParamsType defines parameters for GetEventsubSubscriptions.
type GetEventsubSubscriptionsParamsType string

// GetExtensionsParams defines parameters for GetExtensions.
type GetExtensionsParams struct {
	// ExtensionId The ID of the extension to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// ExtensionVersion The version of the extension to get. If not specified, it returns the latest, released version. If you dont have a released version, you must specify a version; otherwise, the list is empty.
	ExtensionVersion *string `form:"extension_version,omitempty" json:"extension_version,omitempty"`
}

func (datatype GetExtensionsParams) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype GetExtensionsParams) GetExtensionVersion() string {
	if datatype.ExtensionVersion == nil {
		var empty string
		return empty
	}
	return *datatype.ExtensionVersion
}

// SendExtensionChatMessageParams defines parameters for SendExtensionChatMessage.
type SendExtensionChatMessageParams struct {
	// BroadcasterId The ID of the broadcaster that has activated the extension.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype SendExtensionChatMessageParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetExtensionConfigurationSegmentParams defines parameters for GetExtensionConfigurationSegment.
type GetExtensionConfigurationSegmentParams struct {
	// BroadcasterId The ID of the broadcaster that installed the extension. This parameter is required if you set the _segment_ parameter to broadcaster or developer. Do not specify this parameter if you set _segment_ to global.
	BroadcasterId *string `form:"broadcaster_id,omitempty" json:"broadcaster_id,omitempty"`

	// ExtensionId The ID of the extension that contains the configuration segment you want to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// Segment The type of configuration segment to get. Possible case-sensitive values are:
	//
	// * broadcaster
	// * developer
	// * global
	//
	// You may specify one or more segments. To specify multiple segments, include the `segment` parameter for each segment to get. For example, `segment=broadcaster&segment=developer`. Ignores duplicate segments.
	Segment GetExtensionConfigurationSegmentParamsSegment `form:"segment" json:"segment"`
}

func (datatype GetExtensionConfigurationSegmentParams) GetBroadcasterId() string {
	if datatype.BroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.BroadcasterId
}
func (datatype GetExtensionConfigurationSegmentParams) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype GetExtensionConfigurationSegmentParams) GetSegment() GetExtensionConfigurationSegmentParamsSegment {
	return datatype.Segment
}

// GetExtensionConfigurationSegmentParamsSegment defines parameters for GetExtensionConfigurationSegment.
type GetExtensionConfigurationSegmentParamsSegment string

// CreateExtensionSecretParams defines parameters for CreateExtensionSecret.
type CreateExtensionSecretParams struct {
	// ExtensionId The ID of the extension to apply the shared secret to.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// Delay The amount of time, in seconds, to delay activating the secret. The delay should provide enough time for instances of the extension to gracefully switch over to the new secret. The minimum delay is 300 seconds (5 minutes). The default is 300 seconds.
	Delay *int32 `form:"delay,omitempty" json:"delay,omitempty"`
}

func (datatype CreateExtensionSecretParams) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype CreateExtensionSecretParams) GetDelay() int32 {
	if datatype.Delay == nil {
		var empty int32
		return empty
	}
	return *datatype.Delay
}

// GetExtensionLiveChannelsParams defines parameters for GetExtensionLiveChannels.
type GetExtensionLiveChannelsParams struct {
	// ExtensionId The ID of the extension to get. Returns the list of broadcasters that are live and that have installed or activated this extension.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The `pagination` field in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetExtensionLiveChannelsParams) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype GetExtensionLiveChannelsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetExtensionLiveChannelsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetReleasedExtensionsParams defines parameters for GetReleasedExtensions.
type GetReleasedExtensionsParams struct {
	// ExtensionId The ID of the extension to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// ExtensionVersion The version of the extension to get. If not specified, it returns the latest version.
	ExtensionVersion *string `form:"extension_version,omitempty" json:"extension_version,omitempty"`
}

func (datatype GetReleasedExtensionsParams) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype GetReleasedExtensionsParams) GetExtensionVersion() string {
	if datatype.ExtensionVersion == nil {
		var empty string
		return empty
	}
	return *datatype.ExtensionVersion
}

// SetExtensionRequiredConfigurationParams defines parameters for SetExtensionRequiredConfiguration.
type SetExtensionRequiredConfigurationParams struct {
	// BroadcasterId The ID of the broadcaster that installed the extension on their channel.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype SetExtensionRequiredConfigurationParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetExtensionTransactionsParams defines parameters for GetExtensionTransactions.
type GetExtensionTransactionsParams struct {
	// ExtensionId The ID of the extension whose list of transactions you want to get.
	ExtensionId string `form:"extension_id" json:"extension_id"`

	// Id A transaction ID used to filter the list of transactions. Specify this parameter for each transaction you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetExtensionTransactionsParams) GetExtensionId() string {
	return datatype.ExtensionId
}
func (datatype GetExtensionTransactionsParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetExtensionTransactionsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetExtensionTransactionsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetGamesParams defines parameters for GetGames.
type GetGamesParams struct {
	// Id The ID of the category or game to get. Include this parameter for each category or game you want to get. For example, `&id=1234&id=5678`. You may specify a maximum of 100 IDs. The endpoint ignores duplicate and invalid IDs or IDs that werent found.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Name The name of the category or game to get. The name must exactly match the categorys or games title. Include this parameter for each category or game you want to get. For example, `&name=foo&name=bar`. You may specify a maximum of 100 names. The endpoint ignores duplicate names and names that werent found.
	Name *[]string `form:"name,omitempty" json:"name,omitempty"`

	// IgdbId The [IGDB](https://www.igdb.com/) ID of the game to get. Include this parameter for each game you want to get. For example, `&igdb_id=1234&igdb_id=5678`. You may specify a maximum of 100 IDs. The endpoint ignores duplicate and invalid IDs or IDs that werent found.
	IgdbId *[]string `form:"igdb_id,omitempty" json:"igdb_id,omitempty"`
}

func (datatype GetGamesParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetGamesParams) GetName() []string {
	if datatype.Name == nil {
		var empty []string
		return empty
	}
	return *datatype.Name
}
func (datatype GetGamesParams) GetIgdbId() []string {
	if datatype.IgdbId == nil {
		var empty []string
		return empty
	}
	return *datatype.IgdbId
}

// GetTopGamesParams defines parameters for GetTopGames.
type GetTopGamesParams struct {
	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

func (datatype GetTopGamesParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetTopGamesParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetTopGamesParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}

// GetCreatorGoalsParams defines parameters for GetCreatorGoals.
type GetCreatorGoalsParams struct {
	// BroadcasterId The ID of the broadcaster that created the goals. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetCreatorGoalsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetChannelGuestStarSettingsParams defines parameters for GetChannelGuestStarSettings.
type GetChannelGuestStarSettingsParams struct {
	// BroadcasterId The ID of the broadcaster you want to get guest star settings for.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype GetChannelGuestStarSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetChannelGuestStarSettingsParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// UpdateChannelGuestStarSettingsParams defines parameters for UpdateChannelGuestStarSettings.
type UpdateChannelGuestStarSettingsParams struct {
	// BroadcasterId The ID of the broadcaster you want to update Guest Star settings for.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype UpdateChannelGuestStarSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// DeleteGuestStarInviteParams defines parameters for DeleteGuestStarInvite.
type DeleteGuestStarInviteParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the session for the invite to be revoked on behalf of the broadcaster.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId Twitch User ID for the guest to revoke the Guest Star session invite from.
	GuestId string `form:"guest_id" json:"guest_id"`
}

func (datatype DeleteGuestStarInviteParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype DeleteGuestStarInviteParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype DeleteGuestStarInviteParams) GetSessionId() string {
	return datatype.SessionId
}
func (datatype DeleteGuestStarInviteParams) GetGuestId() string {
	return datatype.GuestId
}

// GetGuestStarInvitesParams defines parameters for GetGuestStarInvites.
type GetGuestStarInvitesParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The session ID to query for invite status.
	SessionId string `form:"session_id" json:"session_id"`
}

func (datatype GetGuestStarInvitesParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetGuestStarInvitesParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype GetGuestStarInvitesParams) GetSessionId() string {
	return datatype.SessionId
}

// SendGuestStarInviteParams defines parameters for SendGuestStarInvite.
type SendGuestStarInviteParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The session ID for the invite to be sent on behalf of the broadcaster.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId Twitch User ID for the guest to invite to the Guest Star session.
	GuestId string `form:"guest_id" json:"guest_id"`
}

func (datatype SendGuestStarInviteParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype SendGuestStarInviteParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype SendGuestStarInviteParams) GetSessionId() string {
	return datatype.SessionId
}
func (datatype SendGuestStarInviteParams) GetGuestId() string {
	return datatype.GuestId
}

// EndGuestStarSessionParams defines parameters for EndGuestStarSession.
type EndGuestStarSessionParams struct {
	// BroadcasterId The ID of the broadcaster you want to end a Guest Star session for. Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// SessionId ID for the session to end on behalf of the broadcaster.
	SessionId string `form:"session_id" json:"session_id"`
}

func (datatype EndGuestStarSessionParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype EndGuestStarSessionParams) GetSessionId() string {
	return datatype.SessionId
}

// GetGuestStarSessionParams defines parameters for GetGuestStarSession.
type GetGuestStarSessionParams struct {
	// BroadcasterId ID for the user hosting the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype GetGuestStarSessionParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetGuestStarSessionParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// CreateGuestStarSessionParams defines parameters for CreateGuestStarSession.
type CreateGuestStarSessionParams struct {
	// BroadcasterId The ID of the broadcaster you want to create a Guest Star session for. Provided `broadcaster_id` must match the `user_id` in the auth token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype CreateGuestStarSessionParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// DeleteGuestStarSlotParams defines parameters for DeleteGuestStarSlot.
type DeleteGuestStarSlotParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to remove the slot assignment.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId The Twitch User ID corresponding to the guest to remove from the session.
	GuestId string `form:"guest_id" json:"guest_id"`

	// SlotId The slot ID representing the slot assignment to remove from the session.
	SlotId string `form:"slot_id" json:"slot_id"`

	// ShouldReinviteGuest Flag signaling that the guest should be reinvited to the session, sending them back to the invite queue.
	ShouldReinviteGuest *string `form:"should_reinvite_guest,omitempty" json:"should_reinvite_guest,omitempty"`
}

func (datatype DeleteGuestStarSlotParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype DeleteGuestStarSlotParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype DeleteGuestStarSlotParams) GetSessionId() string {
	return datatype.SessionId
}
func (datatype DeleteGuestStarSlotParams) GetGuestId() string {
	return datatype.GuestId
}
func (datatype DeleteGuestStarSlotParams) GetSlotId() string {
	return datatype.SlotId
}
func (datatype DeleteGuestStarSlotParams) GetShouldReinviteGuest() string {
	if datatype.ShouldReinviteGuest == nil {
		var empty string
		return empty
	}
	return *datatype.ShouldReinviteGuest
}

// UpdateGuestStarSlotParams defines parameters for UpdateGuestStarSlot.
type UpdateGuestStarSlotParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to update slot settings.
	SessionId string `form:"session_id" json:"session_id"`

	// SourceSlotId The slot assignment previously assigned to a user.
	SourceSlotId string `form:"source_slot_id" json:"source_slot_id"`

	// DestinationSlotId The slot to move this user assignment to. If the destination slot is occupied, the user assigned will be swapped into `source_slot_id`.
	DestinationSlotId *string `form:"destination_slot_id,omitempty" json:"destination_slot_id,omitempty"`
}

func (datatype UpdateGuestStarSlotParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateGuestStarSlotParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype UpdateGuestStarSlotParams) GetSessionId() string {
	return datatype.SessionId
}
func (datatype UpdateGuestStarSlotParams) GetSourceSlotId() string {
	return datatype.SourceSlotId
}
func (datatype UpdateGuestStarSlotParams) GetDestinationSlotId() string {
	if datatype.DestinationSlotId == nil {
		var empty string
		return empty
	}
	return *datatype.DestinationSlotId
}

// AssignGuestStarSlotParams defines parameters for AssignGuestStarSlot.
type AssignGuestStarSlotParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the `user_id` in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to assign the slot.
	SessionId string `form:"session_id" json:"session_id"`

	// GuestId The Twitch User ID corresponding to the guest to assign a slot in the session. This user must already have an invite to this session, and have indicated that they are ready to join.
	GuestId string `form:"guest_id" json:"guest_id"`

	// SlotId The slot assignment to give to the user. Must be a numeric identifier between 1 and N where N is the max number of slots for the session. Max number of slots allowed for the session is reported by [Get Channel Guest Star Settings](https://dev.twitch.tv/docs/api/reference#get-channel-guest-star-settings).
	SlotId string `form:"slot_id" json:"slot_id"`
}

func (datatype AssignGuestStarSlotParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype AssignGuestStarSlotParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype AssignGuestStarSlotParams) GetSessionId() string {
	return datatype.SessionId
}
func (datatype AssignGuestStarSlotParams) GetGuestId() string {
	return datatype.GuestId
}
func (datatype AssignGuestStarSlotParams) GetSlotId() string {
	return datatype.SlotId
}

// UpdateGuestStarSlotSettingsParams defines parameters for UpdateGuestStarSlotSettings.
type UpdateGuestStarSlotSettingsParams struct {
	// BroadcasterId The ID of the broadcaster running the Guest Star session.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// SessionId The ID of the Guest Star session in which to update a slots settings.
	SessionId string `form:"session_id" json:"session_id"`

	// SlotId The slot assignment that has previously been assigned to a user.
	SlotId string `form:"slot_id" json:"slot_id"`

	// IsAudioEnabled Flag indicating whether the slot is allowed to share their audio with the rest of the session. If false, the slot will be muted in any views containing the slot.
	IsAudioEnabled *bool `form:"is_audio_enabled,omitempty" json:"is_audio_enabled,omitempty"`

	// IsVideoEnabled Flag indicating whether the slot is allowed to share their video with the rest of the session. If false, the slot will have no video shared in any views containing the slot.
	IsVideoEnabled *bool `form:"is_video_enabled,omitempty" json:"is_video_enabled,omitempty"`

	// IsLive Flag indicating whether the user assigned to this slot is visible/can be heard from any public subscriptions. Generally, this determines whether or not the slot is enabled in any broadcasting software integrations.
	IsLive *bool `form:"is_live,omitempty" json:"is_live,omitempty"`

	// Volume Value from 0-100 that controls the audio volume for shared views containing the slot.
	Volume *int32 `form:"volume,omitempty" json:"volume,omitempty"`
}

func (datatype UpdateGuestStarSlotSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateGuestStarSlotSettingsParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype UpdateGuestStarSlotSettingsParams) GetSessionId() string {
	return datatype.SessionId
}
func (datatype UpdateGuestStarSlotSettingsParams) GetSlotId() string {
	return datatype.SlotId
}
func (datatype UpdateGuestStarSlotSettingsParams) GetIsAudioEnabled() bool {
	if datatype.IsAudioEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsAudioEnabled
}
func (datatype UpdateGuestStarSlotSettingsParams) GetIsVideoEnabled() bool {
	if datatype.IsVideoEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsVideoEnabled
}
func (datatype UpdateGuestStarSlotSettingsParams) GetIsLive() bool {
	if datatype.IsLive == nil {
		var empty bool
		return empty
	}
	return *datatype.IsLive
}
func (datatype UpdateGuestStarSlotSettingsParams) GetVolume() int32 {
	if datatype.Volume == nil {
		var empty int32
		return empty
	}
	return *datatype.Volume
}

// GetHypeTrainEventsParams defines parameters for GetHypeTrainEvents.
type GetHypeTrainEventsParams struct {
	// BroadcasterId The ID of the broadcaster thats running the Hype Train. This ID must match the User ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 1.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetHypeTrainEventsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetHypeTrainEventsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetHypeTrainEventsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetAutomodSettingsParams defines parameters for GetAutomodSettings.
type GetAutomodSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose AutoMod settings you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype GetAutomodSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetAutomodSettingsParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// UpdateAutomodSettingsParams defines parameters for UpdateAutomodSettings.
type UpdateAutomodSettingsParams struct {
	// BroadcasterId The ID of the broadcaster whose AutoMod settings you want to update.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype UpdateAutomodSettingsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateAutomodSettingsParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// GetBannedUsersParams defines parameters for GetBannedUsers.
type GetBannedUsersParams struct {
	// BroadcasterId The ID of the broadcaster whose list of banned users you want to get. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each user you want to get. For example, `user_id=1234&user_id=5678`. You may specify a maximum of 100 IDs.
	//
	// The returned list includes only those users that were banned or put in a timeout. The list is returned in the same order that you specified the IDs.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

func (datatype GetBannedUsersParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetBannedUsersParams) GetUserId() []string {
	if datatype.UserId == nil {
		var empty []string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetBannedUsersParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetBannedUsersParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetBannedUsersParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}

// UnbanUserParams defines parameters for UnbanUser.
type UnbanUserParams struct {
	// BroadcasterId The ID of the broadcaster whose chat room the user is banned from chatting in.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// UserId The ID of the user to remove the ban or timeout from.
	UserId string `form:"user_id" json:"user_id"`
}

func (datatype UnbanUserParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UnbanUserParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype UnbanUserParams) GetUserId() string {
	return datatype.UserId
}

// BanUserParams defines parameters for BanUser.
type BanUserParams struct {
	// BroadcasterId The ID of the broadcaster whose chat room the user is being banned from.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype BanUserParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype BanUserParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// RemoveBlockedTermParams defines parameters for RemoveBlockedTerm.
type RemoveBlockedTermParams struct {
	// BroadcasterId The ID of the broadcaster that owns the list of blocked terms.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// Id The ID of the blocked term to remove from the broadcasters list of blocked terms.
	Id string `form:"id" json:"id"`
}

func (datatype RemoveBlockedTermParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype RemoveBlockedTermParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype RemoveBlockedTermParams) GetId() string {
	return datatype.Id
}

// GetBlockedTermsParams defines parameters for GetBlockedTerms.
type GetBlockedTermsParams struct {
	// BroadcasterId The ID of the broadcaster whose blocked terms youre getting.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetBlockedTermsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetBlockedTermsParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype GetBlockedTermsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetBlockedTermsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// AddBlockedTermParams defines parameters for AddBlockedTerm.
type AddBlockedTermParams struct {
	// BroadcasterId The ID of the broadcaster that owns the list of blocked terms.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype AddBlockedTermParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype AddBlockedTermParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// GetModeratedChannelsParams defines parameters for GetModeratedChannels.
type GetModeratedChannelsParams struct {
	// UserId A users ID. Returns the list of channels that this user has moderator privileges in. This ID must match the user ID in the user OAuth token
	UserId string `form:"user_id" json:"user_id"`

	// After The cursor used to get the next page of results. The Pagination object in the response contains the cursors value.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of items to return per page in the response.
	//
	// Minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

func (datatype GetModeratedChannelsParams) GetUserId() string {
	return datatype.UserId
}
func (datatype GetModeratedChannelsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetModeratedChannelsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}

// DeleteChatMessagesParams defines parameters for DeleteChatMessages.
type DeleteChatMessagesParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room to remove messages from.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters chat room. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// MessageId The ID of the message to remove. The `id` tag in the [PRIVMSG](https://dev.twitch.tv/docs/irc/tags#privmsg-tags) tag contains the messages ID. Restrictions:
	//
	// * The message must have been created within the last 6 hours.
	// * The message must not belong to the broadcaster.
	// * The message must not belong to another moderator.
	//
	// If not specified, the request removes all messages in the broadcasters chat room.
	MessageId *string `form:"message_id,omitempty" json:"message_id,omitempty"`
}

func (datatype DeleteChatMessagesParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype DeleteChatMessagesParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype DeleteChatMessagesParams) GetMessageId() string {
	if datatype.MessageId == nil {
		var empty string
		return empty
	}
	return *datatype.MessageId
}

// CheckAutomodStatusParams defines parameters for CheckAutomodStatus.
type CheckAutomodStatusParams struct {
	// BroadcasterId The ID of the broadcaster whose AutoMod settings and list of blocked terms are used to check the message. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype CheckAutomodStatusParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// RemoveChannelModeratorParams defines parameters for RemoveChannelModerator.
type RemoveChannelModeratorParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId The ID of the user to remove as a moderator from the broadcasters chat room.
	UserId string `form:"user_id" json:"user_id"`
}

func (datatype RemoveChannelModeratorParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype RemoveChannelModeratorParams) GetUserId() string {
	return datatype.UserId
}

// GetModeratorsParams defines parameters for GetModerators.
type GetModeratorsParams struct {
	// BroadcasterId The ID of the broadcaster whose list of moderators you want to get. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId A list of user IDs used to filter the results. To specify more than one ID, include this parameter for each moderator you want to get. For example, `user_id=1234&user_id=5678`. You may specify a maximum of 100 IDs.
	//
	// The returned list includes only the users from the list who are moderators in the broadcasters channel. The list is returned in the same order as you specified the IDs.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetModeratorsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetModeratorsParams) GetUserId() []string {
	if datatype.UserId == nil {
		var empty []string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetModeratorsParams) GetFirst() string {
	if datatype.First == nil {
		var empty string
		return empty
	}
	return *datatype.First
}
func (datatype GetModeratorsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// AddChannelModeratorParams defines parameters for AddChannelModerator.
type AddChannelModeratorParams struct {
	// BroadcasterId The ID of the broadcaster that owns the chat room. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId The ID of the user to add as a moderator in the broadcasters chat room.
	UserId string `form:"user_id" json:"user_id"`
}

func (datatype AddChannelModeratorParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype AddChannelModeratorParams) GetUserId() string {
	return datatype.UserId
}

// GetShieldModeStatusParams defines parameters for GetShieldModeStatus.
type GetShieldModeStatusParams struct {
	// BroadcasterId The ID of the broadcaster whose Shield Mode activation status you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that is one of the broadcasters moderators. This ID must match the user ID in the access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype GetShieldModeStatusParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetShieldModeStatusParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// UpdateShieldModeStatusParams defines parameters for UpdateShieldModeStatus.
type UpdateShieldModeStatusParams struct {
	// BroadcasterId The ID of the broadcaster whose Shield Mode you want to activate or deactivate.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that is one of the broadcasters moderators. This ID must match the user ID in the access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype UpdateShieldModeStatusParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateShieldModeStatusParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// GetUnbanRequestsParams defines parameters for GetUnbanRequests.
type GetUnbanRequestsParams struct {
	// BroadcasterId The ID of the broadcaster whose channel is receiving unban requests.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters unban requests. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// Status Filter by a status.
	//
	// * pending
	// * approved
	// * denied
	// * acknowledged
	// * canceled
	Status string `form:"status" json:"status"`

	// UserId The ID used to filter what unban requests are returned.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// After Cursor used to get next page of results. Pagination object in response contains cursor value.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// First The maximum number of items to return per page in response
	First *int32 `form:"first,omitempty" json:"first,omitempty"`
}

func (datatype GetUnbanRequestsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetUnbanRequestsParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype GetUnbanRequestsParams) GetStatus() string {
	return datatype.Status
}
func (datatype GetUnbanRequestsParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetUnbanRequestsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetUnbanRequestsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}

// ResolveUnbanRequestsParams defines parameters for ResolveUnbanRequests.
type ResolveUnbanRequestsParams struct {
	// BroadcasterId The ID of the broadcaster whose channel is approving or denying the unban request.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the broadcaster or a user that has permission to moderate the broadcasters unban requests. This ID must match the user ID in the user access token.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`

	// UnbanRequestId The ID of the broadcaster or a user that has permission to moderate the broadcasters unban requests. This ID must match the user ID in the user access token.
	UnbanRequestId string `form:"unban_request_id" json:"unban_request_id"`

	// Status Resolution status.
	//
	// * approved
	// * denied
	Status string `form:"status" json:"status"`

	// ResolutionText Message supplied by the unban request resolver. The message is limited to a maximum of 500 characters.
	ResolutionText *string `form:"resolution_text,omitempty" json:"resolution_text,omitempty"`
}

func (datatype ResolveUnbanRequestsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype ResolveUnbanRequestsParams) GetModeratorId() string {
	return datatype.ModeratorId
}
func (datatype ResolveUnbanRequestsParams) GetUnbanRequestId() string {
	return datatype.UnbanRequestId
}
func (datatype ResolveUnbanRequestsParams) GetStatus() string {
	return datatype.Status
}
func (datatype ResolveUnbanRequestsParams) GetResolutionText() string {
	if datatype.ResolutionText == nil {
		var empty string
		return empty
	}
	return *datatype.ResolutionText
}

// WarnChatUserParams defines parameters for WarnChatUser.
type WarnChatUserParams struct {
	// BroadcasterId The ID of the channel in which the warning will take effect.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// ModeratorId The ID of the twitch user who requested the warning.
	ModeratorId string `form:"moderator_id" json:"moderator_id"`
}

func (datatype WarnChatUserParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype WarnChatUserParams) GetModeratorId() string {
	return datatype.ModeratorId
}

// GetPollsParams defines parameters for GetPolls.
type GetPollsParams struct {
	// BroadcasterId The ID of the broadcaster that created the polls. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id A list of IDs that identify the polls to return. To specify more than one ID, include this parameter for each poll you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 20 IDs.
	//
	// Specify this parameter only if you want to filter the list that the request returns. The endpoint ignores duplicate IDs and those not owned by this broadcaster.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 20 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetPollsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetPollsParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetPollsParams) GetFirst() string {
	if datatype.First == nil {
		var empty string
		return empty
	}
	return *datatype.First
}
func (datatype GetPollsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetPredictionsParams defines parameters for GetPredictions.
type GetPredictionsParams struct {
	// BroadcasterId The ID of the broadcaster whose predictions you want to get. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the prediction to get. To specify more than one ID, include this parameter for each prediction you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 25 IDs. The endpoint ignores duplicate IDs and those not owned by the broadcaster.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetPredictionsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetPredictionsParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetPredictionsParams) GetFirst() string {
	if datatype.First == nil {
		var empty string
		return empty
	}
	return *datatype.First
}
func (datatype GetPredictionsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// CancelARaidParams defines parameters for CancelARaid.
type CancelARaidParams struct {
	// BroadcasterId The ID of the broadcaster that initiated the raid. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype CancelARaidParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// StartARaidParams defines parameters for StartARaid.
type StartARaidParams struct {
	// FromBroadcasterId The ID of the broadcaster thats sending the raiding party. This ID must match the user ID in the user access token.
	FromBroadcasterId *string `form:"from_broadcaster_id,omitempty" json:"from_broadcaster_id,omitempty"`

	// ToBroadcasterId The ID of the broadcaster to raid.
	ToBroadcasterId *string `form:"to_broadcaster_id,omitempty" json:"to_broadcaster_id,omitempty"`
}

func (datatype StartARaidParams) GetFromBroadcasterId() string {
	if datatype.FromBroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.FromBroadcasterId
}
func (datatype StartARaidParams) GetToBroadcasterId() string {
	if datatype.ToBroadcasterId == nil {
		var empty string
		return empty
	}
	return *datatype.ToBroadcasterId
}

// GetChannelStreamScheduleParams defines parameters for GetChannelStreamSchedule.
type GetChannelStreamScheduleParams struct {
	// BroadcasterId The ID of the broadcaster that owns the streaming schedule you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the scheduled segment to return. To specify more than one segment, include the ID of each segment you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// StartTime The UTC date and time that identifies when in the broadcasters schedule to start returning segments. If not specified, the request returns segments starting after the current UTC date and time. Specify the date and time in RFC3339 format (for example, `2022-09-01T00:00:00Z`).
	StartTime *time.Time `form:"start_time,omitempty" json:"start_time,omitempty"`

	// UtcOffset Not supported.
	UtcOffset *string `form:"utc_offset,omitempty" json:"utc_offset,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 25 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetChannelStreamScheduleParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetChannelStreamScheduleParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetChannelStreamScheduleParams) GetStartTime() time.Time {
	if datatype.StartTime == nil {
		var empty time.Time
		return empty
	}
	return *datatype.StartTime
}
func (datatype GetChannelStreamScheduleParams) GetUtcOffset() string {
	if datatype.UtcOffset == nil {
		var empty string
		return empty
	}
	return *datatype.UtcOffset
}
func (datatype GetChannelStreamScheduleParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetChannelStreamScheduleParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetChannelIcalendarParams defines parameters for GetChannelIcalendar.
type GetChannelIcalendarParams struct {
	// BroadcasterId The ID of the broadcaster that owns the streaming schedule you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetChannelIcalendarParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// DeleteChannelStreamScheduleSegmentParams defines parameters for DeleteChannelStreamScheduleSegment.
type DeleteChannelStreamScheduleSegmentParams struct {
	// BroadcasterId The ID of the broadcaster that owns the streaming schedule. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the broadcast segment to remove.
	Id string `form:"id" json:"id"`
}

func (datatype DeleteChannelStreamScheduleSegmentParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype DeleteChannelStreamScheduleSegmentParams) GetId() string {
	return datatype.Id
}

// UpdateChannelStreamScheduleSegmentParams defines parameters for UpdateChannelStreamScheduleSegment.
type UpdateChannelStreamScheduleSegmentParams struct {
	// BroadcasterId The ID of the broadcaster who owns the broadcast segment to update. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// Id The ID of the broadcast segment to update.
	Id string `form:"id" json:"id"`
}

func (datatype UpdateChannelStreamScheduleSegmentParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateChannelStreamScheduleSegmentParams) GetId() string {
	return datatype.Id
}

// CreateChannelStreamScheduleSegmentParams defines parameters for CreateChannelStreamScheduleSegment.
type CreateChannelStreamScheduleSegmentParams struct {
	// BroadcasterId The ID of the broadcaster that owns the schedule to add the broadcast segment to. This ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype CreateChannelStreamScheduleSegmentParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// UpdateChannelStreamScheduleParams defines parameters for UpdateChannelStreamSchedule.
type UpdateChannelStreamScheduleParams struct {
	// BroadcasterId The ID of the broadcaster whose schedule settings you want to update. The ID must match the user ID in the user access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// IsVacationEnabled A Boolean value that indicates whether the broadcaster has scheduled a vacation. Set to **true** to enable Vacation Mode and add vacation dates, or **false** to cancel a previously scheduled vacation.
	IsVacationEnabled *bool `form:"is_vacation_enabled,omitempty" json:"is_vacation_enabled,omitempty"`

	// VacationStartTime The UTC date and time of when the broadcasters vacation starts. Specify the date and time in RFC3339 format (for example, 2021-05-16T00:00:00Z). Required if _is\_vacation\_enabled_ is **true**.
	VacationStartTime *time.Time `form:"vacation_start_time,omitempty" json:"vacation_start_time,omitempty"`

	// VacationEndTime The UTC date and time of when the broadcasters vacation ends. Specify the date and time in RFC3339 format (for example, 2021-05-30T23:59:59Z). Required if _is\_vacation\_enabled_ is **true**.
	VacationEndTime *time.Time `form:"vacation_end_time,omitempty" json:"vacation_end_time,omitempty"`

	// Timezone The time zone that the broadcaster broadcasts from. Specify the time zone using [IANA time zone database](https://www.iana.org/time-zones) format (for example, America/New\_York). Required if _is\_vacation\_enabled_ is **true**.
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty"`
}

func (datatype UpdateChannelStreamScheduleParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype UpdateChannelStreamScheduleParams) GetIsVacationEnabled() bool {
	if datatype.IsVacationEnabled == nil {
		var empty bool
		return empty
	}
	return *datatype.IsVacationEnabled
}
func (datatype UpdateChannelStreamScheduleParams) GetVacationStartTime() time.Time {
	if datatype.VacationStartTime == nil {
		var empty time.Time
		return empty
	}
	return *datatype.VacationStartTime
}
func (datatype UpdateChannelStreamScheduleParams) GetVacationEndTime() time.Time {
	if datatype.VacationEndTime == nil {
		var empty time.Time
		return empty
	}
	return *datatype.VacationEndTime
}
func (datatype UpdateChannelStreamScheduleParams) GetTimezone() string {
	if datatype.Timezone == nil {
		var empty string
		return empty
	}
	return *datatype.Timezone
}

// SearchCategoriesParams defines parameters for SearchCategories.
type SearchCategoriesParams struct {
	// Query The URI-encoded search string. For example, encode _#archery_ as `%23archery` and search strings like _angel of death_ as `angel%20of%20death`.
	Query string `form:"query" json:"query"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype SearchCategoriesParams) GetQuery() string {
	return datatype.Query
}
func (datatype SearchCategoriesParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype SearchCategoriesParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// SearchChannelsParams defines parameters for SearchChannels.
type SearchChannelsParams struct {
	// Query The URI-encoded search string. For example, encode search strings like _angel of death_ as `angel%20of%20death`.
	Query string `form:"query" json:"query"`

	// LiveOnly A Boolean value that determines whether the response includes only channels that are currently streaming live. Set to **true** to get only channels that are streaming live; otherwise, **false** to get live and offline channels. The default is **false**.
	LiveOnly *bool `form:"live_only,omitempty" json:"live_only,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype SearchChannelsParams) GetQuery() string {
	return datatype.Query
}
func (datatype SearchChannelsParams) GetLiveOnly() bool {
	if datatype.LiveOnly == nil {
		var empty bool
		return empty
	}
	return *datatype.LiveOnly
}
func (datatype SearchChannelsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype SearchChannelsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetSharedChatSessionParams defines parameters for GetSharedChatSession.
type GetSharedChatSessionParams struct {
	// BroadcasterId The User ID of the channel broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetSharedChatSessionParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetStreamsParams defines parameters for GetStreams.
type GetStreamsParams struct {
	// UserId A user ID used to filter the list of streams. Returns only the streams of those users that are broadcasting. You may specify a maximum of 100 IDs. To specify multiple IDs, include the _user\_id_ parameter for each user. For example, `&user_id=1234&user_id=5678`.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// UserLogin A user login name used to filter the list of streams. Returns only the streams of those users that are broadcasting. You may specify a maximum of 100 login names. To specify multiple names, include the _user\_login_ parameter for each user. For example, `&user_login=foo&user_login=bar`.
	UserLogin *[]string `form:"user_login,omitempty" json:"user_login,omitempty"`

	// GameId A game (category) ID used to filter the list of streams. Returns only the streams that are broadcasting the game (category). You may specify a maximum of 100 IDs. To specify multiple IDs, include the _game\_id_ parameter for each game. For example, `&game_id=9876&game_id=5432`.
	GameId *[]string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Type The type of stream to filter the list of streams by. Possible values are:
	//
	// * all
	// * live
	//
	// The default is _all_.
	Type *GetStreamsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// Language A language code used to filter the list of streams. Returns only streams that broadcast in the specified language. Specify the language using an ISO 639-1 two-letter language code or _other_ if the broadcast uses a language not in the list of [supported stream languages](https://help.twitch.tv/s/article/languages-on-twitch#streamlang).
	//
	// You may specify a maximum of 100 language codes. To specify multiple languages, include the _language_ parameter for each language. For example, `&language=de&language=fr`.
	Language *[]string `form:"language,omitempty" json:"language,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetStreamsParams) GetUserId() []string {
	if datatype.UserId == nil {
		var empty []string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetStreamsParams) GetUserLogin() []string {
	if datatype.UserLogin == nil {
		var empty []string
		return empty
	}
	return *datatype.UserLogin
}
func (datatype GetStreamsParams) GetGameId() []string {
	if datatype.GameId == nil {
		var empty []string
		return empty
	}
	return *datatype.GameId
}
func (datatype GetStreamsParams) GetType() GetStreamsParamsType {
	if datatype.Type == nil {
		var empty GetStreamsParamsType
		return empty
	}
	return *datatype.Type
}
func (datatype GetStreamsParams) GetLanguage() []string {
	if datatype.Language == nil {
		var empty []string
		return empty
	}
	return *datatype.Language
}
func (datatype GetStreamsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetStreamsParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}
func (datatype GetStreamsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetStreamsParamsType defines parameters for GetStreams.
type GetStreamsParamsType string

// GetFollowedStreamsParams defines parameters for GetFollowedStreams.
type GetFollowedStreamsParams struct {
	// UserId The ID of the user whose list of followed streams you want to get. This ID must match the user ID in the access token.
	UserId string `form:"user_id" json:"user_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 100.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetFollowedStreamsParams) GetUserId() string {
	return datatype.UserId
}
func (datatype GetFollowedStreamsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetFollowedStreamsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetStreamKeyParams defines parameters for GetStreamKey.
type GetStreamKeyParams struct {
	// BroadcasterId The ID of the broadcaster that owns the channel. The ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetStreamKeyParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetStreamMarkersParams defines parameters for GetStreamMarkers.
type GetStreamMarkersParams struct {
	// UserId A user ID. The request returns the markers from this users most recent video. This ID must match the user ID in the access token or the user in the access token must be one of the broadcasters editors.
	//
	// This parameter and the _video\_id_ query parameter are mutually exclusive.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// VideoId A video on demand (VOD)/video ID. The request returns the markers from this VOD/video. The user in the access token must own the video or the user must be one of the broadcasters editors.
	//
	// This parameter and the _user\_id_ query parameter are mutually exclusive.
	VideoId *string `form:"video_id,omitempty" json:"video_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetStreamMarkersParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetStreamMarkersParams) GetVideoId() string {
	if datatype.VideoId == nil {
		var empty string
		return empty
	}
	return *datatype.VideoId
}
func (datatype GetStreamMarkersParams) GetFirst() string {
	if datatype.First == nil {
		var empty string
		return empty
	}
	return *datatype.First
}
func (datatype GetStreamMarkersParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}
func (datatype GetStreamMarkersParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetStreamTagsParams defines parameters for GetStreamTags.
type GetStreamTagsParams struct {
	// BroadcasterId The ID of the broadcaster whose stream tags you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetStreamTagsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetBroadcasterSubscriptionsParams defines parameters for GetBroadcasterSubscriptions.
type GetBroadcasterSubscriptionsParams struct {
	// BroadcasterId The broadcasters ID. This ID must match the user ID in the access token.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId Filters the list to include only the specified subscribers. To specify more than one subscriber, include this parameter for each subscriber. For example, `&user_id=1234&user_id=5678`. You may specify a maximum of 100 subscribers.
	UserId *[]string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100 items per page. The default is 20.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. Do not specify if you set the _user\_id_ query parameter. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. Do not specify if you set the _user\_id_ query parameter. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

func (datatype GetBroadcasterSubscriptionsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetBroadcasterSubscriptionsParams) GetUserId() []string {
	if datatype.UserId == nil {
		var empty []string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetBroadcasterSubscriptionsParams) GetFirst() string {
	if datatype.First == nil {
		var empty string
		return empty
	}
	return *datatype.First
}
func (datatype GetBroadcasterSubscriptionsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetBroadcasterSubscriptionsParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}

// CheckUserSubscriptionParams defines parameters for CheckUserSubscription.
type CheckUserSubscriptionParams struct {
	// BroadcasterId The ID of a partner or affiliate broadcaster.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// UserId The ID of the user that youre checking to see whether they subscribe to the broadcaster in _broadcaster\_id_. This ID must match the user ID in the access Token.
	UserId string `form:"user_id" json:"user_id"`
}

func (datatype CheckUserSubscriptionParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype CheckUserSubscriptionParams) GetUserId() string {
	return datatype.UserId
}

// GetAllStreamTagsParams defines parameters for GetAllStreamTags.
type GetAllStreamTagsParams struct {
	// TagId The ID of the tag to get. Used to filter the list of tags. To specify more than one tag, include the _tag\_id_ parameter for each tag to get. For example, `tag_id=1234&tag_id=5678`. The maximum number of IDs you may specify is 100\. Ignores invalid IDs but not duplicate IDs.
	TagId *[]string `form:"tag_id,omitempty" json:"tag_id,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetAllStreamTagsParams) GetTagId() []string {
	if datatype.TagId == nil {
		var empty []string
		return empty
	}
	return *datatype.TagId
}
func (datatype GetAllStreamTagsParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetAllStreamTagsParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams struct {
	// Name The name of the team to get. This parameter and the _id_ parameter are mutually exclusive; you must specify the teams name or ID but not both.
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Id The ID of the team to get. This parameter and the _name_ parameter are mutually exclusive; you must specify the teams name or ID but not both.
	Id *string `form:"id,omitempty" json:"id,omitempty"`
}

func (datatype GetTeamsParams) GetName() string {
	if datatype.Name == nil {
		var empty string
		return empty
	}
	return *datatype.Name
}
func (datatype GetTeamsParams) GetId() string {
	if datatype.Id == nil {
		var empty string
		return empty
	}
	return *datatype.Id
}

// GetChannelTeamsParams defines parameters for GetChannelTeams.
type GetChannelTeamsParams struct {
	// BroadcasterId The ID of the broadcaster whose teams you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`
}

func (datatype GetChannelTeamsParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Id The ID of the user to get. To specify more than one user, include the _id_ parameter for each user to get. For example, `id=1234&id=5678`. The maximum number of IDs you may specify is 100.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// Login The login name of the user to get. To specify more than one user, include the _login_ parameter for each user to get. For example, `login=foo&login=bar`. The maximum number of login names you may specify is 100.
	Login *[]string `form:"login,omitempty" json:"login,omitempty"`
}

func (datatype GetUsersParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetUsersParams) GetLogin() []string {
	if datatype.Login == nil {
		var empty []string
		return empty
	}
	return *datatype.Login
}

// UpdateUserParams defines parameters for UpdateUser.
type UpdateUserParams struct {
	// Description The string to update the channels description to. The description is limited to a maximum of 300 characters.
	//
	// To remove the description, specify this parameter but dont set its value (for example, `?description=`).
	Description *string `form:"description,omitempty" json:"description,omitempty"`
}

func (datatype UpdateUserParams) GetDescription() string {
	if datatype.Description == nil {
		var empty string
		return empty
	}
	return *datatype.Description
}

// UnblockUserParams defines parameters for UnblockUser.
type UnblockUserParams struct {
	// TargetUserId The ID of the user to remove from the broadcasters list of blocked users. The API ignores the request if the broadcaster hasnt blocked the user.
	TargetUserId string `form:"target_user_id" json:"target_user_id"`
}

func (datatype UnblockUserParams) GetTargetUserId() string {
	return datatype.TargetUserId
}

// GetUserBlockListParams defines parameters for GetUserBlockList.
type GetUserBlockListParams struct {
	// BroadcasterId The ID of the broadcaster whose list of blocked users you want to get.
	BroadcasterId string `form:"broadcaster_id" json:"broadcaster_id"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	First *int32 `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	After *string `form:"after,omitempty" json:"after,omitempty"`
}

func (datatype GetUserBlockListParams) GetBroadcasterId() string {
	return datatype.BroadcasterId
}
func (datatype GetUserBlockListParams) GetFirst() int32 {
	if datatype.First == nil {
		var empty int32
		return empty
	}
	return *datatype.First
}
func (datatype GetUserBlockListParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}

// BlockUserParams defines parameters for BlockUser.
type BlockUserParams struct {
	// TargetUserId The ID of the user to block. The API ignores the request if the broadcaster has already blocked the user.
	TargetUserId string `form:"target_user_id" json:"target_user_id"`

	// SourceContext The location where the harassment took place that is causing the brodcaster to block the user. Possible values are:
	//
	// * chat
	// * whisper
	//
	// .
	SourceContext *BlockUserParamsSourceContext `form:"source_context,omitempty" json:"source_context,omitempty"`

	// Reason The reason that the broadcaster is blocking the user. Possible values are:
	//
	// * harassment
	// * spam
	// * other
	Reason *BlockUserParamsReason `form:"reason,omitempty" json:"reason,omitempty"`
}

func (datatype BlockUserParams) GetTargetUserId() string {
	return datatype.TargetUserId
}
func (datatype BlockUserParams) GetSourceContext() BlockUserParamsSourceContext {
	if datatype.SourceContext == nil {
		var empty BlockUserParamsSourceContext
		return empty
	}
	return *datatype.SourceContext
}
func (datatype BlockUserParams) GetReason() BlockUserParamsReason {
	if datatype.Reason == nil {
		var empty BlockUserParamsReason
		return empty
	}
	return *datatype.Reason
}

// BlockUserParamsSourceContext defines parameters for BlockUser.
type BlockUserParamsSourceContext string

// BlockUserParamsReason defines parameters for BlockUser.
type BlockUserParamsReason string

// GetUserActiveExtensionsParams defines parameters for GetUserActiveExtensions.
type GetUserActiveExtensionsParams struct {
	// UserId The ID of the broadcaster whose active extensions you want to get.
	//
	// This parameter is required if you specify an app access token and is optional if you specify a user access token. If you specify a user access token and dont specify this parameter, the API uses the user ID from the access token.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`
}

func (datatype GetUserActiveExtensionsParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}

// DeleteVideosParams defines parameters for DeleteVideos.
type DeleteVideosParams struct {
	// Id The list of videos to delete. To specify more than one video, include the _id_ parameter for each video to delete. For example, `id=1234&id=5678`. You can delete a maximum of 5 videos per request. Ignores invalid video IDs.
	//
	// If the user doesnt have permission to delete one of the videos in the list, none of the videos are deleted.
	Id []string `form:"id" json:"id"`
}

func (datatype DeleteVideosParams) GetId() []string {
	return datatype.Id
}

// GetVideosParams defines parameters for GetVideos.
type GetVideosParams struct {
	// Id A list of IDs that identify the videos you want to get. To get more than one video, include this parameter for each video you want to get. For example, `id=1234&id=5678`. You may specify a maximum of 100 IDs. The endpoint ignores duplicate IDs and IDs that weren't found (if there's at least one valid ID).
	//
	// The _id_, _user\_id_, and _game\_id_ parameters are mutually exclusive.
	Id *[]string `form:"id,omitempty" json:"id,omitempty"`

	// UserId The ID of the user whose list of videos you want to get.
	//
	// The _id_, _user\_id_, and _game\_id_ parameters are mutually exclusive.
	UserId *string `form:"user_id,omitempty" json:"user_id,omitempty"`

	// GameId A category or game ID. The response contains a maximum of 500 videos that show this content. To get category/game IDs, use the [Search Categories](https://dev.twitch.tv/docs/api/reference#search-categories) endpoint.
	//
	// The _id_, _user\_id_, and _game\_id_ parameters are mutually exclusive.
	GameId *string `form:"game_id,omitempty" json:"game_id,omitempty"`

	// Language A filter used to filter the list of videos by the language that the video owner broadcasts in. For example, to get videos that were broadcast in German, set this parameter to the ISO 639-1 two-letter code for German (i.e., DE). For a list of supported languages, see [Supported Stream Language](https://help.twitch.tv/s/article/languages-on-twitch#streamlang). If the language is not supported, use other.
	//
	// Specify this parameter only if you specify the _game\_id_ query parameter.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Period A filter used to filter the list of videos by when they were published. For example, videos published in the last week. Possible values are:
	//
	// * all
	// * day
	// * month
	// * week
	//
	// The default is "all," which returns videos published in all periods.
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	Period *GetVideosParamsPeriod `form:"period,omitempty" json:"period,omitempty"`

	// Sort The order to sort the returned videos in. Possible values are:
	//
	// * time  Sort the results in descending order by when they were created (i.e., latest video first).
	// * trending  Sort the results in descending order by biggest gains in viewership (i.e., highest trending video first).
	// * views  Sort the results in descending order by most views (i.e., highest number of views first).
	//
	// The default is "time."
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	Sort *GetVideosParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Type A filter used to filter the list of videos by the video's type. Possible case-sensitive values are:
	//
	// * all
	// * archive  On-demand videos (VODs) of past streams.
	// * highlight  Highlight reels of past streams.
	// * upload  External videos that the broadcaster uploaded using the Video Producer.
	//
	// The default is "all," which returns all video types.
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	Type *GetVideosParamsType `form:"type,omitempty" json:"type,omitempty"`

	// First The maximum number of items to return per page in the response. The minimum page size is 1 item per page and the maximum is 100\. The default is 20.
	//
	// Specify this parameter only if you specify the _game\_id_ or _user\_id_ query parameter.
	First *string `form:"first,omitempty" json:"first,omitempty"`

	// After The cursor used to get the next page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// Specify this parameter only if you specify the _user\_id_ query parameter.
	After *string `form:"after,omitempty" json:"after,omitempty"`

	// Before The cursor used to get the previous page of results. The **Pagination** object in the response contains the cursors value. [Read More](https://dev.twitch.tv/docs/api/guide#pagination)
	//
	// Specify this parameter only if you specify the _user\_id_ query parameter.
	Before *string `form:"before,omitempty" json:"before,omitempty"`
}

func (datatype GetVideosParams) GetId() []string {
	if datatype.Id == nil {
		var empty []string
		return empty
	}
	return *datatype.Id
}
func (datatype GetVideosParams) GetUserId() string {
	if datatype.UserId == nil {
		var empty string
		return empty
	}
	return *datatype.UserId
}
func (datatype GetVideosParams) GetGameId() string {
	if datatype.GameId == nil {
		var empty string
		return empty
	}
	return *datatype.GameId
}
func (datatype GetVideosParams) GetLanguage() string {
	if datatype.Language == nil {
		var empty string
		return empty
	}
	return *datatype.Language
}
func (datatype GetVideosParams) GetPeriod() GetVideosParamsPeriod {
	if datatype.Period == nil {
		var empty GetVideosParamsPeriod
		return empty
	}
	return *datatype.Period
}
func (datatype GetVideosParams) GetSort() GetVideosParamsSort {
	if datatype.Sort == nil {
		var empty GetVideosParamsSort
		return empty
	}
	return *datatype.Sort
}
func (datatype GetVideosParams) GetType() GetVideosParamsType {
	if datatype.Type == nil {
		var empty GetVideosParamsType
		return empty
	}
	return *datatype.Type
}
func (datatype GetVideosParams) GetFirst() string {
	if datatype.First == nil {
		var empty string
		return empty
	}
	return *datatype.First
}
func (datatype GetVideosParams) GetAfter() string {
	if datatype.After == nil {
		var empty string
		return empty
	}
	return *datatype.After
}
func (datatype GetVideosParams) GetBefore() string {
	if datatype.Before == nil {
		var empty string
		return empty
	}
	return *datatype.Before
}

// GetVideosParamsPeriod defines parameters for GetVideos.
type GetVideosParamsPeriod string

// GetVideosParamsSort defines parameters for GetVideos.
type GetVideosParamsSort string

// GetVideosParamsType defines parameters for GetVideos.
type GetVideosParamsType string

// SendWhisperParams defines parameters for SendWhisper.
type SendWhisperParams struct {
	// FromUserId The ID of the user sending the whisper. This user must have a verified phone number. This ID must match the user ID in the user access token.
	FromUserId string `form:"from_user_id" json:"from_user_id"`

	// ToUserId The ID of the user to receive the whisper.
	ToUserId string `form:"to_user_id" json:"to_user_id"`
}

func (datatype SendWhisperParams) GetFromUserId() string {
	return datatype.FromUserId
}
func (datatype SendWhisperParams) GetToUserId() string {
	return datatype.ToUserId
}

//Generated with request-bodies.tmpl

// UpdateExtensionBitsProductJSONRequestBody defines body for UpdateExtensionBitsProduct for application/json ContentType.
type UpdateExtensionBitsProductJSONRequestBody = UpdateExtensionBitsProductBody

// UpdateCustomRewardJSONRequestBody defines body for UpdateCustomReward for application/json ContentType.
type UpdateCustomRewardJSONRequestBody = UpdateCustomRewardBody

// CreateCustomRewardsJSONRequestBody defines body for CreateCustomRewards for application/json ContentType.
type CreateCustomRewardsJSONRequestBody = CreateCustomRewardsBody

// UpdateRedemptionStatusJSONRequestBody defines body for UpdateRedemptionStatus for application/json ContentType.
type UpdateRedemptionStatusJSONRequestBody = UpdateRedemptionStatusBody

// ModifyChannelInformationJSONRequestBody defines body for ModifyChannelInformation for application/json ContentType.
type ModifyChannelInformationJSONRequestBody = ModifyChannelInformationBody

// StartCommercialJSONRequestBody defines body for StartCommercial for application/json ContentType.
type StartCommercialJSONRequestBody = StartCommercialBody

// SendChatAnnouncementJSONRequestBody defines body for SendChatAnnouncement for application/json ContentType.
type SendChatAnnouncementJSONRequestBody = SendChatAnnouncementBody

// SendChatMessageJSONRequestBody defines body for SendChatMessage for application/json ContentType.
type SendChatMessageJSONRequestBody = SendChatMessageBody

// UpdateChatSettingsJSONRequestBody defines body for UpdateChatSettings for application/json ContentType.
type UpdateChatSettingsJSONRequestBody = UpdateChatSettingsBody

// UpdateDropsEntitlementsJSONRequestBody defines body for UpdateDropsEntitlements for application/json ContentType.
type UpdateDropsEntitlementsJSONRequestBody = UpdateDropsEntitlementsBody

// UpdateConduitsJSONRequestBody defines body for UpdateConduits for application/json ContentType.
type UpdateConduitsJSONRequestBody = UpdateConduitsBody

// CreateConduitsJSONRequestBody defines body for CreateConduits for application/json ContentType.
type CreateConduitsJSONRequestBody = CreateConduitsBody

// UpdateConduitShardsJSONRequestBody defines body for UpdateConduitShards for application/json ContentType.
type UpdateConduitShardsJSONRequestBody = UpdateConduitShardsBody

// CreateEventsubSubscriptionJSONRequestBody defines body for CreateEventsubSubscription for application/json ContentType.
type CreateEventsubSubscriptionJSONRequestBody = CreateEventSubSubscriptionBody

// SendExtensionChatMessageJSONRequestBody defines body for SendExtensionChatMessage for application/json ContentType.
type SendExtensionChatMessageJSONRequestBody = SendExtensionChatMessageBody

// SetExtensionConfigurationSegmentJSONRequestBody defines body for SetExtensionConfigurationSegment for application/json ContentType.
type SetExtensionConfigurationSegmentJSONRequestBody = SetExtensionConfigurationSegmentBody

// SendExtensionPubsubMessageJSONRequestBody defines body for SendExtensionPubsubMessage for application/json ContentType.
type SendExtensionPubsubMessageJSONRequestBody = SendExtensionPubSubMessageBody

// SetExtensionRequiredConfigurationJSONRequestBody defines body for SetExtensionRequiredConfiguration for application/json ContentType.
type SetExtensionRequiredConfigurationJSONRequestBody = SetExtensionRequiredConfigurationBody

// UpdateChannelGuestStarSettingsJSONRequestBody defines body for UpdateChannelGuestStarSettings for application/json ContentType.
type UpdateChannelGuestStarSettingsJSONRequestBody = UpdateChannelGuestStarSettingsBody

// ManageHeldAutomodMessagesJSONRequestBody defines body for ManageHeldAutomodMessages for application/json ContentType.
type ManageHeldAutomodMessagesJSONRequestBody = ManageHeldAutoModMessagesBody

// UpdateAutomodSettingsJSONRequestBody defines body for UpdateAutomodSettings for application/json ContentType.
type UpdateAutomodSettingsJSONRequestBody = UpdateAutoModSettingsBody

// BanUserJSONRequestBody defines body for BanUser for application/json ContentType.
type BanUserJSONRequestBody = BanUserBody

// AddBlockedTermJSONRequestBody defines body for AddBlockedTerm for application/json ContentType.
type AddBlockedTermJSONRequestBody = AddBlockedTermBody

// CheckAutomodStatusJSONRequestBody defines body for CheckAutomodStatus for application/json ContentType.
type CheckAutomodStatusJSONRequestBody = CheckAutoModStatusBody

// UpdateShieldModeStatusJSONRequestBody defines body for UpdateShieldModeStatus for application/json ContentType.
type UpdateShieldModeStatusJSONRequestBody = UpdateShieldModeStatusBody

// WarnChatUserJSONRequestBody defines body for WarnChatUser for application/json ContentType.
type WarnChatUserJSONRequestBody = WarnChatUserBody

// EndPollJSONRequestBody defines body for EndPoll for application/json ContentType.
type EndPollJSONRequestBody = EndPollBody

// CreatePollJSONRequestBody defines body for CreatePoll for application/json ContentType.
type CreatePollJSONRequestBody = CreatePollBody

// EndPredictionJSONRequestBody defines body for EndPrediction for application/json ContentType.
type EndPredictionJSONRequestBody = EndPredictionBody

// CreatePredictionJSONRequestBody defines body for CreatePrediction for application/json ContentType.
type CreatePredictionJSONRequestBody = CreatePredictionBody

// UpdateChannelStreamScheduleSegmentJSONRequestBody defines body for UpdateChannelStreamScheduleSegment for application/json ContentType.
type UpdateChannelStreamScheduleSegmentJSONRequestBody = UpdateChannelStreamScheduleSegmentBody

// CreateChannelStreamScheduleSegmentJSONRequestBody defines body for CreateChannelStreamScheduleSegment for application/json ContentType.
type CreateChannelStreamScheduleSegmentJSONRequestBody = CreateChannelStreamScheduleSegmentBody

// CreateStreamMarkerJSONRequestBody defines body for CreateStreamMarker for application/json ContentType.
type CreateStreamMarkerJSONRequestBody = CreateStreamMarkerBody

// UpdateUserExtensionsJSONRequestBody defines body for UpdateUserExtensions for application/json ContentType.
type UpdateUserExtensionsJSONRequestBody = UpdateUserExtensionsBody

// SendWhisperJSONRequestBody defines body for SendWhisper for application/json ContentType.
type SendWhisperJSONRequestBody = SendWhisperBody

// Generated with additional-properties.tmpl
// Generated with additional-properties.tmpl
// Generated with client.tmpl
// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetExtensionAnalytics request
	GetExtensionAnalytics(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGameAnalytics request
	GetGameAnalytics(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCheermotes request
	GetCheermotes(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionBitsProducts request
	GetExtensionBitsProducts(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateExtensionBitsProductWithBody request with any body
	UpdateExtensionBitsProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateExtensionBitsProduct(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBitsLeaderboard request
	GetBitsLeaderboard(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomReward request
	DeleteCustomReward(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomReward request
	GetCustomReward(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomRewardWithBody request with any body
	UpdateCustomRewardWithBody(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomReward(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomRewardsWithBody request with any body
	CreateCustomRewardsWithBody(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomRewards(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomRewardRedemption request
	GetCustomRewardRedemption(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRedemptionStatusWithBody request with any body
	UpdateRedemptionStatusWithBody(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRedemptionStatus(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelInformation request
	GetChannelInformation(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ModifyChannelInformationWithBody request with any body
	ModifyChannelInformationWithBody(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ModifyChannelInformation(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAdSchedule request
	GetAdSchedule(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SnoozeNextAd request
	SnoozeNextAd(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartCommercialWithBody request with any body
	StartCommercialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	StartCommercial(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelEditors request
	GetChannelEditors(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFollowedChannels request
	GetFollowedChannels(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelFollowers request
	GetChannelFollowers(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveChannelVip request
	RemoveChannelVip(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVips request
	GetVips(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelVip request
	AddChannelVip(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharityCampaign request
	GetCharityCampaign(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharityCampaignDonations request
	GetCharityCampaignDonations(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendChatAnnouncementWithBody request with any body
	SendChatAnnouncementWithBody(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendChatAnnouncement(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelChatBadges request
	GetChannelChatBadges(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalChatBadges request
	GetGlobalChatBadges(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChatters request
	GetChatters(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserChatColor request
	GetUserChatColor(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserChatColor request
	UpdateUserChatColor(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelEmotes request
	GetChannelEmotes(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalEmotes request
	GetGlobalEmotes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEmoteSets request
	GetEmoteSets(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserEmotes request
	GetUserEmotes(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendChatMessageWithBody request with any body
	SendChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendChatMessage(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChatSettings request
	GetChatSettings(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChatSettingsWithBody request with any body
	UpdateChatSettingsWithBody(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChatSettings(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendAShoutout request
	SendAShoutout(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClips request
	GetClips(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateClip request
	CreateClip(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContentClassificationLabels request
	GetContentClassificationLabels(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDropsEntitlements request
	GetDropsEntitlements(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDropsEntitlementsWithBody request with any body
	UpdateDropsEntitlementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDropsEntitlements(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConduit request
	DeleteConduit(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConduits request
	GetConduits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConduitsWithBody request with any body
	UpdateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConduits(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConduitsWithBody request with any body
	CreateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConduits(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConduitShards request
	GetConduitShards(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConduitShardsWithBody request with any body
	UpdateConduitShardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConduitShards(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEventsubSubscription request
	DeleteEventsubSubscription(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsubSubscriptions request
	GetEventsubSubscriptions(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEventsubSubscriptionWithBody request with any body
	CreateEventsubSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEventsubSubscription(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensions request
	GetExtensions(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendExtensionChatMessageWithBody request with any body
	SendExtensionChatMessageWithBody(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendExtensionChatMessage(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionConfigurationSegment request
	GetExtensionConfigurationSegment(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetExtensionConfigurationSegmentWithBody request with any body
	SetExtensionConfigurationSegmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetExtensionConfigurationSegment(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionSecrets request
	GetExtensionSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateExtensionSecret request
	CreateExtensionSecret(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionLiveChannels request
	GetExtensionLiveChannels(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendExtensionPubsubMessageWithBody request with any body
	SendExtensionPubsubMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendExtensionPubsubMessage(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReleasedExtensions request
	GetReleasedExtensions(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetExtensionRequiredConfigurationWithBody request with any body
	SetExtensionRequiredConfigurationWithBody(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetExtensionRequiredConfiguration(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExtensionTransactions request
	GetExtensionTransactions(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGames request
	GetGames(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopGames request
	GetTopGames(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCreatorGoals request
	GetCreatorGoals(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelGuestStarSettings request
	GetChannelGuestStarSettings(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelGuestStarSettingsWithBody request with any body
	UpdateChannelGuestStarSettingsWithBody(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelGuestStarSettings(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGuestStarInvite request
	DeleteGuestStarInvite(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGuestStarInvites request
	GetGuestStarInvites(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendGuestStarInvite request
	SendGuestStarInvite(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndGuestStarSession request
	EndGuestStarSession(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGuestStarSession request
	GetGuestStarSession(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGuestStarSession request
	CreateGuestStarSession(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGuestStarSlot request
	DeleteGuestStarSlot(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGuestStarSlot request
	UpdateGuestStarSlot(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AssignGuestStarSlot request
	AssignGuestStarSlot(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGuestStarSlotSettings request
	UpdateGuestStarSlotSettings(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHypeTrainEvents request
	GetHypeTrainEvents(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ManageHeldAutomodMessagesWithBody request with any body
	ManageHeldAutomodMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ManageHeldAutomodMessages(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAutomodSettings request
	GetAutomodSettings(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAutomodSettingsWithBody request with any body
	UpdateAutomodSettingsWithBody(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAutomodSettings(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBannedUsers request
	GetBannedUsers(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnbanUser request
	UnbanUser(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BanUserWithBody request with any body
	BanUserWithBody(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BanUser(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveBlockedTerm request
	RemoveBlockedTerm(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBlockedTerms request
	GetBlockedTerms(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBlockedTermWithBody request with any body
	AddBlockedTermWithBody(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddBlockedTerm(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModeratedChannels request
	GetModeratedChannels(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChatMessages request
	DeleteChatMessages(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckAutomodStatusWithBody request with any body
	CheckAutomodStatusWithBody(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CheckAutomodStatus(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveChannelModerator request
	RemoveChannelModerator(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetModerators request
	GetModerators(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddChannelModerator request
	AddChannelModerator(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetShieldModeStatus request
	GetShieldModeStatus(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateShieldModeStatusWithBody request with any body
	UpdateShieldModeStatusWithBody(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateShieldModeStatus(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUnbanRequests request
	GetUnbanRequests(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResolveUnbanRequests request
	ResolveUnbanRequests(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// WarnChatUserWithBody request with any body
	WarnChatUserWithBody(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	WarnChatUser(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolls request
	GetPolls(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndPollWithBody request with any body
	EndPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndPoll(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePollWithBody request with any body
	CreatePollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePoll(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPredictions request
	GetPredictions(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndPredictionWithBody request with any body
	EndPredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndPrediction(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePredictionWithBody request with any body
	CreatePredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePrediction(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CancelARaid request
	CancelARaid(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StartARaid request
	StartARaid(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelStreamSchedule request
	GetChannelStreamSchedule(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelIcalendar request
	GetChannelIcalendar(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChannelStreamScheduleSegment request
	DeleteChannelStreamScheduleSegment(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelStreamScheduleSegmentWithBody request with any body
	UpdateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateChannelStreamScheduleSegment(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateChannelStreamScheduleSegmentWithBody request with any body
	CreateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateChannelStreamScheduleSegment(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateChannelStreamSchedule request
	UpdateChannelStreamSchedule(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchCategories request
	SearchCategories(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchChannels request
	SearchChannels(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSharedChatSession request
	GetSharedChatSession(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreams request
	GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFollowedStreams request
	GetFollowedStreams(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamKey request
	GetStreamKey(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamMarkers request
	GetStreamMarkers(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStreamMarkerWithBody request with any body
	CreateStreamMarkerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStreamMarker(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStreamTags request
	GetStreamTags(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBroadcasterSubscriptions request
	GetBroadcasterSubscriptions(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckUserSubscription request
	CheckUserSubscription(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllStreamTags request
	GetAllStreamTags(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeams request
	GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChannelTeams request
	GetChannelTeams(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUser request
	UpdateUser(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnblockUser request
	UnblockUser(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserBlockList request
	GetUserBlockList(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BlockUser request
	BlockUser(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserActiveExtensions request
	GetUserActiveExtensions(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserExtensionsWithBody request with any body
	UpdateUserExtensionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserExtensions(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserExtensions request
	GetUserExtensions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteVideos request
	DeleteVideos(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetVideos request
	GetVideos(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SendWhisperWithBody request with any body
	SendWhisperWithBody(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SendWhisper(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetExtensionAnalytics(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGameAnalytics(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGameAnalyticsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCheermotes(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCheermotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionBitsProducts(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionBitsProductsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExtensionBitsProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExtensionBitsProductRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateExtensionBitsProduct(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateExtensionBitsProductRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBitsLeaderboard(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBitsLeaderboardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomReward(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomRewardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomReward(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomRewardRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomRewardWithBody(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomRewardRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomReward(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomRewardRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomRewardsWithBody(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomRewardsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomRewards(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomRewardsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomRewardRedemption(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomRewardRedemptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRedemptionStatusWithBody(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRedemptionStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRedemptionStatus(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRedemptionStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelInformation(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelInformationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyChannelInformationWithBody(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyChannelInformationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ModifyChannelInformation(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewModifyChannelInformationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAdSchedule(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAdScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SnoozeNextAd(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSnoozeNextAdRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartCommercialWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartCommercialRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartCommercial(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartCommercialRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelEditors(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelEditorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFollowedChannels(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFollowedChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelFollowers(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelFollowersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveChannelVip(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveChannelVipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVips(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelVip(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelVipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharityCampaign(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharityCampaignRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharityCampaignDonations(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharityCampaignDonationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatAnnouncementWithBody(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatAnnouncementRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatAnnouncement(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatAnnouncementRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelChatBadges(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelChatBadgesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalChatBadges(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalChatBadgesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChatters(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChattersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserChatColor(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserChatColorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserChatColor(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserChatColorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelEmotes(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelEmotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalEmotes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalEmotesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEmoteSets(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEmoteSetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserEmotes(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserEmotesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendChatMessage(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendChatMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChatSettings(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChatSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChatSettingsWithBody(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChatSettings(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChatSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendAShoutout(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendAShoutoutRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClips(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClipsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateClip(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateClipRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContentClassificationLabels(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContentClassificationLabelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDropsEntitlements(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDropsEntitlementsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDropsEntitlementsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDropsEntitlementsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDropsEntitlements(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDropsEntitlementsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConduit(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConduitRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConduits(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConduitsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduits(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConduitsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConduitsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConduits(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConduitsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConduitShards(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConduitShardsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduitShardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitShardsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConduitShards(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConduitShardsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEventsubSubscription(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEventsubSubscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsubSubscriptions(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsubSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventsubSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventsubSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEventsubSubscription(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEventsubSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensions(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionChatMessageWithBody(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionChatMessageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionChatMessage(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionChatMessageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionConfigurationSegment(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionConfigurationSegmentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionConfigurationSegmentWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionConfigurationSegmentRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionConfigurationSegment(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionConfigurationSegmentRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionSecrets(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionSecretsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateExtensionSecret(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateExtensionSecretRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionLiveChannels(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionLiveChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionPubsubMessageWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionPubsubMessageRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendExtensionPubsubMessage(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendExtensionPubsubMessageRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReleasedExtensions(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReleasedExtensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionRequiredConfigurationWithBody(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionRequiredConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetExtensionRequiredConfiguration(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetExtensionRequiredConfigurationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExtensionTransactions(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExtensionTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGames(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGamesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopGames(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopGamesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCreatorGoals(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCreatorGoalsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelGuestStarSettings(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelGuestStarSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelGuestStarSettingsWithBody(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelGuestStarSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelGuestStarSettings(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelGuestStarSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGuestStarInvite(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGuestStarInviteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGuestStarInvites(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGuestStarInvitesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendGuestStarInvite(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendGuestStarInviteRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndGuestStarSession(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndGuestStarSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGuestStarSession(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGuestStarSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGuestStarSession(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGuestStarSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGuestStarSlot(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGuestStarSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGuestStarSlot(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGuestStarSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AssignGuestStarSlot(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAssignGuestStarSlotRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGuestStarSlotSettings(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGuestStarSlotSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHypeTrainEvents(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHypeTrainEventsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageHeldAutomodMessagesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageHeldAutomodMessagesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ManageHeldAutomodMessages(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewManageHeldAutomodMessagesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAutomodSettings(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAutomodSettingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomodSettingsWithBody(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomodSettingsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAutomodSettings(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAutomodSettingsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBannedUsers(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBannedUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnbanUser(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnbanUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanUserWithBody(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BanUser(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBanUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveBlockedTerm(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveBlockedTermRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBlockedTerms(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBlockedTermsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBlockedTermWithBody(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBlockedTermRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBlockedTerm(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBlockedTermRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModeratedChannels(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModeratedChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChatMessages(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChatMessagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAutomodStatusWithBody(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAutomodStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckAutomodStatus(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAutomodStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveChannelModerator(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveChannelModeratorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetModerators(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetModeratorsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddChannelModerator(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddChannelModeratorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetShieldModeStatus(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetShieldModeStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShieldModeStatusWithBody(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShieldModeStatusRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateShieldModeStatus(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateShieldModeStatusRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUnbanRequests(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUnbanRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResolveUnbanRequests(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResolveUnbanRequestsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WarnChatUserWithBody(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWarnChatUserRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) WarnChatUser(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewWarnChatUserRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolls(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPollsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPoll(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePollWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePollRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePoll(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePollRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPredictions(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPredictionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPredictionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndPrediction(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndPredictionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePredictionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePredictionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePrediction(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePredictionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CancelARaid(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCancelARaidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StartARaid(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStartARaidRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelStreamSchedule(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelStreamScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelIcalendar(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelIcalendarRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChannelStreamScheduleSegment(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChannelStreamScheduleSegmentRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelStreamScheduleSegmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelStreamScheduleSegment(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelStreamScheduleSegmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelStreamScheduleSegmentWithBody(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelStreamScheduleSegmentRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateChannelStreamScheduleSegment(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateChannelStreamScheduleSegmentRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateChannelStreamSchedule(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateChannelStreamScheduleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchCategories(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchChannels(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSharedChatSession(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSharedChatSessionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreams(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFollowedStreams(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFollowedStreamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamKey(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamKeyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamMarkers(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamMarkersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStreamMarkerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStreamMarkerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStreamMarker(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStreamMarkerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStreamTags(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStreamTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBroadcasterSubscriptions(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBroadcasterSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckUserSubscription(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckUserSubscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllStreamTags(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllStreamTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChannelTeams(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChannelTeamsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUser(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnblockUser(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnblockUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserBlockList(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserBlockListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BlockUser(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBlockUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserActiveExtensions(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserActiveExtensionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserExtensionsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserExtensionsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserExtensions(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserExtensionsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserExtensions(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserExtensionsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteVideos(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteVideosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetVideos(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetVideosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendWhisperWithBody(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendWhisperRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SendWhisper(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSendWhisperRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err = c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetExtensionAnalyticsRequest generates requests for GetExtensionAnalytics
func NewGetExtensionAnalyticsRequest(server string, params *GetExtensionAnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ExtensionId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, *params.ExtensionId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ended_at", runtime.ParamLocationQuery, *params.EndedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGameAnalyticsRequest generates requests for GetGameAnalytics
func NewGetGameAnalyticsRequest(server string, params *GetGameAnalyticsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/analytics/games")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ended_at", runtime.ParamLocationQuery, *params.EndedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCheermotesRequest generates requests for GetCheermotes
func NewGetCheermotesRequest(server string, params *GetCheermotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/cheermotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExtensionBitsProductsRequest generates requests for GetExtensionBitsProducts
func NewGetExtensionBitsProductsRequest(server string, params *GetExtensionBitsProductsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShouldIncludeAll != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "should_include_all", runtime.ParamLocationQuery, *params.ShouldIncludeAll); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateExtensionBitsProductRequest calls the generic UpdateExtensionBitsProduct builder with application/json body
func NewUpdateExtensionBitsProductRequest(server string, body UpdateExtensionBitsProductJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateExtensionBitsProductRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateExtensionBitsProductRequestWithBody generates requests for UpdateExtensionBitsProduct with any type of body
func NewUpdateExtensionBitsProductRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBitsLeaderboardRequest generates requests for GetBitsLeaderboard
func NewGetBitsLeaderboardRequest(server string, params *GetBitsLeaderboardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/bits/leaderboard")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Count != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, *params.Count); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Period != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, *params.Period); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomRewardRequest generates requests for DeleteCustomReward
func NewDeleteCustomRewardRequest(server string, params *DeleteCustomRewardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomRewardRequest generates requests for GetCustomReward
func NewGetCustomRewardRequest(server string, params *GetCustomRewardParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyManageableRewards != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "only_manageable_rewards", runtime.ParamLocationQuery, *params.OnlyManageableRewards); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomRewardRequest calls the generic UpdateCustomReward builder with application/json body
func NewUpdateCustomRewardRequest(server string, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomRewardRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateCustomRewardRequestWithBody generates requests for UpdateCustomReward with any type of body
func NewUpdateCustomRewardRequestWithBody(server string, params *UpdateCustomRewardParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateCustomRewardsRequest calls the generic CreateCustomRewards builder with application/json body
func NewCreateCustomRewardsRequest(server string, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomRewardsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateCustomRewardsRequestWithBody generates requests for CreateCustomRewards with any type of body
func NewCreateCustomRewardsRequestWithBody(server string, params *CreateCustomRewardsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomRewardRedemptionRequest generates requests for GetCustomRewardRedemption
func NewGetCustomRewardRedemptionRequest(server string, params *GetCustomRewardRedemptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards/redemptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_id", runtime.ParamLocationQuery, params.RewardId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRedemptionStatusRequest calls the generic UpdateRedemptionStatus builder with application/json body
func NewUpdateRedemptionStatusRequest(server string, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRedemptionStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateRedemptionStatusRequestWithBody generates requests for UpdateRedemptionStatus with any type of body
func NewUpdateRedemptionStatusRequestWithBody(server string, params *UpdateRedemptionStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channel_points/custom_rewards/redemptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reward_id", runtime.ParamLocationQuery, params.RewardId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelInformationRequest generates requests for GetChannelInformation
func NewGetChannelInformationRequest(server string, params *GetChannelInformationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewModifyChannelInformationRequest calls the generic ModifyChannelInformation builder with application/json body
func NewModifyChannelInformationRequest(server string, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewModifyChannelInformationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewModifyChannelInformationRequestWithBody generates requests for ModifyChannelInformation with any type of body
func NewModifyChannelInformationRequestWithBody(server string, params *ModifyChannelInformationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAdScheduleRequest generates requests for GetAdSchedule
func NewGetAdScheduleRequest(server string, params *GetAdScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/ads")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSnoozeNextAdRequest generates requests for SnoozeNextAd
func NewSnoozeNextAdRequest(server string, params *SnoozeNextAdParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/ads/schedule/snooze")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartCommercialRequest calls the generic StartCommercial builder with application/json body
func NewStartCommercialRequest(server string, body StartCommercialJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewStartCommercialRequestWithBody(server, "application/json", bodyReader)
}

// NewStartCommercialRequestWithBody generates requests for StartCommercial with any type of body
func NewStartCommercialRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/commercial")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelEditorsRequest generates requests for GetChannelEditors
func NewGetChannelEditorsRequest(server string, params *GetChannelEditorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/editors")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFollowedChannelsRequest generates requests for GetFollowedChannels
func NewGetFollowedChannelsRequest(server string, params *GetFollowedChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/followed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelFollowersRequest generates requests for GetChannelFollowers
func NewGetChannelFollowersRequest(server string, params *GetChannelFollowersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/followers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRemoveChannelVipRequest generates requests for RemoveChannelVip
func NewRemoveChannelVipRequest(server string, params *RemoveChannelVipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/vips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVipsRequest generates requests for GetVips
func NewGetVipsRequest(server string, params *GetVipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/vips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddChannelVipRequest generates requests for AddChannelVip
func NewAddChannelVipRequest(server string, params *AddChannelVipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/channels/vips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharityCampaignRequest generates requests for GetCharityCampaign
func NewGetCharityCampaignRequest(server string, params *GetCharityCampaignParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charity/campaigns")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharityCampaignDonationsRequest generates requests for GetCharityCampaignDonations
func NewGetCharityCampaignDonationsRequest(server string, params *GetCharityCampaignDonationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/charity/donations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendChatAnnouncementRequest calls the generic SendChatAnnouncement builder with application/json body
func NewSendChatAnnouncementRequest(server string, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendChatAnnouncementRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendChatAnnouncementRequestWithBody generates requests for SendChatAnnouncement with any type of body
func NewSendChatAnnouncementRequestWithBody(server string, params *SendChatAnnouncementParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/announcements")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChannelChatBadgesRequest generates requests for GetChannelChatBadges
func NewGetChannelChatBadgesRequest(server string, params *GetChannelChatBadgesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/badges")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalChatBadgesRequest generates requests for GetGlobalChatBadges
func NewGetGlobalChatBadgesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/badges/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChattersRequest generates requests for GetChatters
func NewGetChattersRequest(server string, params *GetChattersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/chatters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserChatColorRequest generates requests for GetUserChatColor
func NewGetUserChatColorRequest(server string, params *GetUserChatColorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/color")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserChatColorRequest generates requests for UpdateUserChatColor
func NewUpdateUserChatColorRequest(server string, params *UpdateUserChatColorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/color")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "color", runtime.ParamLocationQuery, params.Color); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelEmotesRequest generates requests for GetChannelEmotes
func NewGetChannelEmotesRequest(server string, params *GetChannelEmotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalEmotesRequest generates requests for GetGlobalEmotes
func NewGetGlobalEmotesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes/global")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEmoteSetsRequest generates requests for GetEmoteSets
func NewGetEmoteSetsRequest(server string, params *GetEmoteSetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes/set")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "emote_set_id", runtime.ParamLocationQuery, params.EmoteSetId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserEmotesRequest generates requests for GetUserEmotes
func NewGetUserEmotesRequest(server string, params *GetUserEmotesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/emotes/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendChatMessageRequest calls the generic SendChatMessage builder with application/json body
func NewSendChatMessageRequest(server string, body SendChatMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendChatMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendChatMessageRequestWithBody generates requests for SendChatMessage with any type of body
func NewSendChatMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/messages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetChatSettingsRequest generates requests for GetChatSettings
func NewGetChatSettingsRequest(server string, params *GetChatSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ModeratorId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, *params.ModeratorId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChatSettingsRequest calls the generic UpdateChatSettings builder with application/json body
func NewUpdateChatSettingsRequest(server string, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChatSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateChatSettingsRequestWithBody generates requests for UpdateChatSettings with any type of body
func NewUpdateChatSettingsRequestWithBody(server string, params *UpdateChatSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSendAShoutoutRequest generates requests for SendAShoutout
func NewSendAShoutoutRequest(server string, params *SendAShoutoutParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chat/shoutouts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_broadcaster_id", runtime.ParamLocationQuery, params.FromBroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_broadcaster_id", runtime.ParamLocationQuery, params.ToBroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClipsRequest generates requests for GetClips
func NewGetClipsRequest(server string, params *GetClipsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "started_at", runtime.ParamLocationQuery, *params.StartedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ended_at", runtime.ParamLocationQuery, *params.EndedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsFeatured != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_featured", runtime.ParamLocationQuery, *params.IsFeatured); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateClipRequest generates requests for CreateClip
func NewCreateClipRequest(server string, params *CreateClipParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clips")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.HasDelay != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "has_delay", runtime.ParamLocationQuery, *params.HasDelay); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContentClassificationLabelsRequest generates requests for GetContentClassificationLabels
func NewGetContentClassificationLabelsRequest(server string, params *GetContentClassificationLabelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/content_classification_labels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Locale != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locale", runtime.ParamLocationQuery, *params.Locale); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDropsEntitlementsRequest generates requests for GetDropsEntitlements
func NewGetDropsEntitlementsRequest(server string, params *GetDropsEntitlementsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entitlements/drops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FulfillmentStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fulfillment_status", runtime.ParamLocationQuery, *params.FulfillmentStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDropsEntitlementsRequest calls the generic UpdateDropsEntitlements builder with application/json body
func NewUpdateDropsEntitlementsRequest(server string, body UpdateDropsEntitlementsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDropsEntitlementsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateDropsEntitlementsRequestWithBody generates requests for UpdateDropsEntitlements with any type of body
func NewUpdateDropsEntitlementsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/entitlements/drops")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteConduitRequest generates requests for DeleteConduit
func NewDeleteConduitRequest(server string, params *DeleteConduitParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConduitsRequest generates requests for GetConduits
func NewGetConduitsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConduitsRequest calls the generic UpdateConduits builder with application/json body
func NewUpdateConduitsRequest(server string, body UpdateConduitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConduitsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConduitsRequestWithBody generates requests for UpdateConduits with any type of body
func NewUpdateConduitsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateConduitsRequest calls the generic CreateConduits builder with application/json body
func NewCreateConduitsRequest(server string, body CreateConduitsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConduitsRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateConduitsRequestWithBody generates requests for CreateConduits with any type of body
func NewCreateConduitsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConduitShardsRequest generates requests for GetConduitShards
func NewGetConduitShardsRequest(server string, params *GetConduitShardsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits/shards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "conduit_id", runtime.ParamLocationQuery, params.ConduitId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConduitShardsRequest calls the generic UpdateConduitShards builder with application/json body
func NewUpdateConduitShardsRequest(server string, body UpdateConduitShardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConduitShardsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConduitShardsRequestWithBody generates requests for UpdateConduitShards with any type of body
func NewUpdateConduitShardsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/conduits/shards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEventsubSubscriptionRequest generates requests for DeleteEventsubSubscription
func NewDeleteEventsubSubscriptionRequest(server string, params *DeleteEventsubSubscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsubSubscriptionsRequest generates requests for GetEventsubSubscriptions
func NewGetEventsubSubscriptionsRequest(server string, params *GetEventsubSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEventsubSubscriptionRequest calls the generic CreateEventsubSubscription builder with application/json body
func NewCreateEventsubSubscriptionRequest(server string, body CreateEventsubSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEventsubSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEventsubSubscriptionRequestWithBody generates requests for CreateEventsubSubscription with any type of body
func NewCreateEventsubSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/eventsub/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionsRequest generates requests for GetExtensions
func NewGetExtensionsRequest(server string, params *GetExtensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ExtensionVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_version", runtime.ParamLocationQuery, *params.ExtensionVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendExtensionChatMessageRequest calls the generic SendExtensionChatMessage builder with application/json body
func NewSendExtensionChatMessageRequest(server string, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendExtensionChatMessageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendExtensionChatMessageRequestWithBody generates requests for SendExtensionChatMessage with any type of body
func NewSendExtensionChatMessageRequestWithBody(server string, params *SendExtensionChatMessageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/chat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionConfigurationSegmentRequest generates requests for GetExtensionConfigurationSegment
func NewGetExtensionConfigurationSegmentRequest(server string, params *GetExtensionConfigurationSegmentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.BroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, *params.BroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "segment", runtime.ParamLocationQuery, params.Segment); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetExtensionConfigurationSegmentRequest calls the generic SetExtensionConfigurationSegment builder with application/json body
func NewSetExtensionConfigurationSegmentRequest(server string, body SetExtensionConfigurationSegmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetExtensionConfigurationSegmentRequestWithBody(server, "application/json", bodyReader)
}

// NewSetExtensionConfigurationSegmentRequestWithBody generates requests for SetExtensionConfigurationSegment with any type of body
func NewSetExtensionConfigurationSegmentRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/configurations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionSecretsRequest generates requests for GetExtensionSecrets
func NewGetExtensionSecretsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/jwt/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateExtensionSecretRequest generates requests for CreateExtensionSecret
func NewCreateExtensionSecretRequest(server string, params *CreateExtensionSecretParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/jwt/secrets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Delay != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "delay", runtime.ParamLocationQuery, *params.Delay); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExtensionLiveChannelsRequest generates requests for GetExtensionLiveChannels
func NewGetExtensionLiveChannelsRequest(server string, params *GetExtensionLiveChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/live")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendExtensionPubsubMessageRequest calls the generic SendExtensionPubsubMessage builder with application/json body
func NewSendExtensionPubsubMessageRequest(server string, body SendExtensionPubsubMessageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendExtensionPubsubMessageRequestWithBody(server, "application/json", bodyReader)
}

// NewSendExtensionPubsubMessageRequestWithBody generates requests for SendExtensionPubsubMessage with any type of body
func NewSendExtensionPubsubMessageRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/pubsub")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReleasedExtensionsRequest generates requests for GetReleasedExtensions
func NewGetReleasedExtensionsRequest(server string, params *GetReleasedExtensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/released")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ExtensionVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_version", runtime.ParamLocationQuery, *params.ExtensionVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetExtensionRequiredConfigurationRequest calls the generic SetExtensionRequiredConfiguration builder with application/json body
func NewSetExtensionRequiredConfigurationRequest(server string, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetExtensionRequiredConfigurationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSetExtensionRequiredConfigurationRequestWithBody generates requests for SetExtensionRequiredConfiguration with any type of body
func NewSetExtensionRequiredConfigurationRequestWithBody(server string, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/required_configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExtensionTransactionsRequest generates requests for GetExtensionTransactions
func NewGetExtensionTransactionsRequest(server string, params *GetExtensionTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/extensions/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "extension_id", runtime.ParamLocationQuery, params.ExtensionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGamesRequest generates requests for GetGames
func NewGetGamesRequest(server string, params *GetGamesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/games")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgdbId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "igdb_id", runtime.ParamLocationQuery, *params.IgdbId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopGamesRequest generates requests for GetTopGames
func NewGetTopGamesRequest(server string, params *GetTopGamesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/games/top")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCreatorGoalsRequest generates requests for GetCreatorGoals
func NewGetCreatorGoalsRequest(server string, params *GetCreatorGoalsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/goals")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelGuestStarSettingsRequest generates requests for GetChannelGuestStarSettings
func NewGetChannelGuestStarSettingsRequest(server string, params *GetChannelGuestStarSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/channel_settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelGuestStarSettingsRequest calls the generic UpdateChannelGuestStarSettings builder with application/json body
func NewUpdateChannelGuestStarSettingsRequest(server string, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelGuestStarSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateChannelGuestStarSettingsRequestWithBody generates requests for UpdateChannelGuestStarSettings with any type of body
func NewUpdateChannelGuestStarSettingsRequestWithBody(server string, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/channel_settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGuestStarInviteRequest generates requests for DeleteGuestStarInvite
func NewDeleteGuestStarInviteRequest(server string, params *DeleteGuestStarInviteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGuestStarInvitesRequest generates requests for GetGuestStarInvites
func NewGetGuestStarInvitesRequest(server string, params *GetGuestStarInvitesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendGuestStarInviteRequest generates requests for SendGuestStarInvite
func NewSendGuestStarInviteRequest(server string, params *SendGuestStarInviteParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/invites")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndGuestStarSessionRequest generates requests for EndGuestStarSession
func NewEndGuestStarSessionRequest(server string, params *EndGuestStarSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGuestStarSessionRequest generates requests for GetGuestStarSession
func NewGetGuestStarSessionRequest(server string, params *GetGuestStarSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGuestStarSessionRequest generates requests for CreateGuestStarSession
func NewCreateGuestStarSessionRequest(server string, params *CreateGuestStarSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteGuestStarSlotRequest generates requests for DeleteGuestStarSlot
func NewDeleteGuestStarSlotRequest(server string, params *DeleteGuestStarSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slot_id", runtime.ParamLocationQuery, params.SlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ShouldReinviteGuest != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "should_reinvite_guest", runtime.ParamLocationQuery, *params.ShouldReinviteGuest); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGuestStarSlotRequest generates requests for UpdateGuestStarSlot
func NewUpdateGuestStarSlotRequest(server string, params *UpdateGuestStarSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_slot_id", runtime.ParamLocationQuery, params.SourceSlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.DestinationSlotId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "destination_slot_id", runtime.ParamLocationQuery, *params.DestinationSlotId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAssignGuestStarSlotRequest generates requests for AssignGuestStarSlot
func NewAssignGuestStarSlotRequest(server string, params *AssignGuestStarSlotParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "guest_id", runtime.ParamLocationQuery, params.GuestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slot_id", runtime.ParamLocationQuery, params.SlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGuestStarSlotSettingsRequest generates requests for UpdateGuestStarSlotSettings
func NewUpdateGuestStarSlotSettingsRequest(server string, params *UpdateGuestStarSlotSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/guest_star/slot_settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "session_id", runtime.ParamLocationQuery, params.SessionId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "slot_id", runtime.ParamLocationQuery, params.SlotId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsAudioEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_audio_enabled", runtime.ParamLocationQuery, *params.IsAudioEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsVideoEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_video_enabled", runtime.ParamLocationQuery, *params.IsVideoEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsLive != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_live", runtime.ParamLocationQuery, *params.IsLive); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Volume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volume", runtime.ParamLocationQuery, *params.Volume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHypeTrainEventsRequest generates requests for GetHypeTrainEvents
func NewGetHypeTrainEventsRequest(server string, params *GetHypeTrainEventsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/hypetrain/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewManageHeldAutomodMessagesRequest calls the generic ManageHeldAutomodMessages builder with application/json body
func NewManageHeldAutomodMessagesRequest(server string, body ManageHeldAutomodMessagesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewManageHeldAutomodMessagesRequestWithBody(server, "application/json", bodyReader)
}

// NewManageHeldAutomodMessagesRequestWithBody generates requests for ManageHeldAutomodMessages with any type of body
func NewManageHeldAutomodMessagesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/automod/message")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAutomodSettingsRequest generates requests for GetAutomodSettings
func NewGetAutomodSettingsRequest(server string, params *GetAutomodSettingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/automod/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAutomodSettingsRequest calls the generic UpdateAutomodSettings builder with application/json body
func NewUpdateAutomodSettingsRequest(server string, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAutomodSettingsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateAutomodSettingsRequestWithBody generates requests for UpdateAutomodSettings with any type of body
func NewUpdateAutomodSettingsRequestWithBody(server string, params *UpdateAutomodSettingsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/automod/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetBannedUsersRequest generates requests for GetBannedUsers
func NewGetBannedUsersRequest(server string, params *GetBannedUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/banned")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnbanUserRequest generates requests for UnbanUser
func NewUnbanUserRequest(server string, params *UnbanUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/bans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBanUserRequest calls the generic BanUser builder with application/json body
func NewBanUserRequest(server string, params *BanUserParams, body BanUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBanUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBanUserRequestWithBody generates requests for BanUser with any type of body
func NewBanUserRequestWithBody(server string, params *BanUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/bans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveBlockedTermRequest generates requests for RemoveBlockedTerm
func NewRemoveBlockedTermRequest(server string, params *RemoveBlockedTermParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/blocked_terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBlockedTermsRequest generates requests for GetBlockedTerms
func NewGetBlockedTermsRequest(server string, params *GetBlockedTermsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/blocked_terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddBlockedTermRequest calls the generic AddBlockedTerm builder with application/json body
func NewAddBlockedTermRequest(server string, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBlockedTermRequestWithBody(server, params, "application/json", bodyReader)
}

// NewAddBlockedTermRequestWithBody generates requests for AddBlockedTerm with any type of body
func NewAddBlockedTermRequestWithBody(server string, params *AddBlockedTermParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/blocked_terms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetModeratedChannelsRequest generates requests for GetModeratedChannels
func NewGetModeratedChannelsRequest(server string, params *GetModeratedChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteChatMessagesRequest generates requests for DeleteChatMessages
func NewDeleteChatMessagesRequest(server string, params *DeleteChatMessagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/chat")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.MessageId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "message_id", runtime.ParamLocationQuery, *params.MessageId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckAutomodStatusRequest calls the generic CheckAutomodStatus builder with application/json body
func NewCheckAutomodStatusRequest(server string, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCheckAutomodStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCheckAutomodStatusRequestWithBody generates requests for CheckAutomodStatus with any type of body
func NewCheckAutomodStatusRequestWithBody(server string, params *CheckAutomodStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/enforcements/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveChannelModeratorRequest generates requests for RemoveChannelModerator
func NewRemoveChannelModeratorRequest(server string, params *RemoveChannelModeratorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/moderators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetModeratorsRequest generates requests for GetModerators
func NewGetModeratorsRequest(server string, params *GetModeratorsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/moderators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddChannelModeratorRequest generates requests for AddChannelModerator
func NewAddChannelModeratorRequest(server string, params *AddChannelModeratorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/moderators")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetShieldModeStatusRequest generates requests for GetShieldModeStatus
func NewGetShieldModeStatusRequest(server string, params *GetShieldModeStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/shield_mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateShieldModeStatusRequest calls the generic UpdateShieldModeStatus builder with application/json body
func NewUpdateShieldModeStatusRequest(server string, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateShieldModeStatusRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateShieldModeStatusRequestWithBody generates requests for UpdateShieldModeStatus with any type of body
func NewUpdateShieldModeStatusRequestWithBody(server string, params *UpdateShieldModeStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/shield_mode")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUnbanRequestsRequest generates requests for GetUnbanRequests
func NewGetUnbanRequestsRequest(server string, params *GetUnbanRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/unban_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewResolveUnbanRequestsRequest generates requests for ResolveUnbanRequests
func NewResolveUnbanRequestsRequest(server string, params *ResolveUnbanRequestsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/unban_requests")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unban_request_id", runtime.ParamLocationQuery, params.UnbanRequestId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ResolutionText != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "resolution_text", runtime.ParamLocationQuery, *params.ResolutionText); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewWarnChatUserRequest calls the generic WarnChatUser builder with application/json body
func NewWarnChatUserRequest(server string, params *WarnChatUserParams, body WarnChatUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewWarnChatUserRequestWithBody(server, params, "application/json", bodyReader)
}

// NewWarnChatUserRequestWithBody generates requests for WarnChatUser with any type of body
func NewWarnChatUserRequestWithBody(server string, params *WarnChatUserParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/moderation/warnings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "moderator_id", runtime.ParamLocationQuery, params.ModeratorId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPollsRequest generates requests for GetPolls
func NewGetPollsRequest(server string, params *GetPollsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndPollRequest calls the generic EndPoll builder with application/json body
func NewEndPollRequest(server string, body EndPollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndPollRequestWithBody(server, "application/json", bodyReader)
}

// NewEndPollRequestWithBody generates requests for EndPoll with any type of body
func NewEndPollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePollRequest calls the generic CreatePoll builder with application/json body
func NewCreatePollRequest(server string, body CreatePollJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePollRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePollRequestWithBody generates requests for CreatePoll with any type of body
func NewCreatePollRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/polls")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPredictionsRequest generates requests for GetPredictions
func NewGetPredictionsRequest(server string, params *GetPredictionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEndPredictionRequest calls the generic EndPrediction builder with application/json body
func NewEndPredictionRequest(server string, body EndPredictionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndPredictionRequestWithBody(server, "application/json", bodyReader)
}

// NewEndPredictionRequestWithBody generates requests for EndPrediction with any type of body
func NewEndPredictionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePredictionRequest calls the generic CreatePrediction builder with application/json body
func NewCreatePredictionRequest(server string, body CreatePredictionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePredictionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePredictionRequestWithBody generates requests for CreatePrediction with any type of body
func NewCreatePredictionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/predictions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCancelARaidRequest generates requests for CancelARaid
func NewCancelARaidRequest(server string, params *CancelARaidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/raids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStartARaidRequest generates requests for StartARaid
func NewStartARaidRequest(server string, params *StartARaidParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/raids")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FromBroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_broadcaster_id", runtime.ParamLocationQuery, *params.FromBroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToBroadcasterId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_broadcaster_id", runtime.ParamLocationQuery, *params.ToBroadcasterId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelStreamScheduleRequest generates requests for GetChannelStreamSchedule
func NewGetChannelStreamScheduleRequest(server string, params *GetChannelStreamScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UtcOffset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "utc_offset", runtime.ParamLocationQuery, *params.UtcOffset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelIcalendarRequest generates requests for GetChannelIcalendar
func NewGetChannelIcalendarRequest(server string, params *GetChannelIcalendarParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/icalendar")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteChannelStreamScheduleSegmentRequest generates requests for DeleteChannelStreamScheduleSegment
func NewDeleteChannelStreamScheduleSegmentRequest(server string, params *DeleteChannelStreamScheduleSegmentParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/segment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateChannelStreamScheduleSegmentRequest calls the generic UpdateChannelStreamScheduleSegment builder with application/json body
func NewUpdateChannelStreamScheduleSegmentRequest(server string, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateChannelStreamScheduleSegmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewUpdateChannelStreamScheduleSegmentRequestWithBody generates requests for UpdateChannelStreamScheduleSegment with any type of body
func NewUpdateChannelStreamScheduleSegmentRequestWithBody(server string, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/segment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateChannelStreamScheduleSegmentRequest calls the generic CreateChannelStreamScheduleSegment builder with application/json body
func NewCreateChannelStreamScheduleSegmentRequest(server string, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateChannelStreamScheduleSegmentRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateChannelStreamScheduleSegmentRequestWithBody generates requests for CreateChannelStreamScheduleSegment with any type of body
func NewCreateChannelStreamScheduleSegmentRequestWithBody(server string, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/segment")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateChannelStreamScheduleRequest generates requests for UpdateChannelStreamSchedule
func NewUpdateChannelStreamScheduleRequest(server string, params *UpdateChannelStreamScheduleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.IsVacationEnabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "is_vacation_enabled", runtime.ParamLocationQuery, *params.IsVacationEnabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VacationStartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vacation_start_time", runtime.ParamLocationQuery, *params.VacationStartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VacationEndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vacation_end_time", runtime.ParamLocationQuery, *params.VacationEndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Timezone != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "timezone", runtime.ParamLocationQuery, *params.Timezone); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchCategoriesRequest generates requests for SearchCategories
func NewSearchCategoriesRequest(server string, params *SearchCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchChannelsRequest generates requests for SearchChannels
func NewSearchChannelsRequest(server string, params *SearchChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/search/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.LiveOnly != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "live_only", runtime.ParamLocationQuery, *params.LiveOnly); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSharedChatSessionRequest generates requests for GetSharedChatSession
func NewGetSharedChatSessionRequest(server string, params *GetSharedChatSessionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/shared_chat/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamsRequest generates requests for GetStreams
func NewGetStreamsRequest(server string, params *GetStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserLogin != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_login", runtime.ParamLocationQuery, *params.UserLogin); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFollowedStreamsRequest generates requests for GetFollowedStreams
func NewGetFollowedStreamsRequest(server string, params *GetFollowedStreamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/followed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamKeyRequest generates requests for GetStreamKey
func NewGetStreamKeyRequest(server string, params *GetStreamKeyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/key")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStreamMarkersRequest generates requests for GetStreamMarkers
func NewGetStreamMarkersRequest(server string, params *GetStreamMarkersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/markers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VideoId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "video_id", runtime.ParamLocationQuery, *params.VideoId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStreamMarkerRequest calls the generic CreateStreamMarker builder with application/json body
func NewCreateStreamMarkerRequest(server string, body CreateStreamMarkerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStreamMarkerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateStreamMarkerRequestWithBody generates requests for CreateStreamMarker with any type of body
func NewCreateStreamMarkerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/markers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStreamTagsRequest generates requests for GetStreamTags
func NewGetStreamTagsRequest(server string, params *GetStreamTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/streams/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBroadcasterSubscriptionsRequest generates requests for GetBroadcasterSubscriptions
func NewGetBroadcasterSubscriptionsRequest(server string, params *GetBroadcasterSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckUserSubscriptionRequest generates requests for CheckUserSubscription
func NewCheckUserSubscriptionRequest(server string, params *CheckUserSubscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, params.UserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllStreamTagsRequest generates requests for GetAllStreamTags
func NewGetAllStreamTagsRequest(server string, params *GetAllStreamTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags/streams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TagId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tag_id", runtime.ParamLocationQuery, *params.TagId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChannelTeamsRequest generates requests for GetChannelTeams
func NewGetChannelTeamsRequest(server string, params *GetChannelTeamsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/teams/channel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Login != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login", runtime.ParamLocationQuery, *params.Login); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRequest generates requests for UpdateUser
func NewUpdateUserRequest(server string, params *UpdateUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnblockUserRequest generates requests for UnblockUser
func NewUnblockUserRequest(server string, params *UnblockUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_user_id", runtime.ParamLocationQuery, params.TargetUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserBlockListRequest generates requests for GetUserBlockList
func NewGetUserBlockListRequest(server string, params *GetUserBlockListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "broadcaster_id", runtime.ParamLocationQuery, params.BroadcasterId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBlockUserRequest generates requests for BlockUser
func NewBlockUserRequest(server string, params *BlockUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/blocks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "target_user_id", runtime.ParamLocationQuery, params.TargetUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SourceContext != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "source_context", runtime.ParamLocationQuery, *params.SourceContext); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserActiveExtensionsRequest generates requests for GetUserActiveExtensions
func NewGetUserActiveExtensionsRequest(server string, params *GetUserActiveExtensionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserExtensionsRequest calls the generic UpdateUserExtensions builder with application/json body
func NewUpdateUserExtensionsRequest(server string, body UpdateUserExtensionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserExtensionsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserExtensionsRequestWithBody generates requests for UpdateUserExtensions with any type of body
func NewUpdateUserExtensionsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/extensions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserExtensionsRequest generates requests for GetUserExtensions
func NewGetUserExtensionsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/extensions/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteVideosRequest generates requests for DeleteVideos
func NewDeleteVideosRequest(server string, params *DeleteVideosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, params.Id); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetVideosRequest generates requests for GetVideos
func NewGetVideosRequest(server string, params *GetVideosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/videos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UserId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user_id", runtime.ParamLocationQuery, *params.UserId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GameId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "game_id", runtime.ParamLocationQuery, *params.GameId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Period != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "period", runtime.ParamLocationQuery, *params.Period); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.First != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "first", runtime.ParamLocationQuery, *params.First); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.After != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "after", runtime.ParamLocationQuery, *params.After); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Before != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "before", runtime.ParamLocationQuery, *params.Before); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSendWhisperRequest calls the generic SendWhisper builder with application/json body
func NewSendWhisperRequest(server string, params *SendWhisperParams, body SendWhisperJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSendWhisperRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSendWhisperRequestWithBody generates requests for SendWhisper with any type of body
func NewSendWhisperRequestWithBody(server string, params *SendWhisperParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/whispers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from_user_id", runtime.ParamLocationQuery, params.FromUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to_user_id", runtime.ParamLocationQuery, params.ToUserId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// Generated with client-with-responses.tmpl
// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
	OkOnNon200 bool
	Tracer     trace.Tracer
}

// StatusFailureError is the error returned if the response was a non-success code.
type StatusFailureError struct {
	Resp *http.Response
	Err  error
}

func (s StatusFailureError) Error() string {
	if s.Err != nil {
		return s.Err.Error()
	}
	return fmt.Sprintf("got non success response code: %d", s.Resp.StatusCode)
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, OkOnNon200 bool, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{
		ClientInterface: client,
		OkOnNon200:      OkOnNon200,
	}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetExtensionAnalyticsWithResponse request
	GetExtensionAnalyticsWithResponse(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (*GetExtensionAnalyticsResponse, error)

	// GetGameAnalyticsWithResponse request
	GetGameAnalyticsWithResponse(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (*GetGameAnalyticsResponse, error)

	// GetCheermotesWithResponse request
	GetCheermotesWithResponse(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (*GetCheermotesResponse, error)

	// GetExtensionBitsProductsWithResponse request
	GetExtensionBitsProductsWithResponse(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (*GetExtensionBitsProductsResponse, error)

	// UpdateExtensionBitsProductWithBodyWithResponse request with any body
	UpdateExtensionBitsProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateExtensionBitsProductResponse, error)

	UpdateExtensionBitsProductWithResponse(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateExtensionBitsProductResponse, error)

	// GetBitsLeaderboardWithResponse request
	GetBitsLeaderboardWithResponse(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (*GetBitsLeaderboardResponse, error)

	// DeleteCustomRewardWithResponse request
	DeleteCustomRewardWithResponse(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (*DeleteCustomRewardResponse, error)

	// GetCustomRewardWithResponse request
	GetCustomRewardWithResponse(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (*GetCustomRewardResponse, error)

	// UpdateCustomRewardWithBodyWithResponse request with any body
	UpdateCustomRewardWithBodyWithResponse(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomRewardResponse, error)

	UpdateCustomRewardWithResponse(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomRewardResponse, error)

	// CreateCustomRewardsWithBodyWithResponse request with any body
	CreateCustomRewardsWithBodyWithResponse(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomRewardsResponse, error)

	CreateCustomRewardsWithResponse(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomRewardsResponse, error)

	// GetCustomRewardRedemptionWithResponse request
	GetCustomRewardRedemptionWithResponse(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (*GetCustomRewardRedemptionResponse, error)

	// UpdateRedemptionStatusWithBodyWithResponse request with any body
	UpdateRedemptionStatusWithBodyWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRedemptionStatusResponse, error)

	UpdateRedemptionStatusWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRedemptionStatusResponse, error)

	// GetChannelInformationWithResponse request
	GetChannelInformationWithResponse(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (*GetChannelInformationResponse, error)

	// ModifyChannelInformationWithBodyWithResponse request with any body
	ModifyChannelInformationWithBodyWithResponse(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ModifyChannelInformationResponse, error)

	ModifyChannelInformationWithResponse(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (*ModifyChannelInformationResponse, error)

	// GetAdScheduleWithResponse request
	GetAdScheduleWithResponse(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (*GetAdScheduleResponse, error)

	// SnoozeNextAdWithResponse request
	SnoozeNextAdWithResponse(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (*SnoozeNextAdResponse, error)

	// StartCommercialWithBodyWithResponse request with any body
	StartCommercialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*StartCommercialResponse, error)

	StartCommercialWithResponse(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (*StartCommercialResponse, error)

	// GetChannelEditorsWithResponse request
	GetChannelEditorsWithResponse(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (*GetChannelEditorsResponse, error)

	// GetFollowedChannelsWithResponse request
	GetFollowedChannelsWithResponse(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (*GetFollowedChannelsResponse, error)

	// GetChannelFollowersWithResponse request
	GetChannelFollowersWithResponse(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (*GetChannelFollowersResponse, error)

	// RemoveChannelVipWithResponse request
	RemoveChannelVipWithResponse(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (*RemoveChannelVipResponse, error)

	// GetVipsWithResponse request
	GetVipsWithResponse(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (*GetVipsResponse, error)

	// AddChannelVipWithResponse request
	AddChannelVipWithResponse(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (*AddChannelVipResponse, error)

	// GetCharityCampaignWithResponse request
	GetCharityCampaignWithResponse(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (*GetCharityCampaignResponse, error)

	// GetCharityCampaignDonationsWithResponse request
	GetCharityCampaignDonationsWithResponse(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (*GetCharityCampaignDonationsResponse, error)

	// SendChatAnnouncementWithBodyWithResponse request with any body
	SendChatAnnouncementWithBodyWithResponse(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendChatAnnouncementResponse, error)

	SendChatAnnouncementWithResponse(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (*SendChatAnnouncementResponse, error)

	// GetChannelChatBadgesWithResponse request
	GetChannelChatBadgesWithResponse(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (*GetChannelChatBadgesResponse, error)

	// GetGlobalChatBadgesWithResponse request
	GetGlobalChatBadgesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalChatBadgesResponse, error)

	// GetChattersWithResponse request
	GetChattersWithResponse(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (*GetChattersResponse, error)

	// GetUserChatColorWithResponse request
	GetUserChatColorWithResponse(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (*GetUserChatColorResponse, error)

	// UpdateUserChatColorWithResponse request
	UpdateUserChatColorWithResponse(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (*UpdateUserChatColorResponse, error)

	// GetChannelEmotesWithResponse request
	GetChannelEmotesWithResponse(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (*GetChannelEmotesResponse, error)

	// GetGlobalEmotesWithResponse request
	GetGlobalEmotesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalEmotesResponse, error)

	// GetEmoteSetsWithResponse request
	GetEmoteSetsWithResponse(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (*GetEmoteSetsResponse, error)

	// GetUserEmotesWithResponse request
	GetUserEmotesWithResponse(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (*GetUserEmotesResponse, error)

	// SendChatMessageWithBodyWithResponse request with any body
	SendChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendChatMessageResponse, error)

	SendChatMessageWithResponse(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendChatMessageResponse, error)

	// GetChatSettingsWithResponse request
	GetChatSettingsWithResponse(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (*GetChatSettingsResponse, error)

	// UpdateChatSettingsWithBodyWithResponse request with any body
	UpdateChatSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChatSettingsResponse, error)

	UpdateChatSettingsWithResponse(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChatSettingsResponse, error)

	// SendAShoutoutWithResponse request
	SendAShoutoutWithResponse(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (*SendAShoutoutResponse, error)

	// GetClipsWithResponse request
	GetClipsWithResponse(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (*GetClipsResponse, error)

	// CreateClipWithResponse request
	CreateClipWithResponse(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (*CreateClipResponse, error)

	// GetContentClassificationLabelsWithResponse request
	GetContentClassificationLabelsWithResponse(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (*GetContentClassificationLabelsResponse, error)

	// GetDropsEntitlementsWithResponse request
	GetDropsEntitlementsWithResponse(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (*GetDropsEntitlementsResponse, error)

	// UpdateDropsEntitlementsWithBodyWithResponse request with any body
	UpdateDropsEntitlementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDropsEntitlementsResponse, error)

	UpdateDropsEntitlementsWithResponse(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDropsEntitlementsResponse, error)

	// DeleteConduitWithResponse request
	DeleteConduitWithResponse(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (*DeleteConduitResponse, error)

	// GetConduitsWithResponse request
	GetConduitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConduitsResponse, error)

	// UpdateConduitsWithBodyWithResponse request with any body
	UpdateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConduitsResponse, error)

	UpdateConduitsWithResponse(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConduitsResponse, error)

	// CreateConduitsWithBodyWithResponse request with any body
	CreateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConduitsResponse, error)

	CreateConduitsWithResponse(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConduitsResponse, error)

	// GetConduitShardsWithResponse request
	GetConduitShardsWithResponse(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (*GetConduitShardsResponse, error)

	// UpdateConduitShardsWithBodyWithResponse request with any body
	UpdateConduitShardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConduitShardsResponse, error)

	UpdateConduitShardsWithResponse(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConduitShardsResponse, error)

	// DeleteEventsubSubscriptionWithResponse request
	DeleteEventsubSubscriptionWithResponse(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (*DeleteEventsubSubscriptionResponse, error)

	// GetEventsubSubscriptionsWithResponse request
	GetEventsubSubscriptionsWithResponse(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetEventsubSubscriptionsResponse, error)

	// CreateEventsubSubscriptionWithBodyWithResponse request with any body
	CreateEventsubSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEventsubSubscriptionResponse, error)

	CreateEventsubSubscriptionWithResponse(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEventsubSubscriptionResponse, error)

	// GetExtensionsWithResponse request
	GetExtensionsWithResponse(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (*GetExtensionsResponse, error)

	// SendExtensionChatMessageWithBodyWithResponse request with any body
	SendExtensionChatMessageWithBodyWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendExtensionChatMessageResponse, error)

	SendExtensionChatMessageWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendExtensionChatMessageResponse, error)

	// GetExtensionConfigurationSegmentWithResponse request
	GetExtensionConfigurationSegmentWithResponse(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (*GetExtensionConfigurationSegmentResponse, error)

	// SetExtensionConfigurationSegmentWithBodyWithResponse request with any body
	SetExtensionConfigurationSegmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetExtensionConfigurationSegmentResponse, error)

	SetExtensionConfigurationSegmentWithResponse(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*SetExtensionConfigurationSegmentResponse, error)

	// GetExtensionSecretsWithResponse request
	GetExtensionSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExtensionSecretsResponse, error)

	// CreateExtensionSecretWithResponse request
	CreateExtensionSecretWithResponse(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (*CreateExtensionSecretResponse, error)

	// GetExtensionLiveChannelsWithResponse request
	GetExtensionLiveChannelsWithResponse(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (*GetExtensionLiveChannelsResponse, error)

	// SendExtensionPubsubMessageWithBodyWithResponse request with any body
	SendExtensionPubsubMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendExtensionPubsubMessageResponse, error)

	SendExtensionPubsubMessageWithResponse(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (*SendExtensionPubsubMessageResponse, error)

	// GetReleasedExtensionsWithResponse request
	GetReleasedExtensionsWithResponse(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (*GetReleasedExtensionsResponse, error)

	// SetExtensionRequiredConfigurationWithBodyWithResponse request with any body
	SetExtensionRequiredConfigurationWithBodyWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetExtensionRequiredConfigurationResponse, error)

	SetExtensionRequiredConfigurationWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*SetExtensionRequiredConfigurationResponse, error)

	// GetExtensionTransactionsWithResponse request
	GetExtensionTransactionsWithResponse(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (*GetExtensionTransactionsResponse, error)

	// GetGamesWithResponse request
	GetGamesWithResponse(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (*GetGamesResponse, error)

	// GetTopGamesWithResponse request
	GetTopGamesWithResponse(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (*GetTopGamesResponse, error)

	// GetCreatorGoalsWithResponse request
	GetCreatorGoalsWithResponse(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (*GetCreatorGoalsResponse, error)

	// GetChannelGuestStarSettingsWithResponse request
	GetChannelGuestStarSettingsWithResponse(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (*GetChannelGuestStarSettingsResponse, error)

	// UpdateChannelGuestStarSettingsWithBodyWithResponse request with any body
	UpdateChannelGuestStarSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelGuestStarSettingsResponse, error)

	UpdateChannelGuestStarSettingsWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelGuestStarSettingsResponse, error)

	// DeleteGuestStarInviteWithResponse request
	DeleteGuestStarInviteWithResponse(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (*DeleteGuestStarInviteResponse, error)

	// GetGuestStarInvitesWithResponse request
	GetGuestStarInvitesWithResponse(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (*GetGuestStarInvitesResponse, error)

	// SendGuestStarInviteWithResponse request
	SendGuestStarInviteWithResponse(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (*SendGuestStarInviteResponse, error)

	// EndGuestStarSessionWithResponse request
	EndGuestStarSessionWithResponse(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (*EndGuestStarSessionResponse, error)

	// GetGuestStarSessionWithResponse request
	GetGuestStarSessionWithResponse(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (*GetGuestStarSessionResponse, error)

	// CreateGuestStarSessionWithResponse request
	CreateGuestStarSessionWithResponse(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (*CreateGuestStarSessionResponse, error)

	// DeleteGuestStarSlotWithResponse request
	DeleteGuestStarSlotWithResponse(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (*DeleteGuestStarSlotResponse, error)

	// UpdateGuestStarSlotWithResponse request
	UpdateGuestStarSlotWithResponse(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (*UpdateGuestStarSlotResponse, error)

	// AssignGuestStarSlotWithResponse request
	AssignGuestStarSlotWithResponse(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (*AssignGuestStarSlotResponse, error)

	// UpdateGuestStarSlotSettingsWithResponse request
	UpdateGuestStarSlotSettingsWithResponse(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (*UpdateGuestStarSlotSettingsResponse, error)

	// GetHypeTrainEventsWithResponse request
	GetHypeTrainEventsWithResponse(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (*GetHypeTrainEventsResponse, error)

	// ManageHeldAutomodMessagesWithBodyWithResponse request with any body
	ManageHeldAutomodMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ManageHeldAutomodMessagesResponse, error)

	ManageHeldAutomodMessagesWithResponse(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (*ManageHeldAutomodMessagesResponse, error)

	// GetAutomodSettingsWithResponse request
	GetAutomodSettingsWithResponse(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (*GetAutomodSettingsResponse, error)

	// UpdateAutomodSettingsWithBodyWithResponse request with any body
	UpdateAutomodSettingsWithBodyWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAutomodSettingsResponse, error)

	UpdateAutomodSettingsWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAutomodSettingsResponse, error)

	// GetBannedUsersWithResponse request
	GetBannedUsersWithResponse(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (*GetBannedUsersResponse, error)

	// UnbanUserWithResponse request
	UnbanUserWithResponse(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (*UnbanUserResponse, error)

	// BanUserWithBodyWithResponse request with any body
	BanUserWithBodyWithResponse(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BanUserResponse, error)

	BanUserWithResponse(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (*BanUserResponse, error)

	// RemoveBlockedTermWithResponse request
	RemoveBlockedTermWithResponse(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (*RemoveBlockedTermResponse, error)

	// GetBlockedTermsWithResponse request
	GetBlockedTermsWithResponse(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (*GetBlockedTermsResponse, error)

	// AddBlockedTermWithBodyWithResponse request with any body
	AddBlockedTermWithBodyWithResponse(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBlockedTermResponse, error)

	AddBlockedTermWithResponse(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBlockedTermResponse, error)

	// GetModeratedChannelsWithResponse request
	GetModeratedChannelsWithResponse(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (*GetModeratedChannelsResponse, error)

	// DeleteChatMessagesWithResponse request
	DeleteChatMessagesWithResponse(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (*DeleteChatMessagesResponse, error)

	// CheckAutomodStatusWithBodyWithResponse request with any body
	CheckAutomodStatusWithBodyWithResponse(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CheckAutomodStatusResponse, error)

	CheckAutomodStatusWithResponse(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*CheckAutomodStatusResponse, error)

	// RemoveChannelModeratorWithResponse request
	RemoveChannelModeratorWithResponse(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (*RemoveChannelModeratorResponse, error)

	// GetModeratorsWithResponse request
	GetModeratorsWithResponse(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (*GetModeratorsResponse, error)

	// AddChannelModeratorWithResponse request
	AddChannelModeratorWithResponse(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (*AddChannelModeratorResponse, error)

	// GetShieldModeStatusWithResponse request
	GetShieldModeStatusWithResponse(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (*GetShieldModeStatusResponse, error)

	// UpdateShieldModeStatusWithBodyWithResponse request with any body
	UpdateShieldModeStatusWithBodyWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateShieldModeStatusResponse, error)

	UpdateShieldModeStatusWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateShieldModeStatusResponse, error)

	// GetUnbanRequestsWithResponse request
	GetUnbanRequestsWithResponse(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (*GetUnbanRequestsResponse, error)

	// ResolveUnbanRequestsWithResponse request
	ResolveUnbanRequestsWithResponse(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (*ResolveUnbanRequestsResponse, error)

	// WarnChatUserWithBodyWithResponse request with any body
	WarnChatUserWithBodyWithResponse(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*WarnChatUserResponse, error)

	WarnChatUserWithResponse(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (*WarnChatUserResponse, error)

	// GetPollsWithResponse request
	GetPollsWithResponse(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (*GetPollsResponse, error)

	// EndPollWithBodyWithResponse request with any body
	EndPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndPollResponse, error)

	EndPollWithResponse(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (*EndPollResponse, error)

	// CreatePollWithBodyWithResponse request with any body
	CreatePollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePollResponse, error)

	CreatePollWithResponse(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePollResponse, error)

	// GetPredictionsWithResponse request
	GetPredictionsWithResponse(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (*GetPredictionsResponse, error)

	// EndPredictionWithBodyWithResponse request with any body
	EndPredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndPredictionResponse, error)

	EndPredictionWithResponse(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*EndPredictionResponse, error)

	// CreatePredictionWithBodyWithResponse request with any body
	CreatePredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePredictionResponse, error)

	CreatePredictionWithResponse(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePredictionResponse, error)

	// CancelARaidWithResponse request
	CancelARaidWithResponse(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (*CancelARaidResponse, error)

	// StartARaidWithResponse request
	StartARaidWithResponse(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (*StartARaidResponse, error)

	// GetChannelStreamScheduleWithResponse request
	GetChannelStreamScheduleWithResponse(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*GetChannelStreamScheduleResponse, error)

	// GetChannelIcalendarWithResponse request
	GetChannelIcalendarWithResponse(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (*GetChannelIcalendarResponse, error)

	// DeleteChannelStreamScheduleSegmentWithResponse request
	DeleteChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (*DeleteChannelStreamScheduleSegmentResponse, error)

	// UpdateChannelStreamScheduleSegmentWithBodyWithResponse request with any body
	UpdateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateChannelStreamScheduleSegmentResponse, error)

	UpdateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateChannelStreamScheduleSegmentResponse, error)

	// CreateChannelStreamScheduleSegmentWithBodyWithResponse request with any body
	CreateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateChannelStreamScheduleSegmentResponse, error)

	CreateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateChannelStreamScheduleSegmentResponse, error)

	// UpdateChannelStreamScheduleWithResponse request
	UpdateChannelStreamScheduleWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (*UpdateChannelStreamScheduleResponse, error)

	// SearchCategoriesWithResponse request
	SearchCategoriesWithResponse(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (*SearchCategoriesResponse, error)

	// SearchChannelsWithResponse request
	SearchChannelsWithResponse(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (*SearchChannelsResponse, error)

	// GetSharedChatSessionWithResponse request
	GetSharedChatSessionWithResponse(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (*GetSharedChatSessionResponse, error)

	// GetStreamsWithResponse request
	GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (*GetStreamsResponse, error)

	// GetFollowedStreamsWithResponse request
	GetFollowedStreamsWithResponse(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (*GetFollowedStreamsResponse, error)

	// GetStreamKeyWithResponse request
	GetStreamKeyWithResponse(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (*GetStreamKeyResponse, error)

	// GetStreamMarkersWithResponse request
	GetStreamMarkersWithResponse(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (*GetStreamMarkersResponse, error)

	// CreateStreamMarkerWithBodyWithResponse request with any body
	CreateStreamMarkerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStreamMarkerResponse, error)

	CreateStreamMarkerWithResponse(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStreamMarkerResponse, error)

	// GetStreamTagsWithResponse request
	GetStreamTagsWithResponse(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (*GetStreamTagsResponse, error)

	// GetBroadcasterSubscriptionsWithResponse request
	GetBroadcasterSubscriptionsWithResponse(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetBroadcasterSubscriptionsResponse, error)

	// CheckUserSubscriptionWithResponse request
	CheckUserSubscriptionWithResponse(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (*CheckUserSubscriptionResponse, error)

	// GetAllStreamTagsWithResponse request
	GetAllStreamTagsWithResponse(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (*GetAllStreamTagsResponse, error)

	// GetTeamsWithResponse request
	GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (*GetTeamsResponse, error)

	// GetChannelTeamsWithResponse request
	GetChannelTeamsWithResponse(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (*GetChannelTeamsResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// UpdateUserWithResponse request
	UpdateUserWithResponse(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (*UpdateUserResponse, error)

	// UnblockUserWithResponse request
	UnblockUserWithResponse(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (*UnblockUserResponse, error)

	// GetUserBlockListWithResponse request
	GetUserBlockListWithResponse(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (*GetUserBlockListResponse, error)

	// BlockUserWithResponse request
	BlockUserWithResponse(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (*BlockUserResponse, error)

	// GetUserActiveExtensionsWithResponse request
	GetUserActiveExtensionsWithResponse(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (*GetUserActiveExtensionsResponse, error)

	// UpdateUserExtensionsWithBodyWithResponse request with any body
	UpdateUserExtensionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserExtensionsResponse, error)

	UpdateUserExtensionsWithResponse(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserExtensionsResponse, error)

	// GetUserExtensionsWithResponse request
	GetUserExtensionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserExtensionsResponse, error)

	// DeleteVideosWithResponse request
	DeleteVideosWithResponse(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (*DeleteVideosResponse, error)

	// GetVideosWithResponse request
	GetVideosWithResponse(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (*GetVideosResponse, error)

	// SendWhisperWithBodyWithResponse request with any body
	SendWhisperWithBodyWithResponse(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SendWhisperResponse, error)

	SendWhisperWithResponse(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (*SendWhisperResponse, error)
}

type GetExtensionAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionAnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGameAnalyticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGameAnalyticsResponse
}

// Status returns HTTPResponse.Status
func (r GetGameAnalyticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGameAnalyticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCheermotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCheermotesResponse
}

// Status returns HTTPResponse.Status
func (r GetCheermotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCheermotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionBitsProductsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionBitsProductsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionBitsProductsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionBitsProductsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateExtensionBitsProductResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateExtensionBitsProductResponse
}

// Status returns HTTPResponse.Status
func (r UpdateExtensionBitsProductResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateExtensionBitsProductResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBitsLeaderboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBitsLeaderboardResponse
}

// Status returns HTTPResponse.Status
func (r GetBitsLeaderboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBitsLeaderboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomRewardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomRewardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomRewardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomRewardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCustomRewardResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomRewardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomRewardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomRewardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateCustomRewardResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCustomRewardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomRewardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomRewardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateCustomRewardsResponse
}

// Status returns HTTPResponse.Status
func (r CreateCustomRewardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomRewardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomRewardRedemptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCustomRewardRedemptionResponse
}

// Status returns HTTPResponse.Status
func (r GetCustomRewardRedemptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomRewardRedemptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRedemptionStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateRedemptionStatusResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRedemptionStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRedemptionStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelInformationResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ModifyChannelInformationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ModifyChannelInformationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ModifyChannelInformationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAdScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAdScheduleResponse
}

// Status returns HTTPResponse.Status
func (r GetAdScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAdScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SnoozeNextAdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SnoozeNextAdResponse
}

// Status returns HTTPResponse.Status
func (r SnoozeNextAdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SnoozeNextAdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartCommercialResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartCommercialResponse
}

// Status returns HTTPResponse.Status
func (r StartCommercialResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartCommercialResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelEditorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelEditorsResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelEditorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelEditorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFollowedChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFollowedChannelsResponse
}

// Status returns HTTPResponse.Status
func (r GetFollowedChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFollowedChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelFollowersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelFollowersResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveChannelVipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveChannelVipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveChannelVipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetVIPsResponse
}

// Status returns HTTPResponse.Status
func (r GetVipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelVipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddChannelVipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelVipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharityCampaignResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCharityCampaignResponse
}

// Status returns HTTPResponse.Status
func (r GetCharityCampaignResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharityCampaignResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharityCampaignDonationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCharityCampaignDonationsResponse
}

// Status returns HTTPResponse.Status
func (r GetCharityCampaignDonationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharityCampaignDonationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendChatAnnouncementResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendChatAnnouncementResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendChatAnnouncementResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelChatBadgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelChatBadgesResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelChatBadgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelChatBadgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalChatBadgesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGlobalChatBadgesResponse
}

// Status returns HTTPResponse.Status
func (r GetGlobalChatBadgesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalChatBadgesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChattersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChattersResponse
}

// Status returns HTTPResponse.Status
func (r GetChattersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChattersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserChatColorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserChatColorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserChatColorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserChatColorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserChatColorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateUserChatColorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserChatColorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelEmotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelEmotesResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelEmotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelEmotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalEmotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGlobalEmotesResponse
}

// Status returns HTTPResponse.Status
func (r GetGlobalEmotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalEmotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEmoteSetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEmoteSetsResponse
}

// Status returns HTTPResponse.Status
func (r GetEmoteSetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmoteSetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserEmotesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserEmotesResponse
}

// Status returns HTTPResponse.Status
func (r GetUserEmotesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserEmotesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendChatMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SendChatMessageResponse
}

// Status returns HTTPResponse.Status
func (r SendChatMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendChatMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChatSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChatSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetChatSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChatSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChatSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateChatSettingsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateChatSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChatSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendAShoutoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendAShoutoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendAShoutoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClipsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetClipsResponse
}

// Status returns HTTPResponse.Status
func (r GetClipsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClipsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateClipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateClipResponse
}

// Status returns HTTPResponse.Status
func (r CreateClipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateClipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContentClassificationLabelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetContentClassificationLabelsResponse
}

// Status returns HTTPResponse.Status
func (r GetContentClassificationLabelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContentClassificationLabelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDropsEntitlementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDropsEntitlementsResponse
}

// Status returns HTTPResponse.Status
func (r GetDropsEntitlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDropsEntitlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDropsEntitlementsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateDropsEntitlementsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateDropsEntitlementsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDropsEntitlementsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConduitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteConduitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConduitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConduitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConduitsResponse
}

// Status returns HTTPResponse.Status
func (r GetConduitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConduitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConduitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateConduitsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConduitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConduitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConduitsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateConduitsResponse
}

// Status returns HTTPResponse.Status
func (r CreateConduitsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConduitsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConduitShardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetConduitShardsResponse
}

// Status returns HTTPResponse.Status
func (r GetConduitShardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConduitShardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConduitShardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *UpdateConduitShardsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateConduitShardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConduitShardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEventsubSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteEventsubSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEventsubSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsubSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetEventSubSubscriptionsResponse
}

// Status returns HTTPResponse.Status
func (r GetEventsubSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsubSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEventsubSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON202      *CreateEventSubSubscriptionResponse
}

// Status returns HTTPResponse.Status
func (r CreateEventsubSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEventsubSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendExtensionChatMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendExtensionChatMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendExtensionChatMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionConfigurationSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionConfigurationSegmentResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionConfigurationSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionConfigurationSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetExtensionConfigurationSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetExtensionConfigurationSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetExtensionConfigurationSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionSecretsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionSecretsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionSecretsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionSecretsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateExtensionSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateExtensionSecretResponse
}

// Status returns HTTPResponse.Status
func (r CreateExtensionSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateExtensionSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionLiveChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionLiveChannelsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionLiveChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionLiveChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendExtensionPubsubMessageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendExtensionPubsubMessageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendExtensionPubsubMessageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReleasedExtensionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetReleasedExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetReleasedExtensionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReleasedExtensionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetExtensionRequiredConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetExtensionRequiredConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetExtensionRequiredConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExtensionTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetExtensionTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetExtensionTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExtensionTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGamesResponse
}

// Status returns HTTPResponse.Status
func (r GetGamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopGamesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTopGamesResponse
}

// Status returns HTTPResponse.Status
func (r GetTopGamesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopGamesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCreatorGoalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCreatorGoalsResponse
}

// Status returns HTTPResponse.Status
func (r GetCreatorGoalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCreatorGoalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelGuestStarSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelGuestStarSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelGuestStarSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelGuestStarSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelGuestStarSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateChannelGuestStarSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelGuestStarSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGuestStarInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGuestStarInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGuestStarInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGuestStarInvitesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGuestStarInvitesResponse
}

// Status returns HTTPResponse.Status
func (r GetGuestStarInvitesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGuestStarInvitesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendGuestStarInviteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendGuestStarInviteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendGuestStarInviteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndGuestStarSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EndGuestStarSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndGuestStarSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGuestStarSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetGuestStarSessionResponse
}

// Status returns HTTPResponse.Status
func (r GetGuestStarSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGuestStarSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGuestStarSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateGuestStarSessionResponse
}

// Status returns HTTPResponse.Status
func (r CreateGuestStarSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGuestStarSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGuestStarSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGuestStarSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGuestStarSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGuestStarSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGuestStarSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGuestStarSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AssignGuestStarSlotResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AssignGuestStarSlotResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AssignGuestStarSlotResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGuestStarSlotSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateGuestStarSlotSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGuestStarSlotSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHypeTrainEventsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetHypeTrainEventsResponse
}

// Status returns HTTPResponse.Status
func (r GetHypeTrainEventsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHypeTrainEventsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ManageHeldAutomodMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ManageHeldAutomodMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ManageHeldAutomodMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAutomodSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAutoModSettingsResponse
}

// Status returns HTTPResponse.Status
func (r GetAutomodSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAutomodSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAutomodSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateAutoModSettingsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateAutomodSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAutomodSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBannedUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBannedUsersResponse
}

// Status returns HTTPResponse.Status
func (r GetBannedUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBannedUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnbanUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnbanUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnbanUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BanUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BanUserResponse
}

// Status returns HTTPResponse.Status
func (r BanUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BanUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveBlockedTermResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveBlockedTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveBlockedTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBlockedTermsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBlockedTermsResponse
}

// Status returns HTTPResponse.Status
func (r GetBlockedTermsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBlockedTermsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBlockedTermResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddBlockedTermResponse
}

// Status returns HTTPResponse.Status
func (r AddBlockedTermResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBlockedTermResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModeratedChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModeratedChannelsResponse
}

// Status returns HTTPResponse.Status
func (r GetModeratedChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModeratedChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChatMessagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteChatMessagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChatMessagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckAutomodStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckAutoModStatusResponse
}

// Status returns HTTPResponse.Status
func (r CheckAutomodStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAutomodStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveChannelModeratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RemoveChannelModeratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveChannelModeratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetModeratorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetModeratorsResponse
}

// Status returns HTTPResponse.Status
func (r GetModeratorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetModeratorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddChannelModeratorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddChannelModeratorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddChannelModeratorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetShieldModeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetShieldModeStatusResponse
}

// Status returns HTTPResponse.Status
func (r GetShieldModeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetShieldModeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateShieldModeStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateShieldModeStatusResponse
}

// Status returns HTTPResponse.Status
func (r UpdateShieldModeStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateShieldModeStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUnbanRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUnbanRequestsResponse
}

// Status returns HTTPResponse.Status
func (r GetUnbanRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUnbanRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResolveUnbanRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResolveUnbanRequestsResponse
}

// Status returns HTTPResponse.Status
func (r ResolveUnbanRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResolveUnbanRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type WarnChatUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WarnChatUserResponse
}

// Status returns HTTPResponse.Status
func (r WarnChatUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r WarnChatUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPollsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPollsResponse
}

// Status returns HTTPResponse.Status
func (r GetPollsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPollsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndPollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndPollResponse
}

// Status returns HTTPResponse.Status
func (r EndPollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndPollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePollResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePollResponse
}

// Status returns HTTPResponse.Status
func (r CreatePollResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePollResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPredictionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPredictionsResponse
}

// Status returns HTTPResponse.Status
func (r GetPredictionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPredictionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndPredictionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EndPredictionResponse
}

// Status returns HTTPResponse.Status
func (r EndPredictionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndPredictionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePredictionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreatePredictionResponse
}

// Status returns HTTPResponse.Status
func (r CreatePredictionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePredictionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CancelARaidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CancelARaidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CancelARaidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StartARaidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StartRaidResponse
}

// Status returns HTTPResponse.Status
func (r StartARaidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StartARaidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelStreamScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelStreamScheduleResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelStreamScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelStreamScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelIcalendarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetChannelIcalendarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelIcalendarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChannelStreamScheduleSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteChannelStreamScheduleSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChannelStreamScheduleSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelStreamScheduleSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateChannelStreamScheduleSegmentResponse
}

// Status returns HTTPResponse.Status
func (r UpdateChannelStreamScheduleSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelStreamScheduleSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateChannelStreamScheduleSegmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateChannelStreamScheduleSegmentResponse
}

// Status returns HTTPResponse.Status
func (r CreateChannelStreamScheduleSegmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateChannelStreamScheduleSegmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateChannelStreamScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateChannelStreamScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateChannelStreamScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchCategoriesResponse
}

// Status returns HTTPResponse.Status
func (r SearchCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SearchChannelsResponse
}

// Status returns HTTPResponse.Status
func (r SearchChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSharedChatSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetSharedChatSessionResponse
}

// Status returns HTTPResponse.Status
func (r GetSharedChatSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSharedChatSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamsResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFollowedStreamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetFollowedStreamsResponse
}

// Status returns HTTPResponse.Status
func (r GetFollowedStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFollowedStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamKeyResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamMarkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamMarkersResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamMarkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamMarkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStreamMarkerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateStreamMarkerResponse
}

// Status returns HTTPResponse.Status
func (r CreateStreamMarkerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStreamMarkerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStreamTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetStreamTagsResponse
}

// Status returns HTTPResponse.Status
func (r GetStreamTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStreamTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBroadcasterSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBroadcasterSubscriptionsResponse
}

// Status returns HTTPResponse.Status
func (r GetBroadcasterSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBroadcasterSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckUserSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckUserSubscriptionResponse
}

// Status returns HTTPResponse.Status
func (r CheckUserSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckUserSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllStreamTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAllStreamTagsResponse
}

// Status returns HTTPResponse.Status
func (r GetAllStreamTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllStreamTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTeamsResponse
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChannelTeamsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetChannelTeamsResponse
}

// Status returns HTTPResponse.Status
func (r GetChannelTeamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChannelTeamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUsersResponse
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserResponse
}

// Status returns HTTPResponse.Status
func (r UpdateUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnblockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UnblockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnblockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserBlockListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserBlockListResponse
}

// Status returns HTTPResponse.Status
func (r GetUserBlockListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserBlockListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BlockUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r BlockUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BlockUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserActiveExtensionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserActiveExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetUserActiveExtensionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserActiveExtensionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserExtensionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UpdateUserExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r UpdateUserExtensionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserExtensionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserExtensionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUserExtensionsResponse
}

// Status returns HTTPResponse.Status
func (r GetUserExtensionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserExtensionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DeleteVideosResponse
}

// Status returns HTTPResponse.Status
func (r DeleteVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetVideosResponse
}

// Status returns HTTPResponse.Status
func (r GetVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SendWhisperResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SendWhisperResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SendWhisperResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetExtensionAnalyticsWithResponse request returning *GetExtensionAnalyticsResponse
func (c *ClientWithResponses) GetExtensionAnalyticsWithResponse(ctx context.Context, params *GetExtensionAnalyticsParams, reqEditors ...RequestEditorFn) (r *GetExtensionAnalyticsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionAnalyticsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionAnalytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionAnalyticsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGameAnalyticsWithResponse request returning *GetGameAnalyticsResponse
func (c *ClientWithResponses) GetGameAnalyticsWithResponse(ctx context.Context, params *GetGameAnalyticsParams, reqEditors ...RequestEditorFn) (r *GetGameAnalyticsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGameAnalyticsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGameAnalytics(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGameAnalyticsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCheermotesWithResponse request returning *GetCheermotesResponse
func (c *ClientWithResponses) GetCheermotesWithResponse(ctx context.Context, params *GetCheermotesParams, reqEditors ...RequestEditorFn) (r *GetCheermotesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCheermotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCheermotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCheermotesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionBitsProductsWithResponse request returning *GetExtensionBitsProductsResponse
func (c *ClientWithResponses) GetExtensionBitsProductsWithResponse(ctx context.Context, params *GetExtensionBitsProductsParams, reqEditors ...RequestEditorFn) (r *GetExtensionBitsProductsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionBitsProductsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionBitsProducts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionBitsProductsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateExtensionBitsProductWithBodyWithResponse request with arbitrary body returning *UpdateExtensionBitsProductResponse
func (c *ClientWithResponses) UpdateExtensionBitsProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateExtensionBitsProductResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateExtensionBitsProductWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateExtensionBitsProductWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateExtensionBitsProductResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateExtensionBitsProductWithResponse(ctx context.Context, body UpdateExtensionBitsProductJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateExtensionBitsProductResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateExtensionBitsProductWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateExtensionBitsProduct(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateExtensionBitsProductResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBitsLeaderboardWithResponse request returning *GetBitsLeaderboardResponse
func (c *ClientWithResponses) GetBitsLeaderboardWithResponse(ctx context.Context, params *GetBitsLeaderboardParams, reqEditors ...RequestEditorFn) (r *GetBitsLeaderboardResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBitsLeaderboardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBitsLeaderboard(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBitsLeaderboardResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteCustomRewardWithResponse request returning *DeleteCustomRewardResponse
func (c *ClientWithResponses) DeleteCustomRewardWithResponse(ctx context.Context, params *DeleteCustomRewardParams, reqEditors ...RequestEditorFn) (r *DeleteCustomRewardResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteCustomRewardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteCustomReward(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteCustomRewardResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCustomRewardWithResponse request returning *GetCustomRewardResponse
func (c *ClientWithResponses) GetCustomRewardWithResponse(ctx context.Context, params *GetCustomRewardParams, reqEditors ...RequestEditorFn) (r *GetCustomRewardResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCustomRewardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCustomReward(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCustomRewardResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateCustomRewardWithBodyWithResponse request with arbitrary body returning *UpdateCustomRewardResponse
func (c *ClientWithResponses) UpdateCustomRewardWithBodyWithResponse(ctx context.Context, params *UpdateCustomRewardParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateCustomRewardResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateCustomRewardWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateCustomRewardWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateCustomRewardResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateCustomRewardWithResponse(ctx context.Context, params *UpdateCustomRewardParams, body UpdateCustomRewardJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateCustomRewardResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateCustomRewardWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateCustomReward(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateCustomRewardResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateCustomRewardsWithBodyWithResponse request with arbitrary body returning *CreateCustomRewardsResponse
func (c *ClientWithResponses) CreateCustomRewardsWithBodyWithResponse(ctx context.Context, params *CreateCustomRewardsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateCustomRewardsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateCustomRewardsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateCustomRewardsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateCustomRewardsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreateCustomRewardsWithResponse(ctx context.Context, params *CreateCustomRewardsParams, body CreateCustomRewardsJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateCustomRewardsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateCustomRewardsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateCustomRewards(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateCustomRewardsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCustomRewardRedemptionWithResponse request returning *GetCustomRewardRedemptionResponse
func (c *ClientWithResponses) GetCustomRewardRedemptionWithResponse(ctx context.Context, params *GetCustomRewardRedemptionParams, reqEditors ...RequestEditorFn) (r *GetCustomRewardRedemptionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCustomRewardRedemptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCustomRewardRedemption(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCustomRewardRedemptionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateRedemptionStatusWithBodyWithResponse request with arbitrary body returning *UpdateRedemptionStatusResponse
func (c *ClientWithResponses) UpdateRedemptionStatusWithBodyWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateRedemptionStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateRedemptionStatusWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateRedemptionStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateRedemptionStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateRedemptionStatusWithResponse(ctx context.Context, params *UpdateRedemptionStatusParams, body UpdateRedemptionStatusJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateRedemptionStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateRedemptionStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateRedemptionStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateRedemptionStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelInformationWithResponse request returning *GetChannelInformationResponse
func (c *ClientWithResponses) GetChannelInformationWithResponse(ctx context.Context, params *GetChannelInformationParams, reqEditors ...RequestEditorFn) (r *GetChannelInformationResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelInformationWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelInformation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelInformationResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ModifyChannelInformationWithBodyWithResponse request with arbitrary body returning *ModifyChannelInformationResponse
func (c *ClientWithResponses) ModifyChannelInformationWithBodyWithResponse(ctx context.Context, params *ModifyChannelInformationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *ModifyChannelInformationResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ModifyChannelInformationWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ModifyChannelInformationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseModifyChannelInformationResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) ModifyChannelInformationWithResponse(ctx context.Context, params *ModifyChannelInformationParams, body ModifyChannelInformationJSONRequestBody, reqEditors ...RequestEditorFn) (r *ModifyChannelInformationResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ModifyChannelInformationWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ModifyChannelInformation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseModifyChannelInformationResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetAdScheduleWithResponse request returning *GetAdScheduleResponse
func (c *ClientWithResponses) GetAdScheduleWithResponse(ctx context.Context, params *GetAdScheduleParams, reqEditors ...RequestEditorFn) (r *GetAdScheduleResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetAdScheduleWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetAdSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetAdScheduleResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SnoozeNextAdWithResponse request returning *SnoozeNextAdResponse
func (c *ClientWithResponses) SnoozeNextAdWithResponse(ctx context.Context, params *SnoozeNextAdParams, reqEditors ...RequestEditorFn) (r *SnoozeNextAdResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SnoozeNextAdWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SnoozeNextAd(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSnoozeNextAdResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// StartCommercialWithBodyWithResponse request with arbitrary body returning *StartCommercialResponse
func (c *ClientWithResponses) StartCommercialWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *StartCommercialResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "StartCommercialWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.StartCommercialWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseStartCommercialResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) StartCommercialWithResponse(ctx context.Context, body StartCommercialJSONRequestBody, reqEditors ...RequestEditorFn) (r *StartCommercialResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "StartCommercialWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.StartCommercial(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseStartCommercialResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelEditorsWithResponse request returning *GetChannelEditorsResponse
func (c *ClientWithResponses) GetChannelEditorsWithResponse(ctx context.Context, params *GetChannelEditorsParams, reqEditors ...RequestEditorFn) (r *GetChannelEditorsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelEditorsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelEditors(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelEditorsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetFollowedChannelsWithResponse request returning *GetFollowedChannelsResponse
func (c *ClientWithResponses) GetFollowedChannelsWithResponse(ctx context.Context, params *GetFollowedChannelsParams, reqEditors ...RequestEditorFn) (r *GetFollowedChannelsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetFollowedChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetFollowedChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetFollowedChannelsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelFollowersWithResponse request returning *GetChannelFollowersResponse
func (c *ClientWithResponses) GetChannelFollowersWithResponse(ctx context.Context, params *GetChannelFollowersParams, reqEditors ...RequestEditorFn) (r *GetChannelFollowersResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelFollowersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelFollowers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelFollowersResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// RemoveChannelVipWithResponse request returning *RemoveChannelVipResponse
func (c *ClientWithResponses) RemoveChannelVipWithResponse(ctx context.Context, params *RemoveChannelVipParams, reqEditors ...RequestEditorFn) (r *RemoveChannelVipResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "RemoveChannelVipWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.RemoveChannelVip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseRemoveChannelVipResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetVipsWithResponse request returning *GetVipsResponse
func (c *ClientWithResponses) GetVipsWithResponse(ctx context.Context, params *GetVipsParams, reqEditors ...RequestEditorFn) (r *GetVipsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetVipsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetVips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetVipsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AddChannelVipWithResponse request returning *AddChannelVipResponse
func (c *ClientWithResponses) AddChannelVipWithResponse(ctx context.Context, params *AddChannelVipParams, reqEditors ...RequestEditorFn) (r *AddChannelVipResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddChannelVipWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddChannelVip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddChannelVipResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCharityCampaignWithResponse request returning *GetCharityCampaignResponse
func (c *ClientWithResponses) GetCharityCampaignWithResponse(ctx context.Context, params *GetCharityCampaignParams, reqEditors ...RequestEditorFn) (r *GetCharityCampaignResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCharityCampaignWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCharityCampaign(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCharityCampaignResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCharityCampaignDonationsWithResponse request returning *GetCharityCampaignDonationsResponse
func (c *ClientWithResponses) GetCharityCampaignDonationsWithResponse(ctx context.Context, params *GetCharityCampaignDonationsParams, reqEditors ...RequestEditorFn) (r *GetCharityCampaignDonationsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCharityCampaignDonationsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCharityCampaignDonations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCharityCampaignDonationsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendChatAnnouncementWithBodyWithResponse request with arbitrary body returning *SendChatAnnouncementResponse
func (c *ClientWithResponses) SendChatAnnouncementWithBodyWithResponse(ctx context.Context, params *SendChatAnnouncementParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendChatAnnouncementResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatAnnouncementWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatAnnouncementWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatAnnouncementResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SendChatAnnouncementWithResponse(ctx context.Context, params *SendChatAnnouncementParams, body SendChatAnnouncementJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendChatAnnouncementResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatAnnouncementWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatAnnouncement(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatAnnouncementResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelChatBadgesWithResponse request returning *GetChannelChatBadgesResponse
func (c *ClientWithResponses) GetChannelChatBadgesWithResponse(ctx context.Context, params *GetChannelChatBadgesParams, reqEditors ...RequestEditorFn) (r *GetChannelChatBadgesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelChatBadgesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelChatBadges(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelChatBadgesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGlobalChatBadgesWithResponse request returning *GetGlobalChatBadgesResponse
func (c *ClientWithResponses) GetGlobalChatBadgesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetGlobalChatBadgesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGlobalChatBadgesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGlobalChatBadges(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGlobalChatBadgesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChattersWithResponse request returning *GetChattersResponse
func (c *ClientWithResponses) GetChattersWithResponse(ctx context.Context, params *GetChattersParams, reqEditors ...RequestEditorFn) (r *GetChattersResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChattersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChatters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChattersResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserChatColorWithResponse request returning *GetUserChatColorResponse
func (c *ClientWithResponses) GetUserChatColorWithResponse(ctx context.Context, params *GetUserChatColorParams, reqEditors ...RequestEditorFn) (r *GetUserChatColorResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserChatColorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserChatColor(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserChatColorResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateUserChatColorWithResponse request returning *UpdateUserChatColorResponse
func (c *ClientWithResponses) UpdateUserChatColorWithResponse(ctx context.Context, params *UpdateUserChatColorParams, reqEditors ...RequestEditorFn) (r *UpdateUserChatColorResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserChatColorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUserChatColor(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserChatColorResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelEmotesWithResponse request returning *GetChannelEmotesResponse
func (c *ClientWithResponses) GetChannelEmotesWithResponse(ctx context.Context, params *GetChannelEmotesParams, reqEditors ...RequestEditorFn) (r *GetChannelEmotesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelEmotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelEmotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelEmotesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGlobalEmotesWithResponse request returning *GetGlobalEmotesResponse
func (c *ClientWithResponses) GetGlobalEmotesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetGlobalEmotesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGlobalEmotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGlobalEmotes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGlobalEmotesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetEmoteSetsWithResponse request returning *GetEmoteSetsResponse
func (c *ClientWithResponses) GetEmoteSetsWithResponse(ctx context.Context, params *GetEmoteSetsParams, reqEditors ...RequestEditorFn) (r *GetEmoteSetsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetEmoteSetsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetEmoteSets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetEmoteSetsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserEmotesWithResponse request returning *GetUserEmotesResponse
func (c *ClientWithResponses) GetUserEmotesWithResponse(ctx context.Context, params *GetUserEmotesParams, reqEditors ...RequestEditorFn) (r *GetUserEmotesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserEmotesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserEmotes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserEmotesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendChatMessageWithBodyWithResponse request with arbitrary body returning *SendChatMessageResponse
func (c *ClientWithResponses) SendChatMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendChatMessageResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatMessageWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatMessageResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SendChatMessageWithResponse(ctx context.Context, body SendChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendChatMessageResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendChatMessageWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendChatMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendChatMessageResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChatSettingsWithResponse request returning *GetChatSettingsResponse
func (c *ClientWithResponses) GetChatSettingsWithResponse(ctx context.Context, params *GetChatSettingsParams, reqEditors ...RequestEditorFn) (r *GetChatSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChatSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChatSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChatSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChatSettingsWithBodyWithResponse request with arbitrary body returning *UpdateChatSettingsResponse
func (c *ClientWithResponses) UpdateChatSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChatSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateChatSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChatSettingsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChatSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChatSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateChatSettingsWithResponse(ctx context.Context, params *UpdateChatSettingsParams, body UpdateChatSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateChatSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChatSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChatSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChatSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendAShoutoutWithResponse request returning *SendAShoutoutResponse
func (c *ClientWithResponses) SendAShoutoutWithResponse(ctx context.Context, params *SendAShoutoutParams, reqEditors ...RequestEditorFn) (r *SendAShoutoutResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendAShoutoutWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendAShoutout(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendAShoutoutResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetClipsWithResponse request returning *GetClipsResponse
func (c *ClientWithResponses) GetClipsWithResponse(ctx context.Context, params *GetClipsParams, reqEditors ...RequestEditorFn) (r *GetClipsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetClipsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetClips(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetClipsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateClipWithResponse request returning *CreateClipResponse
func (c *ClientWithResponses) CreateClipWithResponse(ctx context.Context, params *CreateClipParams, reqEditors ...RequestEditorFn) (r *CreateClipResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateClipWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateClip(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateClipResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetContentClassificationLabelsWithResponse request returning *GetContentClassificationLabelsResponse
func (c *ClientWithResponses) GetContentClassificationLabelsWithResponse(ctx context.Context, params *GetContentClassificationLabelsParams, reqEditors ...RequestEditorFn) (r *GetContentClassificationLabelsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetContentClassificationLabelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetContentClassificationLabels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetContentClassificationLabelsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetDropsEntitlementsWithResponse request returning *GetDropsEntitlementsResponse
func (c *ClientWithResponses) GetDropsEntitlementsWithResponse(ctx context.Context, params *GetDropsEntitlementsParams, reqEditors ...RequestEditorFn) (r *GetDropsEntitlementsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetDropsEntitlementsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetDropsEntitlements(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetDropsEntitlementsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateDropsEntitlementsWithBodyWithResponse request with arbitrary body returning *UpdateDropsEntitlementsResponse
func (c *ClientWithResponses) UpdateDropsEntitlementsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateDropsEntitlementsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateDropsEntitlementsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateDropsEntitlementsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateDropsEntitlementsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateDropsEntitlementsWithResponse(ctx context.Context, body UpdateDropsEntitlementsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateDropsEntitlementsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateDropsEntitlementsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateDropsEntitlements(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateDropsEntitlementsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteConduitWithResponse request returning *DeleteConduitResponse
func (c *ClientWithResponses) DeleteConduitWithResponse(ctx context.Context, params *DeleteConduitParams, reqEditors ...RequestEditorFn) (r *DeleteConduitResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteConduitWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteConduit(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteConduitResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetConduitsWithResponse request returning *GetConduitsResponse
func (c *ClientWithResponses) GetConduitsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetConduitsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetConduitsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetConduits(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetConduitsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateConduitsWithBodyWithResponse request with arbitrary body returning *UpdateConduitsResponse
func (c *ClientWithResponses) UpdateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateConduitsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduitsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateConduitsWithResponse(ctx context.Context, body UpdateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateConduitsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateConduitsWithBodyWithResponse request with arbitrary body returning *CreateConduitsResponse
func (c *ClientWithResponses) CreateConduitsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateConduitsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateConduitsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateConduitsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateConduitsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreateConduitsWithResponse(ctx context.Context, body CreateConduitsJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateConduitsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateConduitsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateConduits(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateConduitsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetConduitShardsWithResponse request returning *GetConduitShardsResponse
func (c *ClientWithResponses) GetConduitShardsWithResponse(ctx context.Context, params *GetConduitShardsParams, reqEditors ...RequestEditorFn) (r *GetConduitShardsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetConduitShardsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetConduitShards(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetConduitShardsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateConduitShardsWithBodyWithResponse request with arbitrary body returning *UpdateConduitShardsResponse
func (c *ClientWithResponses) UpdateConduitShardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateConduitShardsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitShardsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduitShardsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitShardsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateConduitShardsWithResponse(ctx context.Context, body UpdateConduitShardsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateConduitShardsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateConduitShardsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateConduitShards(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateConduitShardsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteEventsubSubscriptionWithResponse request returning *DeleteEventsubSubscriptionResponse
func (c *ClientWithResponses) DeleteEventsubSubscriptionWithResponse(ctx context.Context, params *DeleteEventsubSubscriptionParams, reqEditors ...RequestEditorFn) (r *DeleteEventsubSubscriptionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteEventsubSubscriptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteEventsubSubscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteEventsubSubscriptionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetEventsubSubscriptionsWithResponse request returning *GetEventsubSubscriptionsResponse
func (c *ClientWithResponses) GetEventsubSubscriptionsWithResponse(ctx context.Context, params *GetEventsubSubscriptionsParams, reqEditors ...RequestEditorFn) (r *GetEventsubSubscriptionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetEventsubSubscriptionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetEventsubSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetEventsubSubscriptionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateEventsubSubscriptionWithBodyWithResponse request with arbitrary body returning *CreateEventsubSubscriptionResponse
func (c *ClientWithResponses) CreateEventsubSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateEventsubSubscriptionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateEventsubSubscriptionWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateEventsubSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateEventsubSubscriptionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreateEventsubSubscriptionWithResponse(ctx context.Context, body CreateEventsubSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateEventsubSubscriptionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateEventsubSubscriptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateEventsubSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateEventsubSubscriptionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionsWithResponse request returning *GetExtensionsResponse
func (c *ClientWithResponses) GetExtensionsWithResponse(ctx context.Context, params *GetExtensionsParams, reqEditors ...RequestEditorFn) (r *GetExtensionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendExtensionChatMessageWithBodyWithResponse request with arbitrary body returning *SendExtensionChatMessageResponse
func (c *ClientWithResponses) SendExtensionChatMessageWithBodyWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendExtensionChatMessageResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionChatMessageWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionChatMessageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionChatMessageResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SendExtensionChatMessageWithResponse(ctx context.Context, params *SendExtensionChatMessageParams, body SendExtensionChatMessageJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendExtensionChatMessageResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionChatMessageWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionChatMessage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionChatMessageResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionConfigurationSegmentWithResponse request returning *GetExtensionConfigurationSegmentResponse
func (c *ClientWithResponses) GetExtensionConfigurationSegmentWithResponse(ctx context.Context, params *GetExtensionConfigurationSegmentParams, reqEditors ...RequestEditorFn) (r *GetExtensionConfigurationSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionConfigurationSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionConfigurationSegment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionConfigurationSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SetExtensionConfigurationSegmentWithBodyWithResponse request with arbitrary body returning *SetExtensionConfigurationSegmentResponse
func (c *ClientWithResponses) SetExtensionConfigurationSegmentWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SetExtensionConfigurationSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionConfigurationSegmentWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionConfigurationSegmentWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionConfigurationSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SetExtensionConfigurationSegmentWithResponse(ctx context.Context, body SetExtensionConfigurationSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (r *SetExtensionConfigurationSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionConfigurationSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionConfigurationSegment(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionConfigurationSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionSecretsWithResponse request returning *GetExtensionSecretsResponse
func (c *ClientWithResponses) GetExtensionSecretsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetExtensionSecretsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionSecretsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionSecrets(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionSecretsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateExtensionSecretWithResponse request returning *CreateExtensionSecretResponse
func (c *ClientWithResponses) CreateExtensionSecretWithResponse(ctx context.Context, params *CreateExtensionSecretParams, reqEditors ...RequestEditorFn) (r *CreateExtensionSecretResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateExtensionSecretWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateExtensionSecret(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateExtensionSecretResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionLiveChannelsWithResponse request returning *GetExtensionLiveChannelsResponse
func (c *ClientWithResponses) GetExtensionLiveChannelsWithResponse(ctx context.Context, params *GetExtensionLiveChannelsParams, reqEditors ...RequestEditorFn) (r *GetExtensionLiveChannelsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionLiveChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionLiveChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionLiveChannelsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendExtensionPubsubMessageWithBodyWithResponse request with arbitrary body returning *SendExtensionPubsubMessageResponse
func (c *ClientWithResponses) SendExtensionPubsubMessageWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendExtensionPubsubMessageResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionPubsubMessageWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionPubsubMessageWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionPubsubMessageResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SendExtensionPubsubMessageWithResponse(ctx context.Context, body SendExtensionPubsubMessageJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendExtensionPubsubMessageResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendExtensionPubsubMessageWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendExtensionPubsubMessage(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendExtensionPubsubMessageResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetReleasedExtensionsWithResponse request returning *GetReleasedExtensionsResponse
func (c *ClientWithResponses) GetReleasedExtensionsWithResponse(ctx context.Context, params *GetReleasedExtensionsParams, reqEditors ...RequestEditorFn) (r *GetReleasedExtensionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetReleasedExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetReleasedExtensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetReleasedExtensionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SetExtensionRequiredConfigurationWithBodyWithResponse request with arbitrary body returning *SetExtensionRequiredConfigurationResponse
func (c *ClientWithResponses) SetExtensionRequiredConfigurationWithBodyWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SetExtensionRequiredConfigurationResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionRequiredConfigurationWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionRequiredConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionRequiredConfigurationResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SetExtensionRequiredConfigurationWithResponse(ctx context.Context, params *SetExtensionRequiredConfigurationParams, body SetExtensionRequiredConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (r *SetExtensionRequiredConfigurationResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SetExtensionRequiredConfigurationWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SetExtensionRequiredConfiguration(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSetExtensionRequiredConfigurationResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetExtensionTransactionsWithResponse request returning *GetExtensionTransactionsResponse
func (c *ClientWithResponses) GetExtensionTransactionsWithResponse(ctx context.Context, params *GetExtensionTransactionsParams, reqEditors ...RequestEditorFn) (r *GetExtensionTransactionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetExtensionTransactionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetExtensionTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetExtensionTransactionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGamesWithResponse request returning *GetGamesResponse
func (c *ClientWithResponses) GetGamesWithResponse(ctx context.Context, params *GetGamesParams, reqEditors ...RequestEditorFn) (r *GetGamesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGamesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGames(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGamesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetTopGamesWithResponse request returning *GetTopGamesResponse
func (c *ClientWithResponses) GetTopGamesWithResponse(ctx context.Context, params *GetTopGamesParams, reqEditors ...RequestEditorFn) (r *GetTopGamesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetTopGamesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetTopGames(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetTopGamesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetCreatorGoalsWithResponse request returning *GetCreatorGoalsResponse
func (c *ClientWithResponses) GetCreatorGoalsWithResponse(ctx context.Context, params *GetCreatorGoalsParams, reqEditors ...RequestEditorFn) (r *GetCreatorGoalsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetCreatorGoalsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetCreatorGoals(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetCreatorGoalsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelGuestStarSettingsWithResponse request returning *GetChannelGuestStarSettingsResponse
func (c *ClientWithResponses) GetChannelGuestStarSettingsWithResponse(ctx context.Context, params *GetChannelGuestStarSettingsParams, reqEditors ...RequestEditorFn) (r *GetChannelGuestStarSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelGuestStarSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelGuestStarSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelGuestStarSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChannelGuestStarSettingsWithBodyWithResponse request with arbitrary body returning *UpdateChannelGuestStarSettingsResponse
func (c *ClientWithResponses) UpdateChannelGuestStarSettingsWithBodyWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateChannelGuestStarSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelGuestStarSettingsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelGuestStarSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelGuestStarSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateChannelGuestStarSettingsWithResponse(ctx context.Context, params *UpdateChannelGuestStarSettingsParams, body UpdateChannelGuestStarSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateChannelGuestStarSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelGuestStarSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelGuestStarSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelGuestStarSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteGuestStarInviteWithResponse request returning *DeleteGuestStarInviteResponse
func (c *ClientWithResponses) DeleteGuestStarInviteWithResponse(ctx context.Context, params *DeleteGuestStarInviteParams, reqEditors ...RequestEditorFn) (r *DeleteGuestStarInviteResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteGuestStarInviteWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteGuestStarInvite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteGuestStarInviteResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGuestStarInvitesWithResponse request returning *GetGuestStarInvitesResponse
func (c *ClientWithResponses) GetGuestStarInvitesWithResponse(ctx context.Context, params *GetGuestStarInvitesParams, reqEditors ...RequestEditorFn) (r *GetGuestStarInvitesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGuestStarInvitesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGuestStarInvites(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGuestStarInvitesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendGuestStarInviteWithResponse request returning *SendGuestStarInviteResponse
func (c *ClientWithResponses) SendGuestStarInviteWithResponse(ctx context.Context, params *SendGuestStarInviteParams, reqEditors ...RequestEditorFn) (r *SendGuestStarInviteResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendGuestStarInviteWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendGuestStarInvite(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendGuestStarInviteResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// EndGuestStarSessionWithResponse request returning *EndGuestStarSessionResponse
func (c *ClientWithResponses) EndGuestStarSessionWithResponse(ctx context.Context, params *EndGuestStarSessionParams, reqEditors ...RequestEditorFn) (r *EndGuestStarSessionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndGuestStarSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndGuestStarSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndGuestStarSessionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetGuestStarSessionWithResponse request returning *GetGuestStarSessionResponse
func (c *ClientWithResponses) GetGuestStarSessionWithResponse(ctx context.Context, params *GetGuestStarSessionParams, reqEditors ...RequestEditorFn) (r *GetGuestStarSessionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetGuestStarSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetGuestStarSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetGuestStarSessionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateGuestStarSessionWithResponse request returning *CreateGuestStarSessionResponse
func (c *ClientWithResponses) CreateGuestStarSessionWithResponse(ctx context.Context, params *CreateGuestStarSessionParams, reqEditors ...RequestEditorFn) (r *CreateGuestStarSessionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateGuestStarSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateGuestStarSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateGuestStarSessionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteGuestStarSlotWithResponse request returning *DeleteGuestStarSlotResponse
func (c *ClientWithResponses) DeleteGuestStarSlotWithResponse(ctx context.Context, params *DeleteGuestStarSlotParams, reqEditors ...RequestEditorFn) (r *DeleteGuestStarSlotResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteGuestStarSlotWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteGuestStarSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteGuestStarSlotResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateGuestStarSlotWithResponse request returning *UpdateGuestStarSlotResponse
func (c *ClientWithResponses) UpdateGuestStarSlotWithResponse(ctx context.Context, params *UpdateGuestStarSlotParams, reqEditors ...RequestEditorFn) (r *UpdateGuestStarSlotResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateGuestStarSlotWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateGuestStarSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateGuestStarSlotResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AssignGuestStarSlotWithResponse request returning *AssignGuestStarSlotResponse
func (c *ClientWithResponses) AssignGuestStarSlotWithResponse(ctx context.Context, params *AssignGuestStarSlotParams, reqEditors ...RequestEditorFn) (r *AssignGuestStarSlotResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AssignGuestStarSlotWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AssignGuestStarSlot(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAssignGuestStarSlotResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateGuestStarSlotSettingsWithResponse request returning *UpdateGuestStarSlotSettingsResponse
func (c *ClientWithResponses) UpdateGuestStarSlotSettingsWithResponse(ctx context.Context, params *UpdateGuestStarSlotSettingsParams, reqEditors ...RequestEditorFn) (r *UpdateGuestStarSlotSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateGuestStarSlotSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateGuestStarSlotSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateGuestStarSlotSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetHypeTrainEventsWithResponse request returning *GetHypeTrainEventsResponse
func (c *ClientWithResponses) GetHypeTrainEventsWithResponse(ctx context.Context, params *GetHypeTrainEventsParams, reqEditors ...RequestEditorFn) (r *GetHypeTrainEventsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetHypeTrainEventsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetHypeTrainEvents(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetHypeTrainEventsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ManageHeldAutomodMessagesWithBodyWithResponse request with arbitrary body returning *ManageHeldAutomodMessagesResponse
func (c *ClientWithResponses) ManageHeldAutomodMessagesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *ManageHeldAutomodMessagesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ManageHeldAutomodMessagesWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ManageHeldAutomodMessagesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseManageHeldAutomodMessagesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) ManageHeldAutomodMessagesWithResponse(ctx context.Context, body ManageHeldAutomodMessagesJSONRequestBody, reqEditors ...RequestEditorFn) (r *ManageHeldAutomodMessagesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ManageHeldAutomodMessagesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ManageHeldAutomodMessages(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseManageHeldAutomodMessagesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetAutomodSettingsWithResponse request returning *GetAutomodSettingsResponse
func (c *ClientWithResponses) GetAutomodSettingsWithResponse(ctx context.Context, params *GetAutomodSettingsParams, reqEditors ...RequestEditorFn) (r *GetAutomodSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetAutomodSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetAutomodSettings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetAutomodSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateAutomodSettingsWithBodyWithResponse request with arbitrary body returning *UpdateAutomodSettingsResponse
func (c *ClientWithResponses) UpdateAutomodSettingsWithBodyWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateAutomodSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateAutomodSettingsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateAutomodSettingsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateAutomodSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateAutomodSettingsWithResponse(ctx context.Context, params *UpdateAutomodSettingsParams, body UpdateAutomodSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateAutomodSettingsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateAutomodSettingsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateAutomodSettings(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateAutomodSettingsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBannedUsersWithResponse request returning *GetBannedUsersResponse
func (c *ClientWithResponses) GetBannedUsersWithResponse(ctx context.Context, params *GetBannedUsersParams, reqEditors ...RequestEditorFn) (r *GetBannedUsersResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBannedUsersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBannedUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBannedUsersResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UnbanUserWithResponse request returning *UnbanUserResponse
func (c *ClientWithResponses) UnbanUserWithResponse(ctx context.Context, params *UnbanUserParams, reqEditors ...RequestEditorFn) (r *UnbanUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UnbanUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UnbanUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUnbanUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// BanUserWithBodyWithResponse request with arbitrary body returning *BanUserResponse
func (c *ClientWithResponses) BanUserWithBodyWithResponse(ctx context.Context, params *BanUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *BanUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "BanUserWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.BanUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseBanUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) BanUserWithResponse(ctx context.Context, params *BanUserParams, body BanUserJSONRequestBody, reqEditors ...RequestEditorFn) (r *BanUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "BanUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.BanUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseBanUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// RemoveBlockedTermWithResponse request returning *RemoveBlockedTermResponse
func (c *ClientWithResponses) RemoveBlockedTermWithResponse(ctx context.Context, params *RemoveBlockedTermParams, reqEditors ...RequestEditorFn) (r *RemoveBlockedTermResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "RemoveBlockedTermWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.RemoveBlockedTerm(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseRemoveBlockedTermResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBlockedTermsWithResponse request returning *GetBlockedTermsResponse
func (c *ClientWithResponses) GetBlockedTermsWithResponse(ctx context.Context, params *GetBlockedTermsParams, reqEditors ...RequestEditorFn) (r *GetBlockedTermsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBlockedTermsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBlockedTerms(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBlockedTermsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AddBlockedTermWithBodyWithResponse request with arbitrary body returning *AddBlockedTermResponse
func (c *ClientWithResponses) AddBlockedTermWithBodyWithResponse(ctx context.Context, params *AddBlockedTermParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *AddBlockedTermResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddBlockedTermWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddBlockedTermWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddBlockedTermResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) AddBlockedTermWithResponse(ctx context.Context, params *AddBlockedTermParams, body AddBlockedTermJSONRequestBody, reqEditors ...RequestEditorFn) (r *AddBlockedTermResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddBlockedTermWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddBlockedTerm(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddBlockedTermResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetModeratedChannelsWithResponse request returning *GetModeratedChannelsResponse
func (c *ClientWithResponses) GetModeratedChannelsWithResponse(ctx context.Context, params *GetModeratedChannelsParams, reqEditors ...RequestEditorFn) (r *GetModeratedChannelsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetModeratedChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetModeratedChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetModeratedChannelsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteChatMessagesWithResponse request returning *DeleteChatMessagesResponse
func (c *ClientWithResponses) DeleteChatMessagesWithResponse(ctx context.Context, params *DeleteChatMessagesParams, reqEditors ...RequestEditorFn) (r *DeleteChatMessagesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteChatMessagesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteChatMessages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteChatMessagesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CheckAutomodStatusWithBodyWithResponse request with arbitrary body returning *CheckAutomodStatusResponse
func (c *ClientWithResponses) CheckAutomodStatusWithBodyWithResponse(ctx context.Context, params *CheckAutomodStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CheckAutomodStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CheckAutomodStatusWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CheckAutomodStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCheckAutomodStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CheckAutomodStatusWithResponse(ctx context.Context, params *CheckAutomodStatusParams, body CheckAutomodStatusJSONRequestBody, reqEditors ...RequestEditorFn) (r *CheckAutomodStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CheckAutomodStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CheckAutomodStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCheckAutomodStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// RemoveChannelModeratorWithResponse request returning *RemoveChannelModeratorResponse
func (c *ClientWithResponses) RemoveChannelModeratorWithResponse(ctx context.Context, params *RemoveChannelModeratorParams, reqEditors ...RequestEditorFn) (r *RemoveChannelModeratorResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "RemoveChannelModeratorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.RemoveChannelModerator(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseRemoveChannelModeratorResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetModeratorsWithResponse request returning *GetModeratorsResponse
func (c *ClientWithResponses) GetModeratorsWithResponse(ctx context.Context, params *GetModeratorsParams, reqEditors ...RequestEditorFn) (r *GetModeratorsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetModeratorsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetModerators(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetModeratorsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// AddChannelModeratorWithResponse request returning *AddChannelModeratorResponse
func (c *ClientWithResponses) AddChannelModeratorWithResponse(ctx context.Context, params *AddChannelModeratorParams, reqEditors ...RequestEditorFn) (r *AddChannelModeratorResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "AddChannelModeratorWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.AddChannelModerator(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseAddChannelModeratorResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetShieldModeStatusWithResponse request returning *GetShieldModeStatusResponse
func (c *ClientWithResponses) GetShieldModeStatusWithResponse(ctx context.Context, params *GetShieldModeStatusParams, reqEditors ...RequestEditorFn) (r *GetShieldModeStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetShieldModeStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetShieldModeStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetShieldModeStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateShieldModeStatusWithBodyWithResponse request with arbitrary body returning *UpdateShieldModeStatusResponse
func (c *ClientWithResponses) UpdateShieldModeStatusWithBodyWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateShieldModeStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateShieldModeStatusWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateShieldModeStatusWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateShieldModeStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateShieldModeStatusWithResponse(ctx context.Context, params *UpdateShieldModeStatusParams, body UpdateShieldModeStatusJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateShieldModeStatusResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateShieldModeStatusWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateShieldModeStatus(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateShieldModeStatusResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUnbanRequestsWithResponse request returning *GetUnbanRequestsResponse
func (c *ClientWithResponses) GetUnbanRequestsWithResponse(ctx context.Context, params *GetUnbanRequestsParams, reqEditors ...RequestEditorFn) (r *GetUnbanRequestsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUnbanRequestsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUnbanRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUnbanRequestsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ResolveUnbanRequestsWithResponse request returning *ResolveUnbanRequestsResponse
func (c *ClientWithResponses) ResolveUnbanRequestsWithResponse(ctx context.Context, params *ResolveUnbanRequestsParams, reqEditors ...RequestEditorFn) (r *ResolveUnbanRequestsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "ResolveUnbanRequestsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.ResolveUnbanRequests(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseResolveUnbanRequestsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// WarnChatUserWithBodyWithResponse request with arbitrary body returning *WarnChatUserResponse
func (c *ClientWithResponses) WarnChatUserWithBodyWithResponse(ctx context.Context, params *WarnChatUserParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *WarnChatUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "WarnChatUserWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.WarnChatUserWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseWarnChatUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) WarnChatUserWithResponse(ctx context.Context, params *WarnChatUserParams, body WarnChatUserJSONRequestBody, reqEditors ...RequestEditorFn) (r *WarnChatUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "WarnChatUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.WarnChatUser(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseWarnChatUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetPollsWithResponse request returning *GetPollsResponse
func (c *ClientWithResponses) GetPollsWithResponse(ctx context.Context, params *GetPollsParams, reqEditors ...RequestEditorFn) (r *GetPollsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetPollsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetPolls(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetPollsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// EndPollWithBodyWithResponse request with arbitrary body returning *EndPollResponse
func (c *ClientWithResponses) EndPollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *EndPollResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPollWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPollResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) EndPollWithResponse(ctx context.Context, body EndPollJSONRequestBody, reqEditors ...RequestEditorFn) (r *EndPollResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPollWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPollResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreatePollWithBodyWithResponse request with arbitrary body returning *CreatePollResponse
func (c *ClientWithResponses) CreatePollWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreatePollResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePollWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePollWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePollResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreatePollWithResponse(ctx context.Context, body CreatePollJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreatePollResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePollWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePoll(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePollResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetPredictionsWithResponse request returning *GetPredictionsResponse
func (c *ClientWithResponses) GetPredictionsWithResponse(ctx context.Context, params *GetPredictionsParams, reqEditors ...RequestEditorFn) (r *GetPredictionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetPredictionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetPredictions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetPredictionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// EndPredictionWithBodyWithResponse request with arbitrary body returning *EndPredictionResponse
func (c *ClientWithResponses) EndPredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *EndPredictionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPredictionWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPredictionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPredictionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) EndPredictionWithResponse(ctx context.Context, body EndPredictionJSONRequestBody, reqEditors ...RequestEditorFn) (r *EndPredictionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "EndPredictionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.EndPrediction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseEndPredictionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreatePredictionWithBodyWithResponse request with arbitrary body returning *CreatePredictionResponse
func (c *ClientWithResponses) CreatePredictionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreatePredictionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePredictionWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePredictionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePredictionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreatePredictionWithResponse(ctx context.Context, body CreatePredictionJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreatePredictionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreatePredictionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreatePrediction(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreatePredictionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CancelARaidWithResponse request returning *CancelARaidResponse
func (c *ClientWithResponses) CancelARaidWithResponse(ctx context.Context, params *CancelARaidParams, reqEditors ...RequestEditorFn) (r *CancelARaidResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CancelARaidWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CancelARaid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCancelARaidResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// StartARaidWithResponse request returning *StartARaidResponse
func (c *ClientWithResponses) StartARaidWithResponse(ctx context.Context, params *StartARaidParams, reqEditors ...RequestEditorFn) (r *StartARaidResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "StartARaidWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.StartARaid(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseStartARaidResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelStreamScheduleWithResponse request returning *GetChannelStreamScheduleResponse
func (c *ClientWithResponses) GetChannelStreamScheduleWithResponse(ctx context.Context, params *GetChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (r *GetChannelStreamScheduleResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelStreamScheduleWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelStreamSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelStreamScheduleResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelIcalendarWithResponse request returning *GetChannelIcalendarResponse
func (c *ClientWithResponses) GetChannelIcalendarWithResponse(ctx context.Context, params *GetChannelIcalendarParams, reqEditors ...RequestEditorFn) (r *GetChannelIcalendarResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelIcalendarWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelIcalendar(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelIcalendarResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteChannelStreamScheduleSegmentWithResponse request returning *DeleteChannelStreamScheduleSegmentResponse
func (c *ClientWithResponses) DeleteChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *DeleteChannelStreamScheduleSegmentParams, reqEditors ...RequestEditorFn) (r *DeleteChannelStreamScheduleSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteChannelStreamScheduleSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteChannelStreamScheduleSegment(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteChannelStreamScheduleSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChannelStreamScheduleSegmentWithBodyWithResponse request with arbitrary body returning *UpdateChannelStreamScheduleSegmentResponse
func (c *ClientWithResponses) UpdateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateChannelStreamScheduleSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelStreamScheduleSegmentWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelStreamScheduleSegmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelStreamScheduleSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleSegmentParams, body UpdateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateChannelStreamScheduleSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelStreamScheduleSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelStreamScheduleSegment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelStreamScheduleSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateChannelStreamScheduleSegmentWithBodyWithResponse request with arbitrary body returning *CreateChannelStreamScheduleSegmentResponse
func (c *ClientWithResponses) CreateChannelStreamScheduleSegmentWithBodyWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateChannelStreamScheduleSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateChannelStreamScheduleSegmentWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateChannelStreamScheduleSegmentWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateChannelStreamScheduleSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreateChannelStreamScheduleSegmentWithResponse(ctx context.Context, params *CreateChannelStreamScheduleSegmentParams, body CreateChannelStreamScheduleSegmentJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateChannelStreamScheduleSegmentResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateChannelStreamScheduleSegmentWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateChannelStreamScheduleSegment(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateChannelStreamScheduleSegmentResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateChannelStreamScheduleWithResponse request returning *UpdateChannelStreamScheduleResponse
func (c *ClientWithResponses) UpdateChannelStreamScheduleWithResponse(ctx context.Context, params *UpdateChannelStreamScheduleParams, reqEditors ...RequestEditorFn) (r *UpdateChannelStreamScheduleResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateChannelStreamScheduleWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateChannelStreamSchedule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateChannelStreamScheduleResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SearchCategoriesWithResponse request returning *SearchCategoriesResponse
func (c *ClientWithResponses) SearchCategoriesWithResponse(ctx context.Context, params *SearchCategoriesParams, reqEditors ...RequestEditorFn) (r *SearchCategoriesResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SearchCategoriesWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SearchCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSearchCategoriesResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SearchChannelsWithResponse request returning *SearchChannelsResponse
func (c *ClientWithResponses) SearchChannelsWithResponse(ctx context.Context, params *SearchChannelsParams, reqEditors ...RequestEditorFn) (r *SearchChannelsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SearchChannelsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SearchChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSearchChannelsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetSharedChatSessionWithResponse request returning *GetSharedChatSessionResponse
func (c *ClientWithResponses) GetSharedChatSessionWithResponse(ctx context.Context, params *GetSharedChatSessionParams, reqEditors ...RequestEditorFn) (r *GetSharedChatSessionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetSharedChatSessionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetSharedChatSession(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetSharedChatSessionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamsWithResponse request returning *GetStreamsResponse
func (c *ClientWithResponses) GetStreamsWithResponse(ctx context.Context, params *GetStreamsParams, reqEditors ...RequestEditorFn) (r *GetStreamsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetFollowedStreamsWithResponse request returning *GetFollowedStreamsResponse
func (c *ClientWithResponses) GetFollowedStreamsWithResponse(ctx context.Context, params *GetFollowedStreamsParams, reqEditors ...RequestEditorFn) (r *GetFollowedStreamsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetFollowedStreamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetFollowedStreams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetFollowedStreamsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamKeyWithResponse request returning *GetStreamKeyResponse
func (c *ClientWithResponses) GetStreamKeyWithResponse(ctx context.Context, params *GetStreamKeyParams, reqEditors ...RequestEditorFn) (r *GetStreamKeyResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamKeyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreamKey(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamKeyResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamMarkersWithResponse request returning *GetStreamMarkersResponse
func (c *ClientWithResponses) GetStreamMarkersWithResponse(ctx context.Context, params *GetStreamMarkersParams, reqEditors ...RequestEditorFn) (r *GetStreamMarkersResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamMarkersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreamMarkers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamMarkersResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CreateStreamMarkerWithBodyWithResponse request with arbitrary body returning *CreateStreamMarkerResponse
func (c *ClientWithResponses) CreateStreamMarkerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *CreateStreamMarkerResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateStreamMarkerWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateStreamMarkerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateStreamMarkerResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) CreateStreamMarkerWithResponse(ctx context.Context, body CreateStreamMarkerJSONRequestBody, reqEditors ...RequestEditorFn) (r *CreateStreamMarkerResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CreateStreamMarkerWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CreateStreamMarker(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCreateStreamMarkerResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetStreamTagsWithResponse request returning *GetStreamTagsResponse
func (c *ClientWithResponses) GetStreamTagsWithResponse(ctx context.Context, params *GetStreamTagsParams, reqEditors ...RequestEditorFn) (r *GetStreamTagsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetStreamTagsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetStreamTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetStreamTagsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetBroadcasterSubscriptionsWithResponse request returning *GetBroadcasterSubscriptionsResponse
func (c *ClientWithResponses) GetBroadcasterSubscriptionsWithResponse(ctx context.Context, params *GetBroadcasterSubscriptionsParams, reqEditors ...RequestEditorFn) (r *GetBroadcasterSubscriptionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetBroadcasterSubscriptionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetBroadcasterSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetBroadcasterSubscriptionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// CheckUserSubscriptionWithResponse request returning *CheckUserSubscriptionResponse
func (c *ClientWithResponses) CheckUserSubscriptionWithResponse(ctx context.Context, params *CheckUserSubscriptionParams, reqEditors ...RequestEditorFn) (r *CheckUserSubscriptionResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "CheckUserSubscriptionWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.CheckUserSubscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseCheckUserSubscriptionResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetAllStreamTagsWithResponse request returning *GetAllStreamTagsResponse
func (c *ClientWithResponses) GetAllStreamTagsWithResponse(ctx context.Context, params *GetAllStreamTagsParams, reqEditors ...RequestEditorFn) (r *GetAllStreamTagsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetAllStreamTagsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetAllStreamTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetAllStreamTagsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors ...RequestEditorFn) (r *GetTeamsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetTeamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetTeamsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetChannelTeamsWithResponse request returning *GetChannelTeamsResponse
func (c *ClientWithResponses) GetChannelTeamsWithResponse(ctx context.Context, params *GetChannelTeamsParams, reqEditors ...RequestEditorFn) (r *GetChannelTeamsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetChannelTeamsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetChannelTeams(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetChannelTeamsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (r *GetUsersResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUsersWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUsersResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateUserWithResponse request returning *UpdateUserResponse
func (c *ClientWithResponses) UpdateUserWithResponse(ctx context.Context, params *UpdateUserParams, reqEditors ...RequestEditorFn) (r *UpdateUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UnblockUserWithResponse request returning *UnblockUserResponse
func (c *ClientWithResponses) UnblockUserWithResponse(ctx context.Context, params *UnblockUserParams, reqEditors ...RequestEditorFn) (r *UnblockUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UnblockUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UnblockUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUnblockUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserBlockListWithResponse request returning *GetUserBlockListResponse
func (c *ClientWithResponses) GetUserBlockListWithResponse(ctx context.Context, params *GetUserBlockListParams, reqEditors ...RequestEditorFn) (r *GetUserBlockListResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserBlockListWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserBlockList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserBlockListResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// BlockUserWithResponse request returning *BlockUserResponse
func (c *ClientWithResponses) BlockUserWithResponse(ctx context.Context, params *BlockUserParams, reqEditors ...RequestEditorFn) (r *BlockUserResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "BlockUserWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.BlockUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseBlockUserResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserActiveExtensionsWithResponse request returning *GetUserActiveExtensionsResponse
func (c *ClientWithResponses) GetUserActiveExtensionsWithResponse(ctx context.Context, params *GetUserActiveExtensionsParams, reqEditors ...RequestEditorFn) (r *GetUserActiveExtensionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserActiveExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserActiveExtensions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserActiveExtensionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// UpdateUserExtensionsWithBodyWithResponse request with arbitrary body returning *UpdateUserExtensionsResponse
func (c *ClientWithResponses) UpdateUserExtensionsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *UpdateUserExtensionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserExtensionsWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUserExtensionsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserExtensionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) UpdateUserExtensionsWithResponse(ctx context.Context, body UpdateUserExtensionsJSONRequestBody, reqEditors ...RequestEditorFn) (r *UpdateUserExtensionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "UpdateUserExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.UpdateUserExtensions(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseUpdateUserExtensionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetUserExtensionsWithResponse request returning *GetUserExtensionsResponse
func (c *ClientWithResponses) GetUserExtensionsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (r *GetUserExtensionsResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetUserExtensionsWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetUserExtensions(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetUserExtensionsResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// DeleteVideosWithResponse request returning *DeleteVideosResponse
func (c *ClientWithResponses) DeleteVideosWithResponse(ctx context.Context, params *DeleteVideosParams, reqEditors ...RequestEditorFn) (r *DeleteVideosResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "DeleteVideosWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.DeleteVideos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseDeleteVideosResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// GetVideosWithResponse request returning *GetVideosResponse
func (c *ClientWithResponses) GetVideosWithResponse(ctx context.Context, params *GetVideosParams, reqEditors ...RequestEditorFn) (r *GetVideosResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "GetVideosWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.GetVideos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseGetVideosResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// SendWhisperWithBodyWithResponse request with arbitrary body returning *SendWhisperResponse
func (c *ClientWithResponses) SendWhisperWithBodyWithResponse(ctx context.Context, params *SendWhisperParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (r *SendWhisperResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendWhisperWithBodyWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendWhisperWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendWhisperResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

func (c *ClientWithResponses) SendWhisperWithResponse(ctx context.Context, params *SendWhisperParams, body SendWhisperJSONRequestBody, reqEditors ...RequestEditorFn) (r *SendWhisperResponse, err error) {
	if c.Tracer != nil {
		var span trace.Span
		ctx, span = c.Tracer.Start(ctx, "SendWhisperWithResponse")
		defer func(span trace.Span) {
			if err != nil {
				if _, ok := err.(StatusFailureError); !ok {
					span.SetStatus(codes.Error, err.Error())
					span.RecordError(err)
				}
			}
			span.End()
		}(span)
	}

	rsp, err := c.SendWhisper(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	r, err = ParseSendWhisperResponse(rsp)
	if !c.OkOnNon200 && (r != nil && r.StatusCode() >= 400) {
		return r, StatusFailureError{Resp: rsp, Err: err}
	}
	return r, err
}

// ParseGetExtensionAnalyticsResponse parses an HTTP response from a GetExtensionAnalyticsWithResponse call
func ParseGetExtensionAnalyticsResponse(rsp *http.Response) (*GetExtensionAnalyticsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionAnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGameAnalyticsResponse parses an HTTP response from a GetGameAnalyticsWithResponse call
func ParseGetGameAnalyticsResponse(rsp *http.Response) (*GetGameAnalyticsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGameAnalyticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGameAnalyticsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCheermotesResponse parses an HTTP response from a GetCheermotesWithResponse call
func ParseGetCheermotesResponse(rsp *http.Response) (*GetCheermotesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCheermotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCheermotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExtensionBitsProductsResponse parses an HTTP response from a GetExtensionBitsProductsWithResponse call
func ParseGetExtensionBitsProductsResponse(rsp *http.Response) (*GetExtensionBitsProductsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionBitsProductsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionBitsProductsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateExtensionBitsProductResponse parses an HTTP response from a UpdateExtensionBitsProductWithResponse call
func ParseUpdateExtensionBitsProductResponse(rsp *http.Response) (*UpdateExtensionBitsProductResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateExtensionBitsProductResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateExtensionBitsProductResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBitsLeaderboardResponse parses an HTTP response from a GetBitsLeaderboardWithResponse call
func ParseGetBitsLeaderboardResponse(rsp *http.Response) (*GetBitsLeaderboardResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBitsLeaderboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBitsLeaderboardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteCustomRewardResponse parses an HTTP response from a DeleteCustomRewardWithResponse call
func ParseDeleteCustomRewardResponse(rsp *http.Response) (*DeleteCustomRewardResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteCustomRewardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomRewardResponse parses an HTTP response from a GetCustomRewardWithResponse call
func ParseGetCustomRewardResponse(rsp *http.Response) (*GetCustomRewardResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCustomRewardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCustomRewardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomRewardResponse parses an HTTP response from a UpdateCustomRewardWithResponse call
func ParseUpdateCustomRewardResponse(rsp *http.Response) (*UpdateCustomRewardResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateCustomRewardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateCustomRewardResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomRewardsResponse parses an HTTP response from a CreateCustomRewardsWithResponse call
func ParseCreateCustomRewardsResponse(rsp *http.Response) (*CreateCustomRewardsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateCustomRewardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateCustomRewardsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCustomRewardRedemptionResponse parses an HTTP response from a GetCustomRewardRedemptionWithResponse call
func ParseGetCustomRewardRedemptionResponse(rsp *http.Response) (*GetCustomRewardRedemptionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCustomRewardRedemptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCustomRewardRedemptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRedemptionStatusResponse parses an HTTP response from a UpdateRedemptionStatusWithResponse call
func ParseUpdateRedemptionStatusResponse(rsp *http.Response) (*UpdateRedemptionStatusResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateRedemptionStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateRedemptionStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelInformationResponse parses an HTTP response from a GetChannelInformationWithResponse call
func ParseGetChannelInformationResponse(rsp *http.Response) (*GetChannelInformationResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelInformationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseModifyChannelInformationResponse parses an HTTP response from a ModifyChannelInformationWithResponse call
func ParseModifyChannelInformationResponse(rsp *http.Response) (*ModifyChannelInformationResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &ModifyChannelInformationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAdScheduleResponse parses an HTTP response from a GetAdScheduleWithResponse call
func ParseGetAdScheduleResponse(rsp *http.Response) (*GetAdScheduleResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetAdScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAdScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSnoozeNextAdResponse parses an HTTP response from a SnoozeNextAdWithResponse call
func ParseSnoozeNextAdResponse(rsp *http.Response) (*SnoozeNextAdResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SnoozeNextAdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SnoozeNextAdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStartCommercialResponse parses an HTTP response from a StartCommercialWithResponse call
func ParseStartCommercialResponse(rsp *http.Response) (*StartCommercialResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &StartCommercialResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartCommercialResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelEditorsResponse parses an HTTP response from a GetChannelEditorsWithResponse call
func ParseGetChannelEditorsResponse(rsp *http.Response) (*GetChannelEditorsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelEditorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelEditorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFollowedChannelsResponse parses an HTTP response from a GetFollowedChannelsWithResponse call
func ParseGetFollowedChannelsResponse(rsp *http.Response) (*GetFollowedChannelsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetFollowedChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFollowedChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelFollowersResponse parses an HTTP response from a GetChannelFollowersWithResponse call
func ParseGetChannelFollowersResponse(rsp *http.Response) (*GetChannelFollowersResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelFollowersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveChannelVipResponse parses an HTTP response from a RemoveChannelVipWithResponse call
func ParseRemoveChannelVipResponse(rsp *http.Response) (*RemoveChannelVipResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &RemoveChannelVipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetVipsResponse parses an HTTP response from a GetVipsWithResponse call
func ParseGetVipsResponse(rsp *http.Response) (*GetVipsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetVipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetVIPsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddChannelVipResponse parses an HTTP response from a AddChannelVipWithResponse call
func ParseAddChannelVipResponse(rsp *http.Response) (*AddChannelVipResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AddChannelVipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCharityCampaignResponse parses an HTTP response from a GetCharityCampaignWithResponse call
func ParseGetCharityCampaignResponse(rsp *http.Response) (*GetCharityCampaignResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCharityCampaignResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCharityCampaignResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharityCampaignDonationsResponse parses an HTTP response from a GetCharityCampaignDonationsWithResponse call
func ParseGetCharityCampaignDonationsResponse(rsp *http.Response) (*GetCharityCampaignDonationsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCharityCampaignDonationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCharityCampaignDonationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendChatAnnouncementResponse parses an HTTP response from a SendChatAnnouncementWithResponse call
func ParseSendChatAnnouncementResponse(rsp *http.Response) (*SendChatAnnouncementResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendChatAnnouncementResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetChannelChatBadgesResponse parses an HTTP response from a GetChannelChatBadgesWithResponse call
func ParseGetChannelChatBadgesResponse(rsp *http.Response) (*GetChannelChatBadgesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelChatBadgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelChatBadgesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalChatBadgesResponse parses an HTTP response from a GetGlobalChatBadgesWithResponse call
func ParseGetGlobalChatBadgesResponse(rsp *http.Response) (*GetGlobalChatBadgesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGlobalChatBadgesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGlobalChatBadgesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChattersResponse parses an HTTP response from a GetChattersWithResponse call
func ParseGetChattersResponse(rsp *http.Response) (*GetChattersResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChattersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChattersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserChatColorResponse parses an HTTP response from a GetUserChatColorWithResponse call
func ParseGetUserChatColorResponse(rsp *http.Response) (*GetUserChatColorResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserChatColorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserChatColorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserChatColorResponse parses an HTTP response from a UpdateUserChatColorWithResponse call
func ParseUpdateUserChatColorResponse(rsp *http.Response) (*UpdateUserChatColorResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateUserChatColorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetChannelEmotesResponse parses an HTTP response from a GetChannelEmotesWithResponse call
func ParseGetChannelEmotesResponse(rsp *http.Response) (*GetChannelEmotesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelEmotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelEmotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGlobalEmotesResponse parses an HTTP response from a GetGlobalEmotesWithResponse call
func ParseGetGlobalEmotesResponse(rsp *http.Response) (*GetGlobalEmotesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGlobalEmotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGlobalEmotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEmoteSetsResponse parses an HTTP response from a GetEmoteSetsWithResponse call
func ParseGetEmoteSetsResponse(rsp *http.Response) (*GetEmoteSetsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetEmoteSetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEmoteSetsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserEmotesResponse parses an HTTP response from a GetUserEmotesWithResponse call
func ParseGetUserEmotesResponse(rsp *http.Response) (*GetUserEmotesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserEmotesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserEmotesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendChatMessageResponse parses an HTTP response from a SendChatMessageWithResponse call
func ParseSendChatMessageResponse(rsp *http.Response) (*SendChatMessageResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendChatMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SendChatMessageResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChatSettingsResponse parses an HTTP response from a GetChatSettingsWithResponse call
func ParseGetChatSettingsResponse(rsp *http.Response) (*GetChatSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChatSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChatSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateChatSettingsResponse parses an HTTP response from a UpdateChatSettingsWithResponse call
func ParseUpdateChatSettingsResponse(rsp *http.Response) (*UpdateChatSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChatSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateChatSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendAShoutoutResponse parses an HTTP response from a SendAShoutoutWithResponse call
func ParseSendAShoutoutResponse(rsp *http.Response) (*SendAShoutoutResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendAShoutoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetClipsResponse parses an HTTP response from a GetClipsWithResponse call
func ParseGetClipsResponse(rsp *http.Response) (*GetClipsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetClipsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetClipsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateClipResponse parses an HTTP response from a CreateClipWithResponse call
func ParseCreateClipResponse(rsp *http.Response) (*CreateClipResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateClipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateClipResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseGetContentClassificationLabelsResponse parses an HTTP response from a GetContentClassificationLabelsWithResponse call
func ParseGetContentClassificationLabelsResponse(rsp *http.Response) (*GetContentClassificationLabelsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetContentClassificationLabelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetContentClassificationLabelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDropsEntitlementsResponse parses an HTTP response from a GetDropsEntitlementsWithResponse call
func ParseGetDropsEntitlementsResponse(rsp *http.Response) (*GetDropsEntitlementsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetDropsEntitlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDropsEntitlementsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDropsEntitlementsResponse parses an HTTP response from a UpdateDropsEntitlementsWithResponse call
func ParseUpdateDropsEntitlementsResponse(rsp *http.Response) (*UpdateDropsEntitlementsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateDropsEntitlementsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateDropsEntitlementsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteConduitResponse parses an HTTP response from a DeleteConduitWithResponse call
func ParseDeleteConduitResponse(rsp *http.Response) (*DeleteConduitResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteConduitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetConduitsResponse parses an HTTP response from a GetConduitsWithResponse call
func ParseGetConduitsResponse(rsp *http.Response) (*GetConduitsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetConduitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConduitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConduitsResponse parses an HTTP response from a UpdateConduitsWithResponse call
func ParseUpdateConduitsResponse(rsp *http.Response) (*UpdateConduitsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateConduitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateConduitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateConduitsResponse parses an HTTP response from a CreateConduitsWithResponse call
func ParseCreateConduitsResponse(rsp *http.Response) (*CreateConduitsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateConduitsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateConduitsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetConduitShardsResponse parses an HTTP response from a GetConduitShardsWithResponse call
func ParseGetConduitShardsResponse(rsp *http.Response) (*GetConduitShardsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetConduitShardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetConduitShardsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConduitShardsResponse parses an HTTP response from a UpdateConduitShardsWithResponse call
func ParseUpdateConduitShardsResponse(rsp *http.Response) (*UpdateConduitShardsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateConduitShardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest UpdateConduitShardsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseDeleteEventsubSubscriptionResponse parses an HTTP response from a DeleteEventsubSubscriptionWithResponse call
func ParseDeleteEventsubSubscriptionResponse(rsp *http.Response) (*DeleteEventsubSubscriptionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteEventsubSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetEventsubSubscriptionsResponse parses an HTTP response from a GetEventsubSubscriptionsWithResponse call
func ParseGetEventsubSubscriptionsResponse(rsp *http.Response) (*GetEventsubSubscriptionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetEventsubSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetEventSubSubscriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateEventsubSubscriptionResponse parses an HTTP response from a CreateEventsubSubscriptionWithResponse call
func ParseCreateEventsubSubscriptionResponse(rsp *http.Response) (*CreateEventsubSubscriptionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateEventsubSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 202:
		var dest CreateEventSubSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON202 = &dest

	}

	return response, nil
}

// ParseGetExtensionsResponse parses an HTTP response from a GetExtensionsWithResponse call
func ParseGetExtensionsResponse(rsp *http.Response) (*GetExtensionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendExtensionChatMessageResponse parses an HTTP response from a SendExtensionChatMessageWithResponse call
func ParseSendExtensionChatMessageResponse(rsp *http.Response) (*SendExtensionChatMessageResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendExtensionChatMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExtensionConfigurationSegmentResponse parses an HTTP response from a GetExtensionConfigurationSegmentWithResponse call
func ParseGetExtensionConfigurationSegmentResponse(rsp *http.Response) (*GetExtensionConfigurationSegmentResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionConfigurationSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionConfigurationSegmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetExtensionConfigurationSegmentResponse parses an HTTP response from a SetExtensionConfigurationSegmentWithResponse call
func ParseSetExtensionConfigurationSegmentResponse(rsp *http.Response) (*SetExtensionConfigurationSegmentResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SetExtensionConfigurationSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExtensionSecretsResponse parses an HTTP response from a GetExtensionSecretsWithResponse call
func ParseGetExtensionSecretsResponse(rsp *http.Response) (*GetExtensionSecretsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionSecretsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionSecretsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateExtensionSecretResponse parses an HTTP response from a CreateExtensionSecretWithResponse call
func ParseCreateExtensionSecretResponse(rsp *http.Response) (*CreateExtensionSecretResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateExtensionSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateExtensionSecretResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetExtensionLiveChannelsResponse parses an HTTP response from a GetExtensionLiveChannelsWithResponse call
func ParseGetExtensionLiveChannelsResponse(rsp *http.Response) (*GetExtensionLiveChannelsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionLiveChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionLiveChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendExtensionPubsubMessageResponse parses an HTTP response from a SendExtensionPubsubMessageWithResponse call
func ParseSendExtensionPubsubMessageResponse(rsp *http.Response) (*SendExtensionPubsubMessageResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendExtensionPubsubMessageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetReleasedExtensionsResponse parses an HTTP response from a GetReleasedExtensionsWithResponse call
func ParseGetReleasedExtensionsResponse(rsp *http.Response) (*GetReleasedExtensionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetReleasedExtensionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetReleasedExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetExtensionRequiredConfigurationResponse parses an HTTP response from a SetExtensionRequiredConfigurationWithResponse call
func ParseSetExtensionRequiredConfigurationResponse(rsp *http.Response) (*SetExtensionRequiredConfigurationResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SetExtensionRequiredConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetExtensionTransactionsResponse parses an HTTP response from a GetExtensionTransactionsWithResponse call
func ParseGetExtensionTransactionsResponse(rsp *http.Response) (*GetExtensionTransactionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetExtensionTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetExtensionTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetGamesResponse parses an HTTP response from a GetGamesWithResponse call
func ParseGetGamesResponse(rsp *http.Response) (*GetGamesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGamesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopGamesResponse parses an HTTP response from a GetTopGamesWithResponse call
func ParseGetTopGamesResponse(rsp *http.Response) (*GetTopGamesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetTopGamesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTopGamesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCreatorGoalsResponse parses an HTTP response from a GetCreatorGoalsWithResponse call
func ParseGetCreatorGoalsResponse(rsp *http.Response) (*GetCreatorGoalsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetCreatorGoalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCreatorGoalsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelGuestStarSettingsResponse parses an HTTP response from a GetChannelGuestStarSettingsWithResponse call
func ParseGetChannelGuestStarSettingsResponse(rsp *http.Response) (*GetChannelGuestStarSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelGuestStarSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelGuestStarSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateChannelGuestStarSettingsResponse parses an HTTP response from a UpdateChannelGuestStarSettingsWithResponse call
func ParseUpdateChannelGuestStarSettingsResponse(rsp *http.Response) (*UpdateChannelGuestStarSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChannelGuestStarSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteGuestStarInviteResponse parses an HTTP response from a DeleteGuestStarInviteWithResponse call
func ParseDeleteGuestStarInviteResponse(rsp *http.Response) (*DeleteGuestStarInviteResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteGuestStarInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGuestStarInvitesResponse parses an HTTP response from a GetGuestStarInvitesWithResponse call
func ParseGetGuestStarInvitesResponse(rsp *http.Response) (*GetGuestStarInvitesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGuestStarInvitesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGuestStarInvitesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendGuestStarInviteResponse parses an HTTP response from a SendGuestStarInviteWithResponse call
func ParseSendGuestStarInviteResponse(rsp *http.Response) (*SendGuestStarInviteResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendGuestStarInviteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseEndGuestStarSessionResponse parses an HTTP response from a EndGuestStarSessionWithResponse call
func ParseEndGuestStarSessionResponse(rsp *http.Response) (*EndGuestStarSessionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &EndGuestStarSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetGuestStarSessionResponse parses an HTTP response from a GetGuestStarSessionWithResponse call
func ParseGetGuestStarSessionResponse(rsp *http.Response) (*GetGuestStarSessionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetGuestStarSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetGuestStarSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGuestStarSessionResponse parses an HTTP response from a CreateGuestStarSessionWithResponse call
func ParseCreateGuestStarSessionResponse(rsp *http.Response) (*CreateGuestStarSessionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateGuestStarSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateGuestStarSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteGuestStarSlotResponse parses an HTTP response from a DeleteGuestStarSlotWithResponse call
func ParseDeleteGuestStarSlotResponse(rsp *http.Response) (*DeleteGuestStarSlotResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteGuestStarSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGuestStarSlotResponse parses an HTTP response from a UpdateGuestStarSlotWithResponse call
func ParseUpdateGuestStarSlotResponse(rsp *http.Response) (*UpdateGuestStarSlotResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateGuestStarSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseAssignGuestStarSlotResponse parses an HTTP response from a AssignGuestStarSlotWithResponse call
func ParseAssignGuestStarSlotResponse(rsp *http.Response) (*AssignGuestStarSlotResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AssignGuestStarSlotResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateGuestStarSlotSettingsResponse parses an HTTP response from a UpdateGuestStarSlotSettingsWithResponse call
func ParseUpdateGuestStarSlotSettingsResponse(rsp *http.Response) (*UpdateGuestStarSlotSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateGuestStarSlotSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetHypeTrainEventsResponse parses an HTTP response from a GetHypeTrainEventsWithResponse call
func ParseGetHypeTrainEventsResponse(rsp *http.Response) (*GetHypeTrainEventsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetHypeTrainEventsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetHypeTrainEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseManageHeldAutomodMessagesResponse parses an HTTP response from a ManageHeldAutomodMessagesWithResponse call
func ParseManageHeldAutomodMessagesResponse(rsp *http.Response) (*ManageHeldAutomodMessagesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &ManageHeldAutomodMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAutomodSettingsResponse parses an HTTP response from a GetAutomodSettingsWithResponse call
func ParseGetAutomodSettingsResponse(rsp *http.Response) (*GetAutomodSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetAutomodSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAutoModSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAutomodSettingsResponse parses an HTTP response from a UpdateAutomodSettingsWithResponse call
func ParseUpdateAutomodSettingsResponse(rsp *http.Response) (*UpdateAutomodSettingsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateAutomodSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateAutoModSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBannedUsersResponse parses an HTTP response from a GetBannedUsersWithResponse call
func ParseGetBannedUsersResponse(rsp *http.Response) (*GetBannedUsersResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBannedUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBannedUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnbanUserResponse parses an HTTP response from a UnbanUserWithResponse call
func ParseUnbanUserResponse(rsp *http.Response) (*UnbanUserResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UnbanUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseBanUserResponse parses an HTTP response from a BanUserWithResponse call
func ParseBanUserResponse(rsp *http.Response) (*BanUserResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &BanUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BanUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveBlockedTermResponse parses an HTTP response from a RemoveBlockedTermWithResponse call
func ParseRemoveBlockedTermResponse(rsp *http.Response) (*RemoveBlockedTermResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &RemoveBlockedTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBlockedTermsResponse parses an HTTP response from a GetBlockedTermsWithResponse call
func ParseGetBlockedTermsResponse(rsp *http.Response) (*GetBlockedTermsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBlockedTermsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBlockedTermsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddBlockedTermResponse parses an HTTP response from a AddBlockedTermWithResponse call
func ParseAddBlockedTermResponse(rsp *http.Response) (*AddBlockedTermResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AddBlockedTermResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddBlockedTermResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetModeratedChannelsResponse parses an HTTP response from a GetModeratedChannelsWithResponse call
func ParseGetModeratedChannelsResponse(rsp *http.Response) (*GetModeratedChannelsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetModeratedChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModeratedChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteChatMessagesResponse parses an HTTP response from a DeleteChatMessagesWithResponse call
func ParseDeleteChatMessagesResponse(rsp *http.Response) (*DeleteChatMessagesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteChatMessagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCheckAutomodStatusResponse parses an HTTP response from a CheckAutomodStatusWithResponse call
func ParseCheckAutomodStatusResponse(rsp *http.Response) (*CheckAutomodStatusResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CheckAutomodStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckAutoModStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRemoveChannelModeratorResponse parses an HTTP response from a RemoveChannelModeratorWithResponse call
func ParseRemoveChannelModeratorResponse(rsp *http.Response) (*RemoveChannelModeratorResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &RemoveChannelModeratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetModeratorsResponse parses an HTTP response from a GetModeratorsWithResponse call
func ParseGetModeratorsResponse(rsp *http.Response) (*GetModeratorsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetModeratorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetModeratorsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddChannelModeratorResponse parses an HTTP response from a AddChannelModeratorWithResponse call
func ParseAddChannelModeratorResponse(rsp *http.Response) (*AddChannelModeratorResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &AddChannelModeratorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetShieldModeStatusResponse parses an HTTP response from a GetShieldModeStatusWithResponse call
func ParseGetShieldModeStatusResponse(rsp *http.Response) (*GetShieldModeStatusResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetShieldModeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetShieldModeStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateShieldModeStatusResponse parses an HTTP response from a UpdateShieldModeStatusWithResponse call
func ParseUpdateShieldModeStatusResponse(rsp *http.Response) (*UpdateShieldModeStatusResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateShieldModeStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateShieldModeStatusResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUnbanRequestsResponse parses an HTTP response from a GetUnbanRequestsWithResponse call
func ParseGetUnbanRequestsResponse(rsp *http.Response) (*GetUnbanRequestsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUnbanRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUnbanRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResolveUnbanRequestsResponse parses an HTTP response from a ResolveUnbanRequestsWithResponse call
func ParseResolveUnbanRequestsResponse(rsp *http.Response) (*ResolveUnbanRequestsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &ResolveUnbanRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResolveUnbanRequestsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseWarnChatUserResponse parses an HTTP response from a WarnChatUserWithResponse call
func ParseWarnChatUserResponse(rsp *http.Response) (*WarnChatUserResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &WarnChatUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WarnChatUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPollsResponse parses an HTTP response from a GetPollsWithResponse call
func ParseGetPollsResponse(rsp *http.Response) (*GetPollsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetPollsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPollsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndPollResponse parses an HTTP response from a EndPollWithResponse call
func ParseEndPollResponse(rsp *http.Response) (*EndPollResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &EndPollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndPollResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePollResponse parses an HTTP response from a CreatePollWithResponse call
func ParseCreatePollResponse(rsp *http.Response) (*CreatePollResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreatePollResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePollResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPredictionsResponse parses an HTTP response from a GetPredictionsWithResponse call
func ParseGetPredictionsResponse(rsp *http.Response) (*GetPredictionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetPredictionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPredictionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndPredictionResponse parses an HTTP response from a EndPredictionWithResponse call
func ParseEndPredictionResponse(rsp *http.Response) (*EndPredictionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &EndPredictionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EndPredictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePredictionResponse parses an HTTP response from a CreatePredictionWithResponse call
func ParseCreatePredictionResponse(rsp *http.Response) (*CreatePredictionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreatePredictionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreatePredictionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCancelARaidResponse parses an HTTP response from a CancelARaidWithResponse call
func ParseCancelARaidResponse(rsp *http.Response) (*CancelARaidResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CancelARaidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseStartARaidResponse parses an HTTP response from a StartARaidWithResponse call
func ParseStartARaidResponse(rsp *http.Response) (*StartARaidResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &StartARaidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StartRaidResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelStreamScheduleResponse parses an HTTP response from a GetChannelStreamScheduleWithResponse call
func ParseGetChannelStreamScheduleResponse(rsp *http.Response) (*GetChannelStreamScheduleResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelStreamScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelStreamScheduleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelIcalendarResponse parses an HTTP response from a GetChannelIcalendarWithResponse call
func ParseGetChannelIcalendarResponse(rsp *http.Response) (*GetChannelIcalendarResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelIcalendarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteChannelStreamScheduleSegmentResponse parses an HTTP response from a DeleteChannelStreamScheduleSegmentWithResponse call
func ParseDeleteChannelStreamScheduleSegmentResponse(rsp *http.Response) (*DeleteChannelStreamScheduleSegmentResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteChannelStreamScheduleSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateChannelStreamScheduleSegmentResponse parses an HTTP response from a UpdateChannelStreamScheduleSegmentWithResponse call
func ParseUpdateChannelStreamScheduleSegmentResponse(rsp *http.Response) (*UpdateChannelStreamScheduleSegmentResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChannelStreamScheduleSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateChannelStreamScheduleSegmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateChannelStreamScheduleSegmentResponse parses an HTTP response from a CreateChannelStreamScheduleSegmentWithResponse call
func ParseCreateChannelStreamScheduleSegmentResponse(rsp *http.Response) (*CreateChannelStreamScheduleSegmentResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateChannelStreamScheduleSegmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateChannelStreamScheduleSegmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateChannelStreamScheduleResponse parses an HTTP response from a UpdateChannelStreamScheduleWithResponse call
func ParseUpdateChannelStreamScheduleResponse(rsp *http.Response) (*UpdateChannelStreamScheduleResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateChannelStreamScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchCategoriesResponse parses an HTTP response from a SearchCategoriesWithResponse call
func ParseSearchCategoriesResponse(rsp *http.Response) (*SearchCategoriesResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SearchCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchCategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSearchChannelsResponse parses an HTTP response from a SearchChannelsWithResponse call
func ParseSearchChannelsResponse(rsp *http.Response) (*SearchChannelsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SearchChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSharedChatSessionResponse parses an HTTP response from a GetSharedChatSessionWithResponse call
func ParseGetSharedChatSessionResponse(rsp *http.Response) (*GetSharedChatSessionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetSharedChatSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetSharedChatSessionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamsResponse parses an HTTP response from a GetStreamsWithResponse call
func ParseGetStreamsResponse(rsp *http.Response) (*GetStreamsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFollowedStreamsResponse parses an HTTP response from a GetFollowedStreamsWithResponse call
func ParseGetFollowedStreamsResponse(rsp *http.Response) (*GetFollowedStreamsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetFollowedStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetFollowedStreamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamKeyResponse parses an HTTP response from a GetStreamKeyWithResponse call
func ParseGetStreamKeyResponse(rsp *http.Response) (*GetStreamKeyResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamKeyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamMarkersResponse parses an HTTP response from a GetStreamMarkersWithResponse call
func ParseGetStreamMarkersResponse(rsp *http.Response) (*GetStreamMarkersResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamMarkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamMarkersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateStreamMarkerResponse parses an HTTP response from a CreateStreamMarkerWithResponse call
func ParseCreateStreamMarkerResponse(rsp *http.Response) (*CreateStreamMarkerResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CreateStreamMarkerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateStreamMarkerResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStreamTagsResponse parses an HTTP response from a GetStreamTagsWithResponse call
func ParseGetStreamTagsResponse(rsp *http.Response) (*GetStreamTagsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetStreamTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetStreamTagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetBroadcasterSubscriptionsResponse parses an HTTP response from a GetBroadcasterSubscriptionsWithResponse call
func ParseGetBroadcasterSubscriptionsResponse(rsp *http.Response) (*GetBroadcasterSubscriptionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetBroadcasterSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBroadcasterSubscriptionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCheckUserSubscriptionResponse parses an HTTP response from a CheckUserSubscriptionWithResponse call
func ParseCheckUserSubscriptionResponse(rsp *http.Response) (*CheckUserSubscriptionResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &CheckUserSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckUserSubscriptionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllStreamTagsResponse parses an HTTP response from a GetAllStreamTagsWithResponse call
func ParseGetAllStreamTagsResponse(rsp *http.Response) (*GetAllStreamTagsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetAllStreamTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAllStreamTagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTeamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetChannelTeamsResponse parses an HTTP response from a GetChannelTeamsWithResponse call
func ParseGetChannelTeamsResponse(rsp *http.Response) (*GetChannelTeamsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetChannelTeamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetChannelTeamsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUsersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserResponse parses an HTTP response from a UpdateUserWithResponse call
func ParseUpdateUserResponse(rsp *http.Response) (*UpdateUserResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnblockUserResponse parses an HTTP response from a UnblockUserWithResponse call
func ParseUnblockUserResponse(rsp *http.Response) (*UnblockUserResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UnblockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserBlockListResponse parses an HTTP response from a GetUserBlockListWithResponse call
func ParseGetUserBlockListResponse(rsp *http.Response) (*GetUserBlockListResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserBlockListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserBlockListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBlockUserResponse parses an HTTP response from a BlockUserWithResponse call
func ParseBlockUserResponse(rsp *http.Response) (*BlockUserResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &BlockUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUserActiveExtensionsResponse parses an HTTP response from a GetUserActiveExtensionsWithResponse call
func ParseGetUserActiveExtensionsResponse(rsp *http.Response) (*GetUserActiveExtensionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserActiveExtensionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserActiveExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateUserExtensionsResponse parses an HTTP response from a UpdateUserExtensionsWithResponse call
func ParseUpdateUserExtensionsResponse(rsp *http.Response) (*UpdateUserExtensionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &UpdateUserExtensionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UpdateUserExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserExtensionsResponse parses an HTTP response from a GetUserExtensionsWithResponse call
func ParseGetUserExtensionsResponse(rsp *http.Response) (*GetUserExtensionsResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetUserExtensionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUserExtensionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteVideosResponse parses an HTTP response from a DeleteVideosWithResponse call
func ParseDeleteVideosResponse(rsp *http.Response) (*DeleteVideosResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &DeleteVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DeleteVideosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetVideosResponse parses an HTTP response from a GetVideosWithResponse call
func ParseGetVideosResponse(rsp *http.Response) (*GetVideosResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &GetVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetVideosResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSendWhisperResponse parses an HTTP response from a SendWhisperWithResponse call
func ParseSendWhisperResponse(rsp *http.Response) (*SendWhisperResponse, error) {
	bodyBytes, er := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if er != nil {
		return nil, er
	}

	response := &SendWhisperResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Generated with echo/echo-interface.tmpl
// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Gets an analytics report for one or more extensions.
	// (GET /analytics/extensions)
	GetExtensionAnalytics(ctx echo.Context, params GetExtensionAnalyticsParams) error
	// Gets an analytics report for one or more games.
	// (GET /analytics/games)
	GetGameAnalytics(ctx echo.Context, params GetGameAnalyticsParams) error
	// Gets a list of Cheermotes that users can use to cheer Bits.
	// (GET /bits/cheermotes)
	GetCheermotes(ctx echo.Context, params GetCheermotesParams) error
	// Gets the list of Bits products that belongs to the extension.
	// (GET /bits/extensions)
	GetExtensionBitsProducts(ctx echo.Context, params GetExtensionBitsProductsParams) error
	// Adds or updates a Bits product that the extension created.
	// (PUT /bits/extensions)
	UpdateExtensionBitsProduct(ctx echo.Context) error
	// Gets the Bits leaderboard for the authenticated broadcaster.
	// (GET /bits/leaderboard)
	GetBitsLeaderboard(ctx echo.Context, params GetBitsLeaderboardParams) error
	// Deletes a custom reward that the broadcaster created.
	// (DELETE /channel_points/custom_rewards)
	DeleteCustomReward(ctx echo.Context, params DeleteCustomRewardParams) error
	// Gets a list of custom rewards that the specified broadcaster created.
	// (GET /channel_points/custom_rewards)
	GetCustomReward(ctx echo.Context, params GetCustomRewardParams) error
	// Updates a custom reward.
	// (PATCH /channel_points/custom_rewards)
	UpdateCustomReward(ctx echo.Context, params UpdateCustomRewardParams) error
	// Creates a Custom Reward in the broadcasters channel.
	// (POST /channel_points/custom_rewards)
	CreateCustomRewards(ctx echo.Context, params CreateCustomRewardsParams) error
	// Gets a list of redemptions for a custom reward.
	// (GET /channel_points/custom_rewards/redemptions)
	GetCustomRewardRedemption(ctx echo.Context, params GetCustomRewardRedemptionParams) error
	// Updates a redemptions status.
	// (PATCH /channel_points/custom_rewards/redemptions)
	UpdateRedemptionStatus(ctx echo.Context, params UpdateRedemptionStatusParams) error
	// Gets information about one or more channels.
	// (GET /channels)
	GetChannelInformation(ctx echo.Context, params GetChannelInformationParams) error
	// Updates a channels properties.
	// (PATCH /channels)
	ModifyChannelInformation(ctx echo.Context, params ModifyChannelInformationParams) error
	// Returns ad schedule related information.
	// (GET /channels/ads)
	GetAdSchedule(ctx echo.Context, params GetAdScheduleParams) error
	// Pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes.
	// (POST /channels/ads/schedule/snooze)
	SnoozeNextAd(ctx echo.Context, params SnoozeNextAdParams) error
	// Starts a commercial on the specified channel.
	// (POST /channels/commercial)
	StartCommercial(ctx echo.Context) error
	// Gets the broadcasters list editors.
	// (GET /channels/editors)
	GetChannelEditors(ctx echo.Context, params GetChannelEditorsParams) error
	// Gets a list of broadcasters that the specified user follows. You can also use this endpoint to see whether a user follows a specific broadcaster.
	// (GET /channels/followed)
	GetFollowedChannels(ctx echo.Context, params GetFollowedChannelsParams) error
	// Gets a list of users that follow the specified broadcaster. You can also use this endpoint to see whether a specific user follows the broadcaster.
	// (GET /channels/followers)
	GetChannelFollowers(ctx echo.Context, params GetChannelFollowersParams) error
	// Removes the specified user as a VIP in the broadcasters channel.
	// (DELETE /channels/vips)
	RemoveChannelVip(ctx echo.Context, params RemoveChannelVipParams) error
	// Gets a list of the broadcasters VIPs.
	// (GET /channels/vips)
	GetVips(ctx echo.Context, params GetVipsParams) error
	// Adds the specified user as a VIP in the broadcasters channel.
	// (POST /channels/vips)
	AddChannelVip(ctx echo.Context, params AddChannelVipParams) error
	// Gets information about the broadcasters active charity campaign.
	// (GET /charity/campaigns)
	GetCharityCampaign(ctx echo.Context, params GetCharityCampaignParams) error
	// Gets the list of donations that users have made to the broadcasters active charity campaign.
	// (GET /charity/donations)
	GetCharityCampaignDonations(ctx echo.Context, params GetCharityCampaignDonationsParams) error
	// Sends an announcement to the broadcasters chat room.
	// (POST /chat/announcements)
	SendChatAnnouncement(ctx echo.Context, params SendChatAnnouncementParams) error
	// Gets the broadcasters list of custom chat badges.
	// (GET /chat/badges)
	GetChannelChatBadges(ctx echo.Context, params GetChannelChatBadgesParams) error
	// Gets Twitchs list of chat badges.
	// (GET /chat/badges/global)
	GetGlobalChatBadges(ctx echo.Context) error
	// Gets the list of users that are connected to the broadcasters chat session.
	// (GET /chat/chatters)
	GetChatters(ctx echo.Context, params GetChattersParams) error
	// Gets the color used for the users name in chat.
	// (GET /chat/color)
	GetUserChatColor(ctx echo.Context, params GetUserChatColorParams) error
	// Updates the color used for the users name in chat.
	// (PUT /chat/color)
	UpdateUserChatColor(ctx echo.Context, params UpdateUserChatColorParams) error
	// Gets the broadcasters list of custom emotes.
	// (GET /chat/emotes)
	GetChannelEmotes(ctx echo.Context, params GetChannelEmotesParams) error
	// Gets all global emotes.
	// (GET /chat/emotes/global)
	GetGlobalEmotes(ctx echo.Context) error
	// Gets emotes for one or more specified emote sets.
	// (GET /chat/emotes/set)
	GetEmoteSets(ctx echo.Context, params GetEmoteSetsParams) error
	// NEW Retrieves emotes available to the user across all channels.
	// (GET /chat/emotes/user)
	GetUserEmotes(ctx echo.Context, params GetUserEmotesParams) error
	// NEW Sends a message to the broadcasters chat room.
	// (POST /chat/messages)
	SendChatMessage(ctx echo.Context) error
	// Gets the broadcasters chat settings.
	// (GET /chat/settings)
	GetChatSettings(ctx echo.Context, params GetChatSettingsParams) error
	// Updates the broadcasters chat settings.
	// (PATCH /chat/settings)
	UpdateChatSettings(ctx echo.Context, params UpdateChatSettingsParams) error
	// Sends a Shoutout to the specified broadcaster.
	// (POST /chat/shoutouts)
	SendAShoutout(ctx echo.Context, params SendAShoutoutParams) error
	// Gets one or more video clips.
	// (GET /clips)
	GetClips(ctx echo.Context, params GetClipsParams) error
	// Creates a clip from the broadcasters stream.
	// (POST /clips)
	CreateClip(ctx echo.Context, params CreateClipParams) error
	// Gets information about Twitch content classification labels.
	// (GET /content_classification_labels)
	GetContentClassificationLabels(ctx echo.Context, params GetContentClassificationLabelsParams) error
	// Gets an organizations list of entitlements that have been granted to a game, a user, or both.
	// (GET /entitlements/drops)
	GetDropsEntitlements(ctx echo.Context, params GetDropsEntitlementsParams) error
	// Updates the Drop entitlements fulfillment status.
	// (PATCH /entitlements/drops)
	UpdateDropsEntitlements(ctx echo.Context) error
	// NEW Deletes a specified conduit.
	// (DELETE /eventsub/conduits)
	DeleteConduit(ctx echo.Context, params DeleteConduitParams) error
	// NEW  Gets the conduits for a client ID.
	// (GET /eventsub/conduits)
	GetConduits(ctx echo.Context) error
	// NEW Updates a conduits shard count.
	// (PATCH /eventsub/conduits)
	UpdateConduits(ctx echo.Context) error
	// NEW Creates a new conduit.
	// (POST /eventsub/conduits)
	CreateConduits(ctx echo.Context) error
	// NEW Gets a lists of all shards for a conduit.
	// (GET /eventsub/conduits/shards)
	GetConduitShards(ctx echo.Context, params GetConduitShardsParams) error
	// NEW Updates shard(s) for a conduit.
	// (PATCH /eventsub/conduits/shards)
	UpdateConduitShards(ctx echo.Context) error
	// Deletes an EventSub subscription.
	// (DELETE /eventsub/subscriptions)
	DeleteEventsubSubscription(ctx echo.Context, params DeleteEventsubSubscriptionParams) error
	// Gets a list of EventSub subscriptions that the client in the access token created.
	// (GET /eventsub/subscriptions)
	GetEventsubSubscriptions(ctx echo.Context, params GetEventsubSubscriptionsParams) error
	// Creates an EventSub subscription.
	// (POST /eventsub/subscriptions)
	CreateEventsubSubscription(ctx echo.Context) error
	// Gets information about an extension.
	// (GET /extensions)
	GetExtensions(ctx echo.Context, params GetExtensionsParams) error
	// Sends a message to the specified broadcasters chat room.
	// (POST /extensions/chat)
	SendExtensionChatMessage(ctx echo.Context, params SendExtensionChatMessageParams) error
	// Gets the specified configuration segment from the specified extension.
	// (GET /extensions/configurations)
	GetExtensionConfigurationSegment(ctx echo.Context, params GetExtensionConfigurationSegmentParams) error
	// Updates a configuration segment.
	// (PUT /extensions/configurations)
	SetExtensionConfigurationSegment(ctx echo.Context) error
	// Gets an extensions list of shared secrets.
	// (GET /extensions/jwt/secrets)
	GetExtensionSecrets(ctx echo.Context) error
	// Creates a shared secret used to sign and verify JWT tokens.
	// (POST /extensions/jwt/secrets)
	CreateExtensionSecret(ctx echo.Context, params CreateExtensionSecretParams) error
	// Gets a list of broadcasters that are streaming live and have installed or activated the extension.
	// (GET /extensions/live)
	GetExtensionLiveChannels(ctx echo.Context, params GetExtensionLiveChannelsParams) error
	// Sends a message to one or more viewers.
	// (POST /extensions/pubsub)
	SendExtensionPubsubMessage(ctx echo.Context) error
	// Gets information about a released extension.
	// (GET /extensions/released)
	GetReleasedExtensions(ctx echo.Context, params GetReleasedExtensionsParams) error
	// Updates the extensions required_configuration string.
	// (PUT /extensions/required_configuration)
	SetExtensionRequiredConfiguration(ctx echo.Context, params SetExtensionRequiredConfigurationParams) error
	// Gets an extensions list of transactions.
	// (GET /extensions/transactions)
	GetExtensionTransactions(ctx echo.Context, params GetExtensionTransactionsParams) error
	// Gets information about specified games.
	// (GET /games)
	GetGames(ctx echo.Context, params GetGamesParams) error
	// Gets information about all broadcasts on Twitch.
	// (GET /games/top)
	GetTopGames(ctx echo.Context, params GetTopGamesParams) error
	// Gets the broadcasters list of active goals.
	// (GET /goals)
	GetCreatorGoals(ctx echo.Context, params GetCreatorGoalsParams) error
	// BETA Gets the channel settings for configuration of the Guest Star feature for a particular host.
	// (GET /guest_star/channel_settings)
	GetChannelGuestStarSettings(ctx echo.Context, params GetChannelGuestStarSettingsParams) error
	// BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.
	// (PUT /guest_star/channel_settings)
	UpdateChannelGuestStarSettings(ctx echo.Context, params UpdateChannelGuestStarSettingsParams) error
	// BETA Revokes a previously sent invite for a Guest Star session.
	// (DELETE /guest_star/invites)
	DeleteGuestStarInvite(ctx echo.Context, params DeleteGuestStarInviteParams) error
	// BETA Provides the caller with a list of pending invites to a Guest Star session.
	// (GET /guest_star/invites)
	GetGuestStarInvites(ctx echo.Context, params GetGuestStarInvitesParams) error
	// BETA Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress.
	// (POST /guest_star/invites)
	SendGuestStarInvite(ctx echo.Context, params SendGuestStarInviteParams) error
	// BETA Programmatically ends a Guest Star session on behalf of the broadcaster.
	// (DELETE /guest_star/session)
	EndGuestStarSession(ctx echo.Context, params EndGuestStarSessionParams) error
	// BETA Gets information about an ongoing Guest Star session for a particular channel.
	// (GET /guest_star/session)
	GetGuestStarSession(ctx echo.Context, params GetGuestStarSessionParams) error
	// BETA Programmatically creates a Guest Star session on behalf of the broadcaster.
	// (POST /guest_star/session)
	CreateGuestStarSession(ctx echo.Context, params CreateGuestStarSessionParams) error
	// BETA Allows a caller to remove a slot assignment from a user participating in an active Guest Star session.
	// (DELETE /guest_star/slot)
	DeleteGuestStarSlot(ctx echo.Context, params DeleteGuestStarSlotParams) error
	// BETA Allows a user to update the assigned slot for a particular user within the active Guest Star session.
	// (PATCH /guest_star/slot)
	UpdateGuestStarSlot(ctx echo.Context, params UpdateGuestStarSlotParams) error
	// BETA Allows a previously invited user to be assigned a slot within the active Guest Star session.
	// (POST /guest_star/slot)
	AssignGuestStarSlot(ctx echo.Context, params AssignGuestStarSlotParams) error
	// BETA Allows a user to update slot settings for a particular guest within a Guest Star session.
	// (PATCH /guest_star/slot_settings)
	UpdateGuestStarSlotSettings(ctx echo.Context, params UpdateGuestStarSlotSettingsParams) error
	// Gets information about the broadcasters current or most recent Hype Train event.
	// (GET /hypetrain/events)
	GetHypeTrainEvents(ctx echo.Context, params GetHypeTrainEventsParams) error
	// Allow or deny the message that AutoMod flagged for review.
	// (POST /moderation/automod/message)
	ManageHeldAutomodMessages(ctx echo.Context) error
	// Gets the broadcasters AutoMod settings.
	// (GET /moderation/automod/settings)
	GetAutomodSettings(ctx echo.Context, params GetAutomodSettingsParams) error
	// Updates the broadcasters AutoMod settings.
	// (PUT /moderation/automod/settings)
	UpdateAutomodSettings(ctx echo.Context, params UpdateAutomodSettingsParams) error
	// Gets all users that the broadcaster banned or put in a timeout.
	// (GET /moderation/banned)
	GetBannedUsers(ctx echo.Context, params GetBannedUsersParams) error
	// Removes the ban or timeout that was placed on the specified user.
	// (DELETE /moderation/bans)
	UnbanUser(ctx echo.Context, params UnbanUserParams) error
	// Bans a user from participating in a broadcasters chat room or puts them in a timeout.
	// (POST /moderation/bans)
	BanUser(ctx echo.Context, params BanUserParams) error
	// Removes the word or phrase from the broadcasters list of blocked terms.
	// (DELETE /moderation/blocked_terms)
	RemoveBlockedTerm(ctx echo.Context, params RemoveBlockedTermParams) error
	// Gets the broadcasters list of non-private, blocked words or phrases.
	// (GET /moderation/blocked_terms)
	GetBlockedTerms(ctx echo.Context, params GetBlockedTermsParams) error
	// Adds a word or phrase to the broadcasters list of blocked terms.
	// (POST /moderation/blocked_terms)
	AddBlockedTerm(ctx echo.Context, params AddBlockedTermParams) error
	// Gets a list of channels that the specified user has moderator privileges in.
	// (GET /moderation/channels)
	GetModeratedChannels(ctx echo.Context, params GetModeratedChannelsParams) error
	// Removes a single chat message or all chat messages from the broadcasters chat room.
	// (DELETE /moderation/chat)
	DeleteChatMessages(ctx echo.Context, params DeleteChatMessagesParams) error
	// Checks whether AutoMod would flag the specified message for review.
	// (POST /moderation/enforcements/status)
	CheckAutomodStatus(ctx echo.Context, params CheckAutomodStatusParams) error
	// Removes a moderator from the broadcasters chat room.
	// (DELETE /moderation/moderators)
	RemoveChannelModerator(ctx echo.Context, params RemoveChannelModeratorParams) error
	// Gets all users allowed to moderate the broadcasters chat room.
	// (GET /moderation/moderators)
	GetModerators(ctx echo.Context, params GetModeratorsParams) error
	// Adds a moderator to the broadcasters chat room.
	// (POST /moderation/moderators)
	AddChannelModerator(ctx echo.Context, params AddChannelModeratorParams) error
	// Gets the broadcasters Shield Mode activation status.
	// (GET /moderation/shield_mode)
	GetShieldModeStatus(ctx echo.Context, params GetShieldModeStatusParams) error
	// Activates or deactivates the broadcasters Shield Mode.
	// (PUT /moderation/shield_mode)
	UpdateShieldModeStatus(ctx echo.Context, params UpdateShieldModeStatusParams) error
	// NEW Gets a list of unban requests for a broadcasters channel.
	// (GET /moderation/unban_requests)
	GetUnbanRequests(ctx echo.Context, params GetUnbanRequestsParams) error
	// NEW Resolves an unban request by approving or denying it.
	// (PATCH /moderation/unban_requests)
	ResolveUnbanRequests(ctx echo.Context, params ResolveUnbanRequestsParams) error
	// NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged.
	// (POST /moderation/warnings)
	WarnChatUser(ctx echo.Context, params WarnChatUserParams) error
	// Gets a list of polls that the broadcaster created.
	// (GET /polls)
	GetPolls(ctx echo.Context, params GetPollsParams) error
	// End an active poll.
	// (PATCH /polls)
	EndPoll(ctx echo.Context) error
	// Creates a poll that viewers in the broadcasters channel can vote on.
	// (POST /polls)
	CreatePoll(ctx echo.Context) error
	// Gets a list of Channel Points Predictions that the broadcaster created.
	// (GET /predictions)
	GetPredictions(ctx echo.Context, params GetPredictionsParams) error
	// Locks, resolves, or cancels a Channel Points Prediction.
	// (PATCH /predictions)
	EndPrediction(ctx echo.Context) error
	// Create a Channel Points Prediction.
	// (POST /predictions)
	CreatePrediction(ctx echo.Context) error
	// Cancel a pending raid.
	// (DELETE /raids)
	CancelARaid(ctx echo.Context, params CancelARaidParams) error
	// Raid another channel by sending the broadcasters viewers to the targeted channel.
	// (POST /raids)
	StartARaid(ctx echo.Context, params StartARaidParams) error
	// Gets the broadcasters streaming schedule.
	// (GET /schedule)
	GetChannelStreamSchedule(ctx echo.Context, params GetChannelStreamScheduleParams) error
	// Gets the broadcasters streaming schedule as an iCalendar.
	// (GET /schedule/icalendar)
	GetChannelIcalendar(ctx echo.Context, params GetChannelIcalendarParams) error
	// Deletes a broadcast from the broadcasters streaming schedule.
	// (DELETE /schedule/segment)
	DeleteChannelStreamScheduleSegment(ctx echo.Context, params DeleteChannelStreamScheduleSegmentParams) error
	// Updates a scheduled broadcast segment.
	// (PATCH /schedule/segment)
	UpdateChannelStreamScheduleSegment(ctx echo.Context, params UpdateChannelStreamScheduleSegmentParams) error
	// Adds a single or recurring broadcast to the broadcasters streaming schedule.
	// (POST /schedule/segment)
	CreateChannelStreamScheduleSegment(ctx echo.Context, params CreateChannelStreamScheduleSegmentParams) error
	// Updates the broadcasters schedule settings, such as scheduling a vacation.
	// (PATCH /schedule/settings)
	UpdateChannelStreamSchedule(ctx echo.Context, params UpdateChannelStreamScheduleParams) error
	// Gets the games or categories that match the specified query.
	// (GET /search/categories)
	SearchCategories(ctx echo.Context, params SearchCategoriesParams) error
	// Gets the channels that match the specified query and have streamed content within the past 6 months.
	// (GET /search/channels)
	SearchChannels(ctx echo.Context, params SearchChannelsParams) error
	// NEW Retrieves the active shared chat session for a channel.
	// (GET /shared_chat/session)
	GetSharedChatSession(ctx echo.Context, params GetSharedChatSessionParams) error
	// Gets a list of all streams.
	// (GET /streams)
	GetStreams(ctx echo.Context, params GetStreamsParams) error
	// Gets the list of broadcasters that the user follows and that are streaming live.
	// (GET /streams/followed)
	GetFollowedStreams(ctx echo.Context, params GetFollowedStreamsParams) error
	// Gets the channels stream key.
	// (GET /streams/key)
	GetStreamKey(ctx echo.Context, params GetStreamKeyParams) error
	// Gets a list of markers from the users most recent stream or from the specified VOD/video.
	// (GET /streams/markers)
	GetStreamMarkers(ctx echo.Context, params GetStreamMarkersParams) error
	// Adds a marker to a live stream.
	// (POST /streams/markers)
	CreateStreamMarker(ctx echo.Context) error
	// Gets the list of stream tags that the broadcaster or Twitch added to their channel.
	// (GET /streams/tags)
	GetStreamTags(ctx echo.Context, params GetStreamTagsParams) error
	// Gets a list of users that subscribe to the specified broadcaster.
	// (GET /subscriptions)
	GetBroadcasterSubscriptions(ctx echo.Context, params GetBroadcasterSubscriptionsParams) error
	// Checks whether the user subscribes to the broadcasters channel.
	// (GET /subscriptions/user)
	CheckUserSubscription(ctx echo.Context, params CheckUserSubscriptionParams) error
	// Gets the list of all stream tags that Twitch defines. You can also filter the list by one or more tag IDs.
	// (GET /tags/streams)
	GetAllStreamTags(ctx echo.Context, params GetAllStreamTagsParams) error
	// Gets information about the specified Twitch team.
	// (GET /teams)
	GetTeams(ctx echo.Context, params GetTeamsParams) error
	// Gets the list of Twitch teams that the broadcaster is a member of.
	// (GET /teams/channel)
	GetChannelTeams(ctx echo.Context, params GetChannelTeamsParams) error
	// Gets information about one or more users.
	// (GET /users)
	GetUsers(ctx echo.Context, params GetUsersParams) error
	// Updates the users information.
	// (PUT /users)
	UpdateUser(ctx echo.Context, params UpdateUserParams) error
	// Removes the user from the broadcasters list of blocked users.
	// (DELETE /users/blocks)
	UnblockUser(ctx echo.Context, params UnblockUserParams) error
	// Gets the list of users that the broadcaster has blocked.
	// (GET /users/blocks)
	GetUserBlockList(ctx echo.Context, params GetUserBlockListParams) error
	// Blocks the specified user from interacting with or having contact with the broadcaster.
	// (PUT /users/blocks)
	BlockUser(ctx echo.Context, params BlockUserParams) error
	// Gets the active extensions that the broadcaster has installed for each configuration.
	// (GET /users/extensions)
	GetUserActiveExtensions(ctx echo.Context, params GetUserActiveExtensionsParams) error
	// Updates an installed extensions information.
	// (PUT /users/extensions)
	UpdateUserExtensions(ctx echo.Context) error
	// Gets a list of all extensions (both active and inactive) that the broadcaster has installed.
	// (GET /users/extensions/list)
	GetUserExtensions(ctx echo.Context) error
	// Deletes one or more videos.
	// (DELETE /videos)
	DeleteVideos(ctx echo.Context, params DeleteVideosParams) error
	// Gets information about one or more published videos.
	// (GET /videos)
	GetVideos(ctx echo.Context, params GetVideosParams) error
	// Sends a whisper message to the specified user.
	// (POST /whispers)
	SendWhisper(ctx echo.Context, params SendWhisperParams) error
}

//Generated with echo/echo-wrappers.tmpl

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetExtensionAnalytics converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensionAnalytics(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensionAnalytics"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"analytics:read:extensions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionAnalyticsParams
	// ------------- Optional query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		log.Err("Invalid format for parameter type", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "started_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "started_at", ctx.QueryParams(), &params.StartedAt)
	if err != nil {
		log.Err("Invalid format for parameter started_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter started_at: %s", err))
	}

	// ------------- Optional query parameter "ended_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "ended_at", ctx.QueryParams(), &params.EndedAt)
	if err != nil {
		log.Err("Invalid format for parameter ended_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ended_at: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensionAnalytics(ctx, params)
	return err
}

// GetGameAnalytics converts echo context to params.
func (w *ServerInterfaceWrapper) GetGameAnalytics(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetGameAnalytics"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"analytics:read:games"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGameAnalyticsParams
	// ------------- Optional query parameter "game_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "game_id", ctx.QueryParams(), &params.GameId)
	if err != nil {
		log.Err("Invalid format for parameter game_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_id: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		log.Err("Invalid format for parameter type", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "started_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "started_at", ctx.QueryParams(), &params.StartedAt)
	if err != nil {
		log.Err("Invalid format for parameter started_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter started_at: %s", err))
	}

	// ------------- Optional query parameter "ended_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "ended_at", ctx.QueryParams(), &params.EndedAt)
	if err != nil {
		log.Err("Invalid format for parameter ended_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ended_at: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGameAnalytics(ctx, params)
	return err
}

// GetCheermotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetCheermotes(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetCheermotes"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCheermotesParams
	// ------------- Optional query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCheermotes(ctx, params)
	return err
}

// GetExtensionBitsProducts converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensionBitsProducts(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensionBitsProducts"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionBitsProductsParams
	// ------------- Optional query parameter "should_include_all" -------------

	err = runtime.BindQueryParameter("form", true, false, "should_include_all", ctx.QueryParams(), &params.ShouldIncludeAll)
	if err != nil {
		log.Err("Invalid format for parameter should_include_all", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter should_include_all: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensionBitsProducts(ctx, params)
	return err
}

// UpdateExtensionBitsProduct converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateExtensionBitsProduct(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateExtensionBitsProduct"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateExtensionBitsProduct(ctx)
	return err
}

// GetBitsLeaderboard converts echo context to params.
func (w *ServerInterfaceWrapper) GetBitsLeaderboard(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetBitsLeaderboard"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"bits:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBitsLeaderboardParams
	// ------------- Optional query parameter "count" -------------

	err = runtime.BindQueryParameter("form", true, false, "count", ctx.QueryParams(), &params.Count)
	if err != nil {
		log.Err("Invalid format for parameter count", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter count: %s", err))
	}

	// ------------- Optional query parameter "period" -------------

	err = runtime.BindQueryParameter("form", true, false, "period", ctx.QueryParams(), &params.Period)
	if err != nil {
		log.Err("Invalid format for parameter period", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter period: %s", err))
	}

	// ------------- Optional query parameter "started_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "started_at", ctx.QueryParams(), &params.StartedAt)
	if err != nil {
		log.Err("Invalid format for parameter started_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter started_at: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBitsLeaderboard(ctx, params)
	return err
}

// DeleteCustomReward converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteCustomReward(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteCustomReward"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:redemptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteCustomRewardParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteCustomReward(ctx, params)
	return err
}

// GetCustomReward converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomReward(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetCustomReward"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:redemptions", "channel:manage:redemptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomRewardParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "only_manageable_rewards" -------------

	err = runtime.BindQueryParameter("form", true, false, "only_manageable_rewards", ctx.QueryParams(), &params.OnlyManageableRewards)
	if err != nil {
		log.Err("Invalid format for parameter only_manageable_rewards", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter only_manageable_rewards: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomReward(ctx, params)
	return err
}

// UpdateCustomReward converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateCustomReward(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateCustomReward"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:redemptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateCustomRewardParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateCustomReward(ctx, params)
	return err
}

// CreateCustomRewards converts echo context to params.
func (w *ServerInterfaceWrapper) CreateCustomRewards(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateCustomRewards"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:redemptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateCustomRewardsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateCustomRewards(ctx, params)
	return err
}

// GetCustomRewardRedemption converts echo context to params.
func (w *ServerInterfaceWrapper) GetCustomRewardRedemption(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetCustomRewardRedemption"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:redemptions", "channel:manage:redemptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCustomRewardRedemptionParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "reward_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "reward_id", ctx.QueryParams(), &params.RewardId)
	if err != nil {
		log.Err("Invalid format for parameter reward_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reward_id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		log.Err("Invalid format for parameter status", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		log.Err("Invalid format for parameter sort", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCustomRewardRedemption(ctx, params)
	return err
}

// UpdateRedemptionStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateRedemptionStatus(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateRedemptionStatus"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:redemptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateRedemptionStatusParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "reward_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "reward_id", ctx.QueryParams(), &params.RewardId)
	if err != nil {
		log.Err("Invalid format for parameter reward_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reward_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateRedemptionStatus(ctx, params)
	return err
}

// GetChannelInformation converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelInformation(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelInformation"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelInformationParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelInformation(ctx, params)
	return err
}

// ModifyChannelInformation converts echo context to params.
func (w *ServerInterfaceWrapper) ModifyChannelInformation(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "ModifyChannelInformation"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:broadcast"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ModifyChannelInformationParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ModifyChannelInformation(ctx, params)
	return err
}

// GetAdSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) GetAdSchedule(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetAdSchedule"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:ads"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAdScheduleParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAdSchedule(ctx, params)
	return err
}

// SnoozeNextAd converts echo context to params.
func (w *ServerInterfaceWrapper) SnoozeNextAd(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SnoozeNextAd"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:ads"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SnoozeNextAdParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SnoozeNextAd(ctx, params)
	return err
}

// StartCommercial converts echo context to params.
func (w *ServerInterfaceWrapper) StartCommercial(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "StartCommercial"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:edit:commercial"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartCommercial(ctx)
	return err
}

// GetChannelEditors converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelEditors(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelEditors"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:editors"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelEditorsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelEditors(ctx, params)
	return err
}

// GetFollowedChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetFollowedChannels(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetFollowedChannels"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:follows"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFollowedChannelsParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFollowedChannels(ctx, params)
	return err
}

// GetChannelFollowers converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelFollowers(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelFollowers"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:read:followers"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelFollowersParams
	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelFollowers(ctx, params)
	return err
}

// RemoveChannelVip converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveChannelVip(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "RemoveChannelVip"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:vips"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RemoveChannelVipParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveChannelVip(ctx, params)
	return err
}

// GetVips converts echo context to params.
func (w *ServerInterfaceWrapper) GetVips(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetVips"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:vips", "channel:manage:vips"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVipsParams
	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVips(ctx, params)
	return err
}

// AddChannelVip converts echo context to params.
func (w *ServerInterfaceWrapper) AddChannelVip(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "AddChannelVip"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:vips"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddChannelVipParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddChannelVip(ctx, params)
	return err
}

// GetCharityCampaign converts echo context to params.
func (w *ServerInterfaceWrapper) GetCharityCampaign(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetCharityCampaign"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:charity"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCharityCampaignParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCharityCampaign(ctx, params)
	return err
}

// GetCharityCampaignDonations converts echo context to params.
func (w *ServerInterfaceWrapper) GetCharityCampaignDonations(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetCharityCampaignDonations"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:charity"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCharityCampaignDonationsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCharityCampaignDonations(ctx, params)
	return err
}

// SendChatAnnouncement converts echo context to params.
func (w *ServerInterfaceWrapper) SendChatAnnouncement(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendChatAnnouncement"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:announcements"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendChatAnnouncementParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendChatAnnouncement(ctx, params)
	return err
}

// GetChannelChatBadges converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelChatBadges(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelChatBadges"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelChatBadgesParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelChatBadges(ctx, params)
	return err
}

// GetGlobalChatBadges converts echo context to params.
func (w *ServerInterfaceWrapper) GetGlobalChatBadges(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetGlobalChatBadges"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGlobalChatBadges(ctx)
	return err
}

// GetChatters converts echo context to params.
func (w *ServerInterfaceWrapper) GetChatters(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChatters"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:read:chatters"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChattersParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChatters(ctx, params)
	return err
}

// GetUserChatColor converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserChatColor(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUserChatColor"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserChatColorParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserChatColor(ctx, params)
	return err
}

// UpdateUserChatColor converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUserChatColor(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateUserChatColor"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:manage:chat_color"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateUserChatColorParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Required query parameter "color" -------------

	err = runtime.BindQueryParameter("form", true, true, "color", ctx.QueryParams(), &params.Color)
	if err != nil {
		log.Err("Invalid format for parameter color", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter color: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUserChatColor(ctx, params)
	return err
}

// GetChannelEmotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelEmotes(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelEmotes"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelEmotesParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelEmotes(ctx, params)
	return err
}

// GetGlobalEmotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetGlobalEmotes(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetGlobalEmotes"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGlobalEmotes(ctx)
	return err
}

// GetEmoteSets converts echo context to params.
func (w *ServerInterfaceWrapper) GetEmoteSets(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetEmoteSets"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEmoteSetsParams
	// ------------- Required query parameter "emote_set_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "emote_set_id", ctx.QueryParams(), &params.EmoteSetId)
	if err != nil {
		log.Err("Invalid format for parameter emote_set_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter emote_set_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEmoteSets(ctx, params)
	return err
}

// GetUserEmotes converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserEmotes(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUserEmotes"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:emotes"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserEmotesParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserEmotes(ctx, params)
	return err
}

// SendChatMessage converts echo context to params.
func (w *ServerInterfaceWrapper) SendChatMessage(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendChatMessage"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:write:chat", "user:bot", "channel:bot"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendChatMessage(ctx)
	return err
}

// GetChatSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetChatSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChatSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChatSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChatSettings(ctx, params)
	return err
}

// UpdateChatSettings converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateChatSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateChatSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:chat_settings"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateChatSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateChatSettings(ctx, params)
	return err
}

// SendAShoutout converts echo context to params.
func (w *ServerInterfaceWrapper) SendAShoutout(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendAShoutout"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:shoutouts"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendAShoutoutParams
	// ------------- Required query parameter "from_broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "from_broadcaster_id", ctx.QueryParams(), &params.FromBroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter from_broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "to_broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "to_broadcaster_id", ctx.QueryParams(), &params.ToBroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter to_broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendAShoutout(ctx, params)
	return err
}

// GetClips converts echo context to params.
func (w *ServerInterfaceWrapper) GetClips(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetClips"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetClipsParams
	// ------------- Optional query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "game_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "game_id", ctx.QueryParams(), &params.GameId)
	if err != nil {
		log.Err("Invalid format for parameter game_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "started_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "started_at", ctx.QueryParams(), &params.StartedAt)
	if err != nil {
		log.Err("Invalid format for parameter started_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter started_at: %s", err))
	}

	// ------------- Optional query parameter "ended_at" -------------

	err = runtime.BindQueryParameter("form", true, false, "ended_at", ctx.QueryParams(), &params.EndedAt)
	if err != nil {
		log.Err("Invalid format for parameter ended_at", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter ended_at: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "is_featured" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_featured", ctx.QueryParams(), &params.IsFeatured)
	if err != nil {
		log.Err("Invalid format for parameter is_featured", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_featured: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetClips(ctx, params)
	return err
}

// CreateClip converts echo context to params.
func (w *ServerInterfaceWrapper) CreateClip(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateClip"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"clips:edit"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateClipParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "has_delay" -------------

	err = runtime.BindQueryParameter("form", true, false, "has_delay", ctx.QueryParams(), &params.HasDelay)
	if err != nil {
		log.Err("Invalid format for parameter has_delay", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter has_delay: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateClip(ctx, params)
	return err
}

// GetContentClassificationLabels converts echo context to params.
func (w *ServerInterfaceWrapper) GetContentClassificationLabels(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetContentClassificationLabels"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetContentClassificationLabelsParams
	// ------------- Optional query parameter "locale" -------------

	err = runtime.BindQueryParameter("form", true, false, "locale", ctx.QueryParams(), &params.Locale)
	if err != nil {
		log.Err("Invalid format for parameter locale", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter locale: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetContentClassificationLabels(ctx, params)
	return err
}

// GetDropsEntitlements converts echo context to params.
func (w *ServerInterfaceWrapper) GetDropsEntitlements(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetDropsEntitlements"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDropsEntitlementsParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "game_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "game_id", ctx.QueryParams(), &params.GameId)
	if err != nil {
		log.Err("Invalid format for parameter game_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_id: %s", err))
	}

	// ------------- Optional query parameter "fulfillment_status" -------------

	err = runtime.BindQueryParameter("form", true, false, "fulfillment_status", ctx.QueryParams(), &params.FulfillmentStatus)
	if err != nil {
		log.Err("Invalid format for parameter fulfillment_status", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter fulfillment_status: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetDropsEntitlements(ctx, params)
	return err
}

// UpdateDropsEntitlements converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateDropsEntitlements(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateDropsEntitlements"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateDropsEntitlements(ctx)
	return err
}

// DeleteConduit converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteConduit(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteConduit"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteConduitParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteConduit(ctx, params)
	return err
}

// GetConduits converts echo context to params.
func (w *ServerInterfaceWrapper) GetConduits(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetConduits"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConduits(ctx)
	return err
}

// UpdateConduits converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateConduits(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateConduits"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateConduits(ctx)
	return err
}

// CreateConduits converts echo context to params.
func (w *ServerInterfaceWrapper) CreateConduits(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateConduits"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateConduits(ctx)
	return err
}

// GetConduitShards converts echo context to params.
func (w *ServerInterfaceWrapper) GetConduitShards(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetConduitShards"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetConduitShardsParams
	// ------------- Required query parameter "conduit_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "conduit_id", ctx.QueryParams(), &params.ConduitId)
	if err != nil {
		log.Err("Invalid format for parameter conduit_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter conduit_id: %s", err))
	}

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		log.Err("Invalid format for parameter status", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetConduitShards(ctx, params)
	return err
}

// UpdateConduitShards converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateConduitShards(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateConduitShards"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateConduitShards(ctx)
	return err
}

// DeleteEventsubSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteEventsubSubscription(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteEventsubSubscription"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteEventsubSubscriptionParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteEventsubSubscription(ctx, params)
	return err
}

// GetEventsubSubscriptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetEventsubSubscriptions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetEventsubSubscriptions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetEventsubSubscriptionsParams
	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		log.Err("Invalid format for parameter status", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		log.Err("Invalid format for parameter type", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetEventsubSubscriptions(ctx, params)
	return err
}

// CreateEventsubSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) CreateEventsubSubscription(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateEventsubSubscription"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:subscriptions"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateEventsubSubscription(ctx)
	return err
}

// GetExtensions converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionsParams
	// ------------- Required query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Optional query parameter "extension_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "extension_version", ctx.QueryParams(), &params.ExtensionVersion)
	if err != nil {
		log.Err("Invalid format for parameter extension_version", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensions(ctx, params)
	return err
}

// SendExtensionChatMessage converts echo context to params.
func (w *ServerInterfaceWrapper) SendExtensionChatMessage(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendExtensionChatMessage"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendExtensionChatMessageParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendExtensionChatMessage(ctx, params)
	return err
}

// GetExtensionConfigurationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensionConfigurationSegment(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensionConfigurationSegment"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionConfigurationSegmentParams
	// ------------- Optional query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Required query parameter "segment" -------------

	err = runtime.BindQueryParameter("form", true, true, "segment", ctx.QueryParams(), &params.Segment)
	if err != nil {
		log.Err("Invalid format for parameter segment", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter segment: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensionConfigurationSegment(ctx, params)
	return err
}

// SetExtensionConfigurationSegment converts echo context to params.
func (w *ServerInterfaceWrapper) SetExtensionConfigurationSegment(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SetExtensionConfigurationSegment"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetExtensionConfigurationSegment(ctx)
	return err
}

// GetExtensionSecrets converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensionSecrets(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensionSecrets"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensionSecrets(ctx)
	return err
}

// CreateExtensionSecret converts echo context to params.
func (w *ServerInterfaceWrapper) CreateExtensionSecret(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateExtensionSecret"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateExtensionSecretParams
	// ------------- Required query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Optional query parameter "delay" -------------

	err = runtime.BindQueryParameter("form", true, false, "delay", ctx.QueryParams(), &params.Delay)
	if err != nil {
		log.Err("Invalid format for parameter delay", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter delay: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateExtensionSecret(ctx, params)
	return err
}

// GetExtensionLiveChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensionLiveChannels(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensionLiveChannels"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionLiveChannelsParams
	// ------------- Required query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensionLiveChannels(ctx, params)
	return err
}

// SendExtensionPubsubMessage converts echo context to params.
func (w *ServerInterfaceWrapper) SendExtensionPubsubMessage(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendExtensionPubsubMessage"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendExtensionPubsubMessage(ctx)
	return err
}

// GetReleasedExtensions converts echo context to params.
func (w *ServerInterfaceWrapper) GetReleasedExtensions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetReleasedExtensions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetReleasedExtensionsParams
	// ------------- Required query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Optional query parameter "extension_version" -------------

	err = runtime.BindQueryParameter("form", true, false, "extension_version", ctx.QueryParams(), &params.ExtensionVersion)
	if err != nil {
		log.Err("Invalid format for parameter extension_version", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_version: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetReleasedExtensions(ctx, params)
	return err
}

// SetExtensionRequiredConfiguration converts echo context to params.
func (w *ServerInterfaceWrapper) SetExtensionRequiredConfiguration(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SetExtensionRequiredConfiguration"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SetExtensionRequiredConfigurationParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetExtensionRequiredConfiguration(ctx, params)
	return err
}

// GetExtensionTransactions converts echo context to params.
func (w *ServerInterfaceWrapper) GetExtensionTransactions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetExtensionTransactions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetExtensionTransactionsParams
	// ------------- Required query parameter "extension_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "extension_id", ctx.QueryParams(), &params.ExtensionId)
	if err != nil {
		log.Err("Invalid format for parameter extension_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter extension_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetExtensionTransactions(ctx, params)
	return err
}

// GetGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetGames(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetGames"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGamesParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		log.Err("Invalid format for parameter name", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "igdb_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "igdb_id", ctx.QueryParams(), &params.IgdbId)
	if err != nil {
		log.Err("Invalid format for parameter igdb_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter igdb_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGames(ctx, params)
	return err
}

// GetTopGames converts echo context to params.
func (w *ServerInterfaceWrapper) GetTopGames(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetTopGames"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTopGamesParams
	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTopGames(ctx, params)
	return err
}

// GetCreatorGoals converts echo context to params.
func (w *ServerInterfaceWrapper) GetCreatorGoals(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetCreatorGoals"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:goals"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetCreatorGoalsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetCreatorGoals(ctx, params)
	return err
}

// GetChannelGuestStarSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelGuestStarSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelGuestStarSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelGuestStarSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelGuestStarSettings(ctx, params)
	return err
}

// UpdateChannelGuestStarSettings converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateChannelGuestStarSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateChannelGuestStarSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateChannelGuestStarSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateChannelGuestStarSettings(ctx, params)
	return err
}

// DeleteGuestStarInvite converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGuestStarInvite(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteGuestStarInvite"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteGuestStarInviteParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// ------------- Required query parameter "guest_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "guest_id", ctx.QueryParams(), &params.GuestId)
	if err != nil {
		log.Err("Invalid format for parameter guest_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guest_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteGuestStarInvite(ctx, params)
	return err
}

// GetGuestStarInvites converts echo context to params.
func (w *ServerInterfaceWrapper) GetGuestStarInvites(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetGuestStarInvites"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGuestStarInvitesParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGuestStarInvites(ctx, params)
	return err
}

// SendGuestStarInvite converts echo context to params.
func (w *ServerInterfaceWrapper) SendGuestStarInvite(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendGuestStarInvite"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params SendGuestStarInviteParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// ------------- Required query parameter "guest_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "guest_id", ctx.QueryParams(), &params.GuestId)
	if err != nil {
		log.Err("Invalid format for parameter guest_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guest_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendGuestStarInvite(ctx, params)
	return err
}

// EndGuestStarSession converts echo context to params.
func (w *ServerInterfaceWrapper) EndGuestStarSession(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "EndGuestStarSession"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params EndGuestStarSessionParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndGuestStarSession(ctx, params)
	return err
}

// GetGuestStarSession converts echo context to params.
func (w *ServerInterfaceWrapper) GetGuestStarSession(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetGuestStarSession"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetGuestStarSessionParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetGuestStarSession(ctx, params)
	return err
}

// CreateGuestStarSession converts echo context to params.
func (w *ServerInterfaceWrapper) CreateGuestStarSession(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateGuestStarSession"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateGuestStarSessionParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateGuestStarSession(ctx, params)
	return err
}

// DeleteGuestStarSlot converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteGuestStarSlot(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteGuestStarSlot"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteGuestStarSlotParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// ------------- Required query parameter "guest_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "guest_id", ctx.QueryParams(), &params.GuestId)
	if err != nil {
		log.Err("Invalid format for parameter guest_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guest_id: %s", err))
	}

	// ------------- Required query parameter "slot_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "slot_id", ctx.QueryParams(), &params.SlotId)
	if err != nil {
		log.Err("Invalid format for parameter slot_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slot_id: %s", err))
	}

	// ------------- Optional query parameter "should_reinvite_guest" -------------

	err = runtime.BindQueryParameter("form", true, false, "should_reinvite_guest", ctx.QueryParams(), &params.ShouldReinviteGuest)
	if err != nil {
		log.Err("Invalid format for parameter should_reinvite_guest", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter should_reinvite_guest: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteGuestStarSlot(ctx, params)
	return err
}

// UpdateGuestStarSlot converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateGuestStarSlot(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateGuestStarSlot"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateGuestStarSlotParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// ------------- Required query parameter "source_slot_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "source_slot_id", ctx.QueryParams(), &params.SourceSlotId)
	if err != nil {
		log.Err("Invalid format for parameter source_slot_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_slot_id: %s", err))
	}

	// ------------- Optional query parameter "destination_slot_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "destination_slot_id", ctx.QueryParams(), &params.DestinationSlotId)
	if err != nil {
		log.Err("Invalid format for parameter destination_slot_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter destination_slot_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateGuestStarSlot(ctx, params)
	return err
}

// AssignGuestStarSlot converts echo context to params.
func (w *ServerInterfaceWrapper) AssignGuestStarSlot(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "AssignGuestStarSlot"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params AssignGuestStarSlotParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// ------------- Required query parameter "guest_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "guest_id", ctx.QueryParams(), &params.GuestId)
	if err != nil {
		log.Err("Invalid format for parameter guest_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter guest_id: %s", err))
	}

	// ------------- Required query parameter "slot_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "slot_id", ctx.QueryParams(), &params.SlotId)
	if err != nil {
		log.Err("Invalid format for parameter slot_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slot_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AssignGuestStarSlot(ctx, params)
	return err
}

// UpdateGuestStarSlotSettings converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateGuestStarSlotSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateGuestStarSlotSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateGuestStarSlotSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "session_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "session_id", ctx.QueryParams(), &params.SessionId)
	if err != nil {
		log.Err("Invalid format for parameter session_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter session_id: %s", err))
	}

	// ------------- Required query parameter "slot_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "slot_id", ctx.QueryParams(), &params.SlotId)
	if err != nil {
		log.Err("Invalid format for parameter slot_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slot_id: %s", err))
	}

	// ------------- Optional query parameter "is_audio_enabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_audio_enabled", ctx.QueryParams(), &params.IsAudioEnabled)
	if err != nil {
		log.Err("Invalid format for parameter is_audio_enabled", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_audio_enabled: %s", err))
	}

	// ------------- Optional query parameter "is_video_enabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_video_enabled", ctx.QueryParams(), &params.IsVideoEnabled)
	if err != nil {
		log.Err("Invalid format for parameter is_video_enabled", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_video_enabled: %s", err))
	}

	// ------------- Optional query parameter "is_live" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_live", ctx.QueryParams(), &params.IsLive)
	if err != nil {
		log.Err("Invalid format for parameter is_live", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_live: %s", err))
	}

	// ------------- Optional query parameter "volume" -------------

	err = runtime.BindQueryParameter("form", true, false, "volume", ctx.QueryParams(), &params.Volume)
	if err != nil {
		log.Err("Invalid format for parameter volume", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter volume: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateGuestStarSlotSettings(ctx, params)
	return err
}

// GetHypeTrainEvents converts echo context to params.
func (w *ServerInterfaceWrapper) GetHypeTrainEvents(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetHypeTrainEvents"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:hype_train"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetHypeTrainEventsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetHypeTrainEvents(ctx, params)
	return err
}

// ManageHeldAutomodMessages converts echo context to params.
func (w *ServerInterfaceWrapper) ManageHeldAutomodMessages(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "ManageHeldAutomodMessages"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:automod"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ManageHeldAutomodMessages(ctx)
	return err
}

// GetAutomodSettings converts echo context to params.
func (w *ServerInterfaceWrapper) GetAutomodSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetAutomodSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:read:automod_settings"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAutomodSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAutomodSettings(ctx, params)
	return err
}

// UpdateAutomodSettings converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateAutomodSettings(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateAutomodSettings"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:automod_settings"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateAutomodSettingsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateAutomodSettings(ctx, params)
	return err
}

// GetBannedUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetBannedUsers(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetBannedUsers"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderation:read", "moderator:manage:banned_users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBannedUsersParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBannedUsers(ctx, params)
	return err
}

// UnbanUser converts echo context to params.
func (w *ServerInterfaceWrapper) UnbanUser(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UnbanUser"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:banned_users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnbanUserParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UnbanUser(ctx, params)
	return err
}

// BanUser converts echo context to params.
func (w *ServerInterfaceWrapper) BanUser(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "BanUser"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:banned_users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params BanUserParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BanUser(ctx, params)
	return err
}

// RemoveBlockedTerm converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveBlockedTerm(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "RemoveBlockedTerm"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:blocked_terms"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RemoveBlockedTermParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveBlockedTerm(ctx, params)
	return err
}

// GetBlockedTerms converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockedTerms(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetBlockedTerms"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:read:blocked_terms", "moderator:manage:blocked_terms"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockedTermsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockedTerms(ctx, params)
	return err
}

// AddBlockedTerm converts echo context to params.
func (w *ServerInterfaceWrapper) AddBlockedTerm(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "AddBlockedTerm"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:blocked_terms"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddBlockedTermParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddBlockedTerm(ctx, params)
	return err
}

// GetModeratedChannels converts echo context to params.
func (w *ServerInterfaceWrapper) GetModeratedChannels(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetModeratedChannels"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetModeratedChannelsParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetModeratedChannels(ctx, params)
	return err
}

// DeleteChatMessages converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteChatMessages(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteChatMessages"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:chat_messages"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteChatMessagesParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Optional query parameter "message_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "message_id", ctx.QueryParams(), &params.MessageId)
	if err != nil {
		log.Err("Invalid format for parameter message_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter message_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteChatMessages(ctx, params)
	return err
}

// CheckAutomodStatus converts echo context to params.
func (w *ServerInterfaceWrapper) CheckAutomodStatus(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CheckAutomodStatus"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderation:read"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CheckAutomodStatusParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckAutomodStatus(ctx, params)
	return err
}

// RemoveChannelModerator converts echo context to params.
func (w *ServerInterfaceWrapper) RemoveChannelModerator(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "RemoveChannelModerator"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:moderators"})

	// Parameter object where we will unmarshal all parameters from the context
	var params RemoveChannelModeratorParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.RemoveChannelModerator(ctx, params)
	return err
}

// GetModerators converts echo context to params.
func (w *ServerInterfaceWrapper) GetModerators(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetModerators"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderation:read", "channel:manage:moderators"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetModeratorsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetModerators(ctx, params)
	return err
}

// AddChannelModerator converts echo context to params.
func (w *ServerInterfaceWrapper) AddChannelModerator(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "AddChannelModerator"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:moderators"})

	// Parameter object where we will unmarshal all parameters from the context
	var params AddChannelModeratorParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AddChannelModerator(ctx, params)
	return err
}

// GetShieldModeStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetShieldModeStatus(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetShieldModeStatus"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:read:shield_mode", "moderator:manage:shield_mode"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetShieldModeStatusParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetShieldModeStatus(ctx, params)
	return err
}

// UpdateShieldModeStatus converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateShieldModeStatus(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateShieldModeStatus"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:shield_mode"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateShieldModeStatusParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateShieldModeStatus(ctx, params)
	return err
}

// GetUnbanRequests converts echo context to params.
func (w *ServerInterfaceWrapper) GetUnbanRequests(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUnbanRequests"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:read:unban_requests", "moderator:manage:unban_requests"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUnbanRequestsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, true, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		log.Err("Invalid format for parameter status", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUnbanRequests(ctx, params)
	return err
}

// ResolveUnbanRequests converts echo context to params.
func (w *ServerInterfaceWrapper) ResolveUnbanRequests(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "ResolveUnbanRequests"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:unban_requests"})

	// Parameter object where we will unmarshal all parameters from the context
	var params ResolveUnbanRequestsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// ------------- Required query parameter "unban_request_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "unban_request_id", ctx.QueryParams(), &params.UnbanRequestId)
	if err != nil {
		log.Err("Invalid format for parameter unban_request_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter unban_request_id: %s", err))
	}

	// ------------- Required query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, true, "status", ctx.QueryParams(), &params.Status)
	if err != nil {
		log.Err("Invalid format for parameter status", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter status: %s", err))
	}

	// ------------- Optional query parameter "resolution_text" -------------

	err = runtime.BindQueryParameter("form", true, false, "resolution_text", ctx.QueryParams(), &params.ResolutionText)
	if err != nil {
		log.Err("Invalid format for parameter resolution_text", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter resolution_text: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.ResolveUnbanRequests(ctx, params)
	return err
}

// WarnChatUser converts echo context to params.
func (w *ServerInterfaceWrapper) WarnChatUser(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "WarnChatUser"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"moderator:manage:warnings"})

	// Parameter object where we will unmarshal all parameters from the context
	var params WarnChatUserParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "moderator_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "moderator_id", ctx.QueryParams(), &params.ModeratorId)
	if err != nil {
		log.Err("Invalid format for parameter moderator_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter moderator_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WarnChatUser(ctx, params)
	return err
}

// GetPolls converts echo context to params.
func (w *ServerInterfaceWrapper) GetPolls(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetPolls"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:polls", "channel:manage:polls"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPollsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPolls(ctx, params)
	return err
}

// EndPoll converts echo context to params.
func (w *ServerInterfaceWrapper) EndPoll(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "EndPoll"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:polls"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndPoll(ctx)
	return err
}

// CreatePoll converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePoll(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreatePoll"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:polls"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreatePoll(ctx)
	return err
}

// GetPredictions converts echo context to params.
func (w *ServerInterfaceWrapper) GetPredictions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetPredictions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:predictions", "channel:manage:predictions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPredictionsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetPredictions(ctx, params)
	return err
}

// EndPrediction converts echo context to params.
func (w *ServerInterfaceWrapper) EndPrediction(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "EndPrediction"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:predictions"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.EndPrediction(ctx)
	return err
}

// CreatePrediction converts echo context to params.
func (w *ServerInterfaceWrapper) CreatePrediction(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreatePrediction"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:predictions"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreatePrediction(ctx)
	return err
}

// CancelARaid converts echo context to params.
func (w *ServerInterfaceWrapper) CancelARaid(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CancelARaid"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:raids"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CancelARaidParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CancelARaid(ctx, params)
	return err
}

// StartARaid converts echo context to params.
func (w *ServerInterfaceWrapper) StartARaid(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "StartARaid"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:raids"})

	// Parameter object where we will unmarshal all parameters from the context
	var params StartARaidParams
	// ------------- Optional query parameter "from_broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "from_broadcaster_id", ctx.QueryParams(), &params.FromBroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter from_broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "to_broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "to_broadcaster_id", ctx.QueryParams(), &params.ToBroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter to_broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.StartARaid(ctx, params)
	return err
}

// GetChannelStreamSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelStreamSchedule(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelStreamSchedule"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelStreamScheduleParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "start_time", ctx.QueryParams(), &params.StartTime)
	if err != nil {
		log.Err("Invalid format for parameter start_time", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter start_time: %s", err))
	}

	// ------------- Optional query parameter "utc_offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "utc_offset", ctx.QueryParams(), &params.UtcOffset)
	if err != nil {
		log.Err("Invalid format for parameter utc_offset", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter utc_offset: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelStreamSchedule(ctx, params)
	return err
}

// GetChannelIcalendar converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelIcalendar(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelIcalendar"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelIcalendarParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelIcalendar(ctx, params)
	return err
}

// DeleteChannelStreamScheduleSegment converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteChannelStreamScheduleSegment(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteChannelStreamScheduleSegment"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:schedule"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteChannelStreamScheduleSegmentParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteChannelStreamScheduleSegment(ctx, params)
	return err
}

// UpdateChannelStreamScheduleSegment converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateChannelStreamScheduleSegment(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateChannelStreamScheduleSegment"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:schedule"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateChannelStreamScheduleSegmentParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateChannelStreamScheduleSegment(ctx, params)
	return err
}

// CreateChannelStreamScheduleSegment converts echo context to params.
func (w *ServerInterfaceWrapper) CreateChannelStreamScheduleSegment(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateChannelStreamScheduleSegment"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:schedule"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateChannelStreamScheduleSegmentParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateChannelStreamScheduleSegment(ctx, params)
	return err
}

// UpdateChannelStreamSchedule converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateChannelStreamSchedule(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateChannelStreamSchedule"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:schedule"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateChannelStreamScheduleParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "is_vacation_enabled" -------------

	err = runtime.BindQueryParameter("form", true, false, "is_vacation_enabled", ctx.QueryParams(), &params.IsVacationEnabled)
	if err != nil {
		log.Err("Invalid format for parameter is_vacation_enabled", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter is_vacation_enabled: %s", err))
	}

	// ------------- Optional query parameter "vacation_start_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "vacation_start_time", ctx.QueryParams(), &params.VacationStartTime)
	if err != nil {
		log.Err("Invalid format for parameter vacation_start_time", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vacation_start_time: %s", err))
	}

	// ------------- Optional query parameter "vacation_end_time" -------------

	err = runtime.BindQueryParameter("form", true, false, "vacation_end_time", ctx.QueryParams(), &params.VacationEndTime)
	if err != nil {
		log.Err("Invalid format for parameter vacation_end_time", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter vacation_end_time: %s", err))
	}

	// ------------- Optional query parameter "timezone" -------------

	err = runtime.BindQueryParameter("form", true, false, "timezone", ctx.QueryParams(), &params.Timezone)
	if err != nil {
		log.Err("Invalid format for parameter timezone", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter timezone: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateChannelStreamSchedule(ctx, params)
	return err
}

// SearchCategories converts echo context to params.
func (w *ServerInterfaceWrapper) SearchCategories(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SearchCategories"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchCategoriesParams
	// ------------- Required query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, true, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		log.Err("Invalid format for parameter query", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchCategories(ctx, params)
	return err
}

// SearchChannels converts echo context to params.
func (w *ServerInterfaceWrapper) SearchChannels(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SearchChannels"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params SearchChannelsParams
	// ------------- Required query parameter "query" -------------

	err = runtime.BindQueryParameter("form", true, true, "query", ctx.QueryParams(), &params.Query)
	if err != nil {
		log.Err("Invalid format for parameter query", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter query: %s", err))
	}

	// ------------- Optional query parameter "live_only" -------------

	err = runtime.BindQueryParameter("form", true, false, "live_only", ctx.QueryParams(), &params.LiveOnly)
	if err != nil {
		log.Err("Invalid format for parameter live_only", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter live_only: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SearchChannels(ctx, params)
	return err
}

// GetSharedChatSession converts echo context to params.
func (w *ServerInterfaceWrapper) GetSharedChatSession(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetSharedChatSession"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetSharedChatSessionParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSharedChatSession(ctx, params)
	return err
}

// GetStreams converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreams(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetStreams"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamsParams
	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "user_login" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_login", ctx.QueryParams(), &params.UserLogin)
	if err != nil {
		log.Err("Invalid format for parameter user_login", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_login: %s", err))
	}

	// ------------- Optional query parameter "game_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "game_id", ctx.QueryParams(), &params.GameId)
	if err != nil {
		log.Err("Invalid format for parameter game_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_id: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		log.Err("Invalid format for parameter type", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", ctx.QueryParams(), &params.Language)
	if err != nil {
		log.Err("Invalid format for parameter language", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStreams(ctx, params)
	return err
}

// GetFollowedStreams converts echo context to params.
func (w *ServerInterfaceWrapper) GetFollowedStreams(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetFollowedStreams"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:follows"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetFollowedStreamsParams
	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetFollowedStreams(ctx, params)
	return err
}

// GetStreamKey converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamKey(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetStreamKey"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:stream_key"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamKeyParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStreamKey(ctx, params)
	return err
}

// GetStreamMarkers converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamMarkers(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetStreamMarkers"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:broadcast", "channel:manage:broadcast"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamMarkersParams
	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "video_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "video_id", ctx.QueryParams(), &params.VideoId)
	if err != nil {
		log.Err("Invalid format for parameter video_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter video_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStreamMarkers(ctx, params)
	return err
}

// CreateStreamMarker converts echo context to params.
func (w *ServerInterfaceWrapper) CreateStreamMarker(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CreateStreamMarker"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:broadcast"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CreateStreamMarker(ctx)
	return err
}

// GetStreamTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetStreamTags(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetStreamTags"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetStreamTagsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStreamTags(ctx, params)
	return err
}

// GetBroadcasterSubscriptions converts echo context to params.
func (w *ServerInterfaceWrapper) GetBroadcasterSubscriptions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetBroadcasterSubscriptions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:read:subscriptions", "channel:read:subscriptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBroadcasterSubscriptionsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBroadcasterSubscriptions(ctx, params)
	return err
}

// CheckUserSubscription converts echo context to params.
func (w *ServerInterfaceWrapper) CheckUserSubscription(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "CheckUserSubscription"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:subscriptions", "user:read:subscriptions"})

	// Parameter object where we will unmarshal all parameters from the context
	var params CheckUserSubscriptionParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Required query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.CheckUserSubscription(ctx, params)
	return err
}

// GetAllStreamTags converts echo context to params.
func (w *ServerInterfaceWrapper) GetAllStreamTags(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetAllStreamTags"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetAllStreamTagsParams
	// ------------- Optional query parameter "tag_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "tag_id", ctx.QueryParams(), &params.TagId)
	if err != nil {
		log.Err("Invalid format for parameter tag_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter tag_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAllStreamTags(ctx, params)
	return err
}

// GetTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetTeams(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetTeams"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTeamsParams
	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, false, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		log.Err("Invalid format for parameter name", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTeams(ctx, params)
	return err
}

// GetChannelTeams converts echo context to params.
func (w *ServerInterfaceWrapper) GetChannelTeams(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetChannelTeams"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChannelTeamsParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetChannelTeams(ctx, params)
	return err
}

// GetUsers converts echo context to params.
func (w *ServerInterfaceWrapper) GetUsers(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUsers"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUsersParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "login" -------------

	err = runtime.BindQueryParameter("form", true, false, "login", ctx.QueryParams(), &params.Login)
	if err != nil {
		log.Err("Invalid format for parameter login", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter login: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUsers(ctx, params)
	return err
}

// UpdateUser converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUser(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateUser"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:edit"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdateUserParams
	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", true, false, "description", ctx.QueryParams(), &params.Description)
	if err != nil {
		log.Err("Invalid format for parameter description", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter description: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUser(ctx, params)
	return err
}

// UnblockUser converts echo context to params.
func (w *ServerInterfaceWrapper) UnblockUser(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UnblockUser"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:manage:blocked_users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params UnblockUserParams
	// ------------- Required query parameter "target_user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "target_user_id", ctx.QueryParams(), &params.TargetUserId)
	if err != nil {
		log.Err("Invalid format for parameter target_user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UnblockUser(ctx, params)
	return err
}

// GetUserBlockList converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserBlockList(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUserBlockList"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:blocked_users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserBlockListParams
	// ------------- Required query parameter "broadcaster_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "broadcaster_id", ctx.QueryParams(), &params.BroadcasterId)
	if err != nil {
		log.Err("Invalid format for parameter broadcaster_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter broadcaster_id: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserBlockList(ctx, params)
	return err
}

// BlockUser converts echo context to params.
func (w *ServerInterfaceWrapper) BlockUser(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "BlockUser"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:manage:blocked_users"})

	// Parameter object where we will unmarshal all parameters from the context
	var params BlockUserParams
	// ------------- Required query parameter "target_user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "target_user_id", ctx.QueryParams(), &params.TargetUserId)
	if err != nil {
		log.Err("Invalid format for parameter target_user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter target_user_id: %s", err))
	}

	// ------------- Optional query parameter "source_context" -------------

	err = runtime.BindQueryParameter("form", true, false, "source_context", ctx.QueryParams(), &params.SourceContext)
	if err != nil {
		log.Err("Invalid format for parameter source_context", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter source_context: %s", err))
	}

	// ------------- Optional query parameter "reason" -------------

	err = runtime.BindQueryParameter("form", true, false, "reason", ctx.QueryParams(), &params.Reason)
	if err != nil {
		log.Err("Invalid format for parameter reason", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter reason: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.BlockUser(ctx, params)
	return err
}

// GetUserActiveExtensions converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserActiveExtensions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUserActiveExtensions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetUserActiveExtensionsParams
	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserActiveExtensions(ctx, params)
	return err
}

// UpdateUserExtensions converts echo context to params.
func (w *ServerInterfaceWrapper) UpdateUserExtensions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "UpdateUserExtensions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:edit:broadcast"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.UpdateUserExtensions(ctx)
	return err
}

// GetUserExtensions converts echo context to params.
func (w *ServerInterfaceWrapper) GetUserExtensions(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetUserExtensions"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:read:broadcast", "user:edit:broadcast", "user:edit:broadcast"})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetUserExtensions(ctx)
	return err
}

// DeleteVideos converts echo context to params.
func (w *ServerInterfaceWrapper) DeleteVideos(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "DeleteVideos"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"channel:manage:videos"})

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteVideosParams
	// ------------- Required query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, true, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.DeleteVideos(ctx, params)
	return err
}

// GetVideos converts echo context to params.
func (w *ServerInterfaceWrapper) GetVideos(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "GetVideos"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetVideosParams
	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", true, false, "id", ctx.QueryParams(), &params.Id)
	if err != nil {
		log.Err("Invalid format for parameter id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	// ------------- Optional query parameter "user_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "user_id", ctx.QueryParams(), &params.UserId)
	if err != nil {
		log.Err("Invalid format for parameter user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter user_id: %s", err))
	}

	// ------------- Optional query parameter "game_id" -------------

	err = runtime.BindQueryParameter("form", true, false, "game_id", ctx.QueryParams(), &params.GameId)
	if err != nil {
		log.Err("Invalid format for parameter game_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter game_id: %s", err))
	}

	// ------------- Optional query parameter "language" -------------

	err = runtime.BindQueryParameter("form", true, false, "language", ctx.QueryParams(), &params.Language)
	if err != nil {
		log.Err("Invalid format for parameter language", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter language: %s", err))
	}

	// ------------- Optional query parameter "period" -------------

	err = runtime.BindQueryParameter("form", true, false, "period", ctx.QueryParams(), &params.Period)
	if err != nil {
		log.Err("Invalid format for parameter period", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter period: %s", err))
	}

	// ------------- Optional query parameter "sort" -------------

	err = runtime.BindQueryParameter("form", true, false, "sort", ctx.QueryParams(), &params.Sort)
	if err != nil {
		log.Err("Invalid format for parameter sort", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sort: %s", err))
	}

	// ------------- Optional query parameter "type" -------------

	err = runtime.BindQueryParameter("form", true, false, "type", ctx.QueryParams(), &params.Type)
	if err != nil {
		log.Err("Invalid format for parameter type", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter type: %s", err))
	}

	// ------------- Optional query parameter "first" -------------

	err = runtime.BindQueryParameter("form", true, false, "first", ctx.QueryParams(), &params.First)
	if err != nil {
		log.Err("Invalid format for parameter first", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter first: %s", err))
	}

	// ------------- Optional query parameter "after" -------------

	err = runtime.BindQueryParameter("form", true, false, "after", ctx.QueryParams(), &params.After)
	if err != nil {
		log.Err("Invalid format for parameter after", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter after: %s", err))
	}

	// ------------- Optional query parameter "before" -------------

	err = runtime.BindQueryParameter("form", true, false, "before", ctx.QueryParams(), &params.Before)
	if err != nil {
		log.Err("Invalid format for parameter before", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter before: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetVideos(ctx, params)
	return err
}

// SendWhisper converts echo context to params.
func (w *ServerInterfaceWrapper) SendWhisper(ctx echo.Context) error {
	var err error
	tlog.EchoWith(ctx, slog.String("operationID", "SendWhisper"))
	log := tlog.FromEcho(ctx)
	if false {
		log.Error("")
	}

	ctx.Set(Twitch_authScopes, []string{"user:manage:whispers"})

	// Parameter object where we will unmarshal all parameters from the context
	var params SendWhisperParams
	// ------------- Required query parameter "from_user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "from_user_id", ctx.QueryParams(), &params.FromUserId)
	if err != nil {
		log.Err("Invalid format for parameter from_user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter from_user_id: %s", err))
	}

	// ------------- Required query parameter "to_user_id" -------------

	err = runtime.BindQueryParameter("form", true, true, "to_user_id", ctx.QueryParams(), &params.ToUserId)
	if err != nil {
		log.Err("Invalid format for parameter to_user_id", err)
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter to_user_id: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SendWhisper(ctx, params)
	return err
}

//Generated with echo/echo-register.tmpl

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/analytics/extensions", wrapper.GetExtensionAnalytics)
	router.GET(baseURL+"/analytics/games", wrapper.GetGameAnalytics)
	router.GET(baseURL+"/bits/cheermotes", wrapper.GetCheermotes)
	router.GET(baseURL+"/bits/extensions", wrapper.GetExtensionBitsProducts)
	router.PUT(baseURL+"/bits/extensions", wrapper.UpdateExtensionBitsProduct)
	router.GET(baseURL+"/bits/leaderboard", wrapper.GetBitsLeaderboard)
	router.DELETE(baseURL+"/channel_points/custom_rewards", wrapper.DeleteCustomReward)
	router.GET(baseURL+"/channel_points/custom_rewards", wrapper.GetCustomReward)
	router.PATCH(baseURL+"/channel_points/custom_rewards", wrapper.UpdateCustomReward)
	router.POST(baseURL+"/channel_points/custom_rewards", wrapper.CreateCustomRewards)
	router.GET(baseURL+"/channel_points/custom_rewards/redemptions", wrapper.GetCustomRewardRedemption)
	router.PATCH(baseURL+"/channel_points/custom_rewards/redemptions", wrapper.UpdateRedemptionStatus)
	router.GET(baseURL+"/channels", wrapper.GetChannelInformation)
	router.PATCH(baseURL+"/channels", wrapper.ModifyChannelInformation)
	router.GET(baseURL+"/channels/ads", wrapper.GetAdSchedule)
	router.POST(baseURL+"/channels/ads/schedule/snooze", wrapper.SnoozeNextAd)
	router.POST(baseURL+"/channels/commercial", wrapper.StartCommercial)
	router.GET(baseURL+"/channels/editors", wrapper.GetChannelEditors)
	router.GET(baseURL+"/channels/followed", wrapper.GetFollowedChannels)
	router.GET(baseURL+"/channels/followers", wrapper.GetChannelFollowers)
	router.DELETE(baseURL+"/channels/vips", wrapper.RemoveChannelVip)
	router.GET(baseURL+"/channels/vips", wrapper.GetVips)
	router.POST(baseURL+"/channels/vips", wrapper.AddChannelVip)
	router.GET(baseURL+"/charity/campaigns", wrapper.GetCharityCampaign)
	router.GET(baseURL+"/charity/donations", wrapper.GetCharityCampaignDonations)
	router.POST(baseURL+"/chat/announcements", wrapper.SendChatAnnouncement)
	router.GET(baseURL+"/chat/badges", wrapper.GetChannelChatBadges)
	router.GET(baseURL+"/chat/badges/global", wrapper.GetGlobalChatBadges)
	router.GET(baseURL+"/chat/chatters", wrapper.GetChatters)
	router.GET(baseURL+"/chat/color", wrapper.GetUserChatColor)
	router.PUT(baseURL+"/chat/color", wrapper.UpdateUserChatColor)
	router.GET(baseURL+"/chat/emotes", wrapper.GetChannelEmotes)
	router.GET(baseURL+"/chat/emotes/global", wrapper.GetGlobalEmotes)
	router.GET(baseURL+"/chat/emotes/set", wrapper.GetEmoteSets)
	router.GET(baseURL+"/chat/emotes/user", wrapper.GetUserEmotes)
	router.POST(baseURL+"/chat/messages", wrapper.SendChatMessage)
	router.GET(baseURL+"/chat/settings", wrapper.GetChatSettings)
	router.PATCH(baseURL+"/chat/settings", wrapper.UpdateChatSettings)
	router.POST(baseURL+"/chat/shoutouts", wrapper.SendAShoutout)
	router.GET(baseURL+"/clips", wrapper.GetClips)
	router.POST(baseURL+"/clips", wrapper.CreateClip)
	router.GET(baseURL+"/content_classification_labels", wrapper.GetContentClassificationLabels)
	router.GET(baseURL+"/entitlements/drops", wrapper.GetDropsEntitlements)
	router.PATCH(baseURL+"/entitlements/drops", wrapper.UpdateDropsEntitlements)
	router.DELETE(baseURL+"/eventsub/conduits", wrapper.DeleteConduit)
	router.GET(baseURL+"/eventsub/conduits", wrapper.GetConduits)
	router.PATCH(baseURL+"/eventsub/conduits", wrapper.UpdateConduits)
	router.POST(baseURL+"/eventsub/conduits", wrapper.CreateConduits)
	router.GET(baseURL+"/eventsub/conduits/shards", wrapper.GetConduitShards)
	router.PATCH(baseURL+"/eventsub/conduits/shards", wrapper.UpdateConduitShards)
	router.DELETE(baseURL+"/eventsub/subscriptions", wrapper.DeleteEventsubSubscription)
	router.GET(baseURL+"/eventsub/subscriptions", wrapper.GetEventsubSubscriptions)
	router.POST(baseURL+"/eventsub/subscriptions", wrapper.CreateEventsubSubscription)
	router.GET(baseURL+"/extensions", wrapper.GetExtensions)
	router.POST(baseURL+"/extensions/chat", wrapper.SendExtensionChatMessage)
	router.GET(baseURL+"/extensions/configurations", wrapper.GetExtensionConfigurationSegment)
	router.PUT(baseURL+"/extensions/configurations", wrapper.SetExtensionConfigurationSegment)
	router.GET(baseURL+"/extensions/jwt/secrets", wrapper.GetExtensionSecrets)
	router.POST(baseURL+"/extensions/jwt/secrets", wrapper.CreateExtensionSecret)
	router.GET(baseURL+"/extensions/live", wrapper.GetExtensionLiveChannels)
	router.POST(baseURL+"/extensions/pubsub", wrapper.SendExtensionPubsubMessage)
	router.GET(baseURL+"/extensions/released", wrapper.GetReleasedExtensions)
	router.PUT(baseURL+"/extensions/required_configuration", wrapper.SetExtensionRequiredConfiguration)
	router.GET(baseURL+"/extensions/transactions", wrapper.GetExtensionTransactions)
	router.GET(baseURL+"/games", wrapper.GetGames)
	router.GET(baseURL+"/games/top", wrapper.GetTopGames)
	router.GET(baseURL+"/goals", wrapper.GetCreatorGoals)
	router.GET(baseURL+"/guest_star/channel_settings", wrapper.GetChannelGuestStarSettings)
	router.PUT(baseURL+"/guest_star/channel_settings", wrapper.UpdateChannelGuestStarSettings)
	router.DELETE(baseURL+"/guest_star/invites", wrapper.DeleteGuestStarInvite)
	router.GET(baseURL+"/guest_star/invites", wrapper.GetGuestStarInvites)
	router.POST(baseURL+"/guest_star/invites", wrapper.SendGuestStarInvite)
	router.DELETE(baseURL+"/guest_star/session", wrapper.EndGuestStarSession)
	router.GET(baseURL+"/guest_star/session", wrapper.GetGuestStarSession)
	router.POST(baseURL+"/guest_star/session", wrapper.CreateGuestStarSession)
	router.DELETE(baseURL+"/guest_star/slot", wrapper.DeleteGuestStarSlot)
	router.PATCH(baseURL+"/guest_star/slot", wrapper.UpdateGuestStarSlot)
	router.POST(baseURL+"/guest_star/slot", wrapper.AssignGuestStarSlot)
	router.PATCH(baseURL+"/guest_star/slot_settings", wrapper.UpdateGuestStarSlotSettings)
	router.GET(baseURL+"/hypetrain/events", wrapper.GetHypeTrainEvents)
	router.POST(baseURL+"/moderation/automod/message", wrapper.ManageHeldAutomodMessages)
	router.GET(baseURL+"/moderation/automod/settings", wrapper.GetAutomodSettings)
	router.PUT(baseURL+"/moderation/automod/settings", wrapper.UpdateAutomodSettings)
	router.GET(baseURL+"/moderation/banned", wrapper.GetBannedUsers)
	router.DELETE(baseURL+"/moderation/bans", wrapper.UnbanUser)
	router.POST(baseURL+"/moderation/bans", wrapper.BanUser)
	router.DELETE(baseURL+"/moderation/blocked_terms", wrapper.RemoveBlockedTerm)
	router.GET(baseURL+"/moderation/blocked_terms", wrapper.GetBlockedTerms)
	router.POST(baseURL+"/moderation/blocked_terms", wrapper.AddBlockedTerm)
	router.GET(baseURL+"/moderation/channels", wrapper.GetModeratedChannels)
	router.DELETE(baseURL+"/moderation/chat", wrapper.DeleteChatMessages)
	router.POST(baseURL+"/moderation/enforcements/status", wrapper.CheckAutomodStatus)
	router.DELETE(baseURL+"/moderation/moderators", wrapper.RemoveChannelModerator)
	router.GET(baseURL+"/moderation/moderators", wrapper.GetModerators)
	router.POST(baseURL+"/moderation/moderators", wrapper.AddChannelModerator)
	router.GET(baseURL+"/moderation/shield_mode", wrapper.GetShieldModeStatus)
	router.PUT(baseURL+"/moderation/shield_mode", wrapper.UpdateShieldModeStatus)
	router.GET(baseURL+"/moderation/unban_requests", wrapper.GetUnbanRequests)
	router.PATCH(baseURL+"/moderation/unban_requests", wrapper.ResolveUnbanRequests)
	router.POST(baseURL+"/moderation/warnings", wrapper.WarnChatUser)
	router.GET(baseURL+"/polls", wrapper.GetPolls)
	router.PATCH(baseURL+"/polls", wrapper.EndPoll)
	router.POST(baseURL+"/polls", wrapper.CreatePoll)
	router.GET(baseURL+"/predictions", wrapper.GetPredictions)
	router.PATCH(baseURL+"/predictions", wrapper.EndPrediction)
	router.POST(baseURL+"/predictions", wrapper.CreatePrediction)
	router.DELETE(baseURL+"/raids", wrapper.CancelARaid)
	router.POST(baseURL+"/raids", wrapper.StartARaid)
	router.GET(baseURL+"/schedule", wrapper.GetChannelStreamSchedule)
	router.GET(baseURL+"/schedule/icalendar", wrapper.GetChannelIcalendar)
	router.DELETE(baseURL+"/schedule/segment", wrapper.DeleteChannelStreamScheduleSegment)
	router.PATCH(baseURL+"/schedule/segment", wrapper.UpdateChannelStreamScheduleSegment)
	router.POST(baseURL+"/schedule/segment", wrapper.CreateChannelStreamScheduleSegment)
	router.PATCH(baseURL+"/schedule/settings", wrapper.UpdateChannelStreamSchedule)
	router.GET(baseURL+"/search/categories", wrapper.SearchCategories)
	router.GET(baseURL+"/search/channels", wrapper.SearchChannels)
	router.GET(baseURL+"/shared_chat/session", wrapper.GetSharedChatSession)
	router.GET(baseURL+"/streams", wrapper.GetStreams)
	router.GET(baseURL+"/streams/followed", wrapper.GetFollowedStreams)
	router.GET(baseURL+"/streams/key", wrapper.GetStreamKey)
	router.GET(baseURL+"/streams/markers", wrapper.GetStreamMarkers)
	router.POST(baseURL+"/streams/markers", wrapper.CreateStreamMarker)
	router.GET(baseURL+"/streams/tags", wrapper.GetStreamTags)
	router.GET(baseURL+"/subscriptions", wrapper.GetBroadcasterSubscriptions)
	router.GET(baseURL+"/subscriptions/user", wrapper.CheckUserSubscription)
	router.GET(baseURL+"/tags/streams", wrapper.GetAllStreamTags)
	router.GET(baseURL+"/teams", wrapper.GetTeams)
	router.GET(baseURL+"/teams/channel", wrapper.GetChannelTeams)
	router.GET(baseURL+"/users", wrapper.GetUsers)
	router.PUT(baseURL+"/users", wrapper.UpdateUser)
	router.DELETE(baseURL+"/users/blocks", wrapper.UnblockUser)
	router.GET(baseURL+"/users/blocks", wrapper.GetUserBlockList)
	router.PUT(baseURL+"/users/blocks", wrapper.BlockUser)
	router.GET(baseURL+"/users/extensions", wrapper.GetUserActiveExtensions)
	router.PUT(baseURL+"/users/extensions", wrapper.UpdateUserExtensions)
	router.GET(baseURL+"/users/extensions/list", wrapper.GetUserExtensions)
	router.DELETE(baseURL+"/videos", wrapper.DeleteVideos)
	router.GET(baseURL+"/videos", wrapper.GetVideos)
	router.POST(baseURL+"/whispers", wrapper.SendWhisper)

}

//Generated with strict-responses.tmpl

//Generated with strict-interface.tmpl

type GetExtensionAnalyticsRequestObject struct {
	Params GetExtensionAnalyticsParams
}

type GetExtensionAnalyticsResponseObject interface {
	VisitGetExtensionAnalyticsResponse(w http.ResponseWriter) error
}

type GetExtensionAnalytics200JSONResponse GetExtensionAnalyticsResponse

func (response GetExtensionAnalytics200JSONResponse) VisitGetExtensionAnalyticsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensionAnalytics400Response struct {
}

func (response GetExtensionAnalytics400Response) VisitGetExtensionAnalyticsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensionAnalytics401Response struct {
}

func (response GetExtensionAnalytics401Response) VisitGetExtensionAnalyticsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionAnalytics404Response struct {
}

func (response GetExtensionAnalytics404Response) VisitGetExtensionAnalyticsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetGameAnalyticsRequestObject struct {
	Params GetGameAnalyticsParams
}

type GetGameAnalyticsResponseObject interface {
	VisitGetGameAnalyticsResponse(w http.ResponseWriter) error
}

type GetGameAnalytics200JSONResponse GetGameAnalyticsResponse

func (response GetGameAnalytics200JSONResponse) VisitGetGameAnalyticsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetGameAnalytics400Response struct {
}

func (response GetGameAnalytics400Response) VisitGetGameAnalyticsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetGameAnalytics401Response struct {
}

func (response GetGameAnalytics401Response) VisitGetGameAnalyticsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetGameAnalytics404Response struct {
}

func (response GetGameAnalytics404Response) VisitGetGameAnalyticsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetCheermotesRequestObject struct {
	Params GetCheermotesParams
}

type GetCheermotesResponseObject interface {
	VisitGetCheermotesResponse(w http.ResponseWriter) error
}

type GetCheermotes200JSONResponse GetCheermotesResponse

func (response GetCheermotes200JSONResponse) VisitGetCheermotesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetCheermotes401Response struct {
}

func (response GetCheermotes401Response) VisitGetCheermotesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionBitsProductsRequestObject struct {
	Params GetExtensionBitsProductsParams
}

type GetExtensionBitsProductsResponseObject interface {
	VisitGetExtensionBitsProductsResponse(w http.ResponseWriter) error
}

type GetExtensionBitsProducts200JSONResponse GetExtensionBitsProductsResponse

func (response GetExtensionBitsProducts200JSONResponse) VisitGetExtensionBitsProductsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensionBitsProducts400Response struct {
}

func (response GetExtensionBitsProducts400Response) VisitGetExtensionBitsProductsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensionBitsProducts401Response struct {
}

func (response GetExtensionBitsProducts401Response) VisitGetExtensionBitsProductsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateExtensionBitsProductRequestObject struct {
	Body *UpdateExtensionBitsProductJSONRequestBody
}

type UpdateExtensionBitsProductResponseObject interface {
	VisitUpdateExtensionBitsProductResponse(w http.ResponseWriter) error
}

type UpdateExtensionBitsProduct200JSONResponse UpdateExtensionBitsProductResponse

func (response UpdateExtensionBitsProduct200JSONResponse) VisitUpdateExtensionBitsProductResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateExtensionBitsProduct400Response struct {
}

func (response UpdateExtensionBitsProduct400Response) VisitUpdateExtensionBitsProductResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateExtensionBitsProduct401Response struct {
}

func (response UpdateExtensionBitsProduct401Response) VisitUpdateExtensionBitsProductResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetBitsLeaderboardRequestObject struct {
	Params GetBitsLeaderboardParams
}

type GetBitsLeaderboardResponseObject interface {
	VisitGetBitsLeaderboardResponse(w http.ResponseWriter) error
}

type GetBitsLeaderboard200JSONResponse GetBitsLeaderboardResponse

func (response GetBitsLeaderboard200JSONResponse) VisitGetBitsLeaderboardResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetBitsLeaderboard400Response struct {
}

func (response GetBitsLeaderboard400Response) VisitGetBitsLeaderboardResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetBitsLeaderboard401Response struct {
}

func (response GetBitsLeaderboard401Response) VisitGetBitsLeaderboardResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetBitsLeaderboard403Response struct {
}

func (response GetBitsLeaderboard403Response) VisitGetBitsLeaderboardResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DeleteCustomRewardRequestObject struct {
	Params DeleteCustomRewardParams
}

type DeleteCustomRewardResponseObject interface {
	VisitDeleteCustomRewardResponse(w http.ResponseWriter) error
}

type DeleteCustomReward204Response struct {
}

func (response DeleteCustomReward204Response) VisitDeleteCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteCustomReward400Response struct {
}

func (response DeleteCustomReward400Response) VisitDeleteCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteCustomReward401Response struct {
}

func (response DeleteCustomReward401Response) VisitDeleteCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type DeleteCustomReward403Response struct {
}

func (response DeleteCustomReward403Response) VisitDeleteCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DeleteCustomReward404Response struct {
}

func (response DeleteCustomReward404Response) VisitDeleteCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type DeleteCustomReward500Response struct {
}

func (response DeleteCustomReward500Response) VisitDeleteCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetCustomRewardRequestObject struct {
	Params GetCustomRewardParams
}

type GetCustomRewardResponseObject interface {
	VisitGetCustomRewardResponse(w http.ResponseWriter) error
}

type GetCustomReward200JSONResponse GetCustomRewardResponse

func (response GetCustomReward200JSONResponse) VisitGetCustomRewardResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetCustomReward400Response struct {
}

func (response GetCustomReward400Response) VisitGetCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetCustomReward401Response struct {
}

func (response GetCustomReward401Response) VisitGetCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetCustomReward403Response struct {
}

func (response GetCustomReward403Response) VisitGetCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetCustomReward404Response struct {
}

func (response GetCustomReward404Response) VisitGetCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetCustomReward500Response struct {
}

func (response GetCustomReward500Response) VisitGetCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type UpdateCustomRewardRequestObject struct {
	Params UpdateCustomRewardParams
	Body   *UpdateCustomRewardJSONRequestBody
}

type UpdateCustomRewardResponseObject interface {
	VisitUpdateCustomRewardResponse(w http.ResponseWriter) error
}

type UpdateCustomReward200JSONResponse UpdateCustomRewardResponse

func (response UpdateCustomReward200JSONResponse) VisitUpdateCustomRewardResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateCustomReward400Response struct {
}

func (response UpdateCustomReward400Response) VisitUpdateCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateCustomReward401Response struct {
}

func (response UpdateCustomReward401Response) VisitUpdateCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateCustomReward403Response struct {
}

func (response UpdateCustomReward403Response) VisitUpdateCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateCustomReward404Response struct {
}

func (response UpdateCustomReward404Response) VisitUpdateCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type UpdateCustomReward500Response struct {
}

func (response UpdateCustomReward500Response) VisitUpdateCustomRewardResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type CreateCustomRewardsRequestObject struct {
	Params CreateCustomRewardsParams
	Body   *CreateCustomRewardsJSONRequestBody
}

type CreateCustomRewardsResponseObject interface {
	VisitCreateCustomRewardsResponse(w http.ResponseWriter) error
}

type CreateCustomRewards200JSONResponse CreateCustomRewardsResponse

func (response CreateCustomRewards200JSONResponse) VisitCreateCustomRewardsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreateCustomRewards400Response struct {
}

func (response CreateCustomRewards400Response) VisitCreateCustomRewardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateCustomRewards401Response struct {
}

func (response CreateCustomRewards401Response) VisitCreateCustomRewardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateCustomRewards403Response struct {
}

func (response CreateCustomRewards403Response) VisitCreateCustomRewardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type CreateCustomRewards500Response struct {
}

func (response CreateCustomRewards500Response) VisitCreateCustomRewardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetCustomRewardRedemptionRequestObject struct {
	Params GetCustomRewardRedemptionParams
}

type GetCustomRewardRedemptionResponseObject interface {
	VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error
}

type GetCustomRewardRedemption200JSONResponse GetCustomRewardRedemptionResponse

func (response GetCustomRewardRedemption200JSONResponse) VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetCustomRewardRedemption400Response struct {
}

func (response GetCustomRewardRedemption400Response) VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetCustomRewardRedemption401Response struct {
}

func (response GetCustomRewardRedemption401Response) VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetCustomRewardRedemption403Response struct {
}

func (response GetCustomRewardRedemption403Response) VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetCustomRewardRedemption404Response struct {
}

func (response GetCustomRewardRedemption404Response) VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetCustomRewardRedemption500Response struct {
}

func (response GetCustomRewardRedemption500Response) VisitGetCustomRewardRedemptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type UpdateRedemptionStatusRequestObject struct {
	Params UpdateRedemptionStatusParams
	Body   *UpdateRedemptionStatusJSONRequestBody
}

type UpdateRedemptionStatusResponseObject interface {
	VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error
}

type UpdateRedemptionStatus200JSONResponse UpdateRedemptionStatusResponse

func (response UpdateRedemptionStatus200JSONResponse) VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateRedemptionStatus400Response struct {
}

func (response UpdateRedemptionStatus400Response) VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateRedemptionStatus401Response struct {
}

func (response UpdateRedemptionStatus401Response) VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateRedemptionStatus403Response struct {
}

func (response UpdateRedemptionStatus403Response) VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateRedemptionStatus404Response struct {
}

func (response UpdateRedemptionStatus404Response) VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type UpdateRedemptionStatus500Response struct {
}

func (response UpdateRedemptionStatus500Response) VisitUpdateRedemptionStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetChannelInformationRequestObject struct {
	Params GetChannelInformationParams
}

type GetChannelInformationResponseObject interface {
	VisitGetChannelInformationResponse(w http.ResponseWriter) error
}

type GetChannelInformation200JSONResponse GetChannelInformationResponse

func (response GetChannelInformation200JSONResponse) VisitGetChannelInformationResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelInformation400Response struct {
}

func (response GetChannelInformation400Response) VisitGetChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelInformation401Response struct {
}

func (response GetChannelInformation401Response) VisitGetChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelInformation429Response struct {
}

func (response GetChannelInformation429Response) VisitGetChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetChannelInformation500Response struct {
}

func (response GetChannelInformation500Response) VisitGetChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type ModifyChannelInformationRequestObject struct {
	Params ModifyChannelInformationParams
	Body   *ModifyChannelInformationJSONRequestBody
}

type ModifyChannelInformationResponseObject interface {
	VisitModifyChannelInformationResponse(w http.ResponseWriter) error
}

type ModifyChannelInformation204Response struct {
}

func (response ModifyChannelInformation204Response) VisitModifyChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type ModifyChannelInformation400Response struct {
}

func (response ModifyChannelInformation400Response) VisitModifyChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type ModifyChannelInformation401Response struct {
}

func (response ModifyChannelInformation401Response) VisitModifyChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type ModifyChannelInformation403Response struct {
}

func (response ModifyChannelInformation403Response) VisitModifyChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type ModifyChannelInformation409Response struct {
}

func (response ModifyChannelInformation409Response) VisitModifyChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type ModifyChannelInformation500Response struct {
}

func (response ModifyChannelInformation500Response) VisitModifyChannelInformationResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetAdScheduleRequestObject struct {
	Params GetAdScheduleParams
}

type GetAdScheduleResponseObject interface {
	VisitGetAdScheduleResponse(w http.ResponseWriter) error
}

type GetAdSchedule200JSONResponse GetAdScheduleResponse

func (response GetAdSchedule200JSONResponse) VisitGetAdScheduleResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetAdSchedule400Response struct {
}

func (response GetAdSchedule400Response) VisitGetAdScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetAdSchedule500Response struct {
}

func (response GetAdSchedule500Response) VisitGetAdScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type SnoozeNextAdRequestObject struct {
	Params SnoozeNextAdParams
}

type SnoozeNextAdResponseObject interface {
	VisitSnoozeNextAdResponse(w http.ResponseWriter) error
}

type SnoozeNextAd200JSONResponse SnoozeNextAdResponse

func (response SnoozeNextAd200JSONResponse) VisitSnoozeNextAdResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type SnoozeNextAd400Response struct {
}

func (response SnoozeNextAd400Response) VisitSnoozeNextAdResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SnoozeNextAd429Response struct {
}

func (response SnoozeNextAd429Response) VisitSnoozeNextAdResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type SnoozeNextAd500Response struct {
}

func (response SnoozeNextAd500Response) VisitSnoozeNextAdResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type StartCommercialRequestObject struct {
	Body *StartCommercialJSONRequestBody
}

type StartCommercialResponseObject interface {
	VisitStartCommercialResponse(w http.ResponseWriter) error
}

type StartCommercial200JSONResponse StartCommercialResponse

func (response StartCommercial200JSONResponse) VisitStartCommercialResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type StartCommercial400Response struct {
}

func (response StartCommercial400Response) VisitStartCommercialResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type StartCommercial401Response struct {
}

func (response StartCommercial401Response) VisitStartCommercialResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type StartCommercial404Response struct {
}

func (response StartCommercial404Response) VisitStartCommercialResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type StartCommercial429Response struct {
}

func (response StartCommercial429Response) VisitStartCommercialResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetChannelEditorsRequestObject struct {
	Params GetChannelEditorsParams
}

type GetChannelEditorsResponseObject interface {
	VisitGetChannelEditorsResponse(w http.ResponseWriter) error
}

type GetChannelEditors200JSONResponse GetChannelEditorsResponse

func (response GetChannelEditors200JSONResponse) VisitGetChannelEditorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelEditors400Response struct {
}

func (response GetChannelEditors400Response) VisitGetChannelEditorsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelEditors401Response struct {
}

func (response GetChannelEditors401Response) VisitGetChannelEditorsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetFollowedChannelsRequestObject struct {
	Params GetFollowedChannelsParams
}

type GetFollowedChannelsResponseObject interface {
	VisitGetFollowedChannelsResponse(w http.ResponseWriter) error
}

type GetFollowedChannels200JSONResponse GetFollowedChannelsResponse

func (response GetFollowedChannels200JSONResponse) VisitGetFollowedChannelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetFollowedChannels400Response struct {
}

func (response GetFollowedChannels400Response) VisitGetFollowedChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetFollowedChannels401Response struct {
}

func (response GetFollowedChannels401Response) VisitGetFollowedChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelFollowersRequestObject struct {
	Params GetChannelFollowersParams
}

type GetChannelFollowersResponseObject interface {
	VisitGetChannelFollowersResponse(w http.ResponseWriter) error
}

type GetChannelFollowers200JSONResponse GetChannelFollowersResponse

func (response GetChannelFollowers200JSONResponse) VisitGetChannelFollowersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelFollowers400Response struct {
}

func (response GetChannelFollowers400Response) VisitGetChannelFollowersResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelFollowers401Response struct {
}

func (response GetChannelFollowers401Response) VisitGetChannelFollowersResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type RemoveChannelVipRequestObject struct {
	Params RemoveChannelVipParams
}

type RemoveChannelVipResponseObject interface {
	VisitRemoveChannelVipResponse(w http.ResponseWriter) error
}

type RemoveChannelVip204Response struct {
}

func (response RemoveChannelVip204Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RemoveChannelVip400Response struct {
}

func (response RemoveChannelVip400Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type RemoveChannelVip401Response struct {
}

func (response RemoveChannelVip401Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type RemoveChannelVip403Response struct {
}

func (response RemoveChannelVip403Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type RemoveChannelVip404Response struct {
}

func (response RemoveChannelVip404Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type RemoveChannelVip422Response struct {
}

func (response RemoveChannelVip422Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(422)
	return nil
}

type RemoveChannelVip429Response struct {
}

func (response RemoveChannelVip429Response) VisitRemoveChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetVipsRequestObject struct {
	Params GetVipsParams
}

type GetVipsResponseObject interface {
	VisitGetVipsResponse(w http.ResponseWriter) error
}

type GetVips200JSONResponse GetVIPsResponse

func (response GetVips200JSONResponse) VisitGetVipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetVips400Response struct {
}

func (response GetVips400Response) VisitGetVipsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetVips401Response struct {
}

func (response GetVips401Response) VisitGetVipsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type AddChannelVipRequestObject struct {
	Params AddChannelVipParams
}

type AddChannelVipResponseObject interface {
	VisitAddChannelVipResponse(w http.ResponseWriter) error
}

type AddChannelVip204Response struct {
}

func (response AddChannelVip204Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AddChannelVip400Response struct {
}

func (response AddChannelVip400Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type AddChannelVip401Response struct {
}

func (response AddChannelVip401Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type AddChannelVip403Response struct {
}

func (response AddChannelVip403Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type AddChannelVip404Response struct {
}

func (response AddChannelVip404Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type AddChannelVip409Response struct {
}

func (response AddChannelVip409Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type AddChannelVip422Response struct {
}

func (response AddChannelVip422Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(422)
	return nil
}

type AddChannelVip425Response struct {
}

func (response AddChannelVip425Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(425)
	return nil
}

type AddChannelVip429Response struct {
}

func (response AddChannelVip429Response) VisitAddChannelVipResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetCharityCampaignRequestObject struct {
	Params GetCharityCampaignParams
}

type GetCharityCampaignResponseObject interface {
	VisitGetCharityCampaignResponse(w http.ResponseWriter) error
}

type GetCharityCampaign200JSONResponse GetCharityCampaignResponse

func (response GetCharityCampaign200JSONResponse) VisitGetCharityCampaignResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetCharityCampaign400Response struct {
}

func (response GetCharityCampaign400Response) VisitGetCharityCampaignResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetCharityCampaign401Response struct {
}

func (response GetCharityCampaign401Response) VisitGetCharityCampaignResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetCharityCampaign403Response struct {
}

func (response GetCharityCampaign403Response) VisitGetCharityCampaignResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetCharityCampaignDonationsRequestObject struct {
	Params GetCharityCampaignDonationsParams
}

type GetCharityCampaignDonationsResponseObject interface {
	VisitGetCharityCampaignDonationsResponse(w http.ResponseWriter) error
}

type GetCharityCampaignDonations200JSONResponse GetCharityCampaignDonationsResponse

func (response GetCharityCampaignDonations200JSONResponse) VisitGetCharityCampaignDonationsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetCharityCampaignDonations400Response struct {
}

func (response GetCharityCampaignDonations400Response) VisitGetCharityCampaignDonationsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetCharityCampaignDonations401Response struct {
}

func (response GetCharityCampaignDonations401Response) VisitGetCharityCampaignDonationsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetCharityCampaignDonations403Response struct {
}

func (response GetCharityCampaignDonations403Response) VisitGetCharityCampaignDonationsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type SendChatAnnouncementRequestObject struct {
	Params SendChatAnnouncementParams
	Body   *SendChatAnnouncementJSONRequestBody
}

type SendChatAnnouncementResponseObject interface {
	VisitSendChatAnnouncementResponse(w http.ResponseWriter) error
}

type SendChatAnnouncement204Response struct {
}

func (response SendChatAnnouncement204Response) VisitSendChatAnnouncementResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SendChatAnnouncement400Response struct {
}

func (response SendChatAnnouncement400Response) VisitSendChatAnnouncementResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendChatAnnouncement401Response struct {
}

func (response SendChatAnnouncement401Response) VisitSendChatAnnouncementResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelChatBadgesRequestObject struct {
	Params GetChannelChatBadgesParams
}

type GetChannelChatBadgesResponseObject interface {
	VisitGetChannelChatBadgesResponse(w http.ResponseWriter) error
}

type GetChannelChatBadges200JSONResponse GetChannelChatBadgesResponse

func (response GetChannelChatBadges200JSONResponse) VisitGetChannelChatBadgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelChatBadges400Response struct {
}

func (response GetChannelChatBadges400Response) VisitGetChannelChatBadgesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelChatBadges401Response struct {
}

func (response GetChannelChatBadges401Response) VisitGetChannelChatBadgesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetGlobalChatBadgesRequestObject struct {
}

type GetGlobalChatBadgesResponseObject interface {
	VisitGetGlobalChatBadgesResponse(w http.ResponseWriter) error
}

type GetGlobalChatBadges200JSONResponse GetGlobalChatBadgesResponse

func (response GetGlobalChatBadges200JSONResponse) VisitGetGlobalChatBadgesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetGlobalChatBadges401Response struct {
}

func (response GetGlobalChatBadges401Response) VisitGetGlobalChatBadgesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChattersRequestObject struct {
	Params GetChattersParams
}

type GetChattersResponseObject interface {
	VisitGetChattersResponse(w http.ResponseWriter) error
}

type GetChatters200JSONResponse GetChattersResponse

func (response GetChatters200JSONResponse) VisitGetChattersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChatters400Response struct {
}

func (response GetChatters400Response) VisitGetChattersResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChatters401Response struct {
}

func (response GetChatters401Response) VisitGetChattersResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChatters403Response struct {
}

func (response GetChatters403Response) VisitGetChattersResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetUserChatColorRequestObject struct {
	Params GetUserChatColorParams
}

type GetUserChatColorResponseObject interface {
	VisitGetUserChatColorResponse(w http.ResponseWriter) error
}

type GetUserChatColor200JSONResponse GetUserChatColorResponse

func (response GetUserChatColor200JSONResponse) VisitGetUserChatColorResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUserChatColor400Response struct {
}

func (response GetUserChatColor400Response) VisitGetUserChatColorResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetUserChatColor401Response struct {
}

func (response GetUserChatColor401Response) VisitGetUserChatColorResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateUserChatColorRequestObject struct {
	Params UpdateUserChatColorParams
}

type UpdateUserChatColorResponseObject interface {
	VisitUpdateUserChatColorResponse(w http.ResponseWriter) error
}

type UpdateUserChatColor204Response struct {
}

func (response UpdateUserChatColor204Response) VisitUpdateUserChatColorResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UpdateUserChatColor400Response struct {
}

func (response UpdateUserChatColor400Response) VisitUpdateUserChatColorResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateUserChatColor401Response struct {
}

func (response UpdateUserChatColor401Response) VisitUpdateUserChatColorResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelEmotesRequestObject struct {
	Params GetChannelEmotesParams
}

type GetChannelEmotesResponseObject interface {
	VisitGetChannelEmotesResponse(w http.ResponseWriter) error
}

type GetChannelEmotes200JSONResponse GetChannelEmotesResponse

func (response GetChannelEmotes200JSONResponse) VisitGetChannelEmotesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelEmotes400Response struct {
}

func (response GetChannelEmotes400Response) VisitGetChannelEmotesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelEmotes401Response struct {
}

func (response GetChannelEmotes401Response) VisitGetChannelEmotesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetGlobalEmotesRequestObject struct {
}

type GetGlobalEmotesResponseObject interface {
	VisitGetGlobalEmotesResponse(w http.ResponseWriter) error
}

type GetGlobalEmotes200JSONResponse GetGlobalEmotesResponse

func (response GetGlobalEmotes200JSONResponse) VisitGetGlobalEmotesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetGlobalEmotes401Response struct {
}

func (response GetGlobalEmotes401Response) VisitGetGlobalEmotesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetEmoteSetsRequestObject struct {
	Params GetEmoteSetsParams
}

type GetEmoteSetsResponseObject interface {
	VisitGetEmoteSetsResponse(w http.ResponseWriter) error
}

type GetEmoteSets200JSONResponse GetEmoteSetsResponse

func (response GetEmoteSets200JSONResponse) VisitGetEmoteSetsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetEmoteSets400Response struct {
}

func (response GetEmoteSets400Response) VisitGetEmoteSetsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetEmoteSets401Response struct {
}

func (response GetEmoteSets401Response) VisitGetEmoteSetsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetUserEmotesRequestObject struct {
	Params GetUserEmotesParams
}

type GetUserEmotesResponseObject interface {
	VisitGetUserEmotesResponse(w http.ResponseWriter) error
}

type GetUserEmotes200JSONResponse GetUserEmotesResponse

func (response GetUserEmotes200JSONResponse) VisitGetUserEmotesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUserEmotes400Response struct {
}

func (response GetUserEmotes400Response) VisitGetUserEmotesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetUserEmotes401Response struct {
}

func (response GetUserEmotes401Response) VisitGetUserEmotesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SendChatMessageRequestObject struct {
	Body *SendChatMessageJSONRequestBody
}

type SendChatMessageResponseObject interface {
	VisitSendChatMessageResponse(w http.ResponseWriter) error
}

type SendChatMessage200JSONResponse SendChatMessageResponse

func (response SendChatMessage200JSONResponse) VisitSendChatMessageResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type SendChatMessage400Response struct {
}

func (response SendChatMessage400Response) VisitSendChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendChatMessage401Response struct {
}

func (response SendChatMessage401Response) VisitSendChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SendChatMessage403Response struct {
}

func (response SendChatMessage403Response) VisitSendChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type SendChatMessage422Response struct {
}

func (response SendChatMessage422Response) VisitSendChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(422)
	return nil
}

type GetChatSettingsRequestObject struct {
	Params GetChatSettingsParams
}

type GetChatSettingsResponseObject interface {
	VisitGetChatSettingsResponse(w http.ResponseWriter) error
}

type GetChatSettings200JSONResponse GetChatSettingsResponse

func (response GetChatSettings200JSONResponse) VisitGetChatSettingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChatSettings400Response struct {
}

func (response GetChatSettings400Response) VisitGetChatSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChatSettings401Response struct {
}

func (response GetChatSettings401Response) VisitGetChatSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateChatSettingsRequestObject struct {
	Params UpdateChatSettingsParams
	Body   *UpdateChatSettingsJSONRequestBody
}

type UpdateChatSettingsResponseObject interface {
	VisitUpdateChatSettingsResponse(w http.ResponseWriter) error
}

type UpdateChatSettings200JSONResponse UpdateChatSettingsResponse

func (response UpdateChatSettings200JSONResponse) VisitUpdateChatSettingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateChatSettings400Response struct {
}

func (response UpdateChatSettings400Response) VisitUpdateChatSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateChatSettings401Response struct {
}

func (response UpdateChatSettings401Response) VisitUpdateChatSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateChatSettings403Response struct {
}

func (response UpdateChatSettings403Response) VisitUpdateChatSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type SendAShoutoutRequestObject struct {
	Params SendAShoutoutParams
}

type SendAShoutoutResponseObject interface {
	VisitSendAShoutoutResponse(w http.ResponseWriter) error
}

type SendAShoutout204Response struct {
}

func (response SendAShoutout204Response) VisitSendAShoutoutResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SendAShoutout400Response struct {
}

func (response SendAShoutout400Response) VisitSendAShoutoutResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendAShoutout401Response struct {
}

func (response SendAShoutout401Response) VisitSendAShoutoutResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SendAShoutout403Response struct {
}

func (response SendAShoutout403Response) VisitSendAShoutoutResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type SendAShoutout429Response struct {
}

func (response SendAShoutout429Response) VisitSendAShoutoutResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetClipsRequestObject struct {
	Params GetClipsParams
}

type GetClipsResponseObject interface {
	VisitGetClipsResponse(w http.ResponseWriter) error
}

type GetClips200JSONResponse GetClipsResponse

func (response GetClips200JSONResponse) VisitGetClipsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetClips400Response struct {
}

func (response GetClips400Response) VisitGetClipsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetClips401Response struct {
}

func (response GetClips401Response) VisitGetClipsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetClips404Response struct {
}

func (response GetClips404Response) VisitGetClipsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CreateClipRequestObject struct {
	Params CreateClipParams
}

type CreateClipResponseObject interface {
	VisitCreateClipResponse(w http.ResponseWriter) error
}

type CreateClip202JSONResponse CreateClipResponse

func (response CreateClip202JSONResponse) VisitCreateClipResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.MarshalWrite(w, response)
}

type CreateClip400Response struct {
}

func (response CreateClip400Response) VisitCreateClipResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateClip401Response struct {
}

func (response CreateClip401Response) VisitCreateClipResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateClip403Response struct {
}

func (response CreateClip403Response) VisitCreateClipResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type CreateClip404Response struct {
}

func (response CreateClip404Response) VisitCreateClipResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetContentClassificationLabelsRequestObject struct {
	Params GetContentClassificationLabelsParams
}

type GetContentClassificationLabelsResponseObject interface {
	VisitGetContentClassificationLabelsResponse(w http.ResponseWriter) error
}

type GetContentClassificationLabels200JSONResponse GetContentClassificationLabelsResponse

func (response GetContentClassificationLabels200JSONResponse) VisitGetContentClassificationLabelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetContentClassificationLabels400Response struct {
}

func (response GetContentClassificationLabels400Response) VisitGetContentClassificationLabelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetContentClassificationLabels401Response struct {
}

func (response GetContentClassificationLabels401Response) VisitGetContentClassificationLabelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetContentClassificationLabels500Response struct {
}

func (response GetContentClassificationLabels500Response) VisitGetContentClassificationLabelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetDropsEntitlementsRequestObject struct {
	Params GetDropsEntitlementsParams
}

type GetDropsEntitlementsResponseObject interface {
	VisitGetDropsEntitlementsResponse(w http.ResponseWriter) error
}

type GetDropsEntitlements200JSONResponse GetDropsEntitlementsResponse

func (response GetDropsEntitlements200JSONResponse) VisitGetDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetDropsEntitlements400Response struct {
}

func (response GetDropsEntitlements400Response) VisitGetDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetDropsEntitlements401Response struct {
}

func (response GetDropsEntitlements401Response) VisitGetDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetDropsEntitlements403Response struct {
}

func (response GetDropsEntitlements403Response) VisitGetDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetDropsEntitlements500Response struct {
}

func (response GetDropsEntitlements500Response) VisitGetDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type UpdateDropsEntitlementsRequestObject struct {
	Body *UpdateDropsEntitlementsJSONRequestBody
}

type UpdateDropsEntitlementsResponseObject interface {
	VisitUpdateDropsEntitlementsResponse(w http.ResponseWriter) error
}

type UpdateDropsEntitlements200JSONResponse UpdateDropsEntitlementsResponse

func (response UpdateDropsEntitlements200JSONResponse) VisitUpdateDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateDropsEntitlements400Response struct {
}

func (response UpdateDropsEntitlements400Response) VisitUpdateDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateDropsEntitlements401Response struct {
}

func (response UpdateDropsEntitlements401Response) VisitUpdateDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateDropsEntitlements500Response struct {
}

func (response UpdateDropsEntitlements500Response) VisitUpdateDropsEntitlementsResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type DeleteConduitRequestObject struct {
	Params DeleteConduitParams
}

type DeleteConduitResponseObject interface {
	VisitDeleteConduitResponse(w http.ResponseWriter) error
}

type DeleteConduit204Response struct {
}

func (response DeleteConduit204Response) VisitDeleteConduitResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteConduit400Response struct {
}

func (response DeleteConduit400Response) VisitDeleteConduitResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteConduit401Response struct {
}

func (response DeleteConduit401Response) VisitDeleteConduitResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type DeleteConduit404Response struct {
}

func (response DeleteConduit404Response) VisitDeleteConduitResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetConduitsRequestObject struct {
}

type GetConduitsResponseObject interface {
	VisitGetConduitsResponse(w http.ResponseWriter) error
}

type GetConduits200JSONResponse GetConduitsResponse

func (response GetConduits200JSONResponse) VisitGetConduitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetConduits401Response struct {
}

func (response GetConduits401Response) VisitGetConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateConduitsRequestObject struct {
	Body *UpdateConduitsJSONRequestBody
}

type UpdateConduitsResponseObject interface {
	VisitUpdateConduitsResponse(w http.ResponseWriter) error
}

type UpdateConduits200JSONResponse UpdateConduitsResponse

func (response UpdateConduits200JSONResponse) VisitUpdateConduitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateConduits400Response struct {
}

func (response UpdateConduits400Response) VisitUpdateConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateConduits401Response struct {
}

func (response UpdateConduits401Response) VisitUpdateConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateConduits404Response struct {
}

func (response UpdateConduits404Response) VisitUpdateConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CreateConduitsRequestObject struct {
	Body *CreateConduitsJSONRequestBody
}

type CreateConduitsResponseObject interface {
	VisitCreateConduitsResponse(w http.ResponseWriter) error
}

type CreateConduits200JSONResponse CreateConduitsResponse

func (response CreateConduits200JSONResponse) VisitCreateConduitsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreateConduits400Response struct {
}

func (response CreateConduits400Response) VisitCreateConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateConduits401Response struct {
}

func (response CreateConduits401Response) VisitCreateConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateConduits429Response struct {
}

func (response CreateConduits429Response) VisitCreateConduitsResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetConduitShardsRequestObject struct {
	Params GetConduitShardsParams
}

type GetConduitShardsResponseObject interface {
	VisitGetConduitShardsResponse(w http.ResponseWriter) error
}

type GetConduitShards200JSONResponse GetConduitShardsResponse

func (response GetConduitShards200JSONResponse) VisitGetConduitShardsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetConduitShards400Response struct {
}

func (response GetConduitShards400Response) VisitGetConduitShardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetConduitShards401Response struct {
}

func (response GetConduitShards401Response) VisitGetConduitShardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetConduitShards404Response struct {
}

func (response GetConduitShards404Response) VisitGetConduitShardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type UpdateConduitShardsRequestObject struct {
	Body *UpdateConduitShardsJSONRequestBody
}

type UpdateConduitShardsResponseObject interface {
	VisitUpdateConduitShardsResponse(w http.ResponseWriter) error
}

type UpdateConduitShards202JSONResponse UpdateConduitShardsResponse

func (response UpdateConduitShards202JSONResponse) VisitUpdateConduitShardsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.MarshalWrite(w, response)
}

type UpdateConduitShards400Response struct {
}

func (response UpdateConduitShards400Response) VisitUpdateConduitShardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateConduitShards401Response struct {
}

func (response UpdateConduitShards401Response) VisitUpdateConduitShardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateConduitShards404Response struct {
}

func (response UpdateConduitShards404Response) VisitUpdateConduitShardsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type DeleteEventsubSubscriptionRequestObject struct {
	Params DeleteEventsubSubscriptionParams
}

type DeleteEventsubSubscriptionResponseObject interface {
	VisitDeleteEventsubSubscriptionResponse(w http.ResponseWriter) error
}

type DeleteEventsubSubscription204Response struct {
}

func (response DeleteEventsubSubscription204Response) VisitDeleteEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteEventsubSubscription400Response struct {
}

func (response DeleteEventsubSubscription400Response) VisitDeleteEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteEventsubSubscription401Response struct {
}

func (response DeleteEventsubSubscription401Response) VisitDeleteEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type DeleteEventsubSubscription404Response struct {
}

func (response DeleteEventsubSubscription404Response) VisitDeleteEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetEventsubSubscriptionsRequestObject struct {
	Params GetEventsubSubscriptionsParams
}

type GetEventsubSubscriptionsResponseObject interface {
	VisitGetEventsubSubscriptionsResponse(w http.ResponseWriter) error
}

type GetEventsubSubscriptions200JSONResponse GetEventSubSubscriptionsResponse

func (response GetEventsubSubscriptions200JSONResponse) VisitGetEventsubSubscriptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetEventsubSubscriptions400Response struct {
}

func (response GetEventsubSubscriptions400Response) VisitGetEventsubSubscriptionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetEventsubSubscriptions401Response struct {
}

func (response GetEventsubSubscriptions401Response) VisitGetEventsubSubscriptionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateEventsubSubscriptionRequestObject struct {
	Body *CreateEventsubSubscriptionJSONRequestBody
}

type CreateEventsubSubscriptionResponseObject interface {
	VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error
}

type CreateEventsubSubscription202JSONResponse CreateEventSubSubscriptionResponse

func (response CreateEventsubSubscription202JSONResponse) VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(202)

	return json.MarshalWrite(w, response)
}

type CreateEventsubSubscription400Response struct {
}

func (response CreateEventsubSubscription400Response) VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateEventsubSubscription401Response struct {
}

func (response CreateEventsubSubscription401Response) VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateEventsubSubscription403Response struct {
}

func (response CreateEventsubSubscription403Response) VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type CreateEventsubSubscription409Response struct {
}

func (response CreateEventsubSubscription409Response) VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type CreateEventsubSubscription429Response struct {
}

func (response CreateEventsubSubscription429Response) VisitCreateEventsubSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetExtensionsRequestObject struct {
	Params GetExtensionsParams
}

type GetExtensionsResponseObject interface {
	VisitGetExtensionsResponse(w http.ResponseWriter) error
}

type GetExtensions200JSONResponse GetExtensionsResponse

func (response GetExtensions200JSONResponse) VisitGetExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensions400Response struct {
}

func (response GetExtensions400Response) VisitGetExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensions401Response struct {
}

func (response GetExtensions401Response) VisitGetExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensions404Response struct {
}

func (response GetExtensions404Response) VisitGetExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type SendExtensionChatMessageRequestObject struct {
	Params SendExtensionChatMessageParams
	Body   *SendExtensionChatMessageJSONRequestBody
}

type SendExtensionChatMessageResponseObject interface {
	VisitSendExtensionChatMessageResponse(w http.ResponseWriter) error
}

type SendExtensionChatMessage204Response struct {
}

func (response SendExtensionChatMessage204Response) VisitSendExtensionChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SendExtensionChatMessage400Response struct {
}

func (response SendExtensionChatMessage400Response) VisitSendExtensionChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendExtensionChatMessage401Response struct {
}

func (response SendExtensionChatMessage401Response) VisitSendExtensionChatMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionConfigurationSegmentRequestObject struct {
	Params GetExtensionConfigurationSegmentParams
}

type GetExtensionConfigurationSegmentResponseObject interface {
	VisitGetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error
}

type GetExtensionConfigurationSegment200JSONResponse GetExtensionConfigurationSegmentResponse

func (response GetExtensionConfigurationSegment200JSONResponse) VisitGetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensionConfigurationSegment400Response struct {
}

func (response GetExtensionConfigurationSegment400Response) VisitGetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensionConfigurationSegment401Response struct {
}

func (response GetExtensionConfigurationSegment401Response) VisitGetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionConfigurationSegment429Response struct {
}

func (response GetExtensionConfigurationSegment429Response) VisitGetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type SetExtensionConfigurationSegmentRequestObject struct {
	Body *SetExtensionConfigurationSegmentJSONRequestBody
}

type SetExtensionConfigurationSegmentResponseObject interface {
	VisitSetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error
}

type SetExtensionConfigurationSegment204Response struct {
}

func (response SetExtensionConfigurationSegment204Response) VisitSetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SetExtensionConfigurationSegment400Response struct {
}

func (response SetExtensionConfigurationSegment400Response) VisitSetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SetExtensionConfigurationSegment401Response struct {
}

func (response SetExtensionConfigurationSegment401Response) VisitSetExtensionConfigurationSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionSecretsRequestObject struct {
}

type GetExtensionSecretsResponseObject interface {
	VisitGetExtensionSecretsResponse(w http.ResponseWriter) error
}

type GetExtensionSecrets200JSONResponse GetExtensionSecretsResponse

func (response GetExtensionSecrets200JSONResponse) VisitGetExtensionSecretsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensionSecrets400Response struct {
}

func (response GetExtensionSecrets400Response) VisitGetExtensionSecretsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensionSecrets401Response struct {
}

func (response GetExtensionSecrets401Response) VisitGetExtensionSecretsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateExtensionSecretRequestObject struct {
	Params CreateExtensionSecretParams
}

type CreateExtensionSecretResponseObject interface {
	VisitCreateExtensionSecretResponse(w http.ResponseWriter) error
}

type CreateExtensionSecret200JSONResponse CreateExtensionSecretResponse

func (response CreateExtensionSecret200JSONResponse) VisitCreateExtensionSecretResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreateExtensionSecret400Response struct {
}

func (response CreateExtensionSecret400Response) VisitCreateExtensionSecretResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateExtensionSecret401Response struct {
}

func (response CreateExtensionSecret401Response) VisitCreateExtensionSecretResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionLiveChannelsRequestObject struct {
	Params GetExtensionLiveChannelsParams
}

type GetExtensionLiveChannelsResponseObject interface {
	VisitGetExtensionLiveChannelsResponse(w http.ResponseWriter) error
}

type GetExtensionLiveChannels200JSONResponse GetExtensionLiveChannelsResponse

func (response GetExtensionLiveChannels200JSONResponse) VisitGetExtensionLiveChannelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensionLiveChannels400Response struct {
}

func (response GetExtensionLiveChannels400Response) VisitGetExtensionLiveChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensionLiveChannels401Response struct {
}

func (response GetExtensionLiveChannels401Response) VisitGetExtensionLiveChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionLiveChannels404Response struct {
}

func (response GetExtensionLiveChannels404Response) VisitGetExtensionLiveChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type SendExtensionPubsubMessageRequestObject struct {
	Body *SendExtensionPubsubMessageJSONRequestBody
}

type SendExtensionPubsubMessageResponseObject interface {
	VisitSendExtensionPubsubMessageResponse(w http.ResponseWriter) error
}

type SendExtensionPubsubMessage204Response struct {
}

func (response SendExtensionPubsubMessage204Response) VisitSendExtensionPubsubMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SendExtensionPubsubMessage400Response struct {
}

func (response SendExtensionPubsubMessage400Response) VisitSendExtensionPubsubMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendExtensionPubsubMessage401Response struct {
}

func (response SendExtensionPubsubMessage401Response) VisitSendExtensionPubsubMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SendExtensionPubsubMessage422Response struct {
}

func (response SendExtensionPubsubMessage422Response) VisitSendExtensionPubsubMessageResponse(w http.ResponseWriter) error {
	w.WriteHeader(422)
	return nil
}

type GetReleasedExtensionsRequestObject struct {
	Params GetReleasedExtensionsParams
}

type GetReleasedExtensionsResponseObject interface {
	VisitGetReleasedExtensionsResponse(w http.ResponseWriter) error
}

type GetReleasedExtensions200JSONResponse GetReleasedExtensionsResponse

func (response GetReleasedExtensions200JSONResponse) VisitGetReleasedExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetReleasedExtensions400Response struct {
}

func (response GetReleasedExtensions400Response) VisitGetReleasedExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetReleasedExtensions401Response struct {
}

func (response GetReleasedExtensions401Response) VisitGetReleasedExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetReleasedExtensions404Response struct {
}

func (response GetReleasedExtensions404Response) VisitGetReleasedExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type SetExtensionRequiredConfigurationRequestObject struct {
	Params SetExtensionRequiredConfigurationParams
	Body   *SetExtensionRequiredConfigurationJSONRequestBody
}

type SetExtensionRequiredConfigurationResponseObject interface {
	VisitSetExtensionRequiredConfigurationResponse(w http.ResponseWriter) error
}

type SetExtensionRequiredConfiguration204Response struct {
}

func (response SetExtensionRequiredConfiguration204Response) VisitSetExtensionRequiredConfigurationResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SetExtensionRequiredConfiguration400Response struct {
}

func (response SetExtensionRequiredConfiguration400Response) VisitSetExtensionRequiredConfigurationResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SetExtensionRequiredConfiguration401Response struct {
}

func (response SetExtensionRequiredConfiguration401Response) VisitSetExtensionRequiredConfigurationResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionTransactionsRequestObject struct {
	Params GetExtensionTransactionsParams
}

type GetExtensionTransactionsResponseObject interface {
	VisitGetExtensionTransactionsResponse(w http.ResponseWriter) error
}

type GetExtensionTransactions200JSONResponse GetExtensionTransactionsResponse

func (response GetExtensionTransactions200JSONResponse) VisitGetExtensionTransactionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetExtensionTransactions400Response struct {
}

func (response GetExtensionTransactions400Response) VisitGetExtensionTransactionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetExtensionTransactions401Response struct {
}

func (response GetExtensionTransactions401Response) VisitGetExtensionTransactionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetExtensionTransactions404Response struct {
}

func (response GetExtensionTransactions404Response) VisitGetExtensionTransactionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetGamesRequestObject struct {
	Params GetGamesParams
}

type GetGamesResponseObject interface {
	VisitGetGamesResponse(w http.ResponseWriter) error
}

type GetGames200JSONResponse GetGamesResponse

func (response GetGames200JSONResponse) VisitGetGamesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetGames400Response struct {
}

func (response GetGames400Response) VisitGetGamesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetGames401Response struct {
}

func (response GetGames401Response) VisitGetGamesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetTopGamesRequestObject struct {
	Params GetTopGamesParams
}

type GetTopGamesResponseObject interface {
	VisitGetTopGamesResponse(w http.ResponseWriter) error
}

type GetTopGames200JSONResponse GetTopGamesResponse

func (response GetTopGames200JSONResponse) VisitGetTopGamesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetTopGames400Response struct {
}

func (response GetTopGames400Response) VisitGetTopGamesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetTopGames401Response struct {
}

func (response GetTopGames401Response) VisitGetTopGamesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetCreatorGoalsRequestObject struct {
	Params GetCreatorGoalsParams
}

type GetCreatorGoalsResponseObject interface {
	VisitGetCreatorGoalsResponse(w http.ResponseWriter) error
}

type GetCreatorGoals200JSONResponse GetCreatorGoalsResponse

func (response GetCreatorGoals200JSONResponse) VisitGetCreatorGoalsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetCreatorGoals400Response struct {
}

func (response GetCreatorGoals400Response) VisitGetCreatorGoalsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetCreatorGoals401Response struct {
}

func (response GetCreatorGoals401Response) VisitGetCreatorGoalsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelGuestStarSettingsRequestObject struct {
	Params GetChannelGuestStarSettingsParams
}

type GetChannelGuestStarSettingsResponseObject interface {
	VisitGetChannelGuestStarSettingsResponse(w http.ResponseWriter) error
}

type GetChannelGuestStarSettings200JSONResponse GetChannelGuestStarSettingsResponse

func (response GetChannelGuestStarSettings200JSONResponse) VisitGetChannelGuestStarSettingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelGuestStarSettings400Response struct {
}

func (response GetChannelGuestStarSettings400Response) VisitGetChannelGuestStarSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelGuestStarSettings403Response struct {
}

func (response GetChannelGuestStarSettings403Response) VisitGetChannelGuestStarSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateChannelGuestStarSettingsRequestObject struct {
	Params UpdateChannelGuestStarSettingsParams
	Body   *UpdateChannelGuestStarSettingsJSONRequestBody
}

type UpdateChannelGuestStarSettingsResponseObject interface {
	VisitUpdateChannelGuestStarSettingsResponse(w http.ResponseWriter) error
}

type UpdateChannelGuestStarSettings204Response struct {
}

func (response UpdateChannelGuestStarSettings204Response) VisitUpdateChannelGuestStarSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UpdateChannelGuestStarSettings400Response struct {
}

func (response UpdateChannelGuestStarSettings400Response) VisitUpdateChannelGuestStarSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteGuestStarInviteRequestObject struct {
	Params DeleteGuestStarInviteParams
}

type DeleteGuestStarInviteResponseObject interface {
	VisitDeleteGuestStarInviteResponse(w http.ResponseWriter) error
}

type DeleteGuestStarInvite204Response struct {
}

func (response DeleteGuestStarInvite204Response) VisitDeleteGuestStarInviteResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteGuestStarInvite400Response struct {
}

func (response DeleteGuestStarInvite400Response) VisitDeleteGuestStarInviteResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteGuestStarInvite404Response struct {
}

func (response DeleteGuestStarInvite404Response) VisitDeleteGuestStarInviteResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetGuestStarInvitesRequestObject struct {
	Params GetGuestStarInvitesParams
}

type GetGuestStarInvitesResponseObject interface {
	VisitGetGuestStarInvitesResponse(w http.ResponseWriter) error
}

type GetGuestStarInvites200JSONResponse GetGuestStarInvitesResponse

func (response GetGuestStarInvites200JSONResponse) VisitGetGuestStarInvitesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetGuestStarInvites400Response struct {
}

func (response GetGuestStarInvites400Response) VisitGetGuestStarInvitesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendGuestStarInviteRequestObject struct {
	Params SendGuestStarInviteParams
}

type SendGuestStarInviteResponseObject interface {
	VisitSendGuestStarInviteResponse(w http.ResponseWriter) error
}

type SendGuestStarInvite204Response struct {
}

func (response SendGuestStarInvite204Response) VisitSendGuestStarInviteResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SendGuestStarInvite400Response struct {
}

func (response SendGuestStarInvite400Response) VisitSendGuestStarInviteResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendGuestStarInvite403Response struct {
}

func (response SendGuestStarInvite403Response) VisitSendGuestStarInviteResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type EndGuestStarSessionRequestObject struct {
	Params EndGuestStarSessionParams
}

type EndGuestStarSessionResponseObject interface {
	VisitEndGuestStarSessionResponse(w http.ResponseWriter) error
}

type EndGuestStarSession204Response struct {
}

func (response EndGuestStarSession204Response) VisitEndGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type EndGuestStarSession400Response struct {
}

func (response EndGuestStarSession400Response) VisitEndGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type EndGuestStarSession403Response struct {
}

func (response EndGuestStarSession403Response) VisitEndGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetGuestStarSessionRequestObject struct {
	Params GetGuestStarSessionParams
}

type GetGuestStarSessionResponseObject interface {
	VisitGetGuestStarSessionResponse(w http.ResponseWriter) error
}

type GetGuestStarSession200JSONResponse GetGuestStarSessionResponse

func (response GetGuestStarSession200JSONResponse) VisitGetGuestStarSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetGuestStarSession400Response struct {
}

func (response GetGuestStarSession400Response) VisitGetGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetGuestStarSession401Response struct {
}

func (response GetGuestStarSession401Response) VisitGetGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateGuestStarSessionRequestObject struct {
	Params CreateGuestStarSessionParams
}

type CreateGuestStarSessionResponseObject interface {
	VisitCreateGuestStarSessionResponse(w http.ResponseWriter) error
}

type CreateGuestStarSession200JSONResponse CreateGuestStarSessionResponse

func (response CreateGuestStarSession200JSONResponse) VisitCreateGuestStarSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreateGuestStarSession400Response struct {
}

func (response CreateGuestStarSession400Response) VisitCreateGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateGuestStarSession401Response struct {
}

func (response CreateGuestStarSession401Response) VisitCreateGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateGuestStarSession403Response struct {
}

func (response CreateGuestStarSession403Response) VisitCreateGuestStarSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DeleteGuestStarSlotRequestObject struct {
	Params DeleteGuestStarSlotParams
}

type DeleteGuestStarSlotResponseObject interface {
	VisitDeleteGuestStarSlotResponse(w http.ResponseWriter) error
}

type DeleteGuestStarSlot204Response struct {
}

func (response DeleteGuestStarSlot204Response) VisitDeleteGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteGuestStarSlot400Response struct {
}

func (response DeleteGuestStarSlot400Response) VisitDeleteGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteGuestStarSlot403Response struct {
}

func (response DeleteGuestStarSlot403Response) VisitDeleteGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DeleteGuestStarSlot404Response struct {
}

func (response DeleteGuestStarSlot404Response) VisitDeleteGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type UpdateGuestStarSlotRequestObject struct {
	Params UpdateGuestStarSlotParams
}

type UpdateGuestStarSlotResponseObject interface {
	VisitUpdateGuestStarSlotResponse(w http.ResponseWriter) error
}

type UpdateGuestStarSlot204Response struct {
}

func (response UpdateGuestStarSlot204Response) VisitUpdateGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UpdateGuestStarSlot400Response struct {
}

func (response UpdateGuestStarSlot400Response) VisitUpdateGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type AssignGuestStarSlotRequestObject struct {
	Params AssignGuestStarSlotParams
}

type AssignGuestStarSlotResponseObject interface {
	VisitAssignGuestStarSlotResponse(w http.ResponseWriter) error
}

type AssignGuestStarSlot204Response struct {
}

func (response AssignGuestStarSlot204Response) VisitAssignGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AssignGuestStarSlot400Response struct {
}

func (response AssignGuestStarSlot400Response) VisitAssignGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type AssignGuestStarSlot401Response struct {
}

func (response AssignGuestStarSlot401Response) VisitAssignGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type AssignGuestStarSlot403Response struct {
}

func (response AssignGuestStarSlot403Response) VisitAssignGuestStarSlotResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateGuestStarSlotSettingsRequestObject struct {
	Params UpdateGuestStarSlotSettingsParams
}

type UpdateGuestStarSlotSettingsResponseObject interface {
	VisitUpdateGuestStarSlotSettingsResponse(w http.ResponseWriter) error
}

type UpdateGuestStarSlotSettings204Response struct {
}

func (response UpdateGuestStarSlotSettings204Response) VisitUpdateGuestStarSlotSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UpdateGuestStarSlotSettings400Response struct {
}

func (response UpdateGuestStarSlotSettings400Response) VisitUpdateGuestStarSlotSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateGuestStarSlotSettings403Response struct {
}

func (response UpdateGuestStarSlotSettings403Response) VisitUpdateGuestStarSlotSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetHypeTrainEventsRequestObject struct {
	Params GetHypeTrainEventsParams
}

type GetHypeTrainEventsResponseObject interface {
	VisitGetHypeTrainEventsResponse(w http.ResponseWriter) error
}

type GetHypeTrainEvents200JSONResponse GetHypeTrainEventsResponse

func (response GetHypeTrainEvents200JSONResponse) VisitGetHypeTrainEventsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetHypeTrainEvents401Response struct {
}

func (response GetHypeTrainEvents401Response) VisitGetHypeTrainEventsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type ManageHeldAutomodMessagesRequestObject struct {
	Body *ManageHeldAutomodMessagesJSONRequestBody
}

type ManageHeldAutomodMessagesResponseObject interface {
	VisitManageHeldAutomodMessagesResponse(w http.ResponseWriter) error
}

type ManageHeldAutomodMessages204Response struct {
}

func (response ManageHeldAutomodMessages204Response) VisitManageHeldAutomodMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type ManageHeldAutomodMessages400Response struct {
}

func (response ManageHeldAutomodMessages400Response) VisitManageHeldAutomodMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type ManageHeldAutomodMessages401Response struct {
}

func (response ManageHeldAutomodMessages401Response) VisitManageHeldAutomodMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type ManageHeldAutomodMessages403Response struct {
}

func (response ManageHeldAutomodMessages403Response) VisitManageHeldAutomodMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type ManageHeldAutomodMessages404Response struct {
}

func (response ManageHeldAutomodMessages404Response) VisitManageHeldAutomodMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetAutomodSettingsRequestObject struct {
	Params GetAutomodSettingsParams
}

type GetAutomodSettingsResponseObject interface {
	VisitGetAutomodSettingsResponse(w http.ResponseWriter) error
}

type GetAutomodSettings200JSONResponse GetAutoModSettingsResponse

func (response GetAutomodSettings200JSONResponse) VisitGetAutomodSettingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetAutomodSettings400Response struct {
}

func (response GetAutomodSettings400Response) VisitGetAutomodSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetAutomodSettings401Response struct {
}

func (response GetAutomodSettings401Response) VisitGetAutomodSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetAutomodSettings403Response struct {
}

func (response GetAutomodSettings403Response) VisitGetAutomodSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateAutomodSettingsRequestObject struct {
	Params UpdateAutomodSettingsParams
	Body   *UpdateAutomodSettingsJSONRequestBody
}

type UpdateAutomodSettingsResponseObject interface {
	VisitUpdateAutomodSettingsResponse(w http.ResponseWriter) error
}

type UpdateAutomodSettings200JSONResponse UpdateAutoModSettingsResponse

func (response UpdateAutomodSettings200JSONResponse) VisitUpdateAutomodSettingsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateAutomodSettings400Response struct {
}

func (response UpdateAutomodSettings400Response) VisitUpdateAutomodSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateAutomodSettings401Response struct {
}

func (response UpdateAutomodSettings401Response) VisitUpdateAutomodSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateAutomodSettings403Response struct {
}

func (response UpdateAutomodSettings403Response) VisitUpdateAutomodSettingsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetBannedUsersRequestObject struct {
	Params GetBannedUsersParams
}

type GetBannedUsersResponseObject interface {
	VisitGetBannedUsersResponse(w http.ResponseWriter) error
}

type GetBannedUsers200JSONResponse GetBannedUsersResponse

func (response GetBannedUsers200JSONResponse) VisitGetBannedUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetBannedUsers400Response struct {
}

func (response GetBannedUsers400Response) VisitGetBannedUsersResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetBannedUsers401Response struct {
}

func (response GetBannedUsers401Response) VisitGetBannedUsersResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UnbanUserRequestObject struct {
	Params UnbanUserParams
}

type UnbanUserResponseObject interface {
	VisitUnbanUserResponse(w http.ResponseWriter) error
}

type UnbanUser204Response struct {
}

func (response UnbanUser204Response) VisitUnbanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UnbanUser400JSONResponse interface{}

func (response UnbanUser400JSONResponse) VisitUnbanUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.MarshalWrite(w, response)
}

type UnbanUser401Response struct {
}

func (response UnbanUser401Response) VisitUnbanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UnbanUser403Response struct {
}

func (response UnbanUser403Response) VisitUnbanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UnbanUser409Response struct {
}

func (response UnbanUser409Response) VisitUnbanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type UnbanUser429Response struct {
}

func (response UnbanUser429Response) VisitUnbanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type BanUserRequestObject struct {
	Params BanUserParams
	Body   *BanUserJSONRequestBody
}

type BanUserResponseObject interface {
	VisitBanUserResponse(w http.ResponseWriter) error
}

type BanUser200JSONResponse BanUserResponse

func (response BanUser200JSONResponse) VisitBanUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type BanUser400JSONResponse interface{}

func (response BanUser400JSONResponse) VisitBanUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.MarshalWrite(w, response)
}

type BanUser401Response struct {
}

func (response BanUser401Response) VisitBanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type BanUser403Response struct {
}

func (response BanUser403Response) VisitBanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type BanUser409Response struct {
}

func (response BanUser409Response) VisitBanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type BanUser429Response struct {
}

func (response BanUser429Response) VisitBanUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type RemoveBlockedTermRequestObject struct {
	Params RemoveBlockedTermParams
}

type RemoveBlockedTermResponseObject interface {
	VisitRemoveBlockedTermResponse(w http.ResponseWriter) error
}

type RemoveBlockedTerm204Response struct {
}

func (response RemoveBlockedTerm204Response) VisitRemoveBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RemoveBlockedTerm400Response struct {
}

func (response RemoveBlockedTerm400Response) VisitRemoveBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type RemoveBlockedTerm401Response struct {
}

func (response RemoveBlockedTerm401Response) VisitRemoveBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type RemoveBlockedTerm403Response struct {
}

func (response RemoveBlockedTerm403Response) VisitRemoveBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetBlockedTermsRequestObject struct {
	Params GetBlockedTermsParams
}

type GetBlockedTermsResponseObject interface {
	VisitGetBlockedTermsResponse(w http.ResponseWriter) error
}

type GetBlockedTerms200JSONResponse GetBlockedTermsResponse

func (response GetBlockedTerms200JSONResponse) VisitGetBlockedTermsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetBlockedTerms400Response struct {
}

func (response GetBlockedTerms400Response) VisitGetBlockedTermsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetBlockedTerms401Response struct {
}

func (response GetBlockedTerms401Response) VisitGetBlockedTermsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetBlockedTerms403Response struct {
}

func (response GetBlockedTerms403Response) VisitGetBlockedTermsResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type AddBlockedTermRequestObject struct {
	Params AddBlockedTermParams
	Body   *AddBlockedTermJSONRequestBody
}

type AddBlockedTermResponseObject interface {
	VisitAddBlockedTermResponse(w http.ResponseWriter) error
}

type AddBlockedTerm200JSONResponse AddBlockedTermResponse

func (response AddBlockedTerm200JSONResponse) VisitAddBlockedTermResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type AddBlockedTerm400Response struct {
}

func (response AddBlockedTerm400Response) VisitAddBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type AddBlockedTerm401Response struct {
}

func (response AddBlockedTerm401Response) VisitAddBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type AddBlockedTerm403Response struct {
}

func (response AddBlockedTerm403Response) VisitAddBlockedTermResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetModeratedChannelsRequestObject struct {
	Params GetModeratedChannelsParams
}

type GetModeratedChannelsResponseObject interface {
	VisitGetModeratedChannelsResponse(w http.ResponseWriter) error
}

type GetModeratedChannels200JSONResponse GetModeratedChannelsResponse

func (response GetModeratedChannels200JSONResponse) VisitGetModeratedChannelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetModeratedChannels400Response struct {
}

func (response GetModeratedChannels400Response) VisitGetModeratedChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetModeratedChannels401Response struct {
}

func (response GetModeratedChannels401Response) VisitGetModeratedChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetModeratedChannels500Response struct {
}

func (response GetModeratedChannels500Response) VisitGetModeratedChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type DeleteChatMessagesRequestObject struct {
	Params DeleteChatMessagesParams
}

type DeleteChatMessagesResponseObject interface {
	VisitDeleteChatMessagesResponse(w http.ResponseWriter) error
}

type DeleteChatMessages204Response struct {
}

func (response DeleteChatMessages204Response) VisitDeleteChatMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteChatMessages400Response struct {
}

func (response DeleteChatMessages400Response) VisitDeleteChatMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteChatMessages401Response struct {
}

func (response DeleteChatMessages401Response) VisitDeleteChatMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type DeleteChatMessages403Response struct {
}

func (response DeleteChatMessages403Response) VisitDeleteChatMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type DeleteChatMessages404Response struct {
}

func (response DeleteChatMessages404Response) VisitDeleteChatMessagesResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CheckAutomodStatusRequestObject struct {
	Params CheckAutomodStatusParams
	Body   *CheckAutomodStatusJSONRequestBody
}

type CheckAutomodStatusResponseObject interface {
	VisitCheckAutomodStatusResponse(w http.ResponseWriter) error
}

type CheckAutomodStatus200JSONResponse CheckAutoModStatusResponse

func (response CheckAutomodStatus200JSONResponse) VisitCheckAutomodStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CheckAutomodStatus400Response struct {
}

func (response CheckAutomodStatus400Response) VisitCheckAutomodStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CheckAutomodStatus401Response struct {
}

func (response CheckAutomodStatus401Response) VisitCheckAutomodStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CheckAutomodStatus403Response struct {
}

func (response CheckAutomodStatus403Response) VisitCheckAutomodStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type CheckAutomodStatus429Response struct {
}

func (response CheckAutomodStatus429Response) VisitCheckAutomodStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type RemoveChannelModeratorRequestObject struct {
	Params RemoveChannelModeratorParams
}

type RemoveChannelModeratorResponseObject interface {
	VisitRemoveChannelModeratorResponse(w http.ResponseWriter) error
}

type RemoveChannelModerator204Response struct {
}

func (response RemoveChannelModerator204Response) VisitRemoveChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type RemoveChannelModerator400Response struct {
}

func (response RemoveChannelModerator400Response) VisitRemoveChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type RemoveChannelModerator401Response struct {
}

func (response RemoveChannelModerator401Response) VisitRemoveChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type RemoveChannelModerator429Response struct {
}

func (response RemoveChannelModerator429Response) VisitRemoveChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetModeratorsRequestObject struct {
	Params GetModeratorsParams
}

type GetModeratorsResponseObject interface {
	VisitGetModeratorsResponse(w http.ResponseWriter) error
}

type GetModerators200JSONResponse GetModeratorsResponse

func (response GetModerators200JSONResponse) VisitGetModeratorsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetModerators400Response struct {
}

func (response GetModerators400Response) VisitGetModeratorsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetModerators401Response struct {
}

func (response GetModerators401Response) VisitGetModeratorsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type AddChannelModeratorRequestObject struct {
	Params AddChannelModeratorParams
}

type AddChannelModeratorResponseObject interface {
	VisitAddChannelModeratorResponse(w http.ResponseWriter) error
}

type AddChannelModerator204Response struct {
}

func (response AddChannelModerator204Response) VisitAddChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type AddChannelModerator400Response struct {
}

func (response AddChannelModerator400Response) VisitAddChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type AddChannelModerator401Response struct {
}

func (response AddChannelModerator401Response) VisitAddChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type AddChannelModerator422Response struct {
}

func (response AddChannelModerator422Response) VisitAddChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(422)
	return nil
}

type AddChannelModerator429Response struct {
}

func (response AddChannelModerator429Response) VisitAddChannelModeratorResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetShieldModeStatusRequestObject struct {
	Params GetShieldModeStatusParams
}

type GetShieldModeStatusResponseObject interface {
	VisitGetShieldModeStatusResponse(w http.ResponseWriter) error
}

type GetShieldModeStatus200JSONResponse GetShieldModeStatusResponse

func (response GetShieldModeStatus200JSONResponse) VisitGetShieldModeStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetShieldModeStatus400Response struct {
}

func (response GetShieldModeStatus400Response) VisitGetShieldModeStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetShieldModeStatus401Response struct {
}

func (response GetShieldModeStatus401Response) VisitGetShieldModeStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetShieldModeStatus403Response struct {
}

func (response GetShieldModeStatus403Response) VisitGetShieldModeStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateShieldModeStatusRequestObject struct {
	Params UpdateShieldModeStatusParams
	Body   *UpdateShieldModeStatusJSONRequestBody
}

type UpdateShieldModeStatusResponseObject interface {
	VisitUpdateShieldModeStatusResponse(w http.ResponseWriter) error
}

type UpdateShieldModeStatus200JSONResponse UpdateShieldModeStatusResponse

func (response UpdateShieldModeStatus200JSONResponse) VisitUpdateShieldModeStatusResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateShieldModeStatus400Response struct {
}

func (response UpdateShieldModeStatus400Response) VisitUpdateShieldModeStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateShieldModeStatus401Response struct {
}

func (response UpdateShieldModeStatus401Response) VisitUpdateShieldModeStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateShieldModeStatus403Response struct {
}

func (response UpdateShieldModeStatus403Response) VisitUpdateShieldModeStatusResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetUnbanRequestsRequestObject struct {
	Params GetUnbanRequestsParams
}

type GetUnbanRequestsResponseObject interface {
	VisitGetUnbanRequestsResponse(w http.ResponseWriter) error
}

type GetUnbanRequests200JSONResponse GetUnbanRequestsResponse

func (response GetUnbanRequests200JSONResponse) VisitGetUnbanRequestsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUnbanRequests400Response struct {
}

func (response GetUnbanRequests400Response) VisitGetUnbanRequestsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetUnbanRequests401Response struct {
}

func (response GetUnbanRequests401Response) VisitGetUnbanRequestsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type ResolveUnbanRequestsRequestObject struct {
	Params ResolveUnbanRequestsParams
}

type ResolveUnbanRequestsResponseObject interface {
	VisitResolveUnbanRequestsResponse(w http.ResponseWriter) error
}

type ResolveUnbanRequests200JSONResponse ResolveUnbanRequestsResponse

func (response ResolveUnbanRequests200JSONResponse) VisitResolveUnbanRequestsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type ResolveUnbanRequests400Response struct {
}

func (response ResolveUnbanRequests400Response) VisitResolveUnbanRequestsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type ResolveUnbanRequests401Response struct {
}

func (response ResolveUnbanRequests401Response) VisitResolveUnbanRequestsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type ResolveUnbanRequests404Response struct {
}

func (response ResolveUnbanRequests404Response) VisitResolveUnbanRequestsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type WarnChatUserRequestObject struct {
	Params WarnChatUserParams
	Body   *WarnChatUserJSONRequestBody
}

type WarnChatUserResponseObject interface {
	VisitWarnChatUserResponse(w http.ResponseWriter) error
}

type WarnChatUser200JSONResponse WarnChatUserResponse

func (response WarnChatUser200JSONResponse) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type WarnChatUser400Response struct {
}

func (response WarnChatUser400Response) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type WarnChatUser401Response struct {
}

func (response WarnChatUser401Response) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type WarnChatUser403Response struct {
}

func (response WarnChatUser403Response) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type WarnChatUser409Response struct {
}

func (response WarnChatUser409Response) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type WarnChatUser429Response struct {
}

func (response WarnChatUser429Response) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type WarnChatUser500Response struct {
}

func (response WarnChatUser500Response) VisitWarnChatUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetPollsRequestObject struct {
	Params GetPollsParams
}

type GetPollsResponseObject interface {
	VisitGetPollsResponse(w http.ResponseWriter) error
}

type GetPolls200JSONResponse GetPollsResponse

func (response GetPolls200JSONResponse) VisitGetPollsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetPolls400Response struct {
}

func (response GetPolls400Response) VisitGetPollsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetPolls401Response struct {
}

func (response GetPolls401Response) VisitGetPollsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetPolls404Response struct {
}

func (response GetPolls404Response) VisitGetPollsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type EndPollRequestObject struct {
	Body *EndPollJSONRequestBody
}

type EndPollResponseObject interface {
	VisitEndPollResponse(w http.ResponseWriter) error
}

type EndPoll200JSONResponse EndPollResponse

func (response EndPoll200JSONResponse) VisitEndPollResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type EndPoll400Response struct {
}

func (response EndPoll400Response) VisitEndPollResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type EndPoll401Response struct {
}

func (response EndPoll401Response) VisitEndPollResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreatePollRequestObject struct {
	Body *CreatePollJSONRequestBody
}

type CreatePollResponseObject interface {
	VisitCreatePollResponse(w http.ResponseWriter) error
}

type CreatePoll200JSONResponse CreatePollResponse

func (response CreatePoll200JSONResponse) VisitCreatePollResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreatePoll400Response struct {
}

func (response CreatePoll400Response) VisitCreatePollResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreatePoll401Response struct {
}

func (response CreatePoll401Response) VisitCreatePollResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetPredictionsRequestObject struct {
	Params GetPredictionsParams
}

type GetPredictionsResponseObject interface {
	VisitGetPredictionsResponse(w http.ResponseWriter) error
}

type GetPredictions200JSONResponse GetPredictionsResponse

func (response GetPredictions200JSONResponse) VisitGetPredictionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetPredictions400Response struct {
}

func (response GetPredictions400Response) VisitGetPredictionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetPredictions401Response struct {
}

func (response GetPredictions401Response) VisitGetPredictionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type EndPredictionRequestObject struct {
	Body *EndPredictionJSONRequestBody
}

type EndPredictionResponseObject interface {
	VisitEndPredictionResponse(w http.ResponseWriter) error
}

type EndPrediction200JSONResponse EndPredictionResponse

func (response EndPrediction200JSONResponse) VisitEndPredictionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type EndPrediction400Response struct {
}

func (response EndPrediction400Response) VisitEndPredictionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type EndPrediction401Response struct {
}

func (response EndPrediction401Response) VisitEndPredictionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type EndPrediction404Response struct {
}

func (response EndPrediction404Response) VisitEndPredictionResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CreatePredictionRequestObject struct {
	Body *CreatePredictionJSONRequestBody
}

type CreatePredictionResponseObject interface {
	VisitCreatePredictionResponse(w http.ResponseWriter) error
}

type CreatePrediction200JSONResponse CreatePredictionResponse

func (response CreatePrediction200JSONResponse) VisitCreatePredictionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreatePrediction400Response struct {
}

func (response CreatePrediction400Response) VisitCreatePredictionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreatePrediction401Response struct {
}

func (response CreatePrediction401Response) VisitCreatePredictionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreatePrediction429Response struct {
}

func (response CreatePrediction429Response) VisitCreatePredictionResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type CancelARaidRequestObject struct {
	Params CancelARaidParams
}

type CancelARaidResponseObject interface {
	VisitCancelARaidResponse(w http.ResponseWriter) error
}

type CancelARaid204Response struct {
}

func (response CancelARaid204Response) VisitCancelARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type CancelARaid400Response struct {
}

func (response CancelARaid400Response) VisitCancelARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CancelARaid401Response struct {
}

func (response CancelARaid401Response) VisitCancelARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CancelARaid404Response struct {
}

func (response CancelARaid404Response) VisitCancelARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CancelARaid429Response struct {
}

func (response CancelARaid429Response) VisitCancelARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type StartARaidRequestObject struct {
	Params StartARaidParams
}

type StartARaidResponseObject interface {
	VisitStartARaidResponse(w http.ResponseWriter) error
}

type StartARaid200JSONResponse StartRaidResponse

func (response StartARaid200JSONResponse) VisitStartARaidResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type StartARaid400Response struct {
}

func (response StartARaid400Response) VisitStartARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type StartARaid401Response struct {
}

func (response StartARaid401Response) VisitStartARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type StartARaid404Response struct {
}

func (response StartARaid404Response) VisitStartARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type StartARaid409Response struct {
}

func (response StartARaid409Response) VisitStartARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(409)
	return nil
}

type StartARaid429Response struct {
}

func (response StartARaid429Response) VisitStartARaidResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

type GetChannelStreamScheduleRequestObject struct {
	Params GetChannelStreamScheduleParams
}

type GetChannelStreamScheduleResponseObject interface {
	VisitGetChannelStreamScheduleResponse(w http.ResponseWriter) error
}

type GetChannelStreamSchedule200JSONResponse GetChannelStreamScheduleResponse

func (response GetChannelStreamSchedule200JSONResponse) VisitGetChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelStreamSchedule400Response struct {
}

func (response GetChannelStreamSchedule400Response) VisitGetChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelStreamSchedule401Response struct {
}

func (response GetChannelStreamSchedule401Response) VisitGetChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelStreamSchedule403Response struct {
}

func (response GetChannelStreamSchedule403Response) VisitGetChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetChannelStreamSchedule404Response struct {
}

func (response GetChannelStreamSchedule404Response) VisitGetChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetChannelIcalendarRequestObject struct {
	Params GetChannelIcalendarParams
}

type GetChannelIcalendarResponseObject interface {
	VisitGetChannelIcalendarResponse(w http.ResponseWriter) error
}

type GetChannelIcalendar200TextcalendarResponse struct {
	Body          io.Reader
	ContentLength int64
}

func (response GetChannelIcalendar200TextcalendarResponse) VisitGetChannelIcalendarResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "text/calendar")
	if response.ContentLength != 0 {
		w.Header().Set("Content-Length", fmt.Sprint(response.ContentLength))
	}
	w.WriteHeader(200)

	if closer, ok := response.Body.(io.ReadCloser); ok {
		defer closer.Close()
	}
	_, err := io.Copy(w, response.Body)
	return err
}

type GetChannelIcalendar400Response struct {
}

func (response GetChannelIcalendar400Response) VisitGetChannelIcalendarResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteChannelStreamScheduleSegmentRequestObject struct {
	Params DeleteChannelStreamScheduleSegmentParams
}

type DeleteChannelStreamScheduleSegmentResponseObject interface {
	VisitDeleteChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error
}

type DeleteChannelStreamScheduleSegment204Response struct {
}

func (response DeleteChannelStreamScheduleSegment204Response) VisitDeleteChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type DeleteChannelStreamScheduleSegment400Response struct {
}

func (response DeleteChannelStreamScheduleSegment400Response) VisitDeleteChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteChannelStreamScheduleSegment401Response struct {
}

func (response DeleteChannelStreamScheduleSegment401Response) VisitDeleteChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateChannelStreamScheduleSegmentRequestObject struct {
	Params UpdateChannelStreamScheduleSegmentParams
	Body   *UpdateChannelStreamScheduleSegmentJSONRequestBody
}

type UpdateChannelStreamScheduleSegmentResponseObject interface {
	VisitUpdateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error
}

type UpdateChannelStreamScheduleSegment200JSONResponse UpdateChannelStreamScheduleSegmentResponse

func (response UpdateChannelStreamScheduleSegment200JSONResponse) VisitUpdateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateChannelStreamScheduleSegment400Response struct {
}

func (response UpdateChannelStreamScheduleSegment400Response) VisitUpdateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateChannelStreamScheduleSegment401Response struct {
}

func (response UpdateChannelStreamScheduleSegment401Response) VisitUpdateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateChannelStreamScheduleSegment404Response struct {
}

func (response UpdateChannelStreamScheduleSegment404Response) VisitUpdateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CreateChannelStreamScheduleSegmentRequestObject struct {
	Params CreateChannelStreamScheduleSegmentParams
	Body   *CreateChannelStreamScheduleSegmentJSONRequestBody
}

type CreateChannelStreamScheduleSegmentResponseObject interface {
	VisitCreateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error
}

type CreateChannelStreamScheduleSegment200JSONResponse CreateChannelStreamScheduleSegmentResponse

func (response CreateChannelStreamScheduleSegment200JSONResponse) VisitCreateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreateChannelStreamScheduleSegment400Response struct {
}

func (response CreateChannelStreamScheduleSegment400Response) VisitCreateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateChannelStreamScheduleSegment401Response struct {
}

func (response CreateChannelStreamScheduleSegment401Response) VisitCreateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateChannelStreamScheduleSegment403Response struct {
}

func (response CreateChannelStreamScheduleSegment403Response) VisitCreateChannelStreamScheduleSegmentResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type UpdateChannelStreamScheduleRequestObject struct {
	Params UpdateChannelStreamScheduleParams
}

type UpdateChannelStreamScheduleResponseObject interface {
	VisitUpdateChannelStreamScheduleResponse(w http.ResponseWriter) error
}

type UpdateChannelStreamSchedule204Response struct {
}

func (response UpdateChannelStreamSchedule204Response) VisitUpdateChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UpdateChannelStreamSchedule400Response struct {
}

func (response UpdateChannelStreamSchedule400Response) VisitUpdateChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateChannelStreamSchedule401Response struct {
}

func (response UpdateChannelStreamSchedule401Response) VisitUpdateChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateChannelStreamSchedule404Response struct {
}

func (response UpdateChannelStreamSchedule404Response) VisitUpdateChannelStreamScheduleResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type SearchCategoriesRequestObject struct {
	Params SearchCategoriesParams
}

type SearchCategoriesResponseObject interface {
	VisitSearchCategoriesResponse(w http.ResponseWriter) error
}

type SearchCategories200JSONResponse SearchCategoriesResponse

func (response SearchCategories200JSONResponse) VisitSearchCategoriesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type SearchCategories400Response struct {
}

func (response SearchCategories400Response) VisitSearchCategoriesResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SearchCategories401Response struct {
}

func (response SearchCategories401Response) VisitSearchCategoriesResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SearchChannelsRequestObject struct {
	Params SearchChannelsParams
}

type SearchChannelsResponseObject interface {
	VisitSearchChannelsResponse(w http.ResponseWriter) error
}

type SearchChannels200JSONResponse SearchChannelsResponse

func (response SearchChannels200JSONResponse) VisitSearchChannelsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type SearchChannels400Response struct {
}

func (response SearchChannels400Response) VisitSearchChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SearchChannels401Response struct {
}

func (response SearchChannels401Response) VisitSearchChannelsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetSharedChatSessionRequestObject struct {
	Params GetSharedChatSessionParams
}

type GetSharedChatSessionResponseObject interface {
	VisitGetSharedChatSessionResponse(w http.ResponseWriter) error
}

type GetSharedChatSession200JSONResponse GetSharedChatSessionResponse

func (response GetSharedChatSession200JSONResponse) VisitGetSharedChatSessionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetSharedChatSession400Response struct {
}

func (response GetSharedChatSession400Response) VisitGetSharedChatSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetSharedChatSession401Response struct {
}

func (response GetSharedChatSession401Response) VisitGetSharedChatSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetSharedChatSession500Response struct {
}

func (response GetSharedChatSession500Response) VisitGetSharedChatSessionResponse(w http.ResponseWriter) error {
	w.WriteHeader(500)
	return nil
}

type GetStreamsRequestObject struct {
	Params GetStreamsParams
}

type GetStreamsResponseObject interface {
	VisitGetStreamsResponse(w http.ResponseWriter) error
}

type GetStreams200JSONResponse GetStreamsResponse

func (response GetStreams200JSONResponse) VisitGetStreamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetStreams400Response struct {
}

func (response GetStreams400Response) VisitGetStreamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetStreams401Response struct {
}

func (response GetStreams401Response) VisitGetStreamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetFollowedStreamsRequestObject struct {
	Params GetFollowedStreamsParams
}

type GetFollowedStreamsResponseObject interface {
	VisitGetFollowedStreamsResponse(w http.ResponseWriter) error
}

type GetFollowedStreams200JSONResponse GetFollowedStreamsResponse

func (response GetFollowedStreams200JSONResponse) VisitGetFollowedStreamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetFollowedStreams400Response struct {
}

func (response GetFollowedStreams400Response) VisitGetFollowedStreamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetFollowedStreams401Response struct {
}

func (response GetFollowedStreams401Response) VisitGetFollowedStreamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetStreamKeyRequestObject struct {
	Params GetStreamKeyParams
}

type GetStreamKeyResponseObject interface {
	VisitGetStreamKeyResponse(w http.ResponseWriter) error
}

type GetStreamKey200JSONResponse GetStreamKeyResponse

func (response GetStreamKey200JSONResponse) VisitGetStreamKeyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetStreamKey400Response struct {
}

func (response GetStreamKey400Response) VisitGetStreamKeyResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetStreamKey401Response struct {
}

func (response GetStreamKey401Response) VisitGetStreamKeyResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetStreamKey403Response struct {
}

func (response GetStreamKey403Response) VisitGetStreamKeyResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetStreamMarkersRequestObject struct {
	Params GetStreamMarkersParams
}

type GetStreamMarkersResponseObject interface {
	VisitGetStreamMarkersResponse(w http.ResponseWriter) error
}

type GetStreamMarkers200JSONResponse GetStreamMarkersResponse

func (response GetStreamMarkers200JSONResponse) VisitGetStreamMarkersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetStreamMarkers400Response struct {
}

func (response GetStreamMarkers400Response) VisitGetStreamMarkersResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetStreamMarkers401Response struct {
}

func (response GetStreamMarkers401Response) VisitGetStreamMarkersResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetStreamMarkers403Response struct {
}

func (response GetStreamMarkers403Response) VisitGetStreamMarkersResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type GetStreamMarkers404Response struct {
}

func (response GetStreamMarkers404Response) VisitGetStreamMarkersResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type CreateStreamMarkerRequestObject struct {
	Body *CreateStreamMarkerJSONRequestBody
}

type CreateStreamMarkerResponseObject interface {
	VisitCreateStreamMarkerResponse(w http.ResponseWriter) error
}

type CreateStreamMarker200JSONResponse CreateStreamMarkerResponse

func (response CreateStreamMarker200JSONResponse) VisitCreateStreamMarkerResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CreateStreamMarker400Response struct {
}

func (response CreateStreamMarker400Response) VisitCreateStreamMarkerResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CreateStreamMarker401Response struct {
}

func (response CreateStreamMarker401Response) VisitCreateStreamMarkerResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CreateStreamMarker403Response struct {
}

func (response CreateStreamMarker403Response) VisitCreateStreamMarkerResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type CreateStreamMarker404Response struct {
}

func (response CreateStreamMarker404Response) VisitCreateStreamMarkerResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetStreamTagsRequestObject struct {
	Params GetStreamTagsParams
}

type GetStreamTagsResponseObject interface {
	VisitGetStreamTagsResponse(w http.ResponseWriter) error
}

type GetStreamTags200JSONResponse GetStreamTagsResponse

func (response GetStreamTags200JSONResponse) VisitGetStreamTagsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetStreamTags400Response struct {
}

func (response GetStreamTags400Response) VisitGetStreamTagsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetStreamTags401Response struct {
}

func (response GetStreamTags401Response) VisitGetStreamTagsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetBroadcasterSubscriptionsRequestObject struct {
	Params GetBroadcasterSubscriptionsParams
}

type GetBroadcasterSubscriptionsResponseObject interface {
	VisitGetBroadcasterSubscriptionsResponse(w http.ResponseWriter) error
}

type GetBroadcasterSubscriptions200JSONResponse GetBroadcasterSubscriptionsResponse

func (response GetBroadcasterSubscriptions200JSONResponse) VisitGetBroadcasterSubscriptionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetBroadcasterSubscriptions400Response struct {
}

func (response GetBroadcasterSubscriptions400Response) VisitGetBroadcasterSubscriptionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetBroadcasterSubscriptions401Response struct {
}

func (response GetBroadcasterSubscriptions401Response) VisitGetBroadcasterSubscriptionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CheckUserSubscriptionRequestObject struct {
	Params CheckUserSubscriptionParams
}

type CheckUserSubscriptionResponseObject interface {
	VisitCheckUserSubscriptionResponse(w http.ResponseWriter) error
}

type CheckUserSubscription200JSONResponse CheckUserSubscriptionResponse

func (response CheckUserSubscription200JSONResponse) VisitCheckUserSubscriptionResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type CheckUserSubscription400Response struct {
}

func (response CheckUserSubscription400Response) VisitCheckUserSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type CheckUserSubscription401Response struct {
}

func (response CheckUserSubscription401Response) VisitCheckUserSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type CheckUserSubscription404Response struct {
}

func (response CheckUserSubscription404Response) VisitCheckUserSubscriptionResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetAllStreamTagsRequestObject struct {
	Params GetAllStreamTagsParams
}

type GetAllStreamTagsResponseObject interface {
	VisitGetAllStreamTagsResponse(w http.ResponseWriter) error
}

type GetAllStreamTags200JSONResponse GetAllStreamTagsResponse

func (response GetAllStreamTags200JSONResponse) VisitGetAllStreamTagsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetAllStreamTags400Response struct {
}

func (response GetAllStreamTags400Response) VisitGetAllStreamTagsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetAllStreamTags401Response struct {
}

func (response GetAllStreamTags401Response) VisitGetAllStreamTagsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetTeamsRequestObject struct {
	Params GetTeamsParams
}

type GetTeamsResponseObject interface {
	VisitGetTeamsResponse(w http.ResponseWriter) error
}

type GetTeams200JSONResponse GetTeamsResponse

func (response GetTeams200JSONResponse) VisitGetTeamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetTeams400Response struct {
}

func (response GetTeams400Response) VisitGetTeamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetTeams401Response struct {
}

func (response GetTeams401Response) VisitGetTeamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetTeams404Response struct {
}

func (response GetTeams404Response) VisitGetTeamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetChannelTeamsRequestObject struct {
	Params GetChannelTeamsParams
}

type GetChannelTeamsResponseObject interface {
	VisitGetChannelTeamsResponse(w http.ResponseWriter) error
}

type GetChannelTeams200JSONResponse GetChannelTeamsResponse

func (response GetChannelTeams200JSONResponse) VisitGetChannelTeamsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetChannelTeams400Response struct {
}

func (response GetChannelTeams400Response) VisitGetChannelTeamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetChannelTeams401Response struct {
}

func (response GetChannelTeams401Response) VisitGetChannelTeamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetChannelTeams404Response struct {
}

func (response GetChannelTeams404Response) VisitGetChannelTeamsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetUsersRequestObject struct {
	Params GetUsersParams
}

type GetUsersResponseObject interface {
	VisitGetUsersResponse(w http.ResponseWriter) error
}

type GetUsers200JSONResponse GetUsersResponse

func (response GetUsers200JSONResponse) VisitGetUsersResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUsers400Response struct {
}

func (response GetUsers400Response) VisitGetUsersResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetUsers401Response struct {
}

func (response GetUsers401Response) VisitGetUsersResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateUserRequestObject struct {
	Params UpdateUserParams
}

type UpdateUserResponseObject interface {
	VisitUpdateUserResponse(w http.ResponseWriter) error
}

type UpdateUser200JSONResponse UpdateUserResponse

func (response UpdateUser200JSONResponse) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateUser400Response struct {
}

func (response UpdateUser400Response) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateUser401Response struct {
}

func (response UpdateUser401Response) VisitUpdateUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UnblockUserRequestObject struct {
	Params UnblockUserParams
}

type UnblockUserResponseObject interface {
	VisitUnblockUserResponse(w http.ResponseWriter) error
}

type UnblockUser204Response struct {
}

func (response UnblockUser204Response) VisitUnblockUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type UnblockUser400Response struct {
}

func (response UnblockUser400Response) VisitUnblockUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UnblockUser401Response struct {
}

func (response UnblockUser401Response) VisitUnblockUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetUserBlockListRequestObject struct {
	Params GetUserBlockListParams
}

type GetUserBlockListResponseObject interface {
	VisitGetUserBlockListResponse(w http.ResponseWriter) error
}

type GetUserBlockList200JSONResponse GetUserBlockListResponse

func (response GetUserBlockList200JSONResponse) VisitGetUserBlockListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUserBlockList400Response struct {
}

func (response GetUserBlockList400Response) VisitGetUserBlockListResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetUserBlockList401Response struct {
}

func (response GetUserBlockList401Response) VisitGetUserBlockListResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type BlockUserRequestObject struct {
	Params BlockUserParams
}

type BlockUserResponseObject interface {
	VisitBlockUserResponse(w http.ResponseWriter) error
}

type BlockUser204Response struct {
}

func (response BlockUser204Response) VisitBlockUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type BlockUser400Response struct {
}

func (response BlockUser400Response) VisitBlockUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type BlockUser401Response struct {
}

func (response BlockUser401Response) VisitBlockUserResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetUserActiveExtensionsRequestObject struct {
	Params GetUserActiveExtensionsParams
}

type GetUserActiveExtensionsResponseObject interface {
	VisitGetUserActiveExtensionsResponse(w http.ResponseWriter) error
}

type GetUserActiveExtensions200JSONResponse GetUserActiveExtensionsResponse

func (response GetUserActiveExtensions200JSONResponse) VisitGetUserActiveExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUserActiveExtensions400Response struct {
}

func (response GetUserActiveExtensions400Response) VisitGetUserActiveExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetUserActiveExtensions401Response struct {
}

func (response GetUserActiveExtensions401Response) VisitGetUserActiveExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateUserExtensionsRequestObject struct {
	Body *UpdateUserExtensionsJSONRequestBody
}

type UpdateUserExtensionsResponseObject interface {
	VisitUpdateUserExtensionsResponse(w http.ResponseWriter) error
}

type UpdateUserExtensions200JSONResponse UpdateUserExtensionsResponse

func (response UpdateUserExtensions200JSONResponse) VisitUpdateUserExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type UpdateUserExtensions400Response struct {
}

func (response UpdateUserExtensions400Response) VisitUpdateUserExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type UpdateUserExtensions401Response struct {
}

func (response UpdateUserExtensions401Response) VisitUpdateUserExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type UpdateUserExtensions404Response struct {
}

func (response UpdateUserExtensions404Response) VisitUpdateUserExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type GetUserExtensionsRequestObject struct {
}

type GetUserExtensionsResponseObject interface {
	VisitGetUserExtensionsResponse(w http.ResponseWriter) error
}

type GetUserExtensions200JSONResponse GetUserExtensionsResponse

func (response GetUserExtensions200JSONResponse) VisitGetUserExtensionsResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetUserExtensions401Response struct {
}

func (response GetUserExtensions401Response) VisitGetUserExtensionsResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type DeleteVideosRequestObject struct {
	Params DeleteVideosParams
}

type DeleteVideosResponseObject interface {
	VisitDeleteVideosResponse(w http.ResponseWriter) error
}

type DeleteVideos200JSONResponse DeleteVideosResponse

func (response DeleteVideos200JSONResponse) VisitDeleteVideosResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type DeleteVideos400Response struct {
}

func (response DeleteVideos400Response) VisitDeleteVideosResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type DeleteVideos401Response struct {
}

func (response DeleteVideos401Response) VisitDeleteVideosResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetVideosRequestObject struct {
	Params GetVideosParams
}

type GetVideosResponseObject interface {
	VisitGetVideosResponse(w http.ResponseWriter) error
}

type GetVideos200JSONResponse GetVideosResponse

func (response GetVideos200JSONResponse) VisitGetVideosResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.MarshalWrite(w, response)
}

type GetVideos400Response struct {
}

func (response GetVideos400Response) VisitGetVideosResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type GetVideos401Response struct {
}

func (response GetVideos401Response) VisitGetVideosResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type GetVideos404Response struct {
}

func (response GetVideos404Response) VisitGetVideosResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type SendWhisperRequestObject struct {
	Params SendWhisperParams
	Body   *SendWhisperJSONRequestBody
}

type SendWhisperResponseObject interface {
	VisitSendWhisperResponse(w http.ResponseWriter) error
}

type SendWhisper204Response struct {
}

func (response SendWhisper204Response) VisitSendWhisperResponse(w http.ResponseWriter) error {
	w.WriteHeader(204)
	return nil
}

type SendWhisper400Response struct {
}

func (response SendWhisper400Response) VisitSendWhisperResponse(w http.ResponseWriter) error {
	w.WriteHeader(400)
	return nil
}

type SendWhisper401Response struct {
}

func (response SendWhisper401Response) VisitSendWhisperResponse(w http.ResponseWriter) error {
	w.WriteHeader(401)
	return nil
}

type SendWhisper403Response struct {
}

func (response SendWhisper403Response) VisitSendWhisperResponse(w http.ResponseWriter) error {
	w.WriteHeader(403)
	return nil
}

type SendWhisper404Response struct {
}

func (response SendWhisper404Response) VisitSendWhisperResponse(w http.ResponseWriter) error {
	w.WriteHeader(404)
	return nil
}

type SendWhisper429Response struct {
}

func (response SendWhisper429Response) VisitSendWhisperResponse(w http.ResponseWriter) error {
	w.WriteHeader(429)
	return nil
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// Gets an analytics report for one or more extensions.
	// (GET /analytics/extensions)
	GetExtensionAnalytics(ctx context.Context, request GetExtensionAnalyticsRequestObject) (GetExtensionAnalyticsResponseObject, error)
	// Gets an analytics report for one or more games.
	// (GET /analytics/games)
	GetGameAnalytics(ctx context.Context, request GetGameAnalyticsRequestObject) (GetGameAnalyticsResponseObject, error)
	// Gets a list of Cheermotes that users can use to cheer Bits.
	// (GET /bits/cheermotes)
	GetCheermotes(ctx context.Context, request GetCheermotesRequestObject) (GetCheermotesResponseObject, error)
	// Gets the list of Bits products that belongs to the extension.
	// (GET /bits/extensions)
	GetExtensionBitsProducts(ctx context.Context, request GetExtensionBitsProductsRequestObject) (GetExtensionBitsProductsResponseObject, error)
	// Adds or updates a Bits product that the extension created.
	// (PUT /bits/extensions)
	UpdateExtensionBitsProduct(ctx context.Context, request UpdateExtensionBitsProductRequestObject) (UpdateExtensionBitsProductResponseObject, error)
	// Gets the Bits leaderboard for the authenticated broadcaster.
	// (GET /bits/leaderboard)
	GetBitsLeaderboard(ctx context.Context, request GetBitsLeaderboardRequestObject) (GetBitsLeaderboardResponseObject, error)
	// Deletes a custom reward that the broadcaster created.
	// (DELETE /channel_points/custom_rewards)
	DeleteCustomReward(ctx context.Context, request DeleteCustomRewardRequestObject) (DeleteCustomRewardResponseObject, error)
	// Gets a list of custom rewards that the specified broadcaster created.
	// (GET /channel_points/custom_rewards)
	GetCustomReward(ctx context.Context, request GetCustomRewardRequestObject) (GetCustomRewardResponseObject, error)
	// Updates a custom reward.
	// (PATCH /channel_points/custom_rewards)
	UpdateCustomReward(ctx context.Context, request UpdateCustomRewardRequestObject) (UpdateCustomRewardResponseObject, error)
	// Creates a Custom Reward in the broadcasters channel.
	// (POST /channel_points/custom_rewards)
	CreateCustomRewards(ctx context.Context, request CreateCustomRewardsRequestObject) (CreateCustomRewardsResponseObject, error)
	// Gets a list of redemptions for a custom reward.
	// (GET /channel_points/custom_rewards/redemptions)
	GetCustomRewardRedemption(ctx context.Context, request GetCustomRewardRedemptionRequestObject) (GetCustomRewardRedemptionResponseObject, error)
	// Updates a redemptions status.
	// (PATCH /channel_points/custom_rewards/redemptions)
	UpdateRedemptionStatus(ctx context.Context, request UpdateRedemptionStatusRequestObject) (UpdateRedemptionStatusResponseObject, error)
	// Gets information about one or more channels.
	// (GET /channels)
	GetChannelInformation(ctx context.Context, request GetChannelInformationRequestObject) (GetChannelInformationResponseObject, error)
	// Updates a channels properties.
	// (PATCH /channels)
	ModifyChannelInformation(ctx context.Context, request ModifyChannelInformationRequestObject) (ModifyChannelInformationResponseObject, error)
	// Returns ad schedule related information.
	// (GET /channels/ads)
	GetAdSchedule(ctx context.Context, request GetAdScheduleRequestObject) (GetAdScheduleResponseObject, error)
	// Pushes back the timestamp of the upcoming automatic mid-roll ad by 5 minutes.
	// (POST /channels/ads/schedule/snooze)
	SnoozeNextAd(ctx context.Context, request SnoozeNextAdRequestObject) (SnoozeNextAdResponseObject, error)
	// Starts a commercial on the specified channel.
	// (POST /channels/commercial)
	StartCommercial(ctx context.Context, request StartCommercialRequestObject) (StartCommercialResponseObject, error)
	// Gets the broadcasters list editors.
	// (GET /channels/editors)
	GetChannelEditors(ctx context.Context, request GetChannelEditorsRequestObject) (GetChannelEditorsResponseObject, error)
	// Gets a list of broadcasters that the specified user follows. You can also use this endpoint to see whether a user follows a specific broadcaster.
	// (GET /channels/followed)
	GetFollowedChannels(ctx context.Context, request GetFollowedChannelsRequestObject) (GetFollowedChannelsResponseObject, error)
	// Gets a list of users that follow the specified broadcaster. You can also use this endpoint to see whether a specific user follows the broadcaster.
	// (GET /channels/followers)
	GetChannelFollowers(ctx context.Context, request GetChannelFollowersRequestObject) (GetChannelFollowersResponseObject, error)
	// Removes the specified user as a VIP in the broadcasters channel.
	// (DELETE /channels/vips)
	RemoveChannelVip(ctx context.Context, request RemoveChannelVipRequestObject) (RemoveChannelVipResponseObject, error)
	// Gets a list of the broadcasters VIPs.
	// (GET /channels/vips)
	GetVips(ctx context.Context, request GetVipsRequestObject) (GetVipsResponseObject, error)
	// Adds the specified user as a VIP in the broadcasters channel.
	// (POST /channels/vips)
	AddChannelVip(ctx context.Context, request AddChannelVipRequestObject) (AddChannelVipResponseObject, error)
	// Gets information about the broadcasters active charity campaign.
	// (GET /charity/campaigns)
	GetCharityCampaign(ctx context.Context, request GetCharityCampaignRequestObject) (GetCharityCampaignResponseObject, error)
	// Gets the list of donations that users have made to the broadcasters active charity campaign.
	// (GET /charity/donations)
	GetCharityCampaignDonations(ctx context.Context, request GetCharityCampaignDonationsRequestObject) (GetCharityCampaignDonationsResponseObject, error)
	// Sends an announcement to the broadcasters chat room.
	// (POST /chat/announcements)
	SendChatAnnouncement(ctx context.Context, request SendChatAnnouncementRequestObject) (SendChatAnnouncementResponseObject, error)
	// Gets the broadcasters list of custom chat badges.
	// (GET /chat/badges)
	GetChannelChatBadges(ctx context.Context, request GetChannelChatBadgesRequestObject) (GetChannelChatBadgesResponseObject, error)
	// Gets Twitchs list of chat badges.
	// (GET /chat/badges/global)
	GetGlobalChatBadges(ctx context.Context, request GetGlobalChatBadgesRequestObject) (GetGlobalChatBadgesResponseObject, error)
	// Gets the list of users that are connected to the broadcasters chat session.
	// (GET /chat/chatters)
	GetChatters(ctx context.Context, request GetChattersRequestObject) (GetChattersResponseObject, error)
	// Gets the color used for the users name in chat.
	// (GET /chat/color)
	GetUserChatColor(ctx context.Context, request GetUserChatColorRequestObject) (GetUserChatColorResponseObject, error)
	// Updates the color used for the users name in chat.
	// (PUT /chat/color)
	UpdateUserChatColor(ctx context.Context, request UpdateUserChatColorRequestObject) (UpdateUserChatColorResponseObject, error)
	// Gets the broadcasters list of custom emotes.
	// (GET /chat/emotes)
	GetChannelEmotes(ctx context.Context, request GetChannelEmotesRequestObject) (GetChannelEmotesResponseObject, error)
	// Gets all global emotes.
	// (GET /chat/emotes/global)
	GetGlobalEmotes(ctx context.Context, request GetGlobalEmotesRequestObject) (GetGlobalEmotesResponseObject, error)
	// Gets emotes for one or more specified emote sets.
	// (GET /chat/emotes/set)
	GetEmoteSets(ctx context.Context, request GetEmoteSetsRequestObject) (GetEmoteSetsResponseObject, error)
	// NEW Retrieves emotes available to the user across all channels.
	// (GET /chat/emotes/user)
	GetUserEmotes(ctx context.Context, request GetUserEmotesRequestObject) (GetUserEmotesResponseObject, error)
	// NEW Sends a message to the broadcasters chat room.
	// (POST /chat/messages)
	SendChatMessage(ctx context.Context, request SendChatMessageRequestObject) (SendChatMessageResponseObject, error)
	// Gets the broadcasters chat settings.
	// (GET /chat/settings)
	GetChatSettings(ctx context.Context, request GetChatSettingsRequestObject) (GetChatSettingsResponseObject, error)
	// Updates the broadcasters chat settings.
	// (PATCH /chat/settings)
	UpdateChatSettings(ctx context.Context, request UpdateChatSettingsRequestObject) (UpdateChatSettingsResponseObject, error)
	// Sends a Shoutout to the specified broadcaster.
	// (POST /chat/shoutouts)
	SendAShoutout(ctx context.Context, request SendAShoutoutRequestObject) (SendAShoutoutResponseObject, error)
	// Gets one or more video clips.
	// (GET /clips)
	GetClips(ctx context.Context, request GetClipsRequestObject) (GetClipsResponseObject, error)
	// Creates a clip from the broadcasters stream.
	// (POST /clips)
	CreateClip(ctx context.Context, request CreateClipRequestObject) (CreateClipResponseObject, error)
	// Gets information about Twitch content classification labels.
	// (GET /content_classification_labels)
	GetContentClassificationLabels(ctx context.Context, request GetContentClassificationLabelsRequestObject) (GetContentClassificationLabelsResponseObject, error)
	// Gets an organizations list of entitlements that have been granted to a game, a user, or both.
	// (GET /entitlements/drops)
	GetDropsEntitlements(ctx context.Context, request GetDropsEntitlementsRequestObject) (GetDropsEntitlementsResponseObject, error)
	// Updates the Drop entitlements fulfillment status.
	// (PATCH /entitlements/drops)
	UpdateDropsEntitlements(ctx context.Context, request UpdateDropsEntitlementsRequestObject) (UpdateDropsEntitlementsResponseObject, error)
	// NEW Deletes a specified conduit.
	// (DELETE /eventsub/conduits)
	DeleteConduit(ctx context.Context, request DeleteConduitRequestObject) (DeleteConduitResponseObject, error)
	// NEW  Gets the conduits for a client ID.
	// (GET /eventsub/conduits)
	GetConduits(ctx context.Context, request GetConduitsRequestObject) (GetConduitsResponseObject, error)
	// NEW Updates a conduits shard count.
	// (PATCH /eventsub/conduits)
	UpdateConduits(ctx context.Context, request UpdateConduitsRequestObject) (UpdateConduitsResponseObject, error)
	// NEW Creates a new conduit.
	// (POST /eventsub/conduits)
	CreateConduits(ctx context.Context, request CreateConduitsRequestObject) (CreateConduitsResponseObject, error)
	// NEW Gets a lists of all shards for a conduit.
	// (GET /eventsub/conduits/shards)
	GetConduitShards(ctx context.Context, request GetConduitShardsRequestObject) (GetConduitShardsResponseObject, error)
	// NEW Updates shard(s) for a conduit.
	// (PATCH /eventsub/conduits/shards)
	UpdateConduitShards(ctx context.Context, request UpdateConduitShardsRequestObject) (UpdateConduitShardsResponseObject, error)
	// Deletes an EventSub subscription.
	// (DELETE /eventsub/subscriptions)
	DeleteEventsubSubscription(ctx context.Context, request DeleteEventsubSubscriptionRequestObject) (DeleteEventsubSubscriptionResponseObject, error)
	// Gets a list of EventSub subscriptions that the client in the access token created.
	// (GET /eventsub/subscriptions)
	GetEventsubSubscriptions(ctx context.Context, request GetEventsubSubscriptionsRequestObject) (GetEventsubSubscriptionsResponseObject, error)
	// Creates an EventSub subscription.
	// (POST /eventsub/subscriptions)
	CreateEventsubSubscription(ctx context.Context, request CreateEventsubSubscriptionRequestObject) (CreateEventsubSubscriptionResponseObject, error)
	// Gets information about an extension.
	// (GET /extensions)
	GetExtensions(ctx context.Context, request GetExtensionsRequestObject) (GetExtensionsResponseObject, error)
	// Sends a message to the specified broadcasters chat room.
	// (POST /extensions/chat)
	SendExtensionChatMessage(ctx context.Context, request SendExtensionChatMessageRequestObject) (SendExtensionChatMessageResponseObject, error)
	// Gets the specified configuration segment from the specified extension.
	// (GET /extensions/configurations)
	GetExtensionConfigurationSegment(ctx context.Context, request GetExtensionConfigurationSegmentRequestObject) (GetExtensionConfigurationSegmentResponseObject, error)
	// Updates a configuration segment.
	// (PUT /extensions/configurations)
	SetExtensionConfigurationSegment(ctx context.Context, request SetExtensionConfigurationSegmentRequestObject) (SetExtensionConfigurationSegmentResponseObject, error)
	// Gets an extensions list of shared secrets.
	// (GET /extensions/jwt/secrets)
	GetExtensionSecrets(ctx context.Context, request GetExtensionSecretsRequestObject) (GetExtensionSecretsResponseObject, error)
	// Creates a shared secret used to sign and verify JWT tokens.
	// (POST /extensions/jwt/secrets)
	CreateExtensionSecret(ctx context.Context, request CreateExtensionSecretRequestObject) (CreateExtensionSecretResponseObject, error)
	// Gets a list of broadcasters that are streaming live and have installed or activated the extension.
	// (GET /extensions/live)
	GetExtensionLiveChannels(ctx context.Context, request GetExtensionLiveChannelsRequestObject) (GetExtensionLiveChannelsResponseObject, error)
	// Sends a message to one or more viewers.
	// (POST /extensions/pubsub)
	SendExtensionPubsubMessage(ctx context.Context, request SendExtensionPubsubMessageRequestObject) (SendExtensionPubsubMessageResponseObject, error)
	// Gets information about a released extension.
	// (GET /extensions/released)
	GetReleasedExtensions(ctx context.Context, request GetReleasedExtensionsRequestObject) (GetReleasedExtensionsResponseObject, error)
	// Updates the extensions required_configuration string.
	// (PUT /extensions/required_configuration)
	SetExtensionRequiredConfiguration(ctx context.Context, request SetExtensionRequiredConfigurationRequestObject) (SetExtensionRequiredConfigurationResponseObject, error)
	// Gets an extensions list of transactions.
	// (GET /extensions/transactions)
	GetExtensionTransactions(ctx context.Context, request GetExtensionTransactionsRequestObject) (GetExtensionTransactionsResponseObject, error)
	// Gets information about specified games.
	// (GET /games)
	GetGames(ctx context.Context, request GetGamesRequestObject) (GetGamesResponseObject, error)
	// Gets information about all broadcasts on Twitch.
	// (GET /games/top)
	GetTopGames(ctx context.Context, request GetTopGamesRequestObject) (GetTopGamesResponseObject, error)
	// Gets the broadcasters list of active goals.
	// (GET /goals)
	GetCreatorGoals(ctx context.Context, request GetCreatorGoalsRequestObject) (GetCreatorGoalsResponseObject, error)
	// BETA Gets the channel settings for configuration of the Guest Star feature for a particular host.
	// (GET /guest_star/channel_settings)
	GetChannelGuestStarSettings(ctx context.Context, request GetChannelGuestStarSettingsRequestObject) (GetChannelGuestStarSettingsResponseObject, error)
	// BETA Mutates the channel settings for configuration of the Guest Star feature for a particular host.
	// (PUT /guest_star/channel_settings)
	UpdateChannelGuestStarSettings(ctx context.Context, request UpdateChannelGuestStarSettingsRequestObject) (UpdateChannelGuestStarSettingsResponseObject, error)
	// BETA Revokes a previously sent invite for a Guest Star session.
	// (DELETE /guest_star/invites)
	DeleteGuestStarInvite(ctx context.Context, request DeleteGuestStarInviteRequestObject) (DeleteGuestStarInviteResponseObject, error)
	// BETA Provides the caller with a list of pending invites to a Guest Star session.
	// (GET /guest_star/invites)
	GetGuestStarInvites(ctx context.Context, request GetGuestStarInvitesRequestObject) (GetGuestStarInvitesResponseObject, error)
	// BETA Sends an invite to a specified guest on behalf of the broadcaster for a Guest Star session in progress.
	// (POST /guest_star/invites)
	SendGuestStarInvite(ctx context.Context, request SendGuestStarInviteRequestObject) (SendGuestStarInviteResponseObject, error)
	// BETA Programmatically ends a Guest Star session on behalf of the broadcaster.
	// (DELETE /guest_star/session)
	EndGuestStarSession(ctx context.Context, request EndGuestStarSessionRequestObject) (EndGuestStarSessionResponseObject, error)
	// BETA Gets information about an ongoing Guest Star session for a particular channel.
	// (GET /guest_star/session)
	GetGuestStarSession(ctx context.Context, request GetGuestStarSessionRequestObject) (GetGuestStarSessionResponseObject, error)
	// BETA Programmatically creates a Guest Star session on behalf of the broadcaster.
	// (POST /guest_star/session)
	CreateGuestStarSession(ctx context.Context, request CreateGuestStarSessionRequestObject) (CreateGuestStarSessionResponseObject, error)
	// BETA Allows a caller to remove a slot assignment from a user participating in an active Guest Star session.
	// (DELETE /guest_star/slot)
	DeleteGuestStarSlot(ctx context.Context, request DeleteGuestStarSlotRequestObject) (DeleteGuestStarSlotResponseObject, error)
	// BETA Allows a user to update the assigned slot for a particular user within the active Guest Star session.
	// (PATCH /guest_star/slot)
	UpdateGuestStarSlot(ctx context.Context, request UpdateGuestStarSlotRequestObject) (UpdateGuestStarSlotResponseObject, error)
	// BETA Allows a previously invited user to be assigned a slot within the active Guest Star session.
	// (POST /guest_star/slot)
	AssignGuestStarSlot(ctx context.Context, request AssignGuestStarSlotRequestObject) (AssignGuestStarSlotResponseObject, error)
	// BETA Allows a user to update slot settings for a particular guest within a Guest Star session.
	// (PATCH /guest_star/slot_settings)
	UpdateGuestStarSlotSettings(ctx context.Context, request UpdateGuestStarSlotSettingsRequestObject) (UpdateGuestStarSlotSettingsResponseObject, error)
	// Gets information about the broadcasters current or most recent Hype Train event.
	// (GET /hypetrain/events)
	GetHypeTrainEvents(ctx context.Context, request GetHypeTrainEventsRequestObject) (GetHypeTrainEventsResponseObject, error)
	// Allow or deny the message that AutoMod flagged for review.
	// (POST /moderation/automod/message)
	ManageHeldAutomodMessages(ctx context.Context, request ManageHeldAutomodMessagesRequestObject) (ManageHeldAutomodMessagesResponseObject, error)
	// Gets the broadcasters AutoMod settings.
	// (GET /moderation/automod/settings)
	GetAutomodSettings(ctx context.Context, request GetAutomodSettingsRequestObject) (GetAutomodSettingsResponseObject, error)
	// Updates the broadcasters AutoMod settings.
	// (PUT /moderation/automod/settings)
	UpdateAutomodSettings(ctx context.Context, request UpdateAutomodSettingsRequestObject) (UpdateAutomodSettingsResponseObject, error)
	// Gets all users that the broadcaster banned or put in a timeout.
	// (GET /moderation/banned)
	GetBannedUsers(ctx context.Context, request GetBannedUsersRequestObject) (GetBannedUsersResponseObject, error)
	// Removes the ban or timeout that was placed on the specified user.
	// (DELETE /moderation/bans)
	UnbanUser(ctx context.Context, request UnbanUserRequestObject) (UnbanUserResponseObject, error)
	// Bans a user from participating in a broadcasters chat room or puts them in a timeout.
	// (POST /moderation/bans)
	BanUser(ctx context.Context, request BanUserRequestObject) (BanUserResponseObject, error)
	// Removes the word or phrase from the broadcasters list of blocked terms.
	// (DELETE /moderation/blocked_terms)
	RemoveBlockedTerm(ctx context.Context, request RemoveBlockedTermRequestObject) (RemoveBlockedTermResponseObject, error)
	// Gets the broadcasters list of non-private, blocked words or phrases.
	// (GET /moderation/blocked_terms)
	GetBlockedTerms(ctx context.Context, request GetBlockedTermsRequestObject) (GetBlockedTermsResponseObject, error)
	// Adds a word or phrase to the broadcasters list of blocked terms.
	// (POST /moderation/blocked_terms)
	AddBlockedTerm(ctx context.Context, request AddBlockedTermRequestObject) (AddBlockedTermResponseObject, error)
	// Gets a list of channels that the specified user has moderator privileges in.
	// (GET /moderation/channels)
	GetModeratedChannels(ctx context.Context, request GetModeratedChannelsRequestObject) (GetModeratedChannelsResponseObject, error)
	// Removes a single chat message or all chat messages from the broadcasters chat room.
	// (DELETE /moderation/chat)
	DeleteChatMessages(ctx context.Context, request DeleteChatMessagesRequestObject) (DeleteChatMessagesResponseObject, error)
	// Checks whether AutoMod would flag the specified message for review.
	// (POST /moderation/enforcements/status)
	CheckAutomodStatus(ctx context.Context, request CheckAutomodStatusRequestObject) (CheckAutomodStatusResponseObject, error)
	// Removes a moderator from the broadcasters chat room.
	// (DELETE /moderation/moderators)
	RemoveChannelModerator(ctx context.Context, request RemoveChannelModeratorRequestObject) (RemoveChannelModeratorResponseObject, error)
	// Gets all users allowed to moderate the broadcasters chat room.
	// (GET /moderation/moderators)
	GetModerators(ctx context.Context, request GetModeratorsRequestObject) (GetModeratorsResponseObject, error)
	// Adds a moderator to the broadcasters chat room.
	// (POST /moderation/moderators)
	AddChannelModerator(ctx context.Context, request AddChannelModeratorRequestObject) (AddChannelModeratorResponseObject, error)
	// Gets the broadcasters Shield Mode activation status.
	// (GET /moderation/shield_mode)
	GetShieldModeStatus(ctx context.Context, request GetShieldModeStatusRequestObject) (GetShieldModeStatusResponseObject, error)
	// Activates or deactivates the broadcasters Shield Mode.
	// (PUT /moderation/shield_mode)
	UpdateShieldModeStatus(ctx context.Context, request UpdateShieldModeStatusRequestObject) (UpdateShieldModeStatusResponseObject, error)
	// NEW Gets a list of unban requests for a broadcasters channel.
	// (GET /moderation/unban_requests)
	GetUnbanRequests(ctx context.Context, request GetUnbanRequestsRequestObject) (GetUnbanRequestsResponseObject, error)
	// NEW Resolves an unban request by approving or denying it.
	// (PATCH /moderation/unban_requests)
	ResolveUnbanRequests(ctx context.Context, request ResolveUnbanRequestsRequestObject) (ResolveUnbanRequestsResponseObject, error)
	// NEW Warns a user in the specified broadcasters chat room, preventing them from chat interaction until the warning is acknowledged.
	// (POST /moderation/warnings)
	WarnChatUser(ctx context.Context, request WarnChatUserRequestObject) (WarnChatUserResponseObject, error)
	// Gets a list of polls that the broadcaster created.
	// (GET /polls)
	GetPolls(ctx context.Context, request GetPollsRequestObject) (GetPollsResponseObject, error)
	// End an active poll.
	// (PATCH /polls)
	EndPoll(ctx context.Context, request EndPollRequestObject) (EndPollResponseObject, error)
	// Creates a poll that viewers in the broadcasters channel can vote on.
	// (POST /polls)
	CreatePoll(ctx context.Context, request CreatePollRequestObject) (CreatePollResponseObject, error)
	// Gets a list of Channel Points Predictions that the broadcaster created.
	// (GET /predictions)
	GetPredictions(ctx context.Context, request GetPredictionsRequestObject) (GetPredictionsResponseObject, error)
	// Locks, resolves, or cancels a Channel Points Prediction.
	// (PATCH /predictions)
	EndPrediction(ctx context.Context, request EndPredictionRequestObject) (EndPredictionResponseObject, error)
	// Create a Channel Points Prediction.
	// (POST /predictions)
	CreatePrediction(ctx context.Context, request CreatePredictionRequestObject) (CreatePredictionResponseObject, error)
	// Cancel a pending raid.
	// (DELETE /raids)
	CancelARaid(ctx context.Context, request CancelARaidRequestObject) (CancelARaidResponseObject, error)
	// Raid another channel by sending the broadcasters viewers to the targeted channel.
	// (POST /raids)
	StartARaid(ctx context.Context, request StartARaidRequestObject) (StartARaidResponseObject, error)
	// Gets the broadcasters streaming schedule.
	// (GET /schedule)
	GetChannelStreamSchedule(ctx context.Context, request GetChannelStreamScheduleRequestObject) (GetChannelStreamScheduleResponseObject, error)
	// Gets the broadcasters streaming schedule as an iCalendar.
	// (GET /schedule/icalendar)
	GetChannelIcalendar(ctx context.Context, request GetChannelIcalendarRequestObject) (GetChannelIcalendarResponseObject, error)
	// Deletes a broadcast from the broadcasters streaming schedule.
	// (DELETE /schedule/segment)
	DeleteChannelStreamScheduleSegment(ctx context.Context, request DeleteChannelStreamScheduleSegmentRequestObject) (DeleteChannelStreamScheduleSegmentResponseObject, error)
	// Updates a scheduled broadcast segment.
	// (PATCH /schedule/segment)
	UpdateChannelStreamScheduleSegment(ctx context.Context, request UpdateChannelStreamScheduleSegmentRequestObject) (UpdateChannelStreamScheduleSegmentResponseObject, error)
	// Adds a single or recurring broadcast to the broadcasters streaming schedule.
	// (POST /schedule/segment)
	CreateChannelStreamScheduleSegment(ctx context.Context, request CreateChannelStreamScheduleSegmentRequestObject) (CreateChannelStreamScheduleSegmentResponseObject, error)
	// Updates the broadcasters schedule settings, such as scheduling a vacation.
	// (PATCH /schedule/settings)
	UpdateChannelStreamSchedule(ctx context.Context, request UpdateChannelStreamScheduleRequestObject) (UpdateChannelStreamScheduleResponseObject, error)
	// Gets the games or categories that match the specified query.
	// (GET /search/categories)
	SearchCategories(ctx context.Context, request SearchCategoriesRequestObject) (SearchCategoriesResponseObject, error)
	// Gets the channels that match the specified query and have streamed content within the past 6 months.
	// (GET /search/channels)
	SearchChannels(ctx context.Context, request SearchChannelsRequestObject) (SearchChannelsResponseObject, error)
	// NEW Retrieves the active shared chat session for a channel.
	// (GET /shared_chat/session)
	GetSharedChatSession(ctx context.Context, request GetSharedChatSessionRequestObject) (GetSharedChatSessionResponseObject, error)
	// Gets a list of all streams.
	// (GET /streams)
	GetStreams(ctx context.Context, request GetStreamsRequestObject) (GetStreamsResponseObject, error)
	// Gets the list of broadcasters that the user follows and that are streaming live.
	// (GET /streams/followed)
	GetFollowedStreams(ctx context.Context, request GetFollowedStreamsRequestObject) (GetFollowedStreamsResponseObject, error)
	// Gets the channels stream key.
	// (GET /streams/key)
	GetStreamKey(ctx context.Context, request GetStreamKeyRequestObject) (GetStreamKeyResponseObject, error)
	// Gets a list of markers from the users most recent stream or from the specified VOD/video.
	// (GET /streams/markers)
	GetStreamMarkers(ctx context.Context, request GetStreamMarkersRequestObject) (GetStreamMarkersResponseObject, error)
	// Adds a marker to a live stream.
	// (POST /streams/markers)
	CreateStreamMarker(ctx context.Context, request CreateStreamMarkerRequestObject) (CreateStreamMarkerResponseObject, error)
	// Gets the list of stream tags that the broadcaster or Twitch added to their channel.
	// (GET /streams/tags)
	GetStreamTags(ctx context.Context, request GetStreamTagsRequestObject) (GetStreamTagsResponseObject, error)
	// Gets a list of users that subscribe to the specified broadcaster.
	// (GET /subscriptions)
	GetBroadcasterSubscriptions(ctx context.Context, request GetBroadcasterSubscriptionsRequestObject) (GetBroadcasterSubscriptionsResponseObject, error)
	// Checks whether the user subscribes to the broadcasters channel.
	// (GET /subscriptions/user)
	CheckUserSubscription(ctx context.Context, request CheckUserSubscriptionRequestObject) (CheckUserSubscriptionResponseObject, error)
	// Gets the list of all stream tags that Twitch defines. You can also filter the list by one or more tag IDs.
	// (GET /tags/streams)
	GetAllStreamTags(ctx context.Context, request GetAllStreamTagsRequestObject) (GetAllStreamTagsResponseObject, error)
	// Gets information about the specified Twitch team.
	// (GET /teams)
	GetTeams(ctx context.Context, request GetTeamsRequestObject) (GetTeamsResponseObject, error)
	// Gets the list of Twitch teams that the broadcaster is a member of.
	// (GET /teams/channel)
	GetChannelTeams(ctx context.Context, request GetChannelTeamsRequestObject) (GetChannelTeamsResponseObject, error)
	// Gets information about one or more users.
	// (GET /users)
	GetUsers(ctx context.Context, request GetUsersRequestObject) (GetUsersResponseObject, error)
	// Updates the users information.
	// (PUT /users)
	UpdateUser(ctx context.Context, request UpdateUserRequestObject) (UpdateUserResponseObject, error)
	// Removes the user from the broadcasters list of blocked users.
	// (DELETE /users/blocks)
	UnblockUser(ctx context.Context, request UnblockUserRequestObject) (UnblockUserResponseObject, error)
	// Gets the list of users that the broadcaster has blocked.
	// (GET /users/blocks)
	GetUserBlockList(ctx context.Context, request GetUserBlockListRequestObject) (GetUserBlockListResponseObject, error)
	// Blocks the specified user from interacting with or having contact with the broadcaster.
	// (PUT /users/blocks)
	BlockUser(ctx context.Context, request BlockUserRequestObject) (BlockUserResponseObject, error)
	// Gets the active extensions that the broadcaster has installed for each configuration.
	// (GET /users/extensions)
	GetUserActiveExtensions(ctx context.Context, request GetUserActiveExtensionsRequestObject) (GetUserActiveExtensionsResponseObject, error)
	// Updates an installed extensions information.
	// (PUT /users/extensions)
	UpdateUserExtensions(ctx context.Context, request UpdateUserExtensionsRequestObject) (UpdateUserExtensionsResponseObject, error)
	// Gets a list of all extensions (both active and inactive) that the broadcaster has installed.
	// (GET /users/extensions/list)
	GetUserExtensions(ctx context.Context, request GetUserExtensionsRequestObject) (GetUserExtensionsResponseObject, error)
	// Deletes one or more videos.
	// (DELETE /videos)
	DeleteVideos(ctx context.Context, request DeleteVideosRequestObject) (DeleteVideosResponseObject, error)
	// Gets information about one or more published videos.
	// (GET /videos)
	GetVideos(ctx context.Context, request GetVideosRequestObject) (GetVideosResponseObject, error)
	// Sends a whisper message to the specified user.
	// (POST /whispers)
	SendWhisper(ctx context.Context, request SendWhisperRequestObject) (SendWhisperResponseObject, error)
}

//Generated with strict-echo.tmpl

type StrictOption func(*strictHandler)

type StrictHandlerFunc func(ctx echo.Context, args interface{}) (interface{}, error)

type StrictMiddlewareFunc func(f StrictHandlerFunc, operationID string) StrictHandlerFunc

func NewStrictHandler(ssi StrictServerInterface, opts ...StrictOption) ServerInterface {
	handler := &strictHandler{ssi: ssi}
	if opts != nil && len(opts) > 0 {
		for _, opt := range opts {
			if opt != nil {
				opt(handler)
			}
		}
	}
	return handler
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	tracer      trace.Tracer
}

func WithMiddlewares(middlewares []StrictMiddlewareFunc) StrictOption {
	return func(s *strictHandler) {
		s.middlewares = middlewares
	}
}

func WithTracer(tracer trace.Tracer) StrictOption {
	return func(s *strictHandler) {
		s.tracer = tracer
	}
}

// GetExtensionAnalytics operation middleware
func (sh *strictHandler) GetExtensionAnalytics(ctx echo.Context, params GetExtensionAnalyticsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionAnalyticsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionAnalyticsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensionAnalytics(ctx.Request().Context(), request.(GetExtensionAnalyticsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensionAnalytics")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensionAnalytics handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionAnalyticsResponseObject); ok {
		return validResponse.VisitGetExtensionAnalyticsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetGameAnalytics operation middleware
func (sh *strictHandler) GetGameAnalytics(ctx echo.Context, params GetGameAnalyticsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetGameAnalyticsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetGameAnalyticsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetGameAnalytics(ctx.Request().Context(), request.(GetGameAnalyticsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGameAnalytics")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetGameAnalytics handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetGameAnalyticsResponseObject); ok {
		return validResponse.VisitGetGameAnalyticsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetCheermotes operation middleware
func (sh *strictHandler) GetCheermotes(ctx echo.Context, params GetCheermotesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetCheermotesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetCheermotesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetCheermotes(ctx.Request().Context(), request.(GetCheermotesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCheermotes")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetCheermotes handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetCheermotesResponseObject); ok {
		return validResponse.VisitGetCheermotesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetExtensionBitsProducts operation middleware
func (sh *strictHandler) GetExtensionBitsProducts(ctx echo.Context, params GetExtensionBitsProductsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionBitsProductsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionBitsProductsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensionBitsProducts(ctx.Request().Context(), request.(GetExtensionBitsProductsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensionBitsProducts")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensionBitsProducts handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionBitsProductsResponseObject); ok {
		return validResponse.VisitGetExtensionBitsProductsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateExtensionBitsProduct operation middleware
func (sh *strictHandler) UpdateExtensionBitsProduct(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateExtensionBitsProductHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateExtensionBitsProductRequestObject

	//read in body of request
	var body UpdateExtensionBitsProductJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateExtensionBitsProduct(ctx.Request().Context(), request.(UpdateExtensionBitsProductRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateExtensionBitsProduct")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateExtensionBitsProduct handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateExtensionBitsProductResponseObject); ok {
		return validResponse.VisitUpdateExtensionBitsProductResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetBitsLeaderboard operation middleware
func (sh *strictHandler) GetBitsLeaderboard(ctx echo.Context, params GetBitsLeaderboardParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetBitsLeaderboardHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetBitsLeaderboardRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetBitsLeaderboard(ctx.Request().Context(), request.(GetBitsLeaderboardRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBitsLeaderboard")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetBitsLeaderboard handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetBitsLeaderboardResponseObject); ok {
		return validResponse.VisitGetBitsLeaderboardResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteCustomReward operation middleware
func (sh *strictHandler) DeleteCustomReward(ctx echo.Context, params DeleteCustomRewardParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteCustomRewardHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteCustomRewardRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteCustomReward(ctx.Request().Context(), request.(DeleteCustomRewardRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteCustomReward")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteCustomReward handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteCustomRewardResponseObject); ok {
		return validResponse.VisitDeleteCustomRewardResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetCustomReward operation middleware
func (sh *strictHandler) GetCustomReward(ctx echo.Context, params GetCustomRewardParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetCustomRewardHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetCustomRewardRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetCustomReward(ctx.Request().Context(), request.(GetCustomRewardRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCustomReward")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetCustomReward handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetCustomRewardResponseObject); ok {
		return validResponse.VisitGetCustomRewardResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateCustomReward operation middleware
func (sh *strictHandler) UpdateCustomReward(ctx echo.Context, params UpdateCustomRewardParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateCustomRewardHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateCustomRewardRequestObject

	request.Params = params

	//read in body of request
	var body UpdateCustomRewardJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateCustomReward(ctx.Request().Context(), request.(UpdateCustomRewardRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateCustomReward")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateCustomReward handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateCustomRewardResponseObject); ok {
		return validResponse.VisitUpdateCustomRewardResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateCustomRewards operation middleware
func (sh *strictHandler) CreateCustomRewards(ctx echo.Context, params CreateCustomRewardsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateCustomRewardsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateCustomRewardsRequestObject

	request.Params = params

	//read in body of request
	var body CreateCustomRewardsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateCustomRewards(ctx.Request().Context(), request.(CreateCustomRewardsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateCustomRewards")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateCustomRewards handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateCustomRewardsResponseObject); ok {
		return validResponse.VisitCreateCustomRewardsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetCustomRewardRedemption operation middleware
func (sh *strictHandler) GetCustomRewardRedemption(ctx echo.Context, params GetCustomRewardRedemptionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetCustomRewardRedemptionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetCustomRewardRedemptionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetCustomRewardRedemption(ctx.Request().Context(), request.(GetCustomRewardRedemptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCustomRewardRedemption")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetCustomRewardRedemption handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetCustomRewardRedemptionResponseObject); ok {
		return validResponse.VisitGetCustomRewardRedemptionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateRedemptionStatus operation middleware
func (sh *strictHandler) UpdateRedemptionStatus(ctx echo.Context, params UpdateRedemptionStatusParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateRedemptionStatusHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateRedemptionStatusRequestObject

	request.Params = params

	//read in body of request
	var body UpdateRedemptionStatusJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateRedemptionStatus(ctx.Request().Context(), request.(UpdateRedemptionStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateRedemptionStatus")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateRedemptionStatus handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateRedemptionStatusResponseObject); ok {
		return validResponse.VisitUpdateRedemptionStatusResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelInformation operation middleware
func (sh *strictHandler) GetChannelInformation(ctx echo.Context, params GetChannelInformationParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelInformationHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelInformationRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelInformation(ctx.Request().Context(), request.(GetChannelInformationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelInformation")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelInformation handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelInformationResponseObject); ok {
		return validResponse.VisitGetChannelInformationResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// ModifyChannelInformation operation middleware
func (sh *strictHandler) ModifyChannelInformation(ctx echo.Context, params ModifyChannelInformationParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "ModifyChannelInformationHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request ModifyChannelInformationRequestObject

	request.Params = params

	//read in body of request
	var body ModifyChannelInformationJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ModifyChannelInformation(ctx.Request().Context(), request.(ModifyChannelInformationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ModifyChannelInformation")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from ModifyChannelInformation handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(ModifyChannelInformationResponseObject); ok {
		return validResponse.VisitModifyChannelInformationResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetAdSchedule operation middleware
func (sh *strictHandler) GetAdSchedule(ctx echo.Context, params GetAdScheduleParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetAdScheduleHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetAdScheduleRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAdSchedule(ctx.Request().Context(), request.(GetAdScheduleRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAdSchedule")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetAdSchedule handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetAdScheduleResponseObject); ok {
		return validResponse.VisitGetAdScheduleResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SnoozeNextAd operation middleware
func (sh *strictHandler) SnoozeNextAd(ctx echo.Context, params SnoozeNextAdParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SnoozeNextAdHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SnoozeNextAdRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SnoozeNextAd(ctx.Request().Context(), request.(SnoozeNextAdRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SnoozeNextAd")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SnoozeNextAd handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SnoozeNextAdResponseObject); ok {
		return validResponse.VisitSnoozeNextAdResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// StartCommercial operation middleware
func (sh *strictHandler) StartCommercial(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "StartCommercialHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request StartCommercialRequestObject

	//read in body of request
	var body StartCommercialJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.StartCommercial(ctx.Request().Context(), request.(StartCommercialRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartCommercial")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from StartCommercial handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(StartCommercialResponseObject); ok {
		return validResponse.VisitStartCommercialResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelEditors operation middleware
func (sh *strictHandler) GetChannelEditors(ctx echo.Context, params GetChannelEditorsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelEditorsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelEditorsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelEditors(ctx.Request().Context(), request.(GetChannelEditorsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelEditors")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelEditors handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelEditorsResponseObject); ok {
		return validResponse.VisitGetChannelEditorsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetFollowedChannels operation middleware
func (sh *strictHandler) GetFollowedChannels(ctx echo.Context, params GetFollowedChannelsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetFollowedChannelsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetFollowedChannelsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFollowedChannels(ctx.Request().Context(), request.(GetFollowedChannelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFollowedChannels")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetFollowedChannels handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetFollowedChannelsResponseObject); ok {
		return validResponse.VisitGetFollowedChannelsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelFollowers operation middleware
func (sh *strictHandler) GetChannelFollowers(ctx echo.Context, params GetChannelFollowersParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelFollowersHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelFollowersRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelFollowers(ctx.Request().Context(), request.(GetChannelFollowersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelFollowers")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelFollowers handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelFollowersResponseObject); ok {
		return validResponse.VisitGetChannelFollowersResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// RemoveChannelVip operation middleware
func (sh *strictHandler) RemoveChannelVip(ctx echo.Context, params RemoveChannelVipParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "RemoveChannelVipHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request RemoveChannelVipRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RemoveChannelVip(ctx.Request().Context(), request.(RemoveChannelVipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RemoveChannelVip")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from RemoveChannelVip handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(RemoveChannelVipResponseObject); ok {
		return validResponse.VisitRemoveChannelVipResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetVips operation middleware
func (sh *strictHandler) GetVips(ctx echo.Context, params GetVipsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetVipsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetVipsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVips(ctx.Request().Context(), request.(GetVipsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVips")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetVips handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetVipsResponseObject); ok {
		return validResponse.VisitGetVipsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// AddChannelVip operation middleware
func (sh *strictHandler) AddChannelVip(ctx echo.Context, params AddChannelVipParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "AddChannelVipHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request AddChannelVipRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AddChannelVip(ctx.Request().Context(), request.(AddChannelVipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddChannelVip")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from AddChannelVip handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(AddChannelVipResponseObject); ok {
		return validResponse.VisitAddChannelVipResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetCharityCampaign operation middleware
func (sh *strictHandler) GetCharityCampaign(ctx echo.Context, params GetCharityCampaignParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetCharityCampaignHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetCharityCampaignRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetCharityCampaign(ctx.Request().Context(), request.(GetCharityCampaignRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCharityCampaign")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetCharityCampaign handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetCharityCampaignResponseObject); ok {
		return validResponse.VisitGetCharityCampaignResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetCharityCampaignDonations operation middleware
func (sh *strictHandler) GetCharityCampaignDonations(ctx echo.Context, params GetCharityCampaignDonationsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetCharityCampaignDonationsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetCharityCampaignDonationsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetCharityCampaignDonations(ctx.Request().Context(), request.(GetCharityCampaignDonationsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCharityCampaignDonations")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetCharityCampaignDonations handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetCharityCampaignDonationsResponseObject); ok {
		return validResponse.VisitGetCharityCampaignDonationsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendChatAnnouncement operation middleware
func (sh *strictHandler) SendChatAnnouncement(ctx echo.Context, params SendChatAnnouncementParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendChatAnnouncementHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendChatAnnouncementRequestObject

	request.Params = params

	//read in body of request
	var body SendChatAnnouncementJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendChatAnnouncement(ctx.Request().Context(), request.(SendChatAnnouncementRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendChatAnnouncement")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendChatAnnouncement handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendChatAnnouncementResponseObject); ok {
		return validResponse.VisitSendChatAnnouncementResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelChatBadges operation middleware
func (sh *strictHandler) GetChannelChatBadges(ctx echo.Context, params GetChannelChatBadgesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelChatBadgesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelChatBadgesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelChatBadges(ctx.Request().Context(), request.(GetChannelChatBadgesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelChatBadges")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelChatBadges handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelChatBadgesResponseObject); ok {
		return validResponse.VisitGetChannelChatBadgesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetGlobalChatBadges operation middleware
func (sh *strictHandler) GetGlobalChatBadges(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetGlobalChatBadgesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetGlobalChatBadgesRequestObject

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetGlobalChatBadges(ctx.Request().Context(), request.(GetGlobalChatBadgesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGlobalChatBadges")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetGlobalChatBadges handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetGlobalChatBadgesResponseObject); ok {
		return validResponse.VisitGetGlobalChatBadgesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChatters operation middleware
func (sh *strictHandler) GetChatters(ctx echo.Context, params GetChattersParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChattersHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChattersRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChatters(ctx.Request().Context(), request.(GetChattersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChatters")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChatters handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChattersResponseObject); ok {
		return validResponse.VisitGetChattersResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUserChatColor operation middleware
func (sh *strictHandler) GetUserChatColor(ctx echo.Context, params GetUserChatColorParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUserChatColorHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUserChatColorRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserChatColor(ctx.Request().Context(), request.(GetUserChatColorRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserChatColor")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUserChatColor handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUserChatColorResponseObject); ok {
		return validResponse.VisitGetUserChatColorResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateUserChatColor operation middleware
func (sh *strictHandler) UpdateUserChatColor(ctx echo.Context, params UpdateUserChatColorParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateUserChatColorHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateUserChatColorRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateUserChatColor(ctx.Request().Context(), request.(UpdateUserChatColorRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateUserChatColor")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateUserChatColor handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateUserChatColorResponseObject); ok {
		return validResponse.VisitUpdateUserChatColorResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelEmotes operation middleware
func (sh *strictHandler) GetChannelEmotes(ctx echo.Context, params GetChannelEmotesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelEmotesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelEmotesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelEmotes(ctx.Request().Context(), request.(GetChannelEmotesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelEmotes")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelEmotes handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelEmotesResponseObject); ok {
		return validResponse.VisitGetChannelEmotesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetGlobalEmotes operation middleware
func (sh *strictHandler) GetGlobalEmotes(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetGlobalEmotesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetGlobalEmotesRequestObject

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetGlobalEmotes(ctx.Request().Context(), request.(GetGlobalEmotesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGlobalEmotes")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetGlobalEmotes handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetGlobalEmotesResponseObject); ok {
		return validResponse.VisitGetGlobalEmotesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetEmoteSets operation middleware
func (sh *strictHandler) GetEmoteSets(ctx echo.Context, params GetEmoteSetsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetEmoteSetsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetEmoteSetsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetEmoteSets(ctx.Request().Context(), request.(GetEmoteSetsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEmoteSets")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetEmoteSets handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetEmoteSetsResponseObject); ok {
		return validResponse.VisitGetEmoteSetsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUserEmotes operation middleware
func (sh *strictHandler) GetUserEmotes(ctx echo.Context, params GetUserEmotesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUserEmotesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUserEmotesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserEmotes(ctx.Request().Context(), request.(GetUserEmotesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserEmotes")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUserEmotes handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUserEmotesResponseObject); ok {
		return validResponse.VisitGetUserEmotesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendChatMessage operation middleware
func (sh *strictHandler) SendChatMessage(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendChatMessageHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendChatMessageRequestObject

	//read in body of request
	var body SendChatMessageJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendChatMessage(ctx.Request().Context(), request.(SendChatMessageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendChatMessage")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendChatMessage handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendChatMessageResponseObject); ok {
		return validResponse.VisitSendChatMessageResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChatSettings operation middleware
func (sh *strictHandler) GetChatSettings(ctx echo.Context, params GetChatSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChatSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChatSettingsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChatSettings(ctx.Request().Context(), request.(GetChatSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChatSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChatSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChatSettingsResponseObject); ok {
		return validResponse.VisitGetChatSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateChatSettings operation middleware
func (sh *strictHandler) UpdateChatSettings(ctx echo.Context, params UpdateChatSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateChatSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateChatSettingsRequestObject

	request.Params = params

	//read in body of request
	var body UpdateChatSettingsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateChatSettings(ctx.Request().Context(), request.(UpdateChatSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateChatSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateChatSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateChatSettingsResponseObject); ok {
		return validResponse.VisitUpdateChatSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendAShoutout operation middleware
func (sh *strictHandler) SendAShoutout(ctx echo.Context, params SendAShoutoutParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendAShoutoutHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendAShoutoutRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendAShoutout(ctx.Request().Context(), request.(SendAShoutoutRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendAShoutout")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendAShoutout handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendAShoutoutResponseObject); ok {
		return validResponse.VisitSendAShoutoutResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetClips operation middleware
func (sh *strictHandler) GetClips(ctx echo.Context, params GetClipsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetClipsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetClipsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetClips(ctx.Request().Context(), request.(GetClipsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetClips")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetClips handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetClipsResponseObject); ok {
		return validResponse.VisitGetClipsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateClip operation middleware
func (sh *strictHandler) CreateClip(ctx echo.Context, params CreateClipParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateClipHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateClipRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateClip(ctx.Request().Context(), request.(CreateClipRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateClip")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateClip handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateClipResponseObject); ok {
		return validResponse.VisitCreateClipResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetContentClassificationLabels operation middleware
func (sh *strictHandler) GetContentClassificationLabels(ctx echo.Context, params GetContentClassificationLabelsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetContentClassificationLabelsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetContentClassificationLabelsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetContentClassificationLabels(ctx.Request().Context(), request.(GetContentClassificationLabelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetContentClassificationLabels")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetContentClassificationLabels handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetContentClassificationLabelsResponseObject); ok {
		return validResponse.VisitGetContentClassificationLabelsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetDropsEntitlements operation middleware
func (sh *strictHandler) GetDropsEntitlements(ctx echo.Context, params GetDropsEntitlementsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetDropsEntitlementsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetDropsEntitlementsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetDropsEntitlements(ctx.Request().Context(), request.(GetDropsEntitlementsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetDropsEntitlements")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetDropsEntitlements handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetDropsEntitlementsResponseObject); ok {
		return validResponse.VisitGetDropsEntitlementsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateDropsEntitlements operation middleware
func (sh *strictHandler) UpdateDropsEntitlements(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateDropsEntitlementsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateDropsEntitlementsRequestObject

	//read in body of request
	var body UpdateDropsEntitlementsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateDropsEntitlements(ctx.Request().Context(), request.(UpdateDropsEntitlementsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateDropsEntitlements")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateDropsEntitlements handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateDropsEntitlementsResponseObject); ok {
		return validResponse.VisitUpdateDropsEntitlementsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteConduit operation middleware
func (sh *strictHandler) DeleteConduit(ctx echo.Context, params DeleteConduitParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteConduitHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteConduitRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteConduit(ctx.Request().Context(), request.(DeleteConduitRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteConduit")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteConduit handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteConduitResponseObject); ok {
		return validResponse.VisitDeleteConduitResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetConduits operation middleware
func (sh *strictHandler) GetConduits(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetConduitsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetConduitsRequestObject

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConduits(ctx.Request().Context(), request.(GetConduitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConduits")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetConduits handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetConduitsResponseObject); ok {
		return validResponse.VisitGetConduitsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateConduits operation middleware
func (sh *strictHandler) UpdateConduits(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateConduitsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateConduitsRequestObject

	//read in body of request
	var body UpdateConduitsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConduits(ctx.Request().Context(), request.(UpdateConduitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConduits")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateConduits handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateConduitsResponseObject); ok {
		return validResponse.VisitUpdateConduitsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateConduits operation middleware
func (sh *strictHandler) CreateConduits(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateConduitsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateConduitsRequestObject

	//read in body of request
	var body CreateConduitsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateConduits(ctx.Request().Context(), request.(CreateConduitsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateConduits")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateConduits handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateConduitsResponseObject); ok {
		return validResponse.VisitCreateConduitsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetConduitShards operation middleware
func (sh *strictHandler) GetConduitShards(ctx echo.Context, params GetConduitShardsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetConduitShardsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetConduitShardsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetConduitShards(ctx.Request().Context(), request.(GetConduitShardsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetConduitShards")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetConduitShards handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetConduitShardsResponseObject); ok {
		return validResponse.VisitGetConduitShardsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateConduitShards operation middleware
func (sh *strictHandler) UpdateConduitShards(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateConduitShardsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateConduitShardsRequestObject

	//read in body of request
	var body UpdateConduitShardsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateConduitShards(ctx.Request().Context(), request.(UpdateConduitShardsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateConduitShards")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateConduitShards handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateConduitShardsResponseObject); ok {
		return validResponse.VisitUpdateConduitShardsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteEventsubSubscription operation middleware
func (sh *strictHandler) DeleteEventsubSubscription(ctx echo.Context, params DeleteEventsubSubscriptionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteEventsubSubscriptionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteEventsubSubscriptionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteEventsubSubscription(ctx.Request().Context(), request.(DeleteEventsubSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteEventsubSubscription")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteEventsubSubscription handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteEventsubSubscriptionResponseObject); ok {
		return validResponse.VisitDeleteEventsubSubscriptionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetEventsubSubscriptions operation middleware
func (sh *strictHandler) GetEventsubSubscriptions(ctx echo.Context, params GetEventsubSubscriptionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetEventsubSubscriptionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetEventsubSubscriptionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetEventsubSubscriptions(ctx.Request().Context(), request.(GetEventsubSubscriptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetEventsubSubscriptions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetEventsubSubscriptions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetEventsubSubscriptionsResponseObject); ok {
		return validResponse.VisitGetEventsubSubscriptionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateEventsubSubscription operation middleware
func (sh *strictHandler) CreateEventsubSubscription(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateEventsubSubscriptionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateEventsubSubscriptionRequestObject

	//read in body of request
	var body CreateEventsubSubscriptionJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateEventsubSubscription(ctx.Request().Context(), request.(CreateEventsubSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateEventsubSubscription")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateEventsubSubscription handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateEventsubSubscriptionResponseObject); ok {
		return validResponse.VisitCreateEventsubSubscriptionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetExtensions operation middleware
func (sh *strictHandler) GetExtensions(ctx echo.Context, params GetExtensionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensions(ctx.Request().Context(), request.(GetExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionsResponseObject); ok {
		return validResponse.VisitGetExtensionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendExtensionChatMessage operation middleware
func (sh *strictHandler) SendExtensionChatMessage(ctx echo.Context, params SendExtensionChatMessageParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendExtensionChatMessageHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendExtensionChatMessageRequestObject

	request.Params = params

	//read in body of request
	var body SendExtensionChatMessageJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendExtensionChatMessage(ctx.Request().Context(), request.(SendExtensionChatMessageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendExtensionChatMessage")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendExtensionChatMessage handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendExtensionChatMessageResponseObject); ok {
		return validResponse.VisitSendExtensionChatMessageResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetExtensionConfigurationSegment operation middleware
func (sh *strictHandler) GetExtensionConfigurationSegment(ctx echo.Context, params GetExtensionConfigurationSegmentParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionConfigurationSegmentHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionConfigurationSegmentRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensionConfigurationSegment(ctx.Request().Context(), request.(GetExtensionConfigurationSegmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensionConfigurationSegment")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensionConfigurationSegment handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionConfigurationSegmentResponseObject); ok {
		return validResponse.VisitGetExtensionConfigurationSegmentResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SetExtensionConfigurationSegment operation middleware
func (sh *strictHandler) SetExtensionConfigurationSegment(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SetExtensionConfigurationSegmentHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SetExtensionConfigurationSegmentRequestObject

	//read in body of request
	var body SetExtensionConfigurationSegmentJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SetExtensionConfigurationSegment(ctx.Request().Context(), request.(SetExtensionConfigurationSegmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetExtensionConfigurationSegment")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SetExtensionConfigurationSegment handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SetExtensionConfigurationSegmentResponseObject); ok {
		return validResponse.VisitSetExtensionConfigurationSegmentResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetExtensionSecrets operation middleware
func (sh *strictHandler) GetExtensionSecrets(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionSecretsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionSecretsRequestObject

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensionSecrets(ctx.Request().Context(), request.(GetExtensionSecretsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensionSecrets")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensionSecrets handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionSecretsResponseObject); ok {
		return validResponse.VisitGetExtensionSecretsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateExtensionSecret operation middleware
func (sh *strictHandler) CreateExtensionSecret(ctx echo.Context, params CreateExtensionSecretParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateExtensionSecretHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateExtensionSecretRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateExtensionSecret(ctx.Request().Context(), request.(CreateExtensionSecretRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateExtensionSecret")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateExtensionSecret handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateExtensionSecretResponseObject); ok {
		return validResponse.VisitCreateExtensionSecretResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetExtensionLiveChannels operation middleware
func (sh *strictHandler) GetExtensionLiveChannels(ctx echo.Context, params GetExtensionLiveChannelsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionLiveChannelsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionLiveChannelsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensionLiveChannels(ctx.Request().Context(), request.(GetExtensionLiveChannelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensionLiveChannels")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensionLiveChannels handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionLiveChannelsResponseObject); ok {
		return validResponse.VisitGetExtensionLiveChannelsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendExtensionPubsubMessage operation middleware
func (sh *strictHandler) SendExtensionPubsubMessage(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendExtensionPubsubMessageHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendExtensionPubsubMessageRequestObject

	//read in body of request
	var body SendExtensionPubsubMessageJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendExtensionPubsubMessage(ctx.Request().Context(), request.(SendExtensionPubsubMessageRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendExtensionPubsubMessage")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendExtensionPubsubMessage handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendExtensionPubsubMessageResponseObject); ok {
		return validResponse.VisitSendExtensionPubsubMessageResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetReleasedExtensions operation middleware
func (sh *strictHandler) GetReleasedExtensions(ctx echo.Context, params GetReleasedExtensionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetReleasedExtensionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetReleasedExtensionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetReleasedExtensions(ctx.Request().Context(), request.(GetReleasedExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetReleasedExtensions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetReleasedExtensions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetReleasedExtensionsResponseObject); ok {
		return validResponse.VisitGetReleasedExtensionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SetExtensionRequiredConfiguration operation middleware
func (sh *strictHandler) SetExtensionRequiredConfiguration(ctx echo.Context, params SetExtensionRequiredConfigurationParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SetExtensionRequiredConfigurationHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SetExtensionRequiredConfigurationRequestObject

	request.Params = params

	//read in body of request
	var body SetExtensionRequiredConfigurationJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SetExtensionRequiredConfiguration(ctx.Request().Context(), request.(SetExtensionRequiredConfigurationRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SetExtensionRequiredConfiguration")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SetExtensionRequiredConfiguration handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SetExtensionRequiredConfigurationResponseObject); ok {
		return validResponse.VisitSetExtensionRequiredConfigurationResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetExtensionTransactions operation middleware
func (sh *strictHandler) GetExtensionTransactions(ctx echo.Context, params GetExtensionTransactionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetExtensionTransactionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetExtensionTransactionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetExtensionTransactions(ctx.Request().Context(), request.(GetExtensionTransactionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetExtensionTransactions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetExtensionTransactions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetExtensionTransactionsResponseObject); ok {
		return validResponse.VisitGetExtensionTransactionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetGames operation middleware
func (sh *strictHandler) GetGames(ctx echo.Context, params GetGamesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetGamesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetGamesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetGames(ctx.Request().Context(), request.(GetGamesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGames")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetGames handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetGamesResponseObject); ok {
		return validResponse.VisitGetGamesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetTopGames operation middleware
func (sh *strictHandler) GetTopGames(ctx echo.Context, params GetTopGamesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetTopGamesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetTopGamesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetTopGames(ctx.Request().Context(), request.(GetTopGamesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTopGames")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetTopGames handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetTopGamesResponseObject); ok {
		return validResponse.VisitGetTopGamesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetCreatorGoals operation middleware
func (sh *strictHandler) GetCreatorGoals(ctx echo.Context, params GetCreatorGoalsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetCreatorGoalsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetCreatorGoalsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetCreatorGoals(ctx.Request().Context(), request.(GetCreatorGoalsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetCreatorGoals")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetCreatorGoals handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetCreatorGoalsResponseObject); ok {
		return validResponse.VisitGetCreatorGoalsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelGuestStarSettings operation middleware
func (sh *strictHandler) GetChannelGuestStarSettings(ctx echo.Context, params GetChannelGuestStarSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelGuestStarSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelGuestStarSettingsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelGuestStarSettings(ctx.Request().Context(), request.(GetChannelGuestStarSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelGuestStarSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelGuestStarSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelGuestStarSettingsResponseObject); ok {
		return validResponse.VisitGetChannelGuestStarSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateChannelGuestStarSettings operation middleware
func (sh *strictHandler) UpdateChannelGuestStarSettings(ctx echo.Context, params UpdateChannelGuestStarSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateChannelGuestStarSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateChannelGuestStarSettingsRequestObject

	request.Params = params

	//read in body of request
	var body UpdateChannelGuestStarSettingsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateChannelGuestStarSettings(ctx.Request().Context(), request.(UpdateChannelGuestStarSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateChannelGuestStarSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateChannelGuestStarSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateChannelGuestStarSettingsResponseObject); ok {
		return validResponse.VisitUpdateChannelGuestStarSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteGuestStarInvite operation middleware
func (sh *strictHandler) DeleteGuestStarInvite(ctx echo.Context, params DeleteGuestStarInviteParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteGuestStarInviteHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteGuestStarInviteRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGuestStarInvite(ctx.Request().Context(), request.(DeleteGuestStarInviteRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGuestStarInvite")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteGuestStarInvite handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteGuestStarInviteResponseObject); ok {
		return validResponse.VisitDeleteGuestStarInviteResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetGuestStarInvites operation middleware
func (sh *strictHandler) GetGuestStarInvites(ctx echo.Context, params GetGuestStarInvitesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetGuestStarInvitesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetGuestStarInvitesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetGuestStarInvites(ctx.Request().Context(), request.(GetGuestStarInvitesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGuestStarInvites")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetGuestStarInvites handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetGuestStarInvitesResponseObject); ok {
		return validResponse.VisitGetGuestStarInvitesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendGuestStarInvite operation middleware
func (sh *strictHandler) SendGuestStarInvite(ctx echo.Context, params SendGuestStarInviteParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendGuestStarInviteHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendGuestStarInviteRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendGuestStarInvite(ctx.Request().Context(), request.(SendGuestStarInviteRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendGuestStarInvite")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendGuestStarInvite handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendGuestStarInviteResponseObject); ok {
		return validResponse.VisitSendGuestStarInviteResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// EndGuestStarSession operation middleware
func (sh *strictHandler) EndGuestStarSession(ctx echo.Context, params EndGuestStarSessionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "EndGuestStarSessionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request EndGuestStarSessionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.EndGuestStarSession(ctx.Request().Context(), request.(EndGuestStarSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EndGuestStarSession")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from EndGuestStarSession handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(EndGuestStarSessionResponseObject); ok {
		return validResponse.VisitEndGuestStarSessionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetGuestStarSession operation middleware
func (sh *strictHandler) GetGuestStarSession(ctx echo.Context, params GetGuestStarSessionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetGuestStarSessionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetGuestStarSessionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetGuestStarSession(ctx.Request().Context(), request.(GetGuestStarSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetGuestStarSession")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetGuestStarSession handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetGuestStarSessionResponseObject); ok {
		return validResponse.VisitGetGuestStarSessionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateGuestStarSession operation middleware
func (sh *strictHandler) CreateGuestStarSession(ctx echo.Context, params CreateGuestStarSessionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateGuestStarSessionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateGuestStarSessionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateGuestStarSession(ctx.Request().Context(), request.(CreateGuestStarSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateGuestStarSession")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateGuestStarSession handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateGuestStarSessionResponseObject); ok {
		return validResponse.VisitCreateGuestStarSessionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteGuestStarSlot operation middleware
func (sh *strictHandler) DeleteGuestStarSlot(ctx echo.Context, params DeleteGuestStarSlotParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteGuestStarSlotHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteGuestStarSlotRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteGuestStarSlot(ctx.Request().Context(), request.(DeleteGuestStarSlotRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteGuestStarSlot")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteGuestStarSlot handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteGuestStarSlotResponseObject); ok {
		return validResponse.VisitDeleteGuestStarSlotResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateGuestStarSlot operation middleware
func (sh *strictHandler) UpdateGuestStarSlot(ctx echo.Context, params UpdateGuestStarSlotParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateGuestStarSlotHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateGuestStarSlotRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateGuestStarSlot(ctx.Request().Context(), request.(UpdateGuestStarSlotRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateGuestStarSlot")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateGuestStarSlot handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateGuestStarSlotResponseObject); ok {
		return validResponse.VisitUpdateGuestStarSlotResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// AssignGuestStarSlot operation middleware
func (sh *strictHandler) AssignGuestStarSlot(ctx echo.Context, params AssignGuestStarSlotParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "AssignGuestStarSlotHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request AssignGuestStarSlotRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AssignGuestStarSlot(ctx.Request().Context(), request.(AssignGuestStarSlotRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AssignGuestStarSlot")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from AssignGuestStarSlot handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(AssignGuestStarSlotResponseObject); ok {
		return validResponse.VisitAssignGuestStarSlotResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateGuestStarSlotSettings operation middleware
func (sh *strictHandler) UpdateGuestStarSlotSettings(ctx echo.Context, params UpdateGuestStarSlotSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateGuestStarSlotSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateGuestStarSlotSettingsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateGuestStarSlotSettings(ctx.Request().Context(), request.(UpdateGuestStarSlotSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateGuestStarSlotSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateGuestStarSlotSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateGuestStarSlotSettingsResponseObject); ok {
		return validResponse.VisitUpdateGuestStarSlotSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetHypeTrainEvents operation middleware
func (sh *strictHandler) GetHypeTrainEvents(ctx echo.Context, params GetHypeTrainEventsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetHypeTrainEventsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetHypeTrainEventsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetHypeTrainEvents(ctx.Request().Context(), request.(GetHypeTrainEventsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetHypeTrainEvents")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetHypeTrainEvents handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetHypeTrainEventsResponseObject); ok {
		return validResponse.VisitGetHypeTrainEventsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// ManageHeldAutomodMessages operation middleware
func (sh *strictHandler) ManageHeldAutomodMessages(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "ManageHeldAutomodMessagesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request ManageHeldAutomodMessagesRequestObject

	//read in body of request
	var body ManageHeldAutomodMessagesJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ManageHeldAutomodMessages(ctx.Request().Context(), request.(ManageHeldAutomodMessagesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ManageHeldAutomodMessages")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from ManageHeldAutomodMessages handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(ManageHeldAutomodMessagesResponseObject); ok {
		return validResponse.VisitManageHeldAutomodMessagesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetAutomodSettings operation middleware
func (sh *strictHandler) GetAutomodSettings(ctx echo.Context, params GetAutomodSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetAutomodSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetAutomodSettingsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAutomodSettings(ctx.Request().Context(), request.(GetAutomodSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAutomodSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetAutomodSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetAutomodSettingsResponseObject); ok {
		return validResponse.VisitGetAutomodSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateAutomodSettings operation middleware
func (sh *strictHandler) UpdateAutomodSettings(ctx echo.Context, params UpdateAutomodSettingsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateAutomodSettingsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateAutomodSettingsRequestObject

	request.Params = params

	//read in body of request
	var body UpdateAutomodSettingsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateAutomodSettings(ctx.Request().Context(), request.(UpdateAutomodSettingsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateAutomodSettings")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateAutomodSettings handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateAutomodSettingsResponseObject); ok {
		return validResponse.VisitUpdateAutomodSettingsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetBannedUsers operation middleware
func (sh *strictHandler) GetBannedUsers(ctx echo.Context, params GetBannedUsersParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetBannedUsersHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetBannedUsersRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetBannedUsers(ctx.Request().Context(), request.(GetBannedUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBannedUsers")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetBannedUsers handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetBannedUsersResponseObject); ok {
		return validResponse.VisitGetBannedUsersResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UnbanUser operation middleware
func (sh *strictHandler) UnbanUser(ctx echo.Context, params UnbanUserParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UnbanUserHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UnbanUserRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UnbanUser(ctx.Request().Context(), request.(UnbanUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UnbanUser")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UnbanUser handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UnbanUserResponseObject); ok {
		return validResponse.VisitUnbanUserResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// BanUser operation middleware
func (sh *strictHandler) BanUser(ctx echo.Context, params BanUserParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "BanUserHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request BanUserRequestObject

	request.Params = params

	//read in body of request
	var body BanUserJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.BanUser(ctx.Request().Context(), request.(BanUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "BanUser")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from BanUser handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(BanUserResponseObject); ok {
		return validResponse.VisitBanUserResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// RemoveBlockedTerm operation middleware
func (sh *strictHandler) RemoveBlockedTerm(ctx echo.Context, params RemoveBlockedTermParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "RemoveBlockedTermHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request RemoveBlockedTermRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RemoveBlockedTerm(ctx.Request().Context(), request.(RemoveBlockedTermRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RemoveBlockedTerm")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from RemoveBlockedTerm handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(RemoveBlockedTermResponseObject); ok {
		return validResponse.VisitRemoveBlockedTermResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetBlockedTerms operation middleware
func (sh *strictHandler) GetBlockedTerms(ctx echo.Context, params GetBlockedTermsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetBlockedTermsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetBlockedTermsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetBlockedTerms(ctx.Request().Context(), request.(GetBlockedTermsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBlockedTerms")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetBlockedTerms handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetBlockedTermsResponseObject); ok {
		return validResponse.VisitGetBlockedTermsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// AddBlockedTerm operation middleware
func (sh *strictHandler) AddBlockedTerm(ctx echo.Context, params AddBlockedTermParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "AddBlockedTermHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request AddBlockedTermRequestObject

	request.Params = params

	//read in body of request
	var body AddBlockedTermJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AddBlockedTerm(ctx.Request().Context(), request.(AddBlockedTermRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddBlockedTerm")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from AddBlockedTerm handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(AddBlockedTermResponseObject); ok {
		return validResponse.VisitAddBlockedTermResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetModeratedChannels operation middleware
func (sh *strictHandler) GetModeratedChannels(ctx echo.Context, params GetModeratedChannelsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetModeratedChannelsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetModeratedChannelsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetModeratedChannels(ctx.Request().Context(), request.(GetModeratedChannelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetModeratedChannels")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetModeratedChannels handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetModeratedChannelsResponseObject); ok {
		return validResponse.VisitGetModeratedChannelsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteChatMessages operation middleware
func (sh *strictHandler) DeleteChatMessages(ctx echo.Context, params DeleteChatMessagesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteChatMessagesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteChatMessagesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteChatMessages(ctx.Request().Context(), request.(DeleteChatMessagesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteChatMessages")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteChatMessages handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteChatMessagesResponseObject); ok {
		return validResponse.VisitDeleteChatMessagesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CheckAutomodStatus operation middleware
func (sh *strictHandler) CheckAutomodStatus(ctx echo.Context, params CheckAutomodStatusParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CheckAutomodStatusHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CheckAutomodStatusRequestObject

	request.Params = params

	//read in body of request
	var body CheckAutomodStatusJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CheckAutomodStatus(ctx.Request().Context(), request.(CheckAutomodStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CheckAutomodStatus")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CheckAutomodStatus handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CheckAutomodStatusResponseObject); ok {
		return validResponse.VisitCheckAutomodStatusResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// RemoveChannelModerator operation middleware
func (sh *strictHandler) RemoveChannelModerator(ctx echo.Context, params RemoveChannelModeratorParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "RemoveChannelModeratorHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request RemoveChannelModeratorRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.RemoveChannelModerator(ctx.Request().Context(), request.(RemoveChannelModeratorRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "RemoveChannelModerator")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from RemoveChannelModerator handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(RemoveChannelModeratorResponseObject); ok {
		return validResponse.VisitRemoveChannelModeratorResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetModerators operation middleware
func (sh *strictHandler) GetModerators(ctx echo.Context, params GetModeratorsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetModeratorsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetModeratorsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetModerators(ctx.Request().Context(), request.(GetModeratorsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetModerators")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetModerators handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetModeratorsResponseObject); ok {
		return validResponse.VisitGetModeratorsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// AddChannelModerator operation middleware
func (sh *strictHandler) AddChannelModerator(ctx echo.Context, params AddChannelModeratorParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "AddChannelModeratorHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request AddChannelModeratorRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.AddChannelModerator(ctx.Request().Context(), request.(AddChannelModeratorRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "AddChannelModerator")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from AddChannelModerator handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(AddChannelModeratorResponseObject); ok {
		return validResponse.VisitAddChannelModeratorResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetShieldModeStatus operation middleware
func (sh *strictHandler) GetShieldModeStatus(ctx echo.Context, params GetShieldModeStatusParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetShieldModeStatusHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetShieldModeStatusRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetShieldModeStatus(ctx.Request().Context(), request.(GetShieldModeStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetShieldModeStatus")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetShieldModeStatus handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetShieldModeStatusResponseObject); ok {
		return validResponse.VisitGetShieldModeStatusResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateShieldModeStatus operation middleware
func (sh *strictHandler) UpdateShieldModeStatus(ctx echo.Context, params UpdateShieldModeStatusParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateShieldModeStatusHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateShieldModeStatusRequestObject

	request.Params = params

	//read in body of request
	var body UpdateShieldModeStatusJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateShieldModeStatus(ctx.Request().Context(), request.(UpdateShieldModeStatusRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateShieldModeStatus")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateShieldModeStatus handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateShieldModeStatusResponseObject); ok {
		return validResponse.VisitUpdateShieldModeStatusResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUnbanRequests operation middleware
func (sh *strictHandler) GetUnbanRequests(ctx echo.Context, params GetUnbanRequestsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUnbanRequestsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUnbanRequestsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUnbanRequests(ctx.Request().Context(), request.(GetUnbanRequestsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUnbanRequests")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUnbanRequests handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUnbanRequestsResponseObject); ok {
		return validResponse.VisitGetUnbanRequestsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// ResolveUnbanRequests operation middleware
func (sh *strictHandler) ResolveUnbanRequests(ctx echo.Context, params ResolveUnbanRequestsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "ResolveUnbanRequestsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request ResolveUnbanRequestsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.ResolveUnbanRequests(ctx.Request().Context(), request.(ResolveUnbanRequestsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ResolveUnbanRequests")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from ResolveUnbanRequests handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(ResolveUnbanRequestsResponseObject); ok {
		return validResponse.VisitResolveUnbanRequestsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// WarnChatUser operation middleware
func (sh *strictHandler) WarnChatUser(ctx echo.Context, params WarnChatUserParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "WarnChatUserHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request WarnChatUserRequestObject

	request.Params = params

	//read in body of request
	var body WarnChatUserJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.WarnChatUser(ctx.Request().Context(), request.(WarnChatUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "WarnChatUser")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from WarnChatUser handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(WarnChatUserResponseObject); ok {
		return validResponse.VisitWarnChatUserResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetPolls operation middleware
func (sh *strictHandler) GetPolls(ctx echo.Context, params GetPollsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetPollsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetPollsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPolls(ctx.Request().Context(), request.(GetPollsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPolls")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetPolls handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetPollsResponseObject); ok {
		return validResponse.VisitGetPollsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// EndPoll operation middleware
func (sh *strictHandler) EndPoll(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "EndPollHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request EndPollRequestObject

	//read in body of request
	var body EndPollJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.EndPoll(ctx.Request().Context(), request.(EndPollRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EndPoll")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from EndPoll handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(EndPollResponseObject); ok {
		return validResponse.VisitEndPollResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreatePoll operation middleware
func (sh *strictHandler) CreatePoll(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreatePollHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreatePollRequestObject

	//read in body of request
	var body CreatePollJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePoll(ctx.Request().Context(), request.(CreatePollRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePoll")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreatePoll handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreatePollResponseObject); ok {
		return validResponse.VisitCreatePollResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetPredictions operation middleware
func (sh *strictHandler) GetPredictions(ctx echo.Context, params GetPredictionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetPredictionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetPredictionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetPredictions(ctx.Request().Context(), request.(GetPredictionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPredictions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetPredictions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetPredictionsResponseObject); ok {
		return validResponse.VisitGetPredictionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// EndPrediction operation middleware
func (sh *strictHandler) EndPrediction(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "EndPredictionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request EndPredictionRequestObject

	//read in body of request
	var body EndPredictionJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.EndPrediction(ctx.Request().Context(), request.(EndPredictionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "EndPrediction")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from EndPrediction handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(EndPredictionResponseObject); ok {
		return validResponse.VisitEndPredictionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreatePrediction operation middleware
func (sh *strictHandler) CreatePrediction(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreatePredictionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreatePredictionRequestObject

	//read in body of request
	var body CreatePredictionJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreatePrediction(ctx.Request().Context(), request.(CreatePredictionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreatePrediction")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreatePrediction handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreatePredictionResponseObject); ok {
		return validResponse.VisitCreatePredictionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CancelARaid operation middleware
func (sh *strictHandler) CancelARaid(ctx echo.Context, params CancelARaidParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CancelARaidHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CancelARaidRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CancelARaid(ctx.Request().Context(), request.(CancelARaidRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CancelARaid")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CancelARaid handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CancelARaidResponseObject); ok {
		return validResponse.VisitCancelARaidResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// StartARaid operation middleware
func (sh *strictHandler) StartARaid(ctx echo.Context, params StartARaidParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "StartARaidHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request StartARaidRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.StartARaid(ctx.Request().Context(), request.(StartARaidRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "StartARaid")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from StartARaid handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(StartARaidResponseObject); ok {
		return validResponse.VisitStartARaidResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelStreamSchedule operation middleware
func (sh *strictHandler) GetChannelStreamSchedule(ctx echo.Context, params GetChannelStreamScheduleParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelStreamScheduleHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelStreamScheduleRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelStreamSchedule(ctx.Request().Context(), request.(GetChannelStreamScheduleRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelStreamSchedule")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelStreamSchedule handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelStreamScheduleResponseObject); ok {
		return validResponse.VisitGetChannelStreamScheduleResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelIcalendar operation middleware
func (sh *strictHandler) GetChannelIcalendar(ctx echo.Context, params GetChannelIcalendarParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelIcalendarHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelIcalendarRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelIcalendar(ctx.Request().Context(), request.(GetChannelIcalendarRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelIcalendar")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelIcalendar handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelIcalendarResponseObject); ok {
		return validResponse.VisitGetChannelIcalendarResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteChannelStreamScheduleSegment operation middleware
func (sh *strictHandler) DeleteChannelStreamScheduleSegment(ctx echo.Context, params DeleteChannelStreamScheduleSegmentParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteChannelStreamScheduleSegmentHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteChannelStreamScheduleSegmentRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteChannelStreamScheduleSegment(ctx.Request().Context(), request.(DeleteChannelStreamScheduleSegmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteChannelStreamScheduleSegment")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteChannelStreamScheduleSegment handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteChannelStreamScheduleSegmentResponseObject); ok {
		return validResponse.VisitDeleteChannelStreamScheduleSegmentResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateChannelStreamScheduleSegment operation middleware
func (sh *strictHandler) UpdateChannelStreamScheduleSegment(ctx echo.Context, params UpdateChannelStreamScheduleSegmentParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateChannelStreamScheduleSegmentHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateChannelStreamScheduleSegmentRequestObject

	request.Params = params

	//read in body of request
	var body UpdateChannelStreamScheduleSegmentJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateChannelStreamScheduleSegment(ctx.Request().Context(), request.(UpdateChannelStreamScheduleSegmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateChannelStreamScheduleSegment")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateChannelStreamScheduleSegment handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateChannelStreamScheduleSegmentResponseObject); ok {
		return validResponse.VisitUpdateChannelStreamScheduleSegmentResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateChannelStreamScheduleSegment operation middleware
func (sh *strictHandler) CreateChannelStreamScheduleSegment(ctx echo.Context, params CreateChannelStreamScheduleSegmentParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateChannelStreamScheduleSegmentHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateChannelStreamScheduleSegmentRequestObject

	request.Params = params

	//read in body of request
	var body CreateChannelStreamScheduleSegmentJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateChannelStreamScheduleSegment(ctx.Request().Context(), request.(CreateChannelStreamScheduleSegmentRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateChannelStreamScheduleSegment")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateChannelStreamScheduleSegment handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateChannelStreamScheduleSegmentResponseObject); ok {
		return validResponse.VisitCreateChannelStreamScheduleSegmentResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateChannelStreamSchedule operation middleware
func (sh *strictHandler) UpdateChannelStreamSchedule(ctx echo.Context, params UpdateChannelStreamScheduleParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateChannelStreamScheduleHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateChannelStreamScheduleRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateChannelStreamSchedule(ctx.Request().Context(), request.(UpdateChannelStreamScheduleRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateChannelStreamSchedule")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateChannelStreamSchedule handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateChannelStreamScheduleResponseObject); ok {
		return validResponse.VisitUpdateChannelStreamScheduleResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SearchCategories operation middleware
func (sh *strictHandler) SearchCategories(ctx echo.Context, params SearchCategoriesParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SearchCategoriesHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SearchCategoriesRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchCategories(ctx.Request().Context(), request.(SearchCategoriesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchCategories")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SearchCategories handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SearchCategoriesResponseObject); ok {
		return validResponse.VisitSearchCategoriesResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SearchChannels operation middleware
func (sh *strictHandler) SearchChannels(ctx echo.Context, params SearchChannelsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SearchChannelsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SearchChannelsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SearchChannels(ctx.Request().Context(), request.(SearchChannelsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SearchChannels")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SearchChannels handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SearchChannelsResponseObject); ok {
		return validResponse.VisitSearchChannelsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetSharedChatSession operation middleware
func (sh *strictHandler) GetSharedChatSession(ctx echo.Context, params GetSharedChatSessionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetSharedChatSessionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetSharedChatSessionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetSharedChatSession(ctx.Request().Context(), request.(GetSharedChatSessionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSharedChatSession")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetSharedChatSession handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetSharedChatSessionResponseObject); ok {
		return validResponse.VisitGetSharedChatSessionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetStreams operation middleware
func (sh *strictHandler) GetStreams(ctx echo.Context, params GetStreamsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetStreamsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetStreamsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetStreams(ctx.Request().Context(), request.(GetStreamsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStreams")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetStreams handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetStreamsResponseObject); ok {
		return validResponse.VisitGetStreamsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetFollowedStreams operation middleware
func (sh *strictHandler) GetFollowedStreams(ctx echo.Context, params GetFollowedStreamsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetFollowedStreamsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetFollowedStreamsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetFollowedStreams(ctx.Request().Context(), request.(GetFollowedStreamsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetFollowedStreams")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetFollowedStreams handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetFollowedStreamsResponseObject); ok {
		return validResponse.VisitGetFollowedStreamsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetStreamKey operation middleware
func (sh *strictHandler) GetStreamKey(ctx echo.Context, params GetStreamKeyParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetStreamKeyHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetStreamKeyRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetStreamKey(ctx.Request().Context(), request.(GetStreamKeyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStreamKey")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetStreamKey handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetStreamKeyResponseObject); ok {
		return validResponse.VisitGetStreamKeyResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetStreamMarkers operation middleware
func (sh *strictHandler) GetStreamMarkers(ctx echo.Context, params GetStreamMarkersParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetStreamMarkersHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetStreamMarkersRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetStreamMarkers(ctx.Request().Context(), request.(GetStreamMarkersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStreamMarkers")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetStreamMarkers handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetStreamMarkersResponseObject); ok {
		return validResponse.VisitGetStreamMarkersResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CreateStreamMarker operation middleware
func (sh *strictHandler) CreateStreamMarker(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CreateStreamMarkerHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CreateStreamMarkerRequestObject

	//read in body of request
	var body CreateStreamMarkerJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CreateStreamMarker(ctx.Request().Context(), request.(CreateStreamMarkerRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CreateStreamMarker")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CreateStreamMarker handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CreateStreamMarkerResponseObject); ok {
		return validResponse.VisitCreateStreamMarkerResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetStreamTags operation middleware
func (sh *strictHandler) GetStreamTags(ctx echo.Context, params GetStreamTagsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetStreamTagsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetStreamTagsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetStreamTags(ctx.Request().Context(), request.(GetStreamTagsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetStreamTags")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetStreamTags handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetStreamTagsResponseObject); ok {
		return validResponse.VisitGetStreamTagsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetBroadcasterSubscriptions operation middleware
func (sh *strictHandler) GetBroadcasterSubscriptions(ctx echo.Context, params GetBroadcasterSubscriptionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetBroadcasterSubscriptionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetBroadcasterSubscriptionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetBroadcasterSubscriptions(ctx.Request().Context(), request.(GetBroadcasterSubscriptionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetBroadcasterSubscriptions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetBroadcasterSubscriptions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetBroadcasterSubscriptionsResponseObject); ok {
		return validResponse.VisitGetBroadcasterSubscriptionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// CheckUserSubscription operation middleware
func (sh *strictHandler) CheckUserSubscription(ctx echo.Context, params CheckUserSubscriptionParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "CheckUserSubscriptionHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request CheckUserSubscriptionRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.CheckUserSubscription(ctx.Request().Context(), request.(CheckUserSubscriptionRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CheckUserSubscription")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from CheckUserSubscription handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(CheckUserSubscriptionResponseObject); ok {
		return validResponse.VisitCheckUserSubscriptionResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetAllStreamTags operation middleware
func (sh *strictHandler) GetAllStreamTags(ctx echo.Context, params GetAllStreamTagsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetAllStreamTagsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetAllStreamTagsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetAllStreamTags(ctx.Request().Context(), request.(GetAllStreamTagsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetAllStreamTags")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetAllStreamTags handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetAllStreamTagsResponseObject); ok {
		return validResponse.VisitGetAllStreamTagsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetTeams operation middleware
func (sh *strictHandler) GetTeams(ctx echo.Context, params GetTeamsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetTeamsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetTeamsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetTeams(ctx.Request().Context(), request.(GetTeamsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetTeams")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetTeams handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetTeamsResponseObject); ok {
		return validResponse.VisitGetTeamsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetChannelTeams operation middleware
func (sh *strictHandler) GetChannelTeams(ctx echo.Context, params GetChannelTeamsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetChannelTeamsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetChannelTeamsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetChannelTeams(ctx.Request().Context(), request.(GetChannelTeamsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetChannelTeams")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetChannelTeams handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetChannelTeamsResponseObject); ok {
		return validResponse.VisitGetChannelTeamsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUsers operation middleware
func (sh *strictHandler) GetUsers(ctx echo.Context, params GetUsersParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUsersHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUsersRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUsers(ctx.Request().Context(), request.(GetUsersRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUsers")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUsers handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUsersResponseObject); ok {
		return validResponse.VisitGetUsersResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateUser operation middleware
func (sh *strictHandler) UpdateUser(ctx echo.Context, params UpdateUserParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateUserHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateUserRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateUser(ctx.Request().Context(), request.(UpdateUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateUser")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateUser handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateUserResponseObject); ok {
		return validResponse.VisitUpdateUserResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UnblockUser operation middleware
func (sh *strictHandler) UnblockUser(ctx echo.Context, params UnblockUserParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UnblockUserHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UnblockUserRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UnblockUser(ctx.Request().Context(), request.(UnblockUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UnblockUser")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UnblockUser handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UnblockUserResponseObject); ok {
		return validResponse.VisitUnblockUserResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUserBlockList operation middleware
func (sh *strictHandler) GetUserBlockList(ctx echo.Context, params GetUserBlockListParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUserBlockListHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUserBlockListRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserBlockList(ctx.Request().Context(), request.(GetUserBlockListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserBlockList")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUserBlockList handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUserBlockListResponseObject); ok {
		return validResponse.VisitGetUserBlockListResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// BlockUser operation middleware
func (sh *strictHandler) BlockUser(ctx echo.Context, params BlockUserParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "BlockUserHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request BlockUserRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.BlockUser(ctx.Request().Context(), request.(BlockUserRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "BlockUser")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from BlockUser handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(BlockUserResponseObject); ok {
		return validResponse.VisitBlockUserResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUserActiveExtensions operation middleware
func (sh *strictHandler) GetUserActiveExtensions(ctx echo.Context, params GetUserActiveExtensionsParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUserActiveExtensionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUserActiveExtensionsRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserActiveExtensions(ctx.Request().Context(), request.(GetUserActiveExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserActiveExtensions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUserActiveExtensions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUserActiveExtensionsResponseObject); ok {
		return validResponse.VisitGetUserActiveExtensionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// UpdateUserExtensions operation middleware
func (sh *strictHandler) UpdateUserExtensions(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "UpdateUserExtensionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request UpdateUserExtensionsRequestObject

	//read in body of request
	var body UpdateUserExtensionsJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.UpdateUserExtensions(ctx.Request().Context(), request.(UpdateUserExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdateUserExtensions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from UpdateUserExtensions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(UpdateUserExtensionsResponseObject); ok {
		return validResponse.VisitUpdateUserExtensionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetUserExtensions operation middleware
func (sh *strictHandler) GetUserExtensions(ctx echo.Context) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetUserExtensionsHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetUserExtensionsRequestObject

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetUserExtensions(ctx.Request().Context(), request.(GetUserExtensionsRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetUserExtensions")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetUserExtensions handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetUserExtensionsResponseObject); ok {
		return validResponse.VisitGetUserExtensionsResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// DeleteVideos operation middleware
func (sh *strictHandler) DeleteVideos(ctx echo.Context, params DeleteVideosParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "DeleteVideosHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request DeleteVideosRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteVideos(ctx.Request().Context(), request.(DeleteVideosRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteVideos")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from DeleteVideos handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(DeleteVideosResponseObject); ok {
		return validResponse.VisitDeleteVideosResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// GetVideos operation middleware
func (sh *strictHandler) GetVideos(ctx echo.Context, params GetVideosParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "GetVideosHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request GetVideosRequestObject

	request.Params = params

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.GetVideos(ctx.Request().Context(), request.(GetVideosRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetVideos")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from GetVideos handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(GetVideosResponseObject); ok {
		return validResponse.VisitGetVideosResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

// SendWhisper operation middleware
func (sh *strictHandler) SendWhisper(ctx echo.Context, params SendWhisperParams) (err error) {
	if sh.tracer != nil {
		cx, span := sh.tracer.Start(ctx.Request().Context(), "SendWhisperHandler")
		ctx.SetRequest(ctx.Request().WithContext(cx))
		defer func(span trace.Span) {
			if err != nil {
				span.SetStatus(codes.Error, err.Error())
				span.RecordError(err)
			}
			span.End()
		}(span)

	}

	//set logger context.
	log := tlog.FromEcho(ctx)

	var request SendWhisperRequestObject

	request.Params = params

	//read in body of request
	var body SendWhisperJSONRequestBody
	b := &bytes.Buffer{}
	_, err = b.ReadFrom(ctx.Request().Body)
	if err != nil {
		log.Err("failed to read body in request", err)
		return echo.ErrBadRequest
	}

	//Marshal body into json
	if err = json.Unmarshal(b.Bytes(), &body); err != nil {
		log.Err("failed to unmarshal body in request",
			err,
			slog.String("request.body", b.String()),
		)
		if sh.tracer != nil {
			trace.SpanFromContext(ctx.Request().Context()).
				SetAttributes(attribute.String("request.body", b.String()))
		}
		return echo.ErrBadRequest
	}
	request.Body = &body

	cx := tlog.Context(ctx.Request().Context(), log)
	ctx.SetRequest(ctx.Request().WithContext(cx))

	handler := func(ctx echo.Context, request interface{}) (interface{}, error) {
		return sh.ssi.SendWhisper(ctx.Request().Context(), request.(SendWhisperRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SendWhisper")
	}
	log.Info("Calling handler")
	response, err := handler(ctx, request)

	if err != nil {
		log.Err(fmt.Sprintf("error response from SendWhisper handler: %s", err.Error()), err)
		return err
	} else if validResponse, ok := response.(SendWhisperResponseObject); ok {
		return validResponse.VisitSendWhisperResponse(ctx.Response())
	} else if response != nil {
		return fmt.Errorf("unexpected response type: %T", response)
	}
	return nil
}

//Generated with inline.tmpl

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
